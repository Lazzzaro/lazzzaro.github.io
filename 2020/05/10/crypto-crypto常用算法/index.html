<!DOCTYPE html><html lang="zh"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1,user-scalable=no,minimal-ui"><meta name="renderer" content="webkit"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta name="format-detection" content="telephone=no,email=no,adress=no"><meta name="theme-color" content="#000000"><meta http-equiv="window-target" content="_top"><title>crypto常用算法 | Lazzaro</title><meta name="description" content="欧几里得算法（辗转相除法）在数学中，辗转相除法，又称欧几里得算法（英语：Euclidean algorithm），是求最大公约数的算法。 两个整数的最大公约数是能够同时整除它们的最大的正整数。辗转相除法基于如下原理：两个整数的最大公约数等于其中较小的数和两数相除余数的最大公约数。在这个过程中，较大的数缩小了，所以继续进行同样的计算可以不断缩小这两个数直至其中一个变成零。这时，所剩下的还没有变成零的"><meta property="og:type" content="article"><meta property="og:title" content="crypto常用算法"><meta property="og:url" content="https://lazzzaro.github.io/2020/05/10/crypto-crypto%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/index.html"><meta property="og:site_name" content="Lazzaro"><meta property="og:description" content="欧几里得算法（辗转相除法）在数学中，辗转相除法，又称欧几里得算法（英语：Euclidean algorithm），是求最大公约数的算法。 两个整数的最大公约数是能够同时整除它们的最大的正整数。辗转相除法基于如下原理：两个整数的最大公约数等于其中较小的数和两数相除余数的最大公约数。在这个过程中，较大的数缩小了，所以继续进行同样的计算可以不断缩小这两个数直至其中一个变成零。这时，所剩下的还没有变成零的"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://lazzzaro.github.io/2020/05/10/crypto-crypto%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/20200212194719428.png"><meta property="og:image" content="https://lazzzaro.github.io/2020/05/10/crypto-crypto%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/20191109103824108.png"><meta property="article:published_time" content="2020-05-10T09:54:00.000Z"><meta property="article:modified_time" content="2023-10-31T17:17:02.117Z"><meta property="article:author" content="Lazzaro"><meta property="article:tag" content="算法"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://lazzzaro.github.io/2020/05/10/crypto-crypto%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/20200212194719428.png"><link rel="canonical" href="https://lazzzaro.github.io/2020/05/10/crypto-crypto%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/index.html"><link rel="alternate" href="/atom.xml" title="Lazzaro" type="application/atom+xml"><link rel="icon" href="/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><script charset="UTF-8" id="LA_COLLECT" src="//sdk.51.la/js-sdk-pro.min.js"></script><script>LA.init({id:"3Ft5J9t2Jl0eb5Zr",ck:"3Ft5J9t2Jl0eb5Zr",hashMode:!0})</script><meta name="generator" content="Hexo 5.4.0"></head><body class="main-center theme-black" itemscope itemtype="http://schema.org/WebPage"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="slimContent"><div class="navbar-header"><div class="profile-block text-center"><a id="avatar" href="https://github.com/Lazzzaro" target="_blank"><img class="img-circle img-rotate" src="/images/avatar.jpg" width="200" height="200"></a><h2 id="name" class="hidden-xs hidden-sm">Lazzaro</h2><h3 id="title" class="hidden-xs hidden-sm hidden-md">CTF弱鸡自进阶</h3><small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> flag{}___Orz</small></div><div class="search" id="search-form-wrap"><form class="search-form sidebar-form"><div class="input-group"><input type="text" class="search-form-input form-control" placeholder="搜索"> <span class="input-group-btn"><button type="submit" class="search-form-submit btn btn-flat" onclick="return!1"><i class="icon icon-search"></i></button></span></div></form><div class="ins-search"><div class="ins-search-mask"></div><div class="ins-search-container"><div class="ins-input-wrapper"><input type="text" class="ins-search-input" placeholder="想要查找什么..." x-webkit-speech> <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button></div><div class="ins-section-wrapper"><div class="ins-section-container"></div></div></div></div></div><button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false"><span class="sr-only">Toggle navigation</span> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span></button></div><nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation"><ul class="nav navbar-nav main-nav menu-highlight"><li class="menu-item menu-item-home"><a href="/."><i class="icon icon-home-fill"></i> <span class="menu-title">总览</span></a></li><li class="menu-item menu-item-archives"><a href="/archives"><i class="icon icon-archives-fill"></i> <span class="menu-title">汇总</span></a></li><li class="menu-item menu-item-categories"><a href="/categories"><i class="icon icon-folder"></i> <span class="menu-title">类别</span></a></li><li class="menu-item menu-item-tags"><a href="/tags"><i class="icon icon-tags"></i> <span class="menu-title">关键词</span></a></li><li class="menu-item menu-item-guestbook"><a href="/guestbook"><i class="icon"></i> <span class="menu-title">来留个言 👉👉👉</span></a></li></ul><ul class="social-links"><li><a href="https://github.com/Lazzzaro" target="_blank" title="Github" data-toggle="tooltip" data-placement="top"><i class="icon icon-github"></i></a></li></ul></nav></div></header><aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar"><div class="slimContent"><div class="widget"><h3 class="widget-title">类别</h3><div class="widget-body"><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/crypto/">crypto</a><span class="category-list-count">16</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/match/">match</a><span class="category-list-count">45</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/misc/">misc</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/other/">other</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/pwn/">pwn</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/reverse/">reverse</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/web/">web</a><span class="category-list-count">17</span></li></ul></div></div><div class="widget"><h3 class="widget-title">关键词云</h3><div class="widget-body tagcloud"><a href="/tags/2020%E8%B5%9B/" style="font-size:14px">2020赛</a> <a href="/tags/2021%E8%B5%9B/" style="font-size:13.83px">2021赛</a> <a href="/tags/2022%E8%B5%9B/" style="font-size:13.67px">2022赛</a> <a href="/tags/2023%E8%B5%9B/" style="font-size:13.67px">2023赛</a> <a href="/tags/AES/" style="font-size:13px">AES</a> <a href="/tags/Android/" style="font-size:13px">Android</a> <a href="/tags/Bash/" style="font-size:13px">Bash</a> <a href="/tags/CMS/" style="font-size:13px">CMS</a> <a href="/tags/CSRF/" style="font-size:13px">CSRF</a> <a href="/tags/DES/" style="font-size:13px">DES</a> <a href="/tags/ECC/" style="font-size:13px">ECC</a> <a href="/tags/IDA/" style="font-size:13px">IDA</a> <a href="/tags/JWT/" style="font-size:13px">JWT</a> <a href="/tags/Java/" style="font-size:13.17px">Java</a> <a href="/tags/Linux/" style="font-size:13px">Linux</a> <a href="/tags/OT/" style="font-size:13px">OT</a> <a href="/tags/PHP/" style="font-size:13.33px">PHP</a> <a href="/tags/RCE/" style="font-size:13px">RCE</a> <a href="/tags/RSA/" style="font-size:13.17px">RSA</a> <a href="/tags/SQL/" style="font-size:13px">SQL</a> <a href="/tags/SSRF/" style="font-size:13px">SSRF</a> <a href="/tags/SSTI/" style="font-size:13px">SSTI</a> <a href="/tags/Sage/" style="font-size:13px">Sage</a> <a href="/tags/USB/" style="font-size:13px">USB</a> <a href="/tags/Unity/" style="font-size:13px">Unity</a> <a href="/tags/WebAssembly/" style="font-size:13px">WebAssembly</a> <a href="/tags/XSS/" style="font-size:13px">XSS</a> <a href="/tags/XXE/" style="font-size:13px">XXE</a> <a href="/tags/angr/" style="font-size:13px">angr</a> <a href="/tags/fuzz/" style="font-size:13px">fuzz</a> <a href="/tags/gmpy2/" style="font-size:13px">gmpy2</a> <a href="/tags/hash/" style="font-size:13px">hash</a> <a href="/tags/js/" style="font-size:13px">js</a> <a href="/tags/node-js/" style="font-size:13.17px">node.js</a> <a href="/tags/pwntools/" style="font-size:13px">pwntools</a> <a href="/tags/python/" style="font-size:13.5px">python</a> <a href="/tags/wasm/" style="font-size:13px">wasm</a> <a href="/tags/z3/" style="font-size:13px">z3</a> <a href="/tags/%E5%86%85%E7%BD%91/" style="font-size:13px">内网</a> <a href="/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/" style="font-size:13px">反序列化</a> <a href="/tags/%E5%8F%8D%E7%BC%96%E8%AF%91/" style="font-size:13px">反编译</a> <a href="/tags/%E5%8F%8D%E8%B0%83%E8%AF%95/" style="font-size:13px">反调试</a> <a href="/tags/%E5%8F%96%E8%AF%81/" style="font-size:13px">取证</a> <a href="/tags/%E5%90%8E%E9%87%8F%E5%AD%90%E5%AF%86%E7%A0%81/" style="font-size:13px">后量子密码</a> <a href="/tags/%E5%91%BD%E4%BB%A4%E8%A1%8C/" style="font-size:13px">命令行</a> <a href="/tags/%E5%9B%BE%E5%83%8F/" style="font-size:13px">图像</a> <a href="/tags/%E5%9D%97%E5%AF%86%E7%A0%81/" style="font-size:13px">块密码</a> <a href="/tags/%E5%A0%86/" style="font-size:13px">堆</a> <a href="/tags/%E5%AF%86%E7%A0%81/" style="font-size:13.17px">密码</a> <a href="/tags/%E6%8F%90%E6%9D%83/" style="font-size:13px">提权</a> <a href="/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/" style="font-size:13px">文件上传</a> <a href="/tags/%E6%9B%B2%E7%BA%BF/" style="font-size:13px">曲线</a> <a href="/tags/%E6%A0%88/" style="font-size:13px">栈</a> <a href="/tags/%E6%A0%BC%E5%AF%86%E7%A0%81/" style="font-size:13px">格密码</a> <a href="/tags/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/" style="font-size:13px">格式化字符串</a> <a href="/tags/%E6%B3%A8%E5%85%A5/" style="font-size:13px">注入</a> <a href="/tags/%E6%B5%81%E5%AF%86%E7%A0%81/" style="font-size:13px">流密码</a> <a href="/tags/%E6%B5%81%E9%87%8F/" style="font-size:13px">流量</a> <a href="/tags/%E6%B7%B7%E6%B7%86/" style="font-size:13px">混淆</a> <a href="/tags/%E6%B8%97%E9%80%8F/" style="font-size:13px">渗透</a> <a href="/tags/%E7%A6%BB%E6%95%A3%E5%AF%B9%E6%95%B0/" style="font-size:13px">离散对数</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size:13.17px">算法</a> <a href="/tags/%E7%BB%95%E8%BF%87/" style="font-size:13.5px">绕过</a> <a href="/tags/%E7%BC%96%E7%A0%81/" style="font-size:13px">编码</a> <a href="/tags/%E8%84%9A%E6%9C%AC/" style="font-size:13.17px">脚本</a> <a href="/tags/%E8%87%AA%E5%8A%A8%E5%8C%96/" style="font-size:13px">自动化</a> <a href="/tags/%E9%80%83%E9%80%B8/" style="font-size:13px">逃逸</a> <a href="/tags/%E9%9A%90%E5%86%99/" style="font-size:13.33px">隐写</a></div></div><div class="widget"><h3 class="widget-title">汇总</h3><div class="widget-body"><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/09/">九月 2023</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/05/">五月 2023</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/02/">二月 2023</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/01/">一月 2023</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/12/">十二月 2022</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/11/">十一月 2022</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/09/">九月 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/07/">七月 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/06/">六月 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/05/">五月 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/02/">二月 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/01/">一月 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/12/">十二月 2021</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/11/">十一月 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/10/">十月 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/09/">九月 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">八月 2021</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">六月 2021</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">五月 2021</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">四月 2021</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">三月 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">二月 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">一月 2021</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">十二月 2020</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">十一月 2020</a><span class="archive-list-count">9</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">十月 2020</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">九月 2020</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">八月 2020</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">七月 2020</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">六月 2020</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">五月 2020</a><span class="archive-list-count">24</span></li></ul></div></div></div></aside><aside class="sidebar sidebar-toc collapse" id="collapseToc" itemscope itemtype="http://schema.org/WPSideBar"><div class="slimContent"><nav id="toc" class="article-toc"><h3 class="toc-title">文章目录</h3><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95%EF%BC%88%E8%BE%97%E8%BD%AC%E7%9B%B8%E9%99%A4%E6%B3%95%EF%BC%89"><span class="toc-number">1.</span> <span class="toc-text">欧几里得算法（辗转相除法）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95"><span class="toc-number">2.</span> <span class="toc-text">扩展欧几里得算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%A7%E6%AD%A5%E5%B0%8F%E6%AD%A5%E7%AE%97%E6%B3%95%EF%BC%88BSGS%E7%AE%97%E6%B3%95%EF%BC%89"><span class="toc-number">3.</span> <span class="toc-text">大步小步算法（BSGS算法）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%E5%A4%A7%E6%AD%A5%E5%B0%8F%E6%AD%A5%E7%AE%97%E6%B3%95%EF%BC%88%E6%89%A9%E5%B1%95BSGS%E7%AE%97%E6%B3%95%EF%BC%89"><span class="toc-number">4.</span> <span class="toc-text">扩展大步小步算法（扩展BSGS算法）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A8%81%E5%B0%94%E9%80%8A%E5%AE%9A%E7%90%86"><span class="toc-number">5.</span> <span class="toc-text">威尔逊定理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AC%A7%E6%8B%89%E5%AE%9A%E7%90%86"><span class="toc-number">6.</span> <span class="toc-text">欧拉定理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B4%B9%E9%A9%AC%E5%B0%8F%E5%AE%9A%E7%90%86"><span class="toc-number">7.</span> <span class="toc-text">费马小定理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B4%B9%E9%A9%AC%E5%95%86"><span class="toc-number">8.</span> <span class="toc-text">费马商</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86%EF%BC%88%E5%AD%99%E5%AD%90%E5%AE%9A%E7%90%86-CRT%EF%BC%89"><span class="toc-number">9.</span> <span class="toc-text">中国剩余定理（孙子定理 &#x2F; CRT）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86%EF%BC%88%E6%89%A9%E5%B1%95CRT-ExCRT%EF%BC%89"><span class="toc-number">10.</span> <span class="toc-text">扩展中国剩余定理（扩展CRT &#x2F; ExCRT）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%98%E7%A7%8D1%EF%BC%9ANoisy-CRT"><span class="toc-number">10.1.</span> <span class="toc-text">变种1：Noisy CRT</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B4%B9%E9%A9%AC%E5%9B%A0%E5%BC%8F%E5%88%86%E8%A7%A3"><span class="toc-number">11.</span> <span class="toc-text">费马因式分解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AB%98%E6%96%AF%E6%95%B4%E6%95%B0"><span class="toc-number">12.</span> <span class="toc-text">高斯整数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CopperSmith%E6%94%BB%E5%87%BB"><span class="toc-number">13.</span> <span class="toc-text">CopperSmith攻击</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Grobner%E5%9F%BA"><span class="toc-number">14.</span> <span class="toc-text">Gröbner基</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Diffie-Hellman%E5%AF%86%E9%92%A5%E4%BA%A4%E6%8D%A2%EF%BC%88DH%E5%AF%86%E9%92%A5%E4%BA%A4%E6%8D%A2-DHKE%EF%BC%89"><span class="toc-number">15.</span> <span class="toc-text">Diffie-Hellman密钥交换（DH密钥交换 &#x2F; DHKE）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82"><span class="toc-number">16.</span> <span class="toc-text">矩阵快速幂</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%A9%E5%B0%94%E6%96%B9%E7%A8%8B-Pell%E6%96%B9%E7%A8%8B"><span class="toc-number">17.</span> <span class="toc-text">佩尔方程 &#x2F; Pell方程</span></a></li></ol></nav></div></aside><main class="main" role="main"><div class="content"><article id="post-crypto-crypto常用算法" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting"><div class="article-header"><h1 class="article-title" itemprop="name">crypto常用算法</h1><div class="article-meta"><span class="article-date"><i class="icon icon-calendar-check"></i> <a href="/2020/05/10/crypto-crypto%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/" class="article-date"><time datetime="2020-05-10T09:54:00.000Z" itemprop="datePublished">2020-05-10</time> </a></span><span class="article-category"><i class="icon icon-folder"></i> <a class="article-category-link" href="/categories/crypto/">crypto</a> </span><span class="article-tag"><i class="icon icon-tags"></i> <a class="article-tag-link-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a> </span><span class="article-read hidden-xs"><i class="icon icon-eye-fill" aria-hidden="true"></i> <span id="/2020/05/10/crypto-crypto%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/" class="leancloud_visitors" data-flag-title="crypto常用算法"><span class="leancloud-visitors-count">∞</span> </span></span><span class="post-comment"><i class="icon icon-comment"></i> <a href="/2020/05/10/crypto-crypto%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/#comments" class="article-comment-link">评论</a></span></div></div><div class="article-entry marked-body" itemprop="articleBody"><h3 id="欧几里得算法（辗转相除法）"><a href="#欧几里得算法（辗转相除法）" class="headerlink" title="欧几里得算法（辗转相除法）"></a>欧几里得算法（辗转相除法）</h3><p>在数学中，<strong>辗转相除法</strong>，又称<strong>欧几里得算法</strong>（英语：Euclidean algorithm），是求最大公约数的算法。</p><p>两个整数的最大公约数是能够同时整除它们的最大的正整数。辗转相除法基于如下原理：两个整数的最大公约数等于其中较小的数和两数相除余数的最大公约数。在这个过程中，较大的数缩小了，所以继续进行同样的计算可以不断缩小这两个数直至其中一个变成零。这时，所剩下的还没有变成零的数就是两数的最大公约数。由辗转相除法也可以推出，两数的最大公约数可以用两数的整数倍相加来表示，如 $21 = 5 × 105 + (−2) × 252$。这个重要的结论叫做裴蜀定理。</p><p>在现代密码学方面，它是RSA算法的重要部分。它还被用来解丢番图方程，比如寻找满足中国剩余定理的数，或者求有限域中元素的逆。辗转相除法还可以用来构造连分数，在施图姆定理和一些整数分解算法中也有应用。辗转相除法是现代数论中的基本工具。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gcd</span>(<span class="params">a, b</span>):</span></span><br><span class="line">	<span class="keyword">if</span> b == <span class="number">0</span>:</span><br><span class="line">		<span class="keyword">return</span> a</span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		<span class="keyword">return</span> gcd(b, a % b)</span><br></pre></td></tr></table></figure><p>​</p><h3 id="扩展欧几里得算法"><a href="#扩展欧几里得算法" class="headerlink" title="扩展欧几里得算法"></a>扩展欧几里得算法</h3><p><strong>扩展欧几里得算法</strong>（英语：Extended Euclidean algorithm）是欧几里得算法（又叫辗转相除法）的扩展。已知整数 $a,b$，扩展欧几里得算法可以在求得$a,b$的最大公约数的同时，能找到整数 $x,y$（其中一个很可能是负数），使它们满足裴蜀定理</p><p>$ax + by = \gcd(a, b)$<br>如果 $a$ 是负数，可以把问题转化成</p><p>$|a|(-x)+by=\gcd(|a|,b))$（$|a|$ 为 $a$ 的绝对值），然后令 $x’=(-x)$。<br>通常谈到最大公约数时，我们都会提到一个非常基本的事实（由裴蜀定理给出）：<strong>给定二个整数 $a,b$，必存在整数 $x,y$ 使得 $ax + by = \gcd(a, b)$。</strong></p><p>众所周知，已知两个数 $a$ 和 $b$，对它们进行辗转相除（欧几里得算法），可得它们的最大公约数。不过，在欧几里得算法中，我们仅仅利用了每步带余除法所得的余数。扩展欧几里得算法还利用了带余除法所得的商，在辗转相除的同时也能得到裴蜀等式中的 $x,y$ 两个系数。以扩展欧几里得算法求得的系数是满足裴蜀等式的最简系数。</p><p>另外，扩展欧几里得算法是一种自验证算法，最后一步得到的 $s_{i+1}$ 和 $t_{i+1}$ 乘以 $\gcd(a,b)$ 后恰为 $a$ 和 $b$，可以用来验证计算结果是否正确。</p><p>扩展欧几里得算法可以用来计算模反元素（也叫模逆元），求出模反元素是RSA加密算法中获得所需公钥、私钥的必要步骤。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ext_euclid</span>(<span class="params">a, b</span>):</span>	 </span><br><span class="line">	<span class="keyword">if</span> b == <span class="number">0</span>:		 </span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>, <span class="number">0</span>, a	 </span><br><span class="line">	<span class="keyword">else</span>:		 </span><br><span class="line">		x, y, q = ext_euclid(b, a % b) 	 </span><br><span class="line">		x, y = y, (x - (a // b) * y)		 </span><br><span class="line">		<span class="keyword">return</span> x, y, q</span><br></pre></td></tr></table></figure><p>​</p><h3 id="大步小步算法（BSGS算法）"><a href="#大步小步算法（BSGS算法）" class="headerlink" title="大步小步算法（BSGS算法）"></a>大步小步算法（BSGS算法）</h3><p>在群论中，<strong>大步小步算法</strong>（英语：baby-step giant-step）是丹尼尔·尚克斯发明的一种中途相遇算法，用于计算离散对数或者有限阿贝尔群的阶。其中离散对数问题在公钥加密领域有着非常重要的地位。</p><p>许多常用的加密系统都基于离散对数极难计算这一假设——计算越困难，这些系统提供的数据传输就越安全。增加离散对数计算难度的一种方法，是把密码系统建立在更大的群上。</p><p>这是一种空间换时间的算法，实质上是求解离散对数的朴素算法（枚举并试乘）的一个相当简单的改进。</p><p>大步小步算法常用于求解用于解决解高次同余方程的问题，问题形式如：有同余方程 $a^x \equiv b \pmod p$，$p$ 为质数，求最小非负整数解 $x$ 使得原方程成立。这类问题也称为<strong>离散对数问题</strong>。该算法的复杂度可以达到 $O(\sqrt{p}\log{n})$ 甚至更低。</p><p><strong>原理</strong></p><p>根据欧拉定理，我们知道模的剩余类有产生循环的情况，即 $a^0, a^1, \ldots, a^{n-1}$ 模 $n$（质数）意义下的剩余类与 $a^n, a^{n+1}, \ldots, a^{2n-1}$ 的剩余类相同，因此我们要的答案一定在 $[0, n-1]$ 内。<br>我们考虑先求出一部分 $a$ 的幂次模 $p$ 意义下的值，将它们存起来，然后使得剩下没有求值的部分能够想个办法利用已求值直接查出来。我们想起了根号，不如直接令求值的长度为 $m=\lceil \sqrt{p} \rceil$。<br>下面要考虑的是没有求值部分怎么来求，比如 $a^m, \ldots, a^{2m-1}$ 这一段，如果有解，一定是 $a^i \cdot a^m \equiv b \pmod{p}$ 的情况，我们把那个 $a^m$ 移到右边来，就变成了 $a^i \equiv b’ \pmod{p}$ 且 $b’ = ba^{-m}$。既然这样，我们为什么不考虑直接查这个 $b’$ 有没有对应的i的答案。这样，没有求值的部分的每一段就可以只进行一次查询来判断该段内是否有解。<br>这个保存，我们可以用一个<code>map&lt;int,int&gt;</code>来存，$x[i]$ 为余数为 $i$ 的 $a^x$ 中最小的 $x$ 值，则插入查询都为 $O(\log n)$，总复杂度达到 $O(\sqrt{n} \log n)$。当然还可以用HashMap存，复杂度会更优一些。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C++</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function">LL <span class="title">quick_mod</span><span class="params">(LL a, LL b, LL c)</span><span class="comment">//费马小定理+快速幂求逆元  </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	LL ans = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (b)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (b % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">			ans = (ans*a) % c;</span><br><span class="line">		b /= <span class="number">2</span>;</span><br><span class="line">		a = (a*a) % c;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">log_mod</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> n)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> m, v, e = <span class="number">1</span>, i;</span><br><span class="line">	m = (<span class="keyword">int</span>)<span class="built_in">sqrt</span>(n + <span class="number">0.5</span>);</span><br><span class="line">	v = <span class="built_in">quick_mod</span>(<span class="built_in">quick_mod</span>(a, m, n),n<span class="number">-2</span>, n);</span><br><span class="line">	map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; x;</span><br><span class="line">	x[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">		e = e*a%n;</span><br><span class="line">		<span class="keyword">if</span> (!x.<span class="built_in">count</span>(e)) x[e] = i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (x.<span class="built_in">count</span>(b)) <span class="keyword">return</span> i*m + x[b];</span><br><span class="line">		b = b*v%n;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#python</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">BSGS</span>(<span class="params">g, y, p</span>):</span></span><br><span class="line">    m = <span class="built_in">int</span>(sqrt(p))</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> is_square(p):</span><br><span class="line">        m += <span class="number">1</span></span><br><span class="line">    S = &#123;<span class="built_in">pow</span>(g, j, p): j <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(m)&#125;</span><br><span class="line">    gs = <span class="built_in">pow</span>(g, inverse(m, p), p)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">        <span class="keyword">if</span> y <span class="keyword">in</span> S:</span><br><span class="line">            <span class="keyword">return</span> i * m + S[y]</span><br><span class="line">        y = y * gs % p</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><p>​</p><h3 id="扩展大步小步算法（扩展BSGS算法）"><a href="#扩展大步小步算法（扩展BSGS算法）" class="headerlink" title="扩展大步小步算法（扩展BSGS算法）"></a>扩展大步小步算法（扩展BSGS算法）</h3><p><strong>原理</strong></p><p>$p$ 非质数怎么办呢？并不是说 $p-1$ 以内没有答案，而是 $p$ 可能会很大。想个办法来缩小 $p$ 的范围。<br>我们想起了一些同余性质，比如</p><p>$a \equiv b \pmod{m} \Leftrightarrow \frac{a}{d} \equiv \frac{b}{d} \pmod{\frac{m}{d}}$，其中 $d$ 为 $a,b,m$ 的正公因数。我们想办法如此提公因数。<br>从方程左边拆一个 $a$ 出来，提公因数，提完就变成这样一个式子</p><p>$a^{x-1} \cdot \frac{a}{d} \equiv \frac{b}{d} \pmod{\frac{p}{d}}$。直到某个时候 $\mathrm{gcd}(a, \frac{p}{\prod_i d_i}) = 1$。<br>如果在提公因数的过程中，遇到 $\mathrm{gcd}(a, \frac{p}{\prod_i d_i}) \neq 1$ 且 $d$ 不能整除 $b$ 的情况，说明式子无解。</p><p>因为 $a^x, p$ 中的一个共同的因数$b$中没有，显然不存在这样的 $b$。<br>结束以后，我们得到的会是一个这样的式子<br>$a^{x-k} \cdot \frac{a^k}{\prod_i d_i} \equiv \frac{b}{\prod_i d_i} \pmod{\frac{p}{\prod_i d_i}}$<br>把分母搞掉<br>$a^x \equiv b \pmod{\frac{p}{\prod_i d_i}}$<br>这个直接扔给普通BSGS做就好了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!b)</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">int</span> i=a%b)&#123;</span><br><span class="line">            a=b;</span><br><span class="line">            b=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">qpow</span><span class="params">(ll a,<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这个快速幂保证p不是1，少模一次是一次</span></span><br><span class="line">    ll s=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(n) &#123;</span><br><span class="line">        <span class="keyword">if</span>(n&amp;<span class="number">1</span>)</span><br><span class="line">            s=s*a%m;</span><br><span class="line">        a=a*a%m;</span><br><span class="line">        n&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">unordered_map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; M;</span><br><span class="line"><span class="comment">//要求a,n互质 a^x=b mod n .k,t是留给exbsgs调用的</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bsgs</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> n,<span class="keyword">int</span> k=<span class="number">1</span>,<span class="keyword">int</span> t=<span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    M.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">int</span> m=<span class="built_in">ceil</span>(<span class="built_in">sqrt</span>(n));</span><br><span class="line">    ll s=b;<span class="comment">//BS</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; i++,s=s*a%n)</span><br><span class="line">        M[s]=i;</span><br><span class="line"> </span><br><span class="line">    s=k;<span class="comment">//GS</span></span><br><span class="line">    k=<span class="built_in">qpow</span>(a,m,n);</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>; i&lt;=m; i++) &#123;</span><br><span class="line">        s=s*k%n;</span><br><span class="line">        <span class="keyword">if</span>(M.<span class="built_in">count</span>(s))</span><br><span class="line">            <span class="keyword">return</span> i*m-M[s]+t;  <span class="comment">//这样就保证找到的是最小解了</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//a^x=b mod n</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">exbsgs</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> d=<span class="built_in">gcd</span>(a,n),k=<span class="number">1</span>,t=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(d^<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(b%d) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ++t;</span><br><span class="line">        b/=d;</span><br><span class="line">        n/=d;</span><br><span class="line">        k=(ll)k*(a/d)%n;</span><br><span class="line">        <span class="keyword">if</span>(b==k) &#123;</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125;</span><br><span class="line">        d=<span class="built_in">gcd</span>(a,n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">bsgs</span>(a,b,n,k,t);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a,b,n;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;n,&amp;b);</span><br><span class="line">        <span class="keyword">if</span>(!a&amp;&amp;!n&amp;&amp;!b)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        a%=n;</span><br><span class="line">        b%=n;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="built_in">exbsgs</span>(a,b,n);</span><br><span class="line">        <span class="keyword">if</span>(ans==<span class="number">-1</span>)</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;No Solution&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​</p><h3 id="威尔逊定理"><a href="#威尔逊定理" class="headerlink" title="威尔逊定理"></a>威尔逊定理</h3><p>在初等数论中，威尔逊定理给出了判定一个自然数是否为质数的充分必要条件。即：当且仅当p为质数时：</p><p>$ (p-1)! \equiv -1 \pmod p$<br>但是由于阶乘是呈爆炸增长的，其结论对于实际操作意义不大。</p><p><strong>推论</strong></p><p>$ (p-2)! \equiv 1\pmod p$</p><p>​</p><h3 id="欧拉定理"><a href="#欧拉定理" class="headerlink" title="欧拉定理"></a>欧拉定理</h3><p>在数论中，欧拉定理（也称费马-欧拉定理或欧拉$\varphi$函数定理）是一个关于同余的性质。欧拉定理表明，若 $n,a$ 为正整数，且 $n,a$ 互素（即 $\gcd(a,n)=1$），则</p><p>$a^{\varphi (n)}\equiv 1{\pmod n}$<br>即 $a^{\varphi (n)}$ 与 $1$ 在模 $n$ 下同余；$\varphi (n)$ 为欧拉函数。欧拉定理得名于瑞士数学家莱昂哈德·欧拉。</p><p>欧拉定理实际上是费马小定理的推广。</p><p>​</p><h3 id="费马小定理"><a href="#费马小定理" class="headerlink" title="费马小定理"></a>费马小定理</h3><p>费马小定理是数论中的一个定理。</p><p>假如 $a$ 是一个整数，$p$ 是一个质数，那么 $a^p-a$ 是 $p$ 的倍数，可以表示为：</p><p>$a^p \equiv a \pmod p$<br>如果 $a$ 不是 $p$ 的倍数，这个定理也可以写成：</p><p>$a^{p-1} \equiv 1 \pmod p$<br>这个书写方式更加常用。</p><p>​</p><h3 id="费马商"><a href="#费马商" class="headerlink" title="费马商"></a>费马商</h3><p>在费马小定理中，$\frac{a^{p-1}-1}{p}$ 显然是一个整数。 这个整数被称作 $p$ 的以 $a$ 为基的费马商(Fermat Quotient)，记作 $q_p(a)$。</p><p><strong>性质</strong></p><p>（其中 $a,b$ 和 $p$ 互素）</p><p>$q_p(ab) \equiv q_p(a)+q_p(b) \pmod p$</p><p>$q_p(a^r) \equiv rq_p(a) \pmod p$</p><p>$q_p(p \mp 1) \equiv \pm 1 \pmod p$</p><p>$q_p(p \mp a) \equiv q_p(a) \pm \frac{1}{a} \pmod p$</p><p>$-2q_p(2) \equiv -\sum\limits_{k = 1}^{p-1} \frac{(-1)^{k-1}}{k} \pmod p = 1+\frac{1}{2}+\cdots+\frac{1}{\frac{p-1}{2}} \pmod p = \sum\limits_{k = 1}^{\frac{p-1}{2}} \frac{1}{k} \pmod p$</p><p>​</p><h3 id="中国剩余定理（孙子定理-CRT）"><a href="#中国剩余定理（孙子定理-CRT）" class="headerlink" title="中国剩余定理（孙子定理 / CRT）"></a>中国剩余定理（孙子定理 / CRT）</h3><p><strong>定义</strong></p><p>用现代数学的语言来说明的话，中国剩余定理给出了以下的一元线性同余方程组：</p><p>$(S):\left\{\begin{array} {c} x \equiv a_1 \pmod {m_1} \\ x \equiv a_2 \pmod {m_2} \\ \vdots \\ x \equiv a_n \pmod {m_n} \end{array} \right.$</p><p>有解的判定条件，并用构造法给出了在有解情况下解的具体形式。</p><p><strong>说明</strong></p><p>假设整数 $m_1,m_2,…,m_n$ 其中<strong>任两数互质</strong>，则对任意的整数：$a_1,a_2,…,a_n$，方程组 $(S)$ 有解，并且通解可以用如下方式构造得到：</p><ol><li><p>设 $M=m_1×m_2×\dots×m_n=\prod\limits_{i=1}^{n} m_i$ 是整数 $m_1,m_2,…,m_n$ 的乘积，并设 $M_i=\cfrac{M}{m_i},\forall i \in \{1,2,…,n\}$，即 $M_i$ 是除了 $m_i$ 以为的 $n-1$ 个整数的乘积。</p></li><li><p>设 $t_i=M_i^{-1}$ 为 $M_i$ 模 $m_i$ 的数论倒数：$t_iM_i \equiv 1 \pmod {m_i},\forall i \in \{1,2,…,n\}$。</p></li><li><p>方程组 $(S)$ 的通解形式为：</p><p>$x=a_1t_1M_1+a_2t_2M_2+\dots+a_nt_nM_n+kM=kM+\sum\limits_{i=1}^{n}a_it_iM_i,\quad k\in \mathbb{Z}$</p><p>在模 $M$ 的意义下，方程组 $(S)$ 只有一个解：$x=\sum\limits_{i=1}^{n}a_it_iM_i$。</p></li></ol><p>模不两两互质的同余式组可化为模两两互质的同余式组，再用孙子定理直接求解。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#sage</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">chinese_remainder</span>(<span class="params">modulus, remainders</span>):</span></span><br><span class="line">    Sum = <span class="number">0</span></span><br><span class="line">    prod = reduce(<span class="keyword">lambda</span> a, b: a*b, modulus)</span><br><span class="line">    <span class="keyword">for</span> m_i, r_i <span class="keyword">in</span> <span class="built_in">zip</span>(modulus, remainders):</span><br><span class="line">        p = prod // m_i</span><br><span class="line">        Sum += r_i * (inverse_mod(p,m_i)*p)</span><br><span class="line">    <span class="keyword">return</span> Sum % prod</span><br><span class="line">chinese_remainder([<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>],[<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>]) <span class="comment">#23</span></span><br></pre></td></tr></table></figure><p>​</p><h3 id="扩展中国剩余定理（扩展CRT-ExCRT）"><a href="#扩展中国剩余定理（扩展CRT-ExCRT）" class="headerlink" title="扩展中国剩余定理（扩展CRT / ExCRT）"></a>扩展中国剩余定理（扩展CRT / ExCRT）</h3><p>中国剩余定理是用来解同余方程组的，它要求 $m_1,m_2,…,m_n$其中两两互质。</p><p><strong>模不两两互质</strong>的同余式组可化为模两两互质的同余式组，再用中国剩余定理直接求解。</p><p><strong>形式</strong></p><p>给定 $n$ 组非负整数 $m_i, a_i$ ，求解关于 $x$ 的方程组的最小非负整数解。</p><p>$\left\{\begin{array} {c} x \equiv a_1 \pmod {m_1} \\ x \equiv a_2 \pmod {m_2} \\ \vdots \\ x \equiv a_n \pmod {m_n} \end{array} \right.$</p><p><strong>解法</strong></p><p>扩展中国剩余定理的方法和中国剩余定理关系不大，我们贪心处理前 $i-1$ 项，然后合并当前方程。</p><p>将每个方程拆成若干个方程 $x=a_i \pmod {p_{i,j}^{k_{i,j}}}$，其中 $m_i=\prod p_{i,j}^{k_{i,j}}$ 为$m_i$ 的分解式。</p><p>对每个质数 $p$，合并对应的所有方程，从而转化为模数两两互质的情形。若合并过程中出现矛盾，则原方程组无解。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#互质与不互质两种情况下都能工作良好的中国剩余定理（解同余方程组）</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">GCRT</span>(<span class="params">mi, ai</span>):</span></span><br><span class="line">	<span class="comment"># mi,ai分别表示模数和取模后的值,都为列表结构</span></span><br><span class="line">	<span class="keyword">assert</span> (<span class="built_in">isinstance</span>(mi, <span class="built_in">list</span>) <span class="keyword">and</span> <span class="built_in">isinstance</span>(ai, <span class="built_in">list</span>))</span><br><span class="line">	curm, cura = mi[<span class="number">0</span>], ai[<span class="number">0</span>]</span><br><span class="line">	<span class="keyword">for</span> (m, a) <span class="keyword">in</span> <span class="built_in">zip</span>(mi[<span class="number">1</span>:], ai[<span class="number">1</span>:]):</span><br><span class="line">		d = gmpy2.gcd(curm, m)</span><br><span class="line">		c = a - cura</span><br><span class="line">		<span class="keyword">assert</span> (c % d == <span class="number">0</span>) <span class="comment">#不成立则不存在解</span></span><br><span class="line">		K = c / d * gmpy2.invert(curm / d, m / d)</span><br><span class="line">		cura += curm * K</span><br><span class="line">		curm = curm * m / d</span><br><span class="line">	<span class="keyword">return</span> (cura % curm, curm) <span class="comment">#(解,最小公倍数)</span></span><br></pre></td></tr></table></figure><h4 id="变种1：Noisy-CRT"><a href="#变种1：Noisy-CRT" class="headerlink" title="变种1：Noisy CRT"></a>变种1：Noisy CRT</h4><p>$L_i=\frac{\prod p_i}{p_i} \cdot \Big((\frac{\prod p_i}{p_i})^{-1} \bmod p_i \Big)$</p><p>$N \equiv \sum\limits_{i=1}^{n}\sum\limits_{j=1}^{m} \delta_{i,j}r_{i,j}L_i \pmod {\prod p_i}, \delta = \{0,1\}$</p><p>构造格：</p><p>$M =<br>\begin{bmatrix}<br>P &amp; 0 &amp; \cdots &amp; \cdots &amp; 0 &amp; \newline<br>r_{1,1}L_1 &amp; B &amp; 0 &amp; \cdots &amp; 0 &amp; \newline<br>r_{1,2}L_1 &amp; 0 &amp; B &amp; \ddots &amp; \vdots &amp; \newline<br>\vdots &amp; \vdots &amp; \ddots &amp; \ddots &amp; 0 &amp; \newline<br>r_{n,m}L_n &amp; 0 &amp; \cdots &amp; 0 &amp; B &amp; \newline<br>\end{bmatrix}$</p><p>$B$ 主要是为了优化格，只需随意选取和 $N$ 的bit相同的数 $2^k$ 即可，目标向量为 $(N,\delta_{1,1}B,\delta_{1,2}B,\cdots,\delta_{n,m}B)$。</p><p>参考：</p><p><a target="_blank" rel="noopener" href="https://link.springer.com/content/pdf/10.1007/3-540-45539-6_4.pdf">Noisy Polynomial Interpolation and Noisy Chinese Remaindering</a></p><p>DeadSec CTF 2023 - Loud系列</p><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/Sone070805/p/17419744.html">Neepu CTF 2023 - Loud &amp; Loud2</a></p><p>​</p><h3 id="费马因式分解"><a href="#费马因式分解" class="headerlink" title="费马因式分解"></a>费马因式分解</h3><p><strong>引理</strong>：如果 $n$ 是一个<strong>正奇数</strong>,那么 $n$ 分解为两个正整数的积和表示成两个平方数是一一对应的。</p><p>即：$n=ab=x^2-y^2=(x+y)(x-y)=\left(\cfrac{a+b}{2}\right)^2-\left(\cfrac{a-b}{2}\right)^2$。</p><p>因为 $n$ 为奇数，$a,b$ 必也为奇数，所以 $(a+b)$ 和 $(a-b)$ 必为偶数，故能被 $2$ 整除。</p><p><strong>算法</strong></p><p>从 $x=\lceil\sqrt{n}\rceil+k,k \in \mathbb{Z}$ 开始，当 $(x^2-n)$ 可被完全开方，即 $x^2-n=y^2$ 时，即求出 $(x,y)$。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">factor</span>(<span class="params">n</span>):</span></span><br><span class="line">    a = gmpy2.iroot(n, <span class="number">2</span>)[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        B2 = <span class="built_in">pow</span>(a, <span class="number">2</span>) - n</span><br><span class="line">        <span class="keyword">if</span> gmpy2.is_square(B2):</span><br><span class="line">            b = gmpy2.iroot(B2, <span class="number">2</span>)[<span class="number">0</span>]</span><br><span class="line">            p = a + b</span><br><span class="line">            q = a - b</span><br><span class="line">            <span class="keyword">return</span> p, q</span><br><span class="line">        a += <span class="number">1</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> gmpy2 <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fermat_factorization</span>(<span class="params">n</span>):</span></span><br><span class="line">	factor_list = []</span><br><span class="line">	get_context().precision = <span class="number">2048</span></span><br><span class="line">	x = <span class="built_in">int</span>(sqrt(n))</span><br><span class="line">	<span class="built_in">print</span>(x)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">		x += <span class="number">1</span></span><br><span class="line">		y2 = x ** <span class="number">2</span> - n</span><br><span class="line">		<span class="keyword">if</span> is_square(y2):</span><br><span class="line">			<span class="built_in">print</span>(<span class="string">&#x27;x = &#x27;</span>,x)</span><br><span class="line">			y2 = mpz(y2)</span><br><span class="line">			get_context().precision = <span class="number">2048</span></span><br><span class="line">			y = <span class="built_in">int</span>(sqrt(y2))</span><br><span class="line">			factor_list.append([x+y, x-y])</span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(factor_list) == <span class="number">2</span>:</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">	<span class="keyword">return</span> factor_list</span><br></pre></td></tr></table></figure><p>​</p><h3 id="高斯整数"><a href="#高斯整数" class="headerlink" title="高斯整数"></a>高斯整数</h3><p>高斯整数 $\mathbb{Z}[i]=\{a+bi \mid a,b \in \mathbb{Z}\}$​。</p><p>对于 $z=x^2+y^2=(x+yi)(x-yi)=(y+xi)(y-xi)$​，且满足 $z=(a_1+b_1i)^t(a_1-b_1i)^t \cdots (a_k+b_ki)^t(a_k-b_ki)^t$，可用于分解 $z$ 求得 $x,y$。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">z = </span><br><span class="line">GI = GaussianIntegers()</span><br><span class="line">GI(z).factor()</span><br><span class="line"><span class="comment">#因子组合</span></span><br></pre></td></tr></table></figure><p>​</p><h3 id="CopperSmith攻击"><a href="#CopperSmith攻击" class="headerlink" title="CopperSmith攻击"></a>CopperSmith攻击</h3><p><strong>算法描述：</strong></p><p>假设 $N$ 是一个未知因子组成的数，且存在一个因子 $b \ge N^{\beta},(0 \lt \beta \le 1)$，$f(x)$ 是一个一元一次 $d$ 阶的多项式，且 $c \ge 1$，那么可以在 $\text{O}(cd^5\log^9(N))$ 的复杂度内求解所有的 $x_0$。</p><p>$f(x_0) \equiv 0 \pmod b, x_0 \le cN^{\frac{\beta^2}{d}}$</p><p>Coppersmith攻击与Don Coppersmith紧密相关，他提出了一种针对于模多项式（单变量，二元变量，甚至多元变量）找所有小整数根的多项式时间的方法。我们的目标是找到在模 $N$ 意义下多项式所有的根，这一问题被认为是复杂的，即满足下式的根：</p><p>$F(x)=x^n+a_{n-1} x^{n-1}+ ···+ a_1 x+a_0 \equiv 0 \pmod N$</p><p>Coppersmith method 主要是通过 Lenstra–Lenstra–Lovász lattice basis reduction algorithm（LLL）方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Sage</span></span><br><span class="line"><span class="comment"># 单元</span></span><br><span class="line">PR.&lt;x&gt; = PolynomialRing(Zmod(n))</span><br><span class="line">f = (a + x)^e - c</span><br><span class="line">root = f.small_roots(X=<span class="number">2</span>^<span class="number">256</span>, beta=<span class="number">1</span>)[<span class="number">0</span>]  <span class="comment"># find root &lt; 2^256 with factor = n</span></span><br><span class="line"><span class="comment">#调参，增大格</span></span><br><span class="line"><span class="comment">#beta=0.48, epsilon=0.02</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">### 多元1</span></span><br><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">small_roots</span>(<span class="params">f, bounds, m=<span class="number">1</span>, d=<span class="literal">None</span></span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> d:</span><br><span class="line">        d = f.degree()</span><br><span class="line"> </span><br><span class="line">    R = f.base_ring()</span><br><span class="line">    N = R.cardinality()</span><br><span class="line">    </span><br><span class="line">    f /= f.coefficients().pop(<span class="number">0</span>)</span><br><span class="line">    f = f.change_ring(ZZ)</span><br><span class="line"> </span><br><span class="line">    G = <span class="type">Sequence</span>([], f.parent())</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m+<span class="number">1</span>):</span><br><span class="line">        base = N^(m-i) * f^i</span><br><span class="line">        <span class="keyword">for</span> shifts <span class="keyword">in</span> itertools.product(<span class="built_in">range</span>(d), repeat=f.nvariables()):</span><br><span class="line">            g = base * prod(<span class="built_in">map</span>(power, f.variables(), shifts))</span><br><span class="line">            G.append(g)</span><br><span class="line"> </span><br><span class="line">    B, monomials = G.coefficient_matrix()</span><br><span class="line">    monomials = vector(monomials)</span><br><span class="line"> </span><br><span class="line">    factors = [monomial(*bounds) <span class="keyword">for</span> monomial <span class="keyword">in</span> monomials]</span><br><span class="line">    <span class="keyword">for</span> i, factor <span class="keyword">in</span> <span class="built_in">enumerate</span>(factors):</span><br><span class="line">        B.rescale_col(i, factor)</span><br><span class="line"> </span><br><span class="line">    B = B.dense_matrix().LLL()</span><br><span class="line"> </span><br><span class="line">    B = B.change_ring(QQ)</span><br><span class="line">    <span class="keyword">for</span> i, factor <span class="keyword">in</span> <span class="built_in">enumerate</span>(factors):</span><br><span class="line">        B.rescale_col(i, <span class="number">1</span>/factor)</span><br><span class="line"> </span><br><span class="line">    H = <span class="type">Sequence</span>([], f.parent().change_ring(QQ))</span><br><span class="line">    <span class="keyword">for</span> h <span class="keyword">in</span> <span class="built_in">filter</span>(<span class="literal">None</span>, B*monomials):</span><br><span class="line">        H.append(h)</span><br><span class="line">        I = H.ideal()</span><br><span class="line">        <span class="keyword">if</span> I.dimension() == -<span class="number">1</span>:</span><br><span class="line">            H.pop()</span><br><span class="line">        <span class="keyword">elif</span> I.dimension() == <span class="number">0</span>:</span><br><span class="line">            roots = []</span><br><span class="line">            <span class="keyword">for</span> root <span class="keyword">in</span> I.variety(ring=ZZ):</span><br><span class="line">                root = <span class="built_in">tuple</span>(R(root[var]) <span class="keyword">for</span> var <span class="keyword">in</span> f.variables())</span><br><span class="line">                roots.append(root)</span><br><span class="line">            <span class="keyword">return</span> roots</span><br><span class="line">    <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">PR.&lt;a, b&gt; = PolynomialRing(Zmod(n))</span><br><span class="line">f = <span class="number">4</span>*r^<span class="number">2</span>*a*b + <span class="number">2</span>*r*(a+b) + <span class="number">1</span> - n</span><br><span class="line">roots = small_roots(f, (<span class="number">2</span>^<span class="number">256</span>, <span class="number">2</span>^<span class="number">256</span>), m=<span class="number">3</span>)</span><br><span class="line">a, b = roots[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">PR.&lt;x, y&gt; = PolynomialRing(Zmod(q)) <span class="comment"># n = x*y</span></span><br><span class="line"><span class="comment"># PR.&lt;x, y&gt; = Polygen(RealField(1000)) # n ≈ x*y</span></span><br><span class="line">f = (<span class="number">2</span>^<span class="number">256</span> * a + x) * s  - (<span class="number">2</span>^<span class="number">256</span> + <span class="number">1</span>) * y * b - c</span><br><span class="line">roots = small_roots(f, [<span class="number">2</span>^<span class="number">256</span>, <span class="number">2</span>^<span class="number">256</span>], m=<span class="number">4</span>, d=<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">### 多元2（二元）</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bivariate</span>(<span class="params">pol, XX, YY, kk=<span class="number">3</span></span>):</span></span><br><span class="line">    N = pol.parent().characteristic()</span><br><span class="line"></span><br><span class="line">    f = pol.change_ring(ZZ)</span><br><span class="line">    PR,(x,y) = f.parent().objgens()</span><br><span class="line"></span><br><span class="line">    idx = [ (k-i, i) <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(kk+<span class="number">1</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k+<span class="number">1</span>) ]</span><br><span class="line">    monomials = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> t: PR( x**t[<span class="number">0</span>]*y**t[<span class="number">1</span>] ), idx))</span><br><span class="line">    <span class="comment"># collect the shift-polynomials</span></span><br><span class="line">    g = []</span><br><span class="line">    <span class="keyword">for</span> h,i <span class="keyword">in</span> idx:</span><br><span class="line">        <span class="keyword">if</span> h == <span class="number">0</span>:</span><br><span class="line">            g.append( y**h * x**i * N )</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            g.append( y**(h-<span class="number">1</span>) * x**i * f )</span><br><span class="line"></span><br><span class="line">    <span class="comment"># construct lattice basis</span></span><br><span class="line">    M = Matrix(ZZ, <span class="built_in">len</span>(g))</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> <span class="built_in">range</span>( M.nrows() ):</span><br><span class="line">        <span class="keyword">for</span> col <span class="keyword">in</span> <span class="built_in">range</span>( M.ncols() ):</span><br><span class="line">            h,i = idx[col]</span><br><span class="line">            M[row,col] = g[row][h,i] * XX**h * YY**i</span><br><span class="line"></span><br><span class="line">    <span class="comment"># LLL</span></span><br><span class="line">    B = M.LLL()</span><br><span class="line"></span><br><span class="line">    PX = PolynomialRing(ZZ, <span class="string">&#x27;xs&#x27;</span>)</span><br><span class="line">    xs = PX.gen()</span><br><span class="line">    PY = PolynomialRing(ZZ, <span class="string">&#x27;ys&#x27;</span>)</span><br><span class="line">    ys = PY.gen()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Transform LLL-reduced vectors to polynomials</span></span><br><span class="line">    H = [ ( i, PR(<span class="number">0</span>) ) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>( B.nrows() ) ]</span><br><span class="line">    H = <span class="built_in">dict</span>(H)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>( B.nrows() ):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>( B.ncols() ):</span><br><span class="line">            H[i] += PR( (monomials[j]*B[i,j]) / monomials[j](XX, YY) )</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Find the root</span></span><br><span class="line">    poly1 = H[<span class="number">0</span>].resultant(H[<span class="number">1</span>], y).subs(x=xs)</span><br><span class="line">    poly2 = H[<span class="number">0</span>].resultant(H[<span class="number">2</span>], y).subs(x=xs)</span><br><span class="line">    poly = gcd(poly1, poly2)</span><br><span class="line">    x_root = poly.roots()[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    poly1 = H[<span class="number">0</span>].resultant(H[<span class="number">1</span>], x).subs(y=ys)</span><br><span class="line">    poly2 = H[<span class="number">0</span>].resultant(H[<span class="number">2</span>], x).subs(y=ys)</span><br><span class="line">    poly = gcd(poly1, poly2)</span><br><span class="line">    y_root = poly.roots()[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> x_root, y_root</span><br><span class="line"></span><br><span class="line">PR.&lt;x,y&gt; = PolynomialRing(Zmod(N))</span><br><span class="line">f = (x*<span class="number">2</span>**<span class="number">923</span>)+p0+y</span><br><span class="line">x, y = bivariate(f, <span class="number">2</span>^<span class="number">101</span>, <span class="number">2</span>^<span class="number">101</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#其他多元</span></span><br><span class="line">load(<span class="string">&#x27;coppersmith.sage&#x27;</span>)</span><br><span class="line">P.&lt;x, y&gt; = PolynomialRing(GF(p))</span><br><span class="line">f = <span class="number">2</span>^<span class="number">170</span> * a^<span class="number">2</span> + <span class="number">2</span>^<span class="number">86</span> * a * x + x^<span class="number">2</span> - <span class="number">2</span>^<span class="number">85</span> * b + c - y</span><br><span class="line">roots = coron(f, X=<span class="number">2</span>^<span class="number">85</span>, Y=<span class="number">2</span>^<span class="number">85</span>, k=<span class="number">1</span>, debug=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p>​</p><h3 id="Grobner基"><a href="#Grobner基" class="headerlink" title="Gröbner基"></a>Gröbner基</h3><p><strong>空间和域</strong></p><p><img src="/2020/05/10/crypto-crypto%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/20200212194719428.png" alt="img" style="zoom:67%"></p><p><img src="/2020/05/10/crypto-crypto%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/20191109103824108.png" alt="img" style="zoom:80%"></p><p><strong>理想</strong></p><p>$F=\{f_1,\cdots,f_k\}$ 是一个多项式集合，其生成的理想为集合元素的线性组合，组合系数也是多项式</p><p>$\langle f_1,\cdots,f_k \rangle=\biggl\{ \sum\limits_{i=1}^k g_if_i \vert g_1,\cdots,g_k \in K[x_1,\cdots,x_n] \biggr\}$，</p><p>其中 $R=K[x_1,\cdots,x_n]$ 是在域 $K$ 上的多项式环。</p><ul><li><p>环 $R$ 的一个非空子集 $I$ ，如果对于 $R$ 的两个代数运算，满足条件：对任意 $a,b \in I,r \in R$，有 $a-b \in I,ra \in I$，则称 $I$ 是环 $R$ 的一个左理想。</p></li><li><p>环 $R$ 的一个非空子集 $I$ ，如果对于 $R$ 的两个代数运算，满足条件：对任意 $a,b \in I,r \in R$，有 $a-b \in I,ar \in I$，则称 $I$ 是环 $R$ 的一个右理想。</p></li><li><p>环 $R$ 的一个非空子集 $I$ ，如果既是左理想又是右理想，称 $I$ 为 $R$ 的双边理想，通常简称 $I$ 为 $R$ 的理想。</p></li></ul><p>根据以下定理，每个理想都有一个生成集：</p><ul><li><p>Hilbert 基定理：</p><p>每个多项式理想 $I \subseteq K[x_1,\cdots,x_n]$ 都有一个有限生成集，即存在 $g_1,\cdots,g_t \in I$，使得 $I=\langle g_1,\cdots,g_t \rangle$。</p></li></ul><p><strong>Gröbner基定义</strong></p><p>对于单项式序下的多项式环 $K[x_1,\cdots,x_n]$，理想 $I \subseteq K[x_1,\cdots,x_n]$ 的非 $\{0\}$ 且满足 $\langle \mathrm{LT}(g_1),\cdots,\mathrm{LT}(g_t) \rangle=\langle \mathrm{LT}(I) \rangle$ 的有限生成集 $G=\{g_1,\cdots,g_t\}$，称为<strong>Gröbner基</strong>。定义 $\{0\}$ 的Gröbner基为空集 $\varnothing$。</p><p>Gröbner基的两个应用，判断一个多项式是否属于当前的Gröbner基生成的理想 （即Ideal Membership problem），另一个应用就是解方程组。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Sage</span></span><br><span class="line"><span class="comment">###ZZ/QQ/RR</span></span><br><span class="line"><span class="comment">#Example-1</span></span><br><span class="line">P.&lt;x, y&gt; = PolynomialRing(QQ)</span><br><span class="line">f1 = x^<span class="number">2</span> + x*y - <span class="number">10</span></span><br><span class="line">f2 = x^<span class="number">3</span> + x^<span class="number">2</span>*y - <span class="number">20</span></span><br><span class="line">f3 = x^<span class="number">4</span> + x*y^<span class="number">3</span> - <span class="number">70</span></span><br><span class="line">G = Ideal([f1, f2, f3]).groebner_basis()</span><br><span class="line"><span class="built_in">print</span>(G)</span><br><span class="line"></span><br><span class="line"><span class="comment">#Example-2</span></span><br><span class="line">PR = PolynomialRing(Zmod(N), <span class="string">&#x27;x&#x27;</span>, <span class="built_in">len</span>(Cs))</span><br><span class="line">x = PR.gens()</span><br><span class="line">f1 = (<span class="number">65537</span>*x[<span class="number">0</span>] - <span class="number">66666</span>*x[<span class="number">1</span>] + <span class="number">12345</span>*x[<span class="number">2</span>] - x[<span class="number">3</span>])</span><br><span class="line">f2 = x[<span class="number">0</span>] + x[<span class="number">1</span>] + x[<span class="number">2</span>] - s</span><br><span class="line">Fs = [f1, f2]</span><br><span class="line">Fs.extend([(x[i]**e - Cs[i]) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(l)])</span><br><span class="line">I = Ideal(Fs)</span><br><span class="line">B = I.groebner_basis()</span><br><span class="line"><span class="built_in">print</span>(B)</span><br><span class="line">m = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> b <span class="keyword">in</span> B:</span><br><span class="line">    <span class="keyword">assert</span> b.degree() == <span class="number">1</span></span><br><span class="line">    mi = ZZ(-b(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">    <span class="built_in">print</span>(mi)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">###Zmod(p)</span></span><br><span class="line"><span class="keyword">from</span> sage.matrix.matrix2 <span class="keyword">import</span> Matrix </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">resultant</span>(<span class="params">f1, f2, var</span>):</span></span><br><span class="line">    <span class="keyword">return</span> Matrix.determinant(f1.sylvester_matrix(f2, var))</span><br><span class="line"></span><br><span class="line">P.&lt;Rx, Ry, Qx, Qy&gt; = PolynomialRing(Zmod(p))</span><br><span class="line">f1 = Ry^<span class="number">2</span> - Rx^<span class="number">3</span> - a*Rx - b</span><br><span class="line">f2 = Qy^<span class="number">2</span> - Qx^<span class="number">3</span> - a*Qx - b</span><br><span class="line">f3 = (Qy + Ry)^<span class="number">2</span> + (Qx - Rx)^<span class="number">2</span> * (- Rx - Qx - Px)</span><br><span class="line">f4 = (- Qy - Ry) * (Rx - Px) + (Qx - Rx) * (- Ry - Py)</span><br><span class="line">f5 = Rx * Qx - N</span><br><span class="line">G = Ideal([f1, f2, f3, f4, f5]).groebner_basis()</span><br><span class="line"></span><br><span class="line"><span class="comment">#结式+矩阵子式（西尔维斯特矩阵）</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;[!] computing resultant h1...&#x27;</span>)</span><br><span class="line">h1 = resultant(G[<span class="number">0</span>], G[<span class="number">1</span>], Rx) <span class="comment"># Ry, Qx, Qy</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;[!] computing resultant h2...&#x27;</span>)</span><br><span class="line">h2 = resultant(G[<span class="number">0</span>], G[<span class="number">2</span>], Rx) <span class="comment"># Ry, Qx, Qy</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;[!] computing resultant h3...&#x27;</span>)</span><br><span class="line">h3 = resultant(G[<span class="number">3</span>], G[<span class="number">4</span>], Rx) <span class="comment"># Ry, Qx, Qy</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;[!] computing resultant h4...&#x27;</span>)</span><br><span class="line">h4 = resultant(G[<span class="number">3</span>], G[<span class="number">5</span>], Rx) <span class="comment"># Ry, Qx, Qy</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;[!] computing resultant h5...&#x27;</span>)</span><br><span class="line">h5 = resultant(h1, h2, Ry) <span class="comment"># Qx, Qy</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;[!] computing resultant h6...&#x27;</span>)</span><br><span class="line">h6 = resultant(h3, h4, Ry) <span class="comment"># Qx, Qy</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;[!] computing resultant h7...&#x27;</span>)</span><br><span class="line">h7 = resultant(h5, h6, Qy) <span class="comment"># Qx</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;[!] computing resultant h8...&#x27;</span>)</span><br><span class="line">h8 = resultant(h7, f5, Qx) <span class="comment"># Rx</span></span><br><span class="line">roots = h8.univariate_polynomial().roots()</span><br><span class="line">p, q = [ZZ(t[<span class="number">0</span>]) <span class="keyword">for</span> t <span class="keyword">in</span> roots <span class="keyword">if</span> ZZ(t[<span class="number">0</span>]).is_prime()]</span><br></pre></td></tr></table></figure><p>​</p><h3 id="Diffie-Hellman密钥交换（DH密钥交换-DHKE）"><a href="#Diffie-Hellman密钥交换（DH密钥交换-DHKE）" class="headerlink" title="Diffie-Hellman密钥交换（DH密钥交换 / DHKE）"></a>Diffie-Hellman密钥交换（DH密钥交换 / DHKE）</h3><p>Diffie-Hellman密钥交换（DHKE）是由Whitfield Diffie和Martin Hellman在1976年提出的。密钥交换方案提供了实际中密钥分配问题的解决方案，即允许双方通过不安全的信道进行交流获得一个共同密钥。许多公开和商业密码协议中都实现了这种基本的密钥协议技术。</p><p>基于乘法群：</p><ol><li>A和B协商一个有限循环群 $G$ 和它的一个生成元 $g$，一个大素数 $p$；</li><li>A生成一个随机数 $a$，计算 $A=g^a \pmod p$，将 $A$ 发送给B；</li><li>B生成一个随机数 $b$，计算 $B=g^b \pmod p$，将 $B$ 发送给A；</li><li>A计算 $K=B^a \pmod p=(g^b)^a \pmod p$，得到共享密钥 $K$；</li><li>B计算 $K=A^b \pmod p=(g^a)^b \pmod p$，得到共享密钥 $K$。</li></ol><p>基于加法群：</p><ol><li>A和B协商一个有限循环群 $G$ 和它的一个生成元 $g$，一个大素数 $p$；</li><li>A生成一个随机数 $a$，计算 $A=ag \pmod p$，将 $A$ 发送给B；</li><li>B生成一个随机数 $b$，计算 $B=bg \pmod p$，将 $B$ 发送给A；</li><li>A计算 $K=aB \pmod p=a(bg) \pmod p$，得到共享密钥 $K$；</li><li><p>B计算 $K=bA \pmod p=b(ag) \pmod p$，得到共享密钥 $K$。</p><p>​</p></li></ol><h3 id="矩阵快速幂"><a href="#矩阵快速幂" class="headerlink" title="矩阵快速幂"></a>矩阵快速幂</h3><p>根据斐波那契的递推公式：</p><p>$\left\{\begin{array}{cl} f(n)&amp;=&amp;f(n-1)+f(n-2) \\ f(n-1)&amp;=&amp;f(n-1) \end{array}\right. \Rightarrow \begin{bmatrix} f(n) \\ f(n-1) \end{bmatrix}=\begin{bmatrix} 1 &amp; 1 \\ 1 &amp; 0 \end{bmatrix}\begin{bmatrix} f(n-1) \\ f(n-2) \end{bmatrix}$</p><p>设 $\begin{bmatrix} f(n) \\ f(n-1) \end{bmatrix}=F(n)$，则 $F(n)=\begin{bmatrix} 1 &amp; 1 \\ 1 &amp; 0 \end{bmatrix} \cdot F(n-1)$</p><p>把矩阵当成一个常数来看，即类似等比数列递推公式，即：</p><p>$\begin{bmatrix} f(n) \\ f(n-1) \end{bmatrix}=\begin{bmatrix} 1 &amp; 1 \\ 1 &amp; 0 \end{bmatrix}^{n-1}\begin{bmatrix} f(1) \\ f(0) \end{bmatrix}$</p><p>所以最终转换成一个求解矩阵幂运算的通项公式。</p><p>普通快速幂算法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &amp; <span class="number">1</span>) </span><br><span class="line">            res = res * x % m;</span><br><span class="line">        x = x * x % m;</span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据矩阵乘法运算改写为矩阵快速幂：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 2</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">matrix</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> m[N][N];</span><br><span class="line">    matrix() &#123;</span><br><span class="line">        <span class="built_in">memset</span>(m, <span class="number">0</span>, <span class="keyword">sizeof</span>(m));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">prt</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">matrix::prt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++ i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; ++ j) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="keyword">this</span> -&gt; m[i][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">matrix <span class="keyword">operator</span> * (<span class="keyword">const</span> matrix a, <span class="keyword">const</span> matrix b) &#123;</span><br><span class="line">    matrix ans;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++ i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; ++ j) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; N; ++ k) &#123;</span><br><span class="line">                ans.m[i][j] += a.m[i][k] * b.m[k][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">matrix <span class="title">qpow</span><span class="params">(matrix x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    matrix res;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++ i) &#123;</span><br><span class="line">        res.m[i][i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &amp; <span class="number">1</span>) res = res * x;</span><br><span class="line">        x = x * x;</span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    matrix a;</span><br><span class="line">    a.m[<span class="number">0</span>][<span class="number">0</span>] = a.m[<span class="number">1</span>][<span class="number">0</span>] = a.m[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    matrix base;</span><br><span class="line">    base.m[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    matrix ans = qpow(a, n - <span class="number">1</span>);</span><br><span class="line">    ans = ans * base;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans.m[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; fib(<span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 1</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; fib(<span class="number">2</span>) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 1</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; fib(<span class="number">3</span>) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 2</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; fib(<span class="number">4</span>) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 3</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; fib(<span class="number">5</span>) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 5</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; fib(<span class="number">6</span>) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 8</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; fib(<span class="number">7</span>) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 13</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>其他递推关系</p><p>$f(n)=af(n-1)+bf(n-2)\Longrightarrow \begin{bmatrix} f(n) \\ f(n-1) \end{bmatrix}=\begin{bmatrix} a &amp; b \\ 1 &amp; 0 \end{bmatrix}\begin{bmatrix} f(n-1) \\ f(n-2) \end{bmatrix}$</p><p>$f(n)=af(n-1)+bf(n-2)+c \Longrightarrow \begin{bmatrix} f(n) \\ f(n-1) \\ c \end{bmatrix}=\begin{bmatrix} a &amp; b &amp; 1 \\ 1 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 1 \end{bmatrix}\begin{bmatrix} f(n-1) \\ f(n-2) \\ c\end{bmatrix}$</p><p>$f(n)=ac^n+bf(n-1)+d \Longrightarrow \begin{bmatrix} f(n) \\ c^n \\ d \end{bmatrix}=\begin{bmatrix} b &amp; ac &amp; 1 \\ 0 &amp; c &amp; 0 \\ 0 &amp; 0 &amp; 1 \end{bmatrix}\begin{bmatrix} f(n-1) \\ c^{n-1} \\ d\end{bmatrix}$</p><p>$S(n)=A \cdot S(n-1)+A\Longrightarrow \begin{bmatrix} S(n) \\ A \end{bmatrix}=\begin{bmatrix} A &amp; E \\ 0 &amp; E \end{bmatrix}\begin{bmatrix} S(n-1) \\ A \end{bmatrix}$</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#以2x2矩阵相乘为例</span></span><br><span class="line">m = [[<span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>)]<span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>)]</span><br><span class="line">m[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mulMatrix</span>(<span class="params">x,y</span>):</span>     <span class="comment">#定义二阶矩阵相乘的函数</span></span><br><span class="line">    ans = [[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>)]<span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>):</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>):</span><br><span class="line">                ans[i][j] += x[i][k] * y[k][j]</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quickMatrix</span>(<span class="params">m,n</span>):</span></span><br><span class="line">    E = [[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>)]<span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>)]        <span class="comment">#先定义一个单位矩阵</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>):</span><br><span class="line">        E[i][i] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span>(n):</span><br><span class="line">        <span class="keyword">if</span> n % <span class="number">2</span> != <span class="number">0</span>:</span><br><span class="line">            E = mulMatrix(E,m)</span><br><span class="line">        m = mulMatrix(m,m)</span><br><span class="line">        n &gt;&gt;= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> E</span><br><span class="line"><span class="built_in">print</span>(quickMatrix(m,n))</span><br></pre></td></tr></table></figure><p>​</p><h3 id="佩尔方程-Pell方程"><a href="#佩尔方程-Pell方程" class="headerlink" title="佩尔方程 / Pell方程"></a>佩尔方程 / Pell方程</h3><p>若一个不定方程具有形式：</p><p>$x^2-ny^2=1$</p><p>则称此二元二次不定方程为佩尔方程。</p><p>若 $n$ 是完全平方数，则这个方程式只有平凡解。对于其余情况，拉格朗日证明了佩尔方程总有非平凡解。而这些解可由 $\sqrt{n}$ 的连分数求出。</p><p>设 $\frac{p}{q}$ 是 $\sqrt{n}$ 的连分数表示：$[a_0;a_1,a_2,a_3,\cdots]$ 的渐进分数列，由连分数理论知存在 $i$ 使得 $(p_i,q_i)$ 为佩尔方程的解。取其中最小的 $i$，将对应的 $(p_i,q_i)$ 称为佩尔方程的基本解（最小解），记作 $(x_1,y_1)$，则所有的解 $(x_i,y_i)$ 可表示成如下形式：</p><p>$x_i+y_i\sqrt{n}=(x_1+y_1\sqrt{n})^i$</p><p>或者由以下的递推式得到：</p><p>$x_{i+1} = x_1x_i+ny_1y_i$</p><p>$y_{i+1} = x_1y_i+y_1x_i$</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solve_pell</span>(<span class="params">N, numTry = <span class="number">100</span></span>):</span></span><br><span class="line">    cf = continued_fraction(sqrt(N))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(numTry):</span><br><span class="line">        denom = cf.denominator(i)</span><br><span class="line">        numer = cf.numerator(i)</span><br><span class="line">        <span class="keyword">if</span> numer^<span class="number">2</span> - N * denom^<span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> numer, denom</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span>, <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">N = </span><br><span class="line">solve_pell(N)</span><br></pre></td></tr></table></figure></div><div class="article-footer"></div></article><section id="comments"><div id="vcomments"></div></section></div><nav class="bar bar-footer clearfix" data-stick-bottom><div class="bar-inner"><ul class="pager pull-left"><li class="prev"><a href="/2020/05/10/crypto-crypto%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/" title="crypto常用工具"><i class="icon icon-angle-left" aria-hidden="true"></i><span>&nbsp;&nbsp;上一篇</span></a></li><li class="next"><a href="/2020/05/10/reverse-Android%E9%80%86%E5%90%91/" title="Android逆向"><span>下一篇&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a></li><li class="toggle-toc"><a class="toggle-btn collapsed" data-toggle="collapse" href="#collapseToc" aria-expanded="false" title="文章目录" role="button"><span>[&nbsp;</span><span>文章目录</span> <i class="text-collapsed icon icon-anchor"></i> <i class="text-in icon icon-close"></i> <span>]</span></a></li></ul><button type="button" class="btn btn-fancy btn-donate pop-onhover bg-gradient-warning" data-toggle="modal" data-target="#donateModal"><span>赏</span></button><div class="bar-right"><div class="share-component" data-sites="weibo,qq,wechat" data-mobile-sites="weibo,qq,wechat"></div></div></div></nav><div class="modal modal-center modal-small modal-xs-full fade" id="donateModal" tabindex="-1" role="dialog"><div class="modal-dialog" role="document"><div class="modal-content donate"><button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button><div class="modal-body"><div class="donate-box"><div class="donate-head"><p>这篇文章对你有用，赏一杯咖啡☕~~</p></div><div class="tab-content"><div role="tabpanel" class="tab-pane fade active in" id="wechatpay"><div class="donate-payimg"><img src="/images/donate/wechatpayimg.png" alt="扫码支持" title="扫一扫"></div><p class="text-muted mv">⎝Lazzaro⎠</p><p class="text-grey">打开微信扫一扫即可扫码打赏他一波哦~</p></div><div role="tabpanel" class="tab-pane fade" id="alipay"><div class="donate-payimg"><img src="/images/donate/alipayimg.png" alt="扫码支持" title="扫一扫"></div><p class="text-muted mv">⎝Lazzaro⎠</p><p class="text-grey">打开支付宝扫一扫即可扫码打赏他一波哦~</p></div></div><div class="donate-footer"><ul class="nav nav-tabs nav-justified" role="tablist"><li role="presentation" class="active"><a href="#wechatpay" role="tab" id="wechatpay-tab" data-toggle="tab" aria-controls="wechatpay" aria-expanded="true"><i class="icon icon-wepay"></i> 微信支付</a></li><li role="presentation"><a href="#alipay" id="alipay-tab" role="tab" data-toggle="tab" aria-controls="alipay" aria-expanded="false"><i class="icon icon-alipay"></i> 支付宝</a></li></ul></div></div></div></div></div></div></main><footer class="footer" itemscope itemtype="http://schema.org/WPFooter"><ul class="social-links"><li><a href="https://github.com/Lazzzaro" target="_blank" title="Github" data-toggle="tooltip" data-placement="top"><i class="icon icon-github"></i></a></li></ul><div class="copyright">&copy; 2023 Lazzaro<br><span>总访问 - <span id="busuanzi_value_site_pv"></span>次</span><br><span>访客数 - <span id="busuanzi_value_site_uv"></span>人</span><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></footer><script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script><script>window.jQuery||document.write('<script src="js/jquery.min.js"><\/script>')</script><script src="/js/plugin.min.js"></script><script src="/js/application.js"></script><script>window.INSIGHT_CONFIG={TRANSLATION:{POSTS:"文章",PAGES:"页面",CATEGORIES:"类别",TAGS:"关键词",UNTITLED:"(未命名)"},ROOT_URL:"/",CONTENT_URL:"/content.json"}</script><script src="/js/insight.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//cdn.jsdelivr.net/npm/valine"></script><script type="text/javascript">var GUEST=["nick","mail","link"],meta=(meta="nick,mail,link").split(",").filter(function(e){return-1<GUEST.indexOf(e)});new Valine({el:"#vcomments",verify:!1,notify:!1,appId:"sK4BUsDgfSB843HYgJyTcV7P-gzGzoHsz",appKey:"NKNx8m2CtFeDofr8LNLX7aNG",placeholder:"来来来说点啥~~\r\n对你有用？赏一波！↘↘",avatar:"mp",meta:meta,pageSize:"10",visitor:!0})</script><script defer type="text/javascript">!function(e,a,t,n,g,c){e.GoogleAnalyticsObject=n,e.ga=e.ga||function(){(e.ga.q=e.ga.q||[]).push(arguments)},e.ga.l=+new Date,g=a.createElement(t),c=a.getElementsByTagName(t)[0],g.async=1,g.src="//www.google-analytics.com/analytics.js",c.parentNode.insertBefore(g,c)}(window,document,"script","ga"),ga("create","UA-165804489-1","auto"),ga("send","pageview")</script><style>.copy-btn{display:inline-block;padding:6px 12px;font-size:13px;font-weight:700;line-height:20px;color:#333;white-space:nowrap;vertical-align:middle;cursor:pointer;background-color:#eee;background-image:linear-gradient(#fcfcfc,#eee);border:1px solid #d5d5d5;border-radius:3px;user-select:none;outline:0}.highlight-wrap .copy-btn{transition:opacity .3s ease-in-out;opacity:0;padding:2px 6px;position:absolute;right:4px;top:8px;z-index:2}.highlight-wrap .copy-btn:focus,.highlight-wrap:hover .copy-btn{opacity:1}.highlight-wrap{position:relative}</style><script>addLoadEvent(()=>{$(".highlight").each(function(t,e){var n=$("<div>").addClass("highlight-wrap");$(e).after(n),n.append($("<button>").addClass("copy-btn").append("复制").on("click",function(t){var e=$(this).parent().find(".code")[0].innerText;e+="\n/**\n* 复制并使用代码请注明引用出处哦~\n* Lazzaro @ https://lazzzaro.github.io\n*/";var n=document.createElement("textarea");document.body.appendChild(n),n.style.position="absolute",n.style.top="0px",n.style.left="0px",n.value=e,n.select(),n.focus();e=document.execCommand("copy");document.body.removeChild(n),e?$(this).text("复制成功"):$(this).text("复制失败"),$(this).blur()})).on("mouseleave",function(t){var e=$(this).find(".copy-btn");setTimeout(function(){e.text("复制")},300)}).append(e)})})</script></body></html>