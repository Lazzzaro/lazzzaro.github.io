<!DOCTYPE html><html lang="zh"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1,user-scalable=no,minimal-ui"><meta name="renderer" content="webkit"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta name="format-detection" content="telephone=no,email=no,adress=no"><meta name="theme-color" content="#000000"><meta http-equiv="window-target" content="_top"><title>其他加密算法 | Lazzaro</title><meta name="description" content="​     GM（Goldwasser-Micali）同态加密Goldwasser-Micali (GM) 加密方案是第一个证明为 CPA 安全的公钥加密方案，其安全性依赖于从合数模的二次非剩余中区分二次剩余困难性假设。  密钥生成 用户随机生成两个大素数 $p$ 和 $q$，计算 $n&#x3D;pq$，$z$ 是模 $n$ 的二次非剩余中的随机数。系统公钥 $pk&#x3D;(n,z)$，系统私钥 $sk&#x3D;(p,"><meta property="og:type" content="article"><meta property="og:title" content="其他加密算法"><meta property="og:url" content="https://lazzzaro.github.io/2020/05/13/crypto-%E5%85%B6%E4%BB%96%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/index.html"><meta property="og:site_name" content="Lazzaro"><meta property="og:description" content="​     GM（Goldwasser-Micali）同态加密Goldwasser-Micali (GM) 加密方案是第一个证明为 CPA 安全的公钥加密方案，其安全性依赖于从合数模的二次非剩余中区分二次剩余困难性假设。  密钥生成 用户随机生成两个大素数 $p$ 和 $q$，计算 $n&#x3D;pq$，$z$ 是模 $n$ 的二次非剩余中的随机数。系统公钥 $pk&#x3D;(n,z)$，系统私钥 $sk&#x3D;(p,"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2020-05-13T12:21:19.000Z"><meta property="article:modified_time" content="2025-07-30T11:14:37.770Z"><meta property="article:author" content="Lazzaro"><meta property="article:tag" content="算法"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://lazzzaro.github.io/2020/05/13/crypto-%E5%85%B6%E4%BB%96%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/index.html"><link rel="alternate" href="/atom.xml" title="Lazzaro" type="application/atom+xml"><link rel="icon" href="/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link href="https://cdn.jsdelivr.net/npm/katex@0.9.0/dist/katex.min.css" rel="stylesheet"><script charset="UTF-8" id="LA_COLLECT" src="//sdk.51.la/js-sdk-pro.min.js"></script><script>LA.init({id:"3Ft5J9t2Jl0eb5Zr",ck:"3Ft5J9t2Jl0eb5Zr",hashMode:!0})</script><meta name="generator" content="Hexo 7.0.0"></head><body class="main-center theme-black" itemscope itemtype="http://schema.org/WebPage"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="slimContent"><div class="navbar-header"><div class="profile-block text-center"><a id="avatar" href="https://github.com/Lazzzaro" target="_blank"><img class="img-circle img-rotate" src="/images/avatar.jpg" width="200" height="200"></a><h2 id="name" class="hidden-xs hidden-sm">Lazzaro</h2><h3 id="title" class="hidden-xs hidden-sm hidden-md">CTF弱鸡自进阶</h3><small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> flag{}___Orz</small></div><div class="search" id="search-form-wrap"><form class="search-form sidebar-form"><div class="input-group"><input type="text" class="search-form-input form-control" placeholder="搜索"> <span class="input-group-btn"><button type="submit" class="search-form-submit btn btn-flat" onclick="return!1"><i class="icon icon-search"></i></button></span></div></form><div class="ins-search"><div class="ins-search-mask"></div><div class="ins-search-container"><div class="ins-input-wrapper"><input type="text" class="ins-search-input" placeholder="想要查找什么..." x-webkit-speech> <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button></div><div class="ins-section-wrapper"><div class="ins-section-container"></div></div></div></div></div><button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false"><span class="sr-only">Toggle navigation</span> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span></button></div><nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation"><ul class="nav navbar-nav main-nav menu-highlight"><li class="menu-item menu-item-home"><a href="/."><i class="icon icon-home-fill"></i> <span class="menu-title">总览</span></a></li><li class="menu-item menu-item-archives"><a href="/archives"><i class="icon icon-archives-fill"></i> <span class="menu-title">汇总</span></a></li><li class="menu-item menu-item-categories"><a href="/categories"><i class="icon icon-folder"></i> <span class="menu-title">类别</span></a></li><li class="menu-item menu-item-tags"><a href="/tags"><i class="icon icon-tags"></i> <span class="menu-title">关键词</span></a></li><li class="menu-item menu-item-guestbook"><a href="/guestbook"><i class="icon"></i> <span class="menu-title">来留个言 👉👉👉</span></a></li></ul><ul class="social-links"><li><a href="https://github.com/Lazzzaro" target="_blank" title="Github" data-toggle="tooltip" data-placement="top"><i class="icon icon-github"></i></a></li></ul></nav></div></header><aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar"><div class="slimContent"><div class="widget"><h3 class="widget-title">类别</h3><div class="widget-body"><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/crypto/">crypto</a><span class="category-list-count">16</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/match/">match</a><span class="category-list-count">50</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/misc/">misc</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/other/">other</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/pwn/">pwn</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/reverse/">reverse</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/web/">web</a><span class="category-list-count">17</span></li></ul></div></div><div class="widget"><h3 class="widget-title">关键词云</h3><div class="widget-body tagcloud"><a href="/tags/2020%E8%B5%9B/" style="font-size:14px">2020赛</a> <a href="/tags/2021%E8%B5%9B/" style="font-size:13.86px">2021赛</a> <a href="/tags/2022%E8%B5%9B/" style="font-size:13.57px">2022赛</a> <a href="/tags/2023%E8%B5%9B/" style="font-size:13.71px">2023赛</a> <a href="/tags/2024%E8%B5%9B/" style="font-size:13.29px">2024赛</a> <a href="/tags/2025%E8%B5%9B/" style="font-size:13px">2025赛</a> <a href="/tags/AES/" style="font-size:13px">AES</a> <a href="/tags/Android/" style="font-size:13px">Android</a> <a href="/tags/Bash/" style="font-size:13px">Bash</a> <a href="/tags/CMS/" style="font-size:13px">CMS</a> <a href="/tags/CSRF/" style="font-size:13px">CSRF</a> <a href="/tags/DES/" style="font-size:13px">DES</a> <a href="/tags/ECC/" style="font-size:13px">ECC</a> <a href="/tags/IDA/" style="font-size:13px">IDA</a> <a href="/tags/JWT/" style="font-size:13px">JWT</a> <a href="/tags/Java/" style="font-size:13.14px">Java</a> <a href="/tags/Linux/" style="font-size:13px">Linux</a> <a href="/tags/OT/" style="font-size:13px">OT</a> <a href="/tags/PHP/" style="font-size:13.29px">PHP</a> <a href="/tags/RCE/" style="font-size:13px">RCE</a> <a href="/tags/RSA/" style="font-size:13.14px">RSA</a> <a href="/tags/SQL/" style="font-size:13px">SQL</a> <a href="/tags/SSRF/" style="font-size:13px">SSRF</a> <a href="/tags/SSTI/" style="font-size:13px">SSTI</a> <a href="/tags/Sage/" style="font-size:13px">Sage</a> <a href="/tags/USB/" style="font-size:13px">USB</a> <a href="/tags/Unity/" style="font-size:13px">Unity</a> <a href="/tags/WebAssembly/" style="font-size:13px">WebAssembly</a> <a href="/tags/XSS/" style="font-size:13px">XSS</a> <a href="/tags/XXE/" style="font-size:13px">XXE</a> <a href="/tags/angr/" style="font-size:13px">angr</a> <a href="/tags/fuzz/" style="font-size:13px">fuzz</a> <a href="/tags/gmpy2/" style="font-size:13px">gmpy2</a> <a href="/tags/hash/" style="font-size:13px">hash</a> <a href="/tags/js/" style="font-size:13px">js</a> <a href="/tags/node-js/" style="font-size:13.14px">node.js</a> <a href="/tags/pwntools/" style="font-size:13px">pwntools</a> <a href="/tags/python/" style="font-size:13.43px">python</a> <a href="/tags/wasm/" style="font-size:13px">wasm</a> <a href="/tags/z3/" style="font-size:13px">z3</a> <a href="/tags/%E5%86%85%E7%BD%91/" style="font-size:13px">内网</a> <a href="/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/" style="font-size:13px">反序列化</a> <a href="/tags/%E5%8F%8D%E7%BC%96%E8%AF%91/" style="font-size:13px">反编译</a> <a href="/tags/%E5%8F%8D%E8%B0%83%E8%AF%95/" style="font-size:13px">反调试</a> <a href="/tags/%E5%8F%96%E8%AF%81/" style="font-size:13px">取证</a> <a href="/tags/%E5%90%8E%E9%87%8F%E5%AD%90%E5%AF%86%E7%A0%81/" style="font-size:13px">后量子密码</a> <a href="/tags/%E5%91%BD%E4%BB%A4%E8%A1%8C/" style="font-size:13px">命令行</a> <a href="/tags/%E5%9B%BE%E5%83%8F/" style="font-size:13px">图像</a> <a href="/tags/%E5%9D%97%E5%AF%86%E7%A0%81/" style="font-size:13px">块密码</a> <a href="/tags/%E5%A0%86/" style="font-size:13px">堆</a> <a href="/tags/%E5%AF%86%E7%A0%81/" style="font-size:13.14px">密码</a> <a href="/tags/%E6%8F%90%E6%9D%83/" style="font-size:13px">提权</a> <a href="/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/" style="font-size:13px">文件上传</a> <a href="/tags/%E6%9B%B2%E7%BA%BF/" style="font-size:13px">曲线</a> <a href="/tags/%E6%A0%88/" style="font-size:13px">栈</a> <a href="/tags/%E6%A0%BC%E5%AF%86%E7%A0%81/" style="font-size:13px">格密码</a> <a href="/tags/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/" style="font-size:13px">格式化字符串</a> <a href="/tags/%E6%B3%A8%E5%85%A5/" style="font-size:13px">注入</a> <a href="/tags/%E6%B5%81%E5%AF%86%E7%A0%81/" style="font-size:13px">流密码</a> <a href="/tags/%E6%B5%81%E9%87%8F/" style="font-size:13px">流量</a> <a href="/tags/%E6%B7%B7%E6%B7%86/" style="font-size:13px">混淆</a> <a href="/tags/%E6%B8%97%E9%80%8F/" style="font-size:13px">渗透</a> <a href="/tags/%E7%A6%BB%E6%95%A3%E5%AF%B9%E6%95%B0/" style="font-size:13px">离散对数</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size:13.14px">算法</a> <a href="/tags/%E7%BB%95%E8%BF%87/" style="font-size:13.43px">绕过</a> <a href="/tags/%E7%BC%96%E7%A0%81/" style="font-size:13px">编码</a> <a href="/tags/%E8%84%9A%E6%9C%AC/" style="font-size:13.14px">脚本</a> <a href="/tags/%E8%87%AA%E5%8A%A8%E5%8C%96/" style="font-size:13px">自动化</a> <a href="/tags/%E9%80%83%E9%80%B8/" style="font-size:13px">逃逸</a> <a href="/tags/%E9%9A%90%E5%86%99/" style="font-size:13.29px">隐写</a></div></div><div class="widget"><h3 class="widget-title">汇总</h3><div class="widget-body"><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/08/">八月 2025</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/06/">六月 2025</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/12/">十二月 2024</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/11/">十一月 2024</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/03/">三月 2024</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/11/">十一月 2023</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/09/">九月 2023</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/05/">五月 2023</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/02/">二月 2023</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/01/">一月 2023</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/12/">十二月 2022</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/11/">十一月 2022</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/09/">九月 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/07/">七月 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/06/">六月 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/05/">五月 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/02/">二月 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/01/">一月 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/12/">十二月 2021</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/11/">十一月 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/10/">十月 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/09/">九月 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">八月 2021</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">六月 2021</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">五月 2021</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">四月 2021</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">三月 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">二月 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">一月 2021</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">十二月 2020</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">十一月 2020</a><span class="archive-list-count">9</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">十月 2020</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">九月 2020</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">八月 2020</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">七月 2020</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">六月 2020</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">五月 2020</a><span class="archive-list-count">24</span></li></ul></div></div></div></aside><aside class="sidebar sidebar-toc collapse" id="collapseToc" itemscope itemtype="http://schema.org/WPSideBar"><div class="slimContent"><nav id="toc" class="article-toc"><h3 class="toc-title">文章目录</h3><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#GM%EF%BC%88Goldwasser-Micali%EF%BC%89%E5%90%8C%E6%80%81%E5%8A%A0%E5%AF%86"><span class="toc-number">1.</span> <span class="toc-text">GM（Goldwasser-Micali）同态加密</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ElGamal%E5%8A%A0%E5%AF%86"><span class="toc-number">2.</span> <span class="toc-text">ElGamal加密</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Paillier%E5%90%8C%E6%80%81%E5%8A%A0%E5%AF%86"><span class="toc-number">3.</span> <span class="toc-text">Paillier同态加密</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Merkle-Hellman%E8%83%8C%E5%8C%85%E5%8A%A0%E5%AF%86%EF%BC%88Knapsack%EF%BC%89"><span class="toc-number">4.</span> <span class="toc-text">Merkle-Hellman背包加密（Knapsack）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%84%E8%A7%A3%E5%AF%86"><span class="toc-number">4.1.</span> <span class="toc-text">常规解密</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%84%E9%9C%B2%E9%83%A8%E5%88%86%E6%98%8E%E6%96%87%E7%A9%BA%E9%97%B4%E7%9A%84%E9%99%8D%E7%BB%B4%E5%A4%84%E7%90%86"><span class="toc-number">4.2.</span> <span class="toc-text">泄露部分明文空间的降维处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%90%E9%9B%86%E5%90%88%E9%97%AE%E9%A2%98-%E8%BD%AC%E5%8C%96%E4%B8%BA-%E6%B1%82%E8%A7%A3SVP-CVP-Lattice-Reduction-Algorithm"><span class="toc-number">4.3.</span> <span class="toc-text">子集合问题 转化为 求解SVP&#x2F;CVP+Lattice Reduction Algorithm</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Benaloh%E5%8A%A0%E5%AF%86"><span class="toc-number">5.</span> <span class="toc-text">Benaloh加密</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LUC-RSA%E5%8A%A0%E5%AF%86"><span class="toc-number">6.</span> <span class="toc-text">LUC-RSA加密</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DSA%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D"><span class="toc-number">7.</span> <span class="toc-text">DSA数字签名</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Elgamal%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D"><span class="toc-number">8.</span> <span class="toc-text">Elgamal数字签名</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Shamir%E5%AF%86%E9%92%A5%E5%88%86%E4%BA%AB%E7%AE%97%E6%B3%95"><span class="toc-number">9.</span> <span class="toc-text">Shamir密钥分享算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Okamoto-Uchiyama%E5%AF%86%E7%A0%81%E7%B3%BB%E7%BB%9F"><span class="toc-number">10.</span> <span class="toc-text">Okamoto-Uchiyama密码系统</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Schmidt-Samoa%E5%AF%86%E7%A0%81%E7%B3%BB%E7%BB%9F"><span class="toc-number">11.</span> <span class="toc-text">Schmidt-Samoa密码系统</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E9%A1%B9%E5%BC%8F"><span class="toc-number">12.</span> <span class="toc-text">多项式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%81%E5%B0%8F%E5%A4%9A%E9%A1%B9%E5%BC%8F"><span class="toc-number">12.1.</span> <span class="toc-text">极小多项式</span></a></li></ol></li></ol></nav></div></aside><main class="main" role="main"><div class="content"><article id="post-crypto-其他加密算法" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting"><div class="article-header"><h1 class="article-title" itemprop="name">其他加密算法</h1><div class="article-meta"><span class="article-date"><i class="icon icon-calendar-check"></i> <a href="/2020/05/13/crypto-%E5%85%B6%E4%BB%96%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/" class="article-date"><time datetime="2020-05-13T12:21:19.000Z" itemprop="datePublished">2020-05-13</time> </a></span><span class="article-category"><i class="icon icon-folder"></i> <a class="article-category-link" href="/categories/crypto/">crypto</a> </span><span class="article-tag"><i class="icon icon-tags"></i> <a class="article-tag-link-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a> </span><span class="article-read hidden-xs"><i class="icon icon-eye-fill" aria-hidden="true"></i> <span id="/2020/05/13/crypto-%E5%85%B6%E4%BB%96%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/" class="leancloud_visitors" data-flag-title="其他加密算法"><span class="leancloud-visitors-count">∞</span> </span></span><span class="post-comment"><i class="icon icon-comment"></i> <a href="/2020/05/13/crypto-%E5%85%B6%E4%BB%96%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/#comments" class="article-comment-link">评论</a></span></div></div><div class="article-entry marked-body" itemprop="articleBody"><p>​</p><h2 id="GM（Goldwasser-Micali）同态加密"><a href="#GM（Goldwasser-Micali）同态加密" class="headerlink" title="GM（Goldwasser-Micali）同态加密"></a>GM（Goldwasser-Micali）同态加密</h2><p>Goldwasser-Micali (GM) 加密方案是第一个证明为 CPA 安全的公钥加密方案，其安全性依赖于从合数模的二次非剩余中区分二次剩余困难性假设。</p><ul><li><p><strong>密钥生成</strong></p><p>用户随机生成两个大素数 $p$ 和 $q$，计算 $n=pq$，$z$ 是模 $n$ 的二次非剩余中的随机数。系统公钥 $pk=(n,z)$，系统私钥 $sk=(p,q)$。</p></li><li><p><strong>加密</strong></p><p>明文空间是 $\{0,1\}$，对于明文 $x\in\{0,1\}$，加密方选取秘密随机数 $r\in Z_n^{*}$，利用系统公钥 $pk$ 计算密文$E(x)=r^2z^x\bmod n$。</p></li><li><p><strong>解密</strong></p><p>对于密文 $E(x)$，判断 $E(x)$ 是否为模 $n$ 的二次剩余，若 $E(x)$ 是模 $n$ 的二次剩余，则明文 $D(E(x))=0$； 若 $E(x)$ 不是模 $n$ 的二次剩余，则 $D(E(x))=1$。</p></li></ul><p>GM加密系统的安全性是基于模 $n$ 的二次剩余问题。对于私钥的拥有者，知道大整数 $n$ 的因子分解，求解模 $n$ 的二次剩余问题是容易的；而对于攻击者，无法获知 $n$ 的因子分解，求解模 $n$ 的二次剩余问题是困难的，继而保证了该加密方案的安全性。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> long_to_bytes</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line">plaintext = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;output.txt&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">	n = <span class="built_in">int</span>(f.readline())</span><br><span class="line">	<span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">		cipher = <span class="built_in">int</span>(line)</span><br><span class="line">		<span class="keyword">if</span> gmpy2.jacobi(cipher,n) == -<span class="number">1</span>:</span><br><span class="line">			plaintext += <span class="string">&#x27;1&#x27;</span></span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			plaintext += <span class="string">&#x27;0&#x27;</span></span><br><span class="line">		<span class="built_in">print</span>(long_to_bytes(<span class="built_in">int</span>(plaintext,<span class="number">2</span>)))</span><br></pre></td></tr></table></figure><p>​</p><h2 id="ElGamal加密"><a href="#ElGamal加密" class="headerlink" title="ElGamal加密"></a>ElGamal加密</h2><p>ElGamal加密算法是一个基于迪菲-赫尔曼密钥交换的非对称加密算法。它在1985年由塔希尔·盖莫尔提出。GnuPG和PGP等很多密码学系统中都应用到了ElGamal算法。ElGamal加密算法可以定义在任何循环群G上。它的安全性取决于G上的离散对数难题。</p><ul><li><p><strong>密钥生成</strong></p><ol><li><p>随机选择一个满足安全要求的大素数 $p$，并生成有限域 $Z_{p}$。的一个生成元 $g\in Z_{p}^{*}$；</p></li><li><p>选一个随机数 $x\;(1&lt;x&lt;p-1)$，计算 $y\equiv g^{x} \pmod p$，则公钥为 $(y,g,p)$，私钥为 $x$。</p></li></ol></li><li><p><strong>加密</strong></p><p>与RSA密码体制相同，加密时首先将明文比特串分组，使得每个分组对应的十进制数小于$p$，即分组长度小于$\log_2p$，然后对每个明文分组分别加密。具体过程分为如下几步：</p><ol><li>得到接收方的公钥 $(y,g,p)$；</li><li>把消息 $m$ 分组为长度为 $L\;(L&lt;\log_2 p)$ 的消息分组 $m=m_1m_2\dots m_t$；</li><li>对第 $i$ 块消息 $(1\leq i\leq t)$ 随机选择整数 $r_i\;(1&lt;r_i&lt;p-1)$；</li><li>计算 $c_i\equiv g^{r_i}\pmod p,\;c_i^\prime\equiv m_iy^{r_i} \pmod p\;(1\leq i\leq t)$；</li><li>将密文 $C=(c_1,c_1^\prime)(c_2,c_2^\prime)\dots(c_t,c_t^\prime)$ 发送给接收方。</li></ol></li><li><p><strong>解密</strong></p><ol><li>接收方收到的密文 $C=(c_1,c_1^\prime)(c_2,c_2^\prime)\dots(c_t,c_t^\prime)$；</li><li>使用私钥 $x$ 和解密算法 $m_i \equiv ({c_i^\prime}({c_i^x})^{-1}) \pmod p \; (1\leq i\leq t)$ 进行计算；</li><li>得到明文 $m=m_1m_2\dots m_t$。</li></ol></li></ul><p>ElGamal加密过程需要两次模指数运算和一次模乘积运算，解密过程需要模指数运算，求逆运算和模乘积运算各一次。每次加密运算需要选择一个随机数，所以密文既依赖于明文，又依赖于选择的随机数，故对于同一个明文，不同的时刻生成的密文不同。另外，ElGamal加密使得消息扩展了两倍，即密文的长度是对应明文长度的两倍。</p><p>​</p><h2 id="Paillier同态加密"><a href="#Paillier同态加密" class="headerlink" title="Paillier同态加密"></a>Paillier同态加密</h2><p>Paillier密码，于1999年由Pascal Paillier发明，是一种用于公钥加密的概率非对称算法。该算法具有加法同态的性质；这意味着，仅给出公钥和 $m_1,m_2$ 加密，可以计算出 $m_1 + m_2$ 。</p><ul><li><p><strong>密钥生成</strong></p><ol><li>随机选择两个大质数 $p,q$ 满足 $\gcd(pq,(p-1)(q-1))=1$。此属性保证两个质数长度相等；</li><li>计算 $n=pq$ 和 $\lambda=\text{lcm}(p-1,q-1)$；</li><li>选择随机整数 $g(g\in \mathbb{Z}_{n^2}^{*}) $，使得满足 $n$ 整除 $g$ 的阶（$0\lt g \lt n^2$）；</li><li>定义 $L(x)=\cfrac{x-1}{n}$；</li><li>计算 $\mu=(L(g^\lambda \bmod n^2))^{-1} \bmod n$；</li><li>公钥为 $(n,g)$，私钥为 $(\lambda,\mu)$。</li></ol><ul><li><p><strong>简化版</strong></p><p>$g=n+1$</p><p>$\lambda=\varphi(n)=(p-1)(q-1)$</p><p>$\mu=\varphi(n)^{-1}\bmod n$</p></li></ul></li><li><p><strong>加密</strong></p><ol><li>$m$ 为原文（$0\leq m \lt n$）；</li><li><p>选择随机数 $r(0 \lt r \lt n,r \in \mathbb{Z}_{n^2}^{*})$，且 $\gcd(r,n)=1$；</p></li><li><p>加密：$c=g^m \cdot r^n\bmod n^2$。</p></li></ol></li><li><p><strong>解密</strong></p><p>解密：$m=L(c^\lambda \bmod n^2)\cdot \mu \bmod n$。</p></li><li><p><strong>性质</strong></p><p>$D(E(m_1,r_1) \cdot E(m_2,r_2) \bmod {n^2})=m_1+m_2 \bmod n$</p><p>$D(E(m_1,r_1) \cdot g^{m_2} \bmod {n^2})=m_1+m_2 \bmod n$</p><p>$D(E(m_1,r_1)^{m_2} \bmod {n^2})=m_1m_2 \bmod n$</p><p>$D(E(m_2,r_2)^{m_1} \bmod {n^2})=m_1m_2 \bmod n$</p><p>$D(E(m,r)^{k} \bmod {n^2})=km \bmod n$</p><p>$D(E(m,r) \cdot (1+n)^k \bmod {n^2})=m+k \bmod n$</p></li></ul><p>​</p><h2 id="Merkle-Hellman背包加密（Knapsack）"><a href="#Merkle-Hellman背包加密（Knapsack）" class="headerlink" title="Merkle-Hellman背包加密（Knapsack）"></a>Merkle-Hellman背包加密（Knapsack）</h2><p>1977年，Merkle与Hellman合作设计了使用背包算法，该算法提出后密码学界提出了很多背包型加密算法。</p><p>其工作原理是：假定甲想加密，则先产生一个较易求解的背包问题，并用它的解作为专用密钥；然后从这个问题出发，生成另一个难解的背包问题，并作为公共密钥。如果乙想向甲发送报文，乙就可以使用难解的背包问题对报文进行加密，由于这个问题十分难解，所以一般没有人能够破译密文；甲收到密文后，可以使用易解的专用密钥解密。</p><p>但是，在它发表几年后，就找到了攻破它的方法。即使如此，它仍然代表着一类很难问题的算法。</p><p><strong>加密</strong></p><p>选择任何一个<strong>超递增集</strong> $\{s_1,s_2,…,s_n\}$。</p><p>陷门由任意大于 $\sum_{i}s_i$ 的素数 $p$ 和任意小于 $p$ 的整数 $a$ 组成，这两个数和集合 $\{s_1,s_2,…,s_n\}$ 都是保密的。</p><p>公开的整数集是 $\{t_1,t_2,…,t_n\}$ ，其中 $t_i=a_i \cdot s_i \pmod p$。</p><p>二进制明文 $(b_1,b_2,…,b_n)$ 的加密操作为 $y=\sum_{i}b_it_i$，整数 $y$ 是密文。</p><p><strong>解密</strong></p><p>找到 $a^{-1} \pmod p$。因为 $p$ 是质数， $a^{-1} \pmod p$ 一定存在。计算 $a^{-1}y \pmod p$。</p><p>得到 $a^{-1}y \pmod p$ 这使得：</p><p>$a^{-1}y=a^{-1}\sum_{i}b_it_i \pmod p=\sum_{i}b_i(a^{-1}as_i) \pmod p=\sum_{i}b_is_i$</p><p>因为集合 $\{s_1,s_2,…,s_n\}$是超递增集，所以很容易定位明文位。</p><p><strong>★注：</strong></p><p>Knapsack系统的<strong><a target="_blank" rel="noopener" href="https://eprint.iacr.org/2007/066.pdf">密度</a></strong>为：</p><p>$d = \cfrac{n}{\log_2(max\{a_i\})}$</p><p>基于子集和问题，<strong>MH密码系统</strong>是最开始出现的一种密度比较低的Knapsack密码系统。很快Shamir等人提出了一系列的攻击方式，包括丢番图逼近，LLL等方法（$d&lt;0.9408$）。虽然这个密码系统被攻破了，新的Knapsack系统诞生了，这种密码系统的密度变高了，$a_i$ 值变小了，而且加密的明文的二进制位中<code>1</code>的数量也很小。</p><p>新的密码系统更加难以破解，也称之为<strong>HardKnapsack</strong>系统，不过后来密码学家们还是发现了攻击方法，我们称之为low-weight attack。</p><ul><li><p><strong>Schroeppel-Shamir Algorithm</strong></p><p>时间复杂度,空间复杂度均为 $O(\cfrac{n}{2})$</p></li><li><p><strong>The Howgrave-Graham–Joux Algorithm</strong></p><p>时间复杂度 $O(0.337n)$，空间复杂度 $O(0.256n)$</p></li></ul><p>总体来说，这两种算法是基于分治和mitm的思想进行攻击的。</p><ul><li><p><strong>Lagarias and Odlyzko’s Method / CJLOSS Method</strong></p><p>参考：<a target="_blank" rel="noopener" href="https://www.ieice.org/publications/conference-FIT-DVDs/FIT2018/data/pdf/A-022.pdf">Lattice Reduction Attack on the Knapsack Type Cryptosystem</a></p><p>构造格：</p><p>$\left(\begin {array}{c} b_0 \newline b_1 \newline \vdots \newline b_n \newline b_{n+1} \end{array} \right) =\left(\begin {array}{c} 1 &amp; 0 &amp; \cdots &amp; 0 &amp; Nk_0 \newline 0 &amp; 1 &amp; \cdots &amp; 0 &amp; Nk_1 \newline \vdots &amp; \vdots &amp; \ddots &amp; \vdots &amp; \vdots \newline 0 &amp; 0 &amp; \cdots &amp; 1 &amp; Nk_n \newline 0 &amp; 0 &amp; \cdots &amp; 0 &amp; Nk_{n+1} \end{array} \right) $</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">M = Matrix.identity(n)</span><br><span class="line"></span><br><span class="line">last_row = [<span class="number">0</span> <span class="keyword">for</span> x <span class="keyword">in</span> keys]</span><br><span class="line">M_last_row = Matrix(ZZ, <span class="number">1</span>, <span class="built_in">len</span>(last_row), last_row)</span><br><span class="line"></span><br><span class="line">ct = </span><br><span class="line">last_col = keys[:]</span><br><span class="line">last_col.append(ct)</span><br><span class="line">M_last_col = Matrix(ZZ, <span class="built_in">len</span>(last_col), <span class="number">1</span>, last_col)</span><br><span class="line"></span><br><span class="line">M = M.stack(M_last_row)</span><br><span class="line">M = M.augment(M_last_col)</span><br><span class="line"></span><br><span class="line">X = M.LLL()</span><br><span class="line">target = X[<span class="number">0</span>][:-<span class="number">1</span>]</span><br><span class="line">ans = [-k <span class="keyword">for</span> k <span class="keyword">in</span> target]</span><br></pre></td></tr></table></figure></li></ul><p>对于密度比较高的Knapsack密码系统，在<code>1</code>的数量确定情况下，可以尝试分段爆破。</p><p>参考论文：<a target="_blank" rel="noopener" href="https://eprint.iacr.org/2011/474.pdf">Improved Generic Algorithms for Hard Knapsacks</a></p><h3 id="常规解密"><a href="#常规解密" class="headerlink" title="常规解密"></a>常规解密</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">pk =  <span class="comment"># public key</span></span><br><span class="line">ct =  <span class="comment"># ciphertext</span></span><br><span class="line"><span class="built_in">print</span>(ct)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(pk))</span><br><span class="line">n = <span class="built_in">len</span>(pk)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Sanity check for application of low density attack</span></span><br><span class="line">d = n / log(<span class="built_in">max</span>(pk), <span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(CDF(d))</span><br><span class="line"><span class="keyword">assert</span> CDF(d) &lt; <span class="number">0.9408</span></span><br><span class="line"></span><br><span class="line">M = Matrix.identity(n) * <span class="number">2</span></span><br><span class="line"></span><br><span class="line">last_row = [<span class="number">1</span> <span class="keyword">for</span> x <span class="keyword">in</span> pk]</span><br><span class="line">M_last_row = Matrix(ZZ, <span class="number">1</span>, <span class="built_in">len</span>(last_row), last_row)</span><br><span class="line"></span><br><span class="line">last_col = pk</span><br><span class="line">last_col.append(ct)</span><br><span class="line">M_last_col = Matrix(ZZ, <span class="built_in">len</span>(last_col), <span class="number">1</span>, last_col)</span><br><span class="line"></span><br><span class="line">M = M.stack(M_last_row)</span><br><span class="line">M = M.augment(M_last_col)</span><br><span class="line"></span><br><span class="line">X = M.BKZ()</span><br><span class="line"></span><br><span class="line">sol = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n + <span class="number">1</span>):</span><br><span class="line">    testrow = X.row(i).<span class="built_in">list</span>()[:-<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">set</span>(testrow).issubset([-<span class="number">1</span>, <span class="number">1</span>]):</span><br><span class="line">        <span class="keyword">for</span> v <span class="keyword">in</span> testrow:</span><br><span class="line">            <span class="keyword">if</span> v == <span class="number">1</span>:</span><br><span class="line">                sol += <span class="string">&#x27;0&#x27;</span></span><br><span class="line">            <span class="keyword">elif</span> v == -<span class="number">1</span>:</span><br><span class="line">                sol += <span class="string">&#x27;1&#x27;</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(sol)</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(<span class="built_in">int</span>(sol, <span class="number">2</span>)))</span><br></pre></td></tr></table></figure><h3 id="泄露部分明文空间的降维处理"><a href="#泄露部分明文空间的降维处理" class="headerlink" title="泄露部分明文空间的降维处理"></a>泄露部分明文空间的降维处理</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">###Sage</span></span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">pubkey =  </span><br><span class="line">c = </span><br><span class="line"></span><br><span class="line"><span class="comment">#前缀 flag&#123;</span></span><br><span class="line">prefix = [<span class="built_in">int</span>(_) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">bin</span>(bytes_to_long(<span class="string">b&#x27;flag&#123;&#x27;</span>))[<span class="number">2</span>:]]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(prefix)):</span><br><span class="line">    c -= prefix[i] * pubkey[i]</span><br><span class="line"></span><br><span class="line"><span class="comment">#后缀 &#125;</span></span><br><span class="line">suffix = [<span class="built_in">int</span>(_) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">bin</span>(<span class="built_in">ord</span>(<span class="string">&#x27;&#125;&#x27;</span>))[<span class="number">2</span>:].rjust(<span class="number">8</span>, <span class="string">&#x27;0&#x27;</span>)]</span><br><span class="line">n = <span class="built_in">len</span>(pubkey)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">    c -= pubkey[n - <span class="number">8</span> + i] * suffix[i]</span><br><span class="line"></span><br><span class="line"><span class="comment">#中部md5范围 0-f</span></span><br><span class="line">elements = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(prefix), <span class="built_in">len</span>(pubkey) - <span class="number">8</span>, <span class="number">8</span>):</span><br><span class="line">    elements.append(pubkey[i + <span class="number">1</span>])</span><br><span class="line">    c -= <span class="number">1</span> * pubkey[i + <span class="number">2</span>]</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>, <span class="number">8</span>):</span><br><span class="line">        elements.append(pubkey[i + j])</span><br><span class="line">        </span><br><span class="line">n = <span class="built_in">len</span>(elements)</span><br><span class="line">A = Matrix(ZZ, n + <span class="number">1</span>, n + <span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    A[i, <span class="number">0</span>] = elements[i]</span><br><span class="line">    A[i, i + <span class="number">1</span>] = <span class="number">2</span></span><br><span class="line">A[n, <span class="number">0</span>] = c</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">    A[n, i] = <span class="number">1</span></span><br><span class="line">AL = A.BKZ()</span><br><span class="line">mid = <span class="literal">None</span></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> AL:</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">all</span>(line[i] == <span class="number">1</span> <span class="keyword">or</span> line[i] == -<span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>)):</span><br><span class="line">        <span class="keyword">if</span> line[<span class="number">1</span>] == <span class="number">1</span>:</span><br><span class="line">            line = -line</span><br><span class="line">        mid = line[<span class="number">1</span>:]</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">mid_str = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> mid:</span><br><span class="line">    <span class="keyword">if</span> _ == -<span class="number">1</span>:</span><br><span class="line">        mid_str += <span class="string">&#x27;0&#x27;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        mid_str += <span class="string">&#x27;1&#x27;</span></span><br><span class="line"></span><br><span class="line">flag = <span class="string">&#x27;&#x27;</span></span><br><span class="line">j = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>):</span><br><span class="line">    flag += <span class="string">&#x27;0&#x27;</span></span><br><span class="line">    flag += mid_str[j]</span><br><span class="line">    j += <span class="number">1</span></span><br><span class="line">    flag += <span class="string">&#x27;1&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        flag += mid_str[j]</span><br><span class="line">        j += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(flag)</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(<span class="built_in">int</span>(flag, <span class="number">2</span>)))</span><br></pre></td></tr></table></figure><h3 id="子集合问题-转化为-求解SVP-CVP-Lattice-Reduction-Algorithm"><a href="#子集合问题-转化为-求解SVP-CVP-Lattice-Reduction-Algorithm" class="headerlink" title="子集合问题 转化为 求解SVP/CVP+Lattice Reduction Algorithm"></a>子集合问题 转化为 求解SVP/CVP+Lattice Reduction Algorithm</h3><p>参考：</p><p><a target="_blank" rel="noopener" href="https://0xdktb.top/2020/08/02/WriteUp-WMCTF2020-Crypto/">WMCTF 2020 - babySum + Sum</a></p><p><a target="_blank" rel="noopener" href="https://soreatu.com/posts/crypto-research-subset-sum-problem/">Crypto Research: Solving Subset Sum Problem by Lattice Reduction</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> multiprocessing <span class="keyword">as</span> mp</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> partial</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">check</span>(<span class="params">sol, A, s</span>):</span><br><span class="line">	<span class="string">&quot;&quot;&quot;Check whether *sol* is a solution to the subset-sum problem.</span></span><br><span class="line"><span class="string">	&quot;&quot;&quot;</span></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">sum</span>(x*a <span class="keyword">for</span> x, a <span class="keyword">in</span> <span class="built_in">zip</span>(sol, A)) == s</span><br><span class="line">	</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">solve</span>(<span class="params">A, n, k, s, ID=<span class="literal">None</span>, BS=<span class="number">22</span></span>):</span><br><span class="line">	N = ceil(sqrt(n)) <span class="comment"># parameter used in the construction of lattice</span></span><br><span class="line">	rand = random.Random(x=ID) <span class="comment"># seed</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment"># 1. Construct the lattice</span></span><br><span class="line">	<span class="comment"># (n+1) * (n+2)</span></span><br><span class="line">	<span class="comment"># 1 0 ... 0 a_0*N N</span></span><br><span class="line">	<span class="comment"># 0 1 ... 0 a_1*N N</span></span><br><span class="line">	<span class="comment"># . . ... . ... .</span></span><br><span class="line">	<span class="comment"># 0 0 ... 1 a_n*N N</span></span><br><span class="line">	<span class="comment"># 0 0 ... 0 s*N k*N</span></span><br><span class="line">	lat = []</span><br><span class="line">	<span class="keyword">for</span> i, a <span class="keyword">in</span> <span class="built_in">enumerate</span>(A):</span><br><span class="line">		lat.append([<span class="number">1</span>*(j == i) <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n)] + [N*a] + [N])</span><br><span class="line">	lat.append([<span class="number">0</span>]*n + [N*s] + [k*N])</span><br><span class="line">	</span><br><span class="line">	<span class="comment"># main loop</span></span><br><span class="line">	itr = <span class="number">0</span></span><br><span class="line">	start_time = cputime()</span><br><span class="line">	<span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">		itr += <span class="number">1</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment"># 2. Randomly shuffle</span></span><br><span class="line">		l = lat[::]</span><br><span class="line">		shuffle(l, random=rand.random)</span><br><span class="line">		</span><br><span class="line">		<span class="comment"># 3. BKZ!!!</span></span><br><span class="line">		m = matrix(ZZ, l)</span><br><span class="line">		t_BKZ = cputime()</span><br><span class="line">		m_BKZ = m.BKZ(block_size=BS)</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">f&quot;n=<span class="subst">&#123;n&#125;</span> <span class="subst">&#123;itr&#125;</span> runs. BKZ running time: <span class="subst">&#123;cputime(t_BKZ):<span class="number">.3</span>f&#125;</span>s&quot;</span>)</span><br><span class="line">		</span><br><span class="line">		<span class="comment"># 4. Check the result</span></span><br><span class="line">		<span class="keyword">for</span> i, row <span class="keyword">in</span> <span class="built_in">enumerate</span>(m_BKZ):</span><br><span class="line">			<span class="keyword">if</span> check(row, A, s):</span><br><span class="line">					<span class="keyword">if</span> row.norm()^<span class="number">2</span> == k:</span><br><span class="line">						<span class="built_in">print</span>(<span class="string">f&quot;n=<span class="subst">&#123;n&#125;</span> After <span class="subst">&#123;itr&#125;</span> runs. FIND SVP!!! <span class="subst">&#123;row&#125;</span>\n&quot;</span></span><br><span class="line">						<span class="string">f&quot;Single core time used: <span class="subst">&#123;cputime(start_time):<span class="number">.3</span>f&#125;</span>s&quot;</span>)</span><br><span class="line">						<span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">s = </span><br><span class="line">A = []</span><br><span class="line"><span class="comment">#choose k numbers from n</span></span><br><span class="line">k = </span><br><span class="line">n = </span><br><span class="line">solve_n = partial(solve, A, n, k, s)</span><br><span class="line">CPU_CORE_NUM = <span class="number">8</span></span><br><span class="line"><span class="keyword">with</span> mp.Pool(CPU_CORE_NUM) <span class="keyword">as</span> pool:</span><br><span class="line">	reslist = pool.imap_unordered(solve_n, <span class="built_in">range</span>(CPU_CORE_NUM))</span><br><span class="line">	<span class="comment"># terminate all processes once one process returns</span></span><br><span class="line">	<span class="keyword">for</span> res <span class="keyword">in</span> reslist:</span><br><span class="line">		<span class="keyword">if</span> res:</span><br><span class="line">			pool.terminate()</span><br><span class="line">			<span class="keyword">break</span></span><br></pre></td></tr></table></figure><p>​</p><h2 id="Benaloh加密"><a href="#Benaloh加密" class="headerlink" title="Benaloh加密"></a>Benaloh加密</h2><ul><li><p><strong>密钥生成</strong></p><p>假定块大小为 $r$，每个明文信息块大小在 $[0,r)$ 范围内。</p><ol><li>选择两个大质数 $p=rp’+1$ 和 $q$ ，满足 $\gcd(p’,r)=\gcd(q-1,r)=1$；</li><li>计算 $n=pq$ 及 $\varphi(n)=(p-1)(q-1)$；</li><li>选择 $0 \leq y \lt n$，满足 $y^{\varphi(n)/r} \not\equiv 1 \pmod n$；</li><li>计算 $x=y^{\varphi(n)/r} \bmod n$，公钥为 $(y,n)$，私钥为 $(\varphi,x)$。</li></ol></li><li><p><strong>加密</strong></p><p>假设要加密的信息 $m \in [0,r)$：</p><ol><li>选择一个数 $u \in [0,n)$；</li><li>计算 $c=y^mu^r \bmod n$ 即为 $m$ 的密文。</li></ol></li><li><p><strong>解密</strong></p><p>假设要解密的信息 $c$：</p><ol><li>计算 $a=c^{\varphi(n)/r} \bmod n$；</li><li>DLP求解满足 $x^m \equiv a \pmod n$ 的 $m$，即 $m=\log_x(a)$。</li></ol></li><li><p><strong>参考</strong></p><p><a target="_blank" rel="noopener" href="https://mystiz.hk/posts/2021-02-15-dicectf-1/">https://mystiz.hk/posts/2021-02-15-dicectf-1/</a></p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> long_to_bytes</span><br><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> tqdm</span><br><span class="line"></span><br><span class="line">n = </span><br><span class="line">y = </span><br><span class="line">e = </span><br><span class="line">C = []</span><br><span class="line"></span><br><span class="line">p = </span><br><span class="line">q = </span><br><span class="line"></span><br><span class="line">phi = (p-<span class="number">1</span>) * (q-<span class="number">1</span>)</span><br><span class="line">tmp = phi // e</span><br><span class="line"></span><br><span class="line">bounds = (<span class="number">1</span>, e)</span><br><span class="line">F = IntegerModRing(n)</span><br><span class="line">result = []</span><br><span class="line"></span><br><span class="line">x = F(<span class="built_in">pow</span>(y, tmp, n))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> tqdm(C):</span><br><span class="line">    a = F(<span class="built_in">pow</span>(c, tmp, n))</span><br><span class="line">    result.append(bsgs(x, a, bounds))</span><br><span class="line"></span><br><span class="line">flag = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> result[::-<span class="number">1</span>]:</span><br><span class="line">    flag = flag*e + i</span><br><span class="line">flag = long_to_bytes(flag)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(flag)</span><br></pre></td></tr></table></figure><p>​</p><h2 id="LUC-RSA加密"><a href="#LUC-RSA加密" class="headerlink" title="LUC-RSA加密"></a>LUC-RSA加密</h2><ul><li><p><strong>Lucas数列（卢卡斯数列）</strong></p><ul><li><p><strong>递推关系</strong></p><p>给定两个整数 $P$ 和 $Q$，满足：$P^2-4Q \ne 0$，</p><p>第一类卢卡斯数列 $U_n(P,Q)$ 定义：</p><p>$U_0(P,Q)=0 \\ U_1(P,Q)=1 \\ U_n(P,Q)=P \cdot U_{n-1}(P,Q) - Q \cdot U_{n-2}(P,Q), n&gt;1$</p><p>第二类卢卡斯数列 $V_n(P,Q)$ 定义：</p><p>$V_0(P,Q)=2 \\ V_1(P,Q)=P \\ V_n(P,Q)=P \cdot V_{n-1}(P,Q) - Q \cdot V_{n-2}(P,Q), n&gt;1$</p></li><li><p><strong>代数关系</strong></p><p>特征方程：$x^2-Px+Q=0$，判别式：$D=P^2-4Q$，根：$a=\cfrac{P+\sqrt{D}}{2},b=\cfrac{P-\sqrt{D}}{2}$。</p><p>卢卡斯数列的项可用 $a$ 和 $b$ 的项定义：</p><p>$U_n = \cfrac{a^n-b^n}{a-b} = \cfrac{a^n-b^n}{\sqrt{D}}$</p><p>$V_n = a^n + b^n$</p></li></ul></li><li><p><strong>密钥生成</strong></p><p>设 $p,q$ 是两个奇素数，$N=pq$。</p><p>$e \in \mathbb{Z}_N$，且 $\gcd(e,(p-1)(p+1)(q-1)(q-1))=1$。</p><p>卢卡斯数列 $V_n(M,1) = M \cdot V_{n-1} - V_{n-2}$，即 $P=M,Q=1$。（更一般情况见paper）</p><p>公钥为：$(N,e)$。</p></li><li><p><strong>加密</strong></p><p>$C=V_e(M,1) \pmod N$，对任意信息 $M \in \mathbb{Z}_N$。</p></li><li><p><strong>解密</strong></p><p>解密密钥 $d$，$ed \equiv 1 \pmod {S(N)}$，</p><p>$S(N)=\text{lcm}\left(p-\left (\cfrac{D}{p} \right),p-\left (\cfrac{D}{q} \right)\right)$，$D=C^2-4$，</p><p>其中 $\left(\cfrac{D}{p} \right)= \begin{cases} 1,&amp; \exists x, x^2 \equiv D \pmod {p} \\ 0,&amp; p \mid D \\ -1, &amp; \text{other} \end{cases}$ 为勒让德(Legendre)符号。</p><p>$M=V_d(C,1) \pmod N$。</p></li><li><p><strong>参考</strong></p><p><a target="_blank" rel="noopener" href="http://jeit.ie.ac.cn/fileDZYXXXB/journal/article/dzyxxxb/2007/1/PDF/20070144.pdf">一种新的基于 Lucas 序列的公钥密码体制</a></p><p><a target="_blank" rel="noopener" href="https://citeseerx.ist.psu.edu/viewdoc/download;jsessionid=5140063BDB10AB1388C9AAB52A8071A1?doi=10.1.1.32.1835&amp;rep=rep1&amp;type=pdf">LUC: A New Public Key System</a></p><p><a target="_blank" rel="noopener" href="https://n00bcak.github.io/writeups/2021/03/27/UMass-CTF.html">UMassCTF 2021 - Weird RSA</a></p><p>LUC-RSA:</p><p><a target="_blank" rel="noopener" href="https://ro.uow.edu.au/cgi/viewcontent.cgi?article=6676&amp;context=eispapers">A new attack on three variants of the RSA cryptosystem</a><br><a target="_blank" rel="noopener" href="https://www.sciencedirect.com/science/article/abs/pii/S2214212616302678">Cryptanalysis of RSA-type cryptosystems based on Lucas sequences, Gaussian integers and elliptic curves</a></p><p><a target="_blank" rel="noopener" href="https://miaotony.xyz/2022/03/25/CTF_2022HFCTF/2022HFCTF-%E7%BA%BF%E4%B8%8A%E8%B5%9B%E5%AE%98%E6%96%B9Writeup.pdf">HFCTF 2022 - RRSSAA</a></p><p><a target="_blank" rel="noopener" href="https://github.com/b3f0re-team/Write-up/blob/main/RCTF/RCTF.md#easyrsa">RCTF 2022 - easyRSA</a></p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#法1，快速矩阵幂</span></span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> long_to_bytes</span><br><span class="line"></span><br><span class="line">N=</span><br><span class="line">C=</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ffm</span>(<span class="params">num</span>): <span class="comment"># Fermat&#x27;s Factorization Method.</span></span><br><span class="line">    <span class="keyword">if</span> num%<span class="number">2</span>==<span class="number">0</span>: <span class="keyword">return</span> (<span class="number">2</span>,num/<span class="number">2</span>)</span><br><span class="line">    a=ceil(sqrt(num))</span><br><span class="line">    c=a**<span class="number">2</span>-num</span><br><span class="line">    <span class="keyword">while</span> is_square(c)==<span class="number">0</span>: a+=<span class="number">1</span></span><br><span class="line">    b=sqrt(c)</span><br><span class="line">    <span class="keyword">return</span> (a-b,a+b)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">matpow</span>(<span class="params">mat,power</span>): <span class="comment"># Matrix Square-And-Multiply Exponentiation.</span></span><br><span class="line">    power_rep=<span class="built_in">bin</span>(power)[<span class="number">3</span>:]</span><br><span class="line">    result=mat</span><br><span class="line">    pcnt=<span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> power_rep:     </span><br><span class="line">        result=result*result</span><br><span class="line">        pcnt*=<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> i==<span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">            result=mat*result</span><br><span class="line">            pcnt+=<span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(pcnt)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decrypt</span>(<span class="params">d</span>): <span class="comment"># Decryption.</span></span><br><span class="line">    Mat=Matrix(Zmod(N),[[C,-<span class="number">1</span>],[<span class="number">1</span>,<span class="number">0</span>]])</span><br><span class="line">    ori=vector(Zmod(N),[C,<span class="number">2</span>])</span><br><span class="line">    <span class="keyword">return</span> matpow(Mat,d-<span class="number">1</span>)*ori</span><br><span class="line"></span><br><span class="line">p,q=ffm(N) </span><br><span class="line"><span class="keyword">assert</span> p*q==N</span><br><span class="line">D=(C**<span class="number">2</span>-<span class="number">4</span>)%N</span><br><span class="line">p_leg,q_leg=<span class="built_in">int</span>((p-kronecker(D,p))%N),<span class="built_in">int</span>((q-kronecker(D,q))%N)</span><br><span class="line">tn=lcm((p_leg),(q_leg))</span><br><span class="line">d=inverse_mod(<span class="number">0x10001</span>,tn)</span><br><span class="line"><span class="keyword">assert</span> (<span class="number">0x10001</span>*d)%tn==<span class="number">1</span></span><br><span class="line">decc,_=decrypt(d)</span><br><span class="line"><span class="built_in">print</span>(long_to_bytes(decc))</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#法2，存储vd</span></span><br><span class="line"><span class="comment">#vd(2n)=vd(n)^2-2</span></span><br><span class="line"><span class="comment">#vd(2n+1)=c*vd(n)^2-vd(n)*vd(n-1)+c</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">v</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>: <span class="keyword">return</span> c</span><br><span class="line">    <span class="keyword">if</span> n <span class="keyword">in</span> v_dict.keys(): <span class="keyword">return</span> v_dict[n]</span><br><span class="line">    <span class="keyword">if</span>(n % <span class="number">2</span> == <span class="number">0</span>): ret = (<span class="built_in">pow</span>(v(n // <span class="number">2</span>), <span class="number">2</span>, N) - <span class="number">2</span>) % N</span><br><span class="line">    <span class="keyword">else</span>: ret = (c * <span class="built_in">pow</span>(v(n // <span class="number">2</span>), <span class="number">2</span>, N) -  v(n // <span class="number">2</span>) * v((n // <span class="number">2</span>) - <span class="number">1</span>) - c) % N</span><br><span class="line">    v_dict[n] = ret</span><br><span class="line">    <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#法3，William&#x27;s p+1算法优化vd</span></span><br><span class="line"><span class="comment"># Williams&#x27;s p + 1 algorithm</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">LUC</span>(<span class="params">c, d, N</span>):</span><br><span class="line">	x = c</span><br><span class="line">	y = (c**<span class="number">2</span> - <span class="number">2</span>) % N</span><br><span class="line">	<span class="keyword">for</span> bit <span class="keyword">in</span> <span class="built_in">bin</span>(d)[<span class="number">3</span>:]:</span><br><span class="line">		<span class="keyword">if</span> bit == <span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">			x = (x*y - c) % N</span><br><span class="line">			y = (y**<span class="number">2</span> - <span class="number">2</span>) % N</span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			y = (x*y - c) % N</span><br><span class="line">			x = (x**<span class="number">2</span> - <span class="number">2</span>) % N</span><br><span class="line">	<span class="keyword">return</span> x</span><br></pre></td></tr></table></figure><p>​</p><h2 id="DSA数字签名"><a href="#DSA数字签名" class="headerlink" title="DSA数字签名"></a>DSA数字签名</h2><ul><li><p><strong>密钥生成</strong></p><ol><li>选择一个合适的哈希函数，目前一般选择SHA1，也可以选择强度更高的哈希函数 $H$；</li><li>选择密钥的长度 $L$ 和 $N$，这两个值决定了签名的安全程度。在最初的DSS（Digital Signature Standard ）中建议 $L$ 必须为64的倍数，并且 $512≤L≤1024$，当然也可以更大。$N$ 大小必须不大于哈希函数 $H$ 输出的长度。FIPS 186-3给出了一些建议的 $L$ 和 $N$ 的取值例子：$(1024, 160),(2048, 224), (2048, 256),(3072, 256)$。</li><li>选择 $N$ 比特的素数 $q$；</li><li>选择 $L$ 比特的素数 $p$，使得 $p-1$ 是 $q$ 的倍数；</li><li>选择满足 $g^k \equiv 1 \pmod p$ 的最小正整数 $k$ 为 $q$ 的 $g$，即在模 $p$ 的背景下，$\mathrm{ord}(g)=q$ 的 $g$。即 $g$ 在模 $p$ 的意义下，其指数次幂可以生成具有 $q$ 个元素的子群。这里可以通过计算 $g \equiv h^{\frac{p−1}{q}} \pmod p$ 来得到 $g$，其中 $h \in (1,p−1)$ 。</li><li>选择私钥 $x \in (0,q)$，计算 $y \equiv g^x \pmod p$。</li><li>公钥为 $(p,q,g,y)$，私钥为 $(x)$。</li></ol></li><li><p><strong>签名</strong></p><ol><li><p>选择随机整数数 $k \in (0,q)$ 作为临时密钥；</p></li><li><p>计算 $r \equiv (g^k \bmod p) \pmod q$；</p></li><li><p>计算 $s \equiv (H(m)+xr)k^{-1} \pmod q$。</p></li></ol><p>签名结果为 $(r,s)$。需要注意的是，这里使用了哈希函数对消息进行了哈希处理。</p></li><li><p><strong>验证</strong></p><ol><li>计算辅助值 $w \equiv s^{-1} \pmod q$；</li><li>计算辅助值 $u_1 \equiv H(m)\cdot w \pmod q$；</li><li>计算辅助值 $u_2 \equiv r\cdot w \pmod q$；</li><li>计算 $v \equiv (g^{u_1}y^{u_2} \bmod p) \pmod q$；</li><li>如果 $v$ 与 $r$ 相等，则校验成功。</li></ol></li><li><p><strong>攻击</strong></p><ul><li><p><strong>$k$ 复用（共享 $k$）</strong></p><p>如果在两次签名的过程中共享了 $k$，就可以进行攻击。</p><p>假设签名的消息为 $m_1,m_2$，显然两者的 $r$ 的值一样，此外</p><p>$s_1 \equiv (H(m_1)+xr)k^{-1} \pmod q$</p><p>$s_2 \equiv (H(m_2)+xr)k^{-1} \pmod q$</p><p>这里除了 $x$ 和 $k$ 不知道剩下的均知道，联立有 $k(s_1-s_2) \equiv (H(m_1)-H(m_2)) \pmod q$，</p><p>此时即可解出 $k$，进一步可以解出 $x$。</p></li><li><p><strong>$k$ 部分泄露</strong></p><p>参考：<a target="_blank" rel="noopener" href="https://eprint.iacr.org/2020/1506.pdf">Recovering cryptographic keys from partial information, by example</a></p></li></ul><p>​</p></li></ul><h2 id="Elgamal数字签名"><a href="#Elgamal数字签名" class="headerlink" title="Elgamal数字签名"></a>Elgamal数字签名</h2><ul><li><p><strong>密钥生成</strong></p><ol><li>选取一个足够大的素数 $p$（十进制位数不低于160），便于在 $\mathbb{Z}_p$ 上求解DLP是困难的；</li><li>选取生成元 $g \in (0,p)$；</li><li>随机选取整数 $d \in [0,p-2]$，并计算 $g^d \equiv y \pmod p$；</li><li>公钥为 $(p,g,y)$，私钥为 $(d)$。</li></ol></li><li><p><strong>签名</strong></p><p>A选取随机数 $k \in (0,p-1)$，且 $\gcd(k,p-1)=1$，对消息进行签名：</p><p>$\mathrm{sig}(m,k)=(r,s)$</p><p>其中：</p><p>$r \equiv g^k \pmod p$</p><p>$s \equiv (m-dr)k^{-1} \pmod {p-1}$。</p></li><li><p><strong>验证</strong></p><p>如果 $g^m \equiv y^rr^s \pmod p$，那么验证成功，否则验证失败。</p></li><li><p><strong>攻击</strong></p><ul><li><p><strong>$k$ 复用（共享 $k$）</strong></p><p>如果签名者复用了随机数 $k$ ，那么攻击者就可以轻而易举地计算出私钥。</p><p>假设目前有两个签名都是使用同一个随机数进行签名的。那么有：</p><p>$r \equiv g^k \pmod p$</p><p>$s_1 \equiv (m_1-dr)k^{-1} \pmod {p-1}$</p><p>$s_2 \equiv (m_2-dr)k^{-1} \pmod {p-1}$,</p><p>进而有 $k(s_1-s_2) \equiv (m_1-m_2) \pmod {p-1}$，</p><p>$s_1,s_2,m_1,m_2,p$ 均已知，容易算出 $k$，进而根据 $s$ 的计算方法得到私钥 $d \equiv (m-ks)r^{-1} \pmod {p-1}$。</p></li><li><p><strong>构造验证</strong></p><ul><li><p>单参数</p><p>选择 $e \in (1,p-1)$，令 $r=g^ey \bmod p$，$s=-r \bmod (p-1)$，有 $m=es \bmod (p-1)$ 满足验证。</p></li><li><p>双参数</p><p>选择 $e,v \in (1,p-1),\gcd(v,p-1)=1$，令 $r=g^ey^v \bmod p$，$s=-rv^{-1} \bmod (p-1)$，有 $m=es \bmod (p-1)$ 满足验证。</p></li></ul></li></ul><p>​</p></li></ul><h2 id="Shamir密钥分享算法"><a href="#Shamir密钥分享算法" class="headerlink" title="Shamir密钥分享算法"></a>Shamir密钥分享算法</h2><p>Shamir 密钥分享算法最早是由 Shamir 和 Blackly 在 1970 年基于 Lagrange 插值和矢量方法提出的。</p><p>算法有 2 个重要参数：$k$ 和 $n$。$n$ 表示将明文加密为 $n$ 个 $\text{Shadow}$，$k$ 表示 至少需要 $k$ 个 $\text{Shadow}$ 才可以恢复出明文。</p><ul><li><p><strong>加密</strong></p><p>若明文为 $s$，$s \in \mathbb{Z}_p$，$p$ 为一个大素数。在 $\text{GF}(p)$ 任取 $k-1$ 个随机数： $a_1,a_2,\cdots,a_{k-1}$，构造如下多项式：</p><p>$f(x)=s+a_1x+a_2x^2+\cdots+a_{k-1}x^{k-1} \pmod p$</p><p>任取 $n$ 个不同的数：$x_1,x_2,\cdots,x_n$，分别代入多项式得到 $n$ 个密钥对：</p><p>$(x_1,f(x_1)),(x_2,f(x_2)),\cdots,(x_n,f(x_n))$</p><p>将这 $n$ 个密钥对分发给 $n$ 个持有者。</p></li><li><p><strong>解密</strong></p><p>得到了 $n$ 个密钥对 $(x_1,f(x_1)),(x_2,f(x_2)),\cdots,(x_n,f(x_n))$ 后，可以列出以下在 $\text{GF}(p)$ 上的方程组：</p><p>$\left\{\begin{array}{c} s+a_1x_1+a_2x_1^2+\cdots+a_{k-1}x_1^{k-1}=f(x_1) \\ s+a_1x_2+a_2x_2^2+\cdots+a_{k-1}x_2^{k-1}=f(x_2) \\ \vdots \\ s+a_1x_n+a_2x_n^2+\cdots+a_{k-1}x_n^{k-1}=f(x_n) \end{array}\right.$</p><p>然后就可用 Lagrange 插值算法求出 $s$ 了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#python-1</span></span><br><span class="line"><span class="keyword">from</span> sslib <span class="keyword">import</span> shamir</span><br><span class="line"></span><br><span class="line">data = &#123;<span class="string">&#x27;required_shares&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;prime_mod&#x27;</span>: <span class="string">&#x27;AQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEp&#x27;</span>, <span class="string">&#x27;shares&#x27;</span>: [<span class="string">&#x27;1-MEwx7cz+C01rL8H0Hhz2EIgHjWYXVcL81uITmRha674=&#x27;</span>, <span class="string">&#x27;2-YJhj22+ntS1s80CT9b6Y7ayc52baTFGNRpPUyLxtaf8=&#x27;</span>, <span class="string">&#x27;3-4SRZDcshiZTVRJ7nVY8NDq83JOsnZtPm&#x27;</span>, <span class="string">&#x27;4-wTDHtrT7CO1wej3TpQHep/XHm2hgOW6uJfdXKASSZoE=&#x27;</span>, <span class="string">&#x27;5-8Xz5pFekss1yPbxzfKOBhRpc9WkjL/0+lakYV6ik5MI=&#x27;</span>]&#125;</span><br><span class="line"><span class="built_in">print</span>(shamir.recover_secret(shamir.from_base64(data)).decode(<span class="string">&#x27;ascii&#x27;</span>))</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#python-2</span></span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> gmpy2</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">product</span>(<span class="params">vals, p</span>):</span><br><span class="line">    <span class="keyword">return</span> reduce(<span class="keyword">lambda</span> x, y: x * y % p, vals)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">lagrange_interpolate</span>(<span class="params">x, x_s, y_s, p</span>):</span><br><span class="line">    n = <span class="built_in">len</span>(x_s)</span><br><span class="line">    <span class="keyword">assert</span> n == <span class="built_in">len</span>(<span class="built_in">set</span>(x_s))  <span class="comment"># x_s must be distinct</span></span><br><span class="line">    num = []</span><br><span class="line">    den = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        others = x_s[:i] + x_s[i+<span class="number">1</span>:]</span><br><span class="line">        num.append(product((x - o <span class="keyword">for</span> o <span class="keyword">in</span> others), p))</span><br><span class="line">        den.append(product((x_s[i] - o <span class="keyword">for</span> o <span class="keyword">in</span> others), p))</span><br><span class="line">    dens = product(den, p)</span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        tmp1 = ((num[i] * dens % p) * y_s[i]) % p</span><br><span class="line">        tmp2 = tmp1 * gmpy2.invert(den[i], p) % p</span><br><span class="line">        res = (res + tmp2) % p </span><br><span class="line">    res = res * gmpy2.invert(dens, p) % p</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">shamir_sharing_encode</span>(<span class="params">s, k, n, p</span>):</span><br><span class="line">    a = [getRandomInteger(Nbits) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(k-<span class="number">1</span>)]</span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        x = getRandomInteger(Nbits)</span><br><span class="line">        fx = s</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k-<span class="number">1</span>):</span><br><span class="line">            fx = (fx + a[i] * <span class="built_in">pow</span>(x, i+<span class="number">1</span>, p)) % p</span><br><span class="line">        res.append((x, fx))</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">shamir_sharing_decode</span>(<span class="params">shares, p</span>):</span><br><span class="line">    x_s, y_s = <span class="built_in">zip</span>(*shares)</span><br><span class="line">    <span class="keyword">return</span> lagrange_interpolate(<span class="number">0</span>, x_s, y_s, p)</span><br><span class="line"></span><br><span class="line">Nbits = <span class="number">1024</span></span><br><span class="line">secret = bytes_to_long(<span class="string">&#x27;it_is_the_top_secret&#x27;</span>)</span><br><span class="line">p = getPrime(Nbits)</span><br><span class="line">k = <span class="number">513</span></span><br><span class="line">n = <span class="number">513</span></span><br><span class="line"></span><br><span class="line">shares = shamir_sharing_encode(secret, k, n, p)</span><br><span class="line"></span><br><span class="line">s = shamir_sharing_decode(shares, p)</span><br><span class="line"><span class="built_in">print</span> long_to_bytes(s)</span><br><span class="line"><span class="comment"># 2s</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Sage</span></span><br><span class="line">P = PolynomialRing(GF(p), <span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">ret = P(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> x, y <span class="keyword">in</span> shares:</span><br><span class="line">    r = P(<span class="number">1</span>) * y</span><br><span class="line">    <span class="keyword">for</span> xx, yy <span class="keyword">in</span> shares:</span><br><span class="line">        <span class="keyword">if</span> x != xx:</span><br><span class="line">            r = r * P((<span class="number">0</span> - xx) / (x - xx))</span><br><span class="line">    ret = ret + r</span><br><span class="line"><span class="built_in">print</span> ret</span><br><span class="line"><span class="comment"># 19s</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#Sage算系数</span></span><br><span class="line">P = PolynomialRing(GF(p), <span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">ret = P(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> x, y <span class="keyword">in</span> shares:</span><br><span class="line">    r = P(<span class="number">1</span>) * y</span><br><span class="line">    <span class="keyword">for</span> xx, yy <span class="keyword">in</span> shares:</span><br><span class="line">        <span class="keyword">if</span> x != xx:</span><br><span class="line">            r = r * P(<span class="string">&#x27;(x - %d) / (%d - %d)&#x27;</span> % (xx, x, xx))</span><br><span class="line">    ret = ret + r</span><br><span class="line"><span class="built_in">print</span> ret[<span class="number">0</span>]</span><br><span class="line"><span class="comment"># 154s</span></span><br></pre></td></tr></table></figure><p>除了 Lagrange 插值，也可以用矩阵。</p><p>可以将上面的方程组化为以下在 $\text{GF}(p)$ 上的矩阵乘法：</p><p>$\left(\begin {array}{c} 1 &amp; x_1 &amp; x_1^2 &amp; \cdots &amp; x_1^{k-1} \\ 1 &amp; x_2 &amp; x_2^2 &amp; \cdots &amp; x_2^{k-1} \\ \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\ 1 &amp; x_n &amp; x_n^2 &amp; \cdots &amp; x_n^{k-1} \end{array} \right) \times \left(\begin {array}{c} s \\ a_1 \\ \vdots \\ a_{k-1} \end{array} \right) = \left(\begin {array}{c} f(x_1) \\ f(x_2) \\ \vdots \\ f{x_n} \end{array} \right)$</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Sage矩阵乘法</span></span><br><span class="line">k = <span class="number">513</span></span><br><span class="line">n = <span class="number">513</span></span><br><span class="line"></span><br><span class="line">x, y = <span class="built_in">zip</span>(*shares)</span><br><span class="line"></span><br><span class="line">array_1 = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">        array_1.append(<span class="built_in">pow</span>(x[i], j, p))</span><br><span class="line">A = matrix(GF(p), n, k, array_1)</span><br><span class="line"></span><br><span class="line">array_2 = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    array_2.append(y[i])</span><br><span class="line">B = matrix(GF(p), n, <span class="number">1</span>, array_2)</span><br><span class="line"></span><br><span class="line">a = A.solve_right(B)</span><br><span class="line"><span class="built_in">print</span> a[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line"><span class="comment"># 266s</span></span><br></pre></td></tr></table></figure><p>也可以将之视为多元同余方程组：</p><p>$\left\{\begin{array}{c} s+a_1x_1+a_2x_1^2+\cdots+a_{k-1}x_1^{k-1} \equiv f(x_1) \pmod p \\ s+a_1x_2+a_2x_2^2+\cdots+a_{k-1}x_2^{k-1} \equiv f(x_2) \pmod p \\ \vdots \\ s+a_1x_n+a_2x_n^2+\cdots+a_{k-1}x_n^{k-1} \equiv f(x_n) \pmod p \end{array}\right.$</p><p>记系数矩阵的行列式为：</p><p>$\Delta = \left \vert \begin {array}{c} 1 &amp; x_1 &amp; x_1^2 &amp; \cdots &amp; x_1^{k-1} \\ 1 &amp; x_2 &amp; x_2^2 &amp; \cdots &amp; x_2^{k-1} \\ \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\ 1 &amp; x_n &amp; x_n^2 &amp; \cdots &amp; x_n^{k-1} \end{array} \right \vert \neq 0$</p><p>要求的是 $s$，因此将行列式第一列换为同余方程的值：</p><p>$\Delta_0 = \left \vert \begin {array}{c} f(x_1) &amp; x_1 &amp; x_1^2 &amp; \cdots &amp; x_1^{k-1} \\ f(x_2) &amp; x_2 &amp; x_2^2 &amp; \cdots &amp; x_2^{k-1} \\ \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\ f(x_n) &amp; x_n &amp; x_n^2 &amp; \cdots &amp; x_n^{k-1} \end{array} \right \vert \neq 0$</p><p>由克拉默法则得：</p><p>$s \equiv \Delta^{-1}\Delta_0 \pmod p$</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Sage</span></span><br><span class="line">fx_num = <span class="number">513</span></span><br><span class="line"></span><br><span class="line">x, y = <span class="built_in">zip</span>(*shares)</span><br><span class="line"></span><br><span class="line">array_1 = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(fx_num):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(fx_num):</span><br><span class="line">        array_1.append(<span class="built_in">pow</span>(x[i], j, p))</span><br><span class="line">delta = matrix(GF(p), fx_num, fx_num, array_1).determinant()</span><br><span class="line"></span><br><span class="line">array_2 = [_ <span class="keyword">for</span> _ <span class="keyword">in</span> array_1]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(fx_num):</span><br><span class="line">    array_2[i*fx_num] = y[i]</span><br><span class="line">delta_0 = matrix(GF(p), fx_num, fx_num, array_2).determinant() % p</span><br><span class="line"></span><br><span class="line">delta_inverse = inverse_mod(<span class="built_in">int</span>(delta), p)</span><br><span class="line">res = delta_inverse * delta_0 % p</span><br><span class="line"><span class="built_in">print</span> res</span><br><span class="line"><span class="comment"># 1200s</span></span><br></pre></td></tr></table></figure><p>但是如果维数很大，直接解行列式会很慢。观察发现 $\Delta$ 其实是旋转后的范德蒙行列式。$\Delta_0$ 是旋转后的范德蒙行列式的变形，第一行不是全 1，而是 $f(x)$。可以按第一行展开，余子式中将每一列除以该列元的一次方，可化为范德蒙行列式。计算速度会快非常多。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Sage</span></span><br><span class="line">fx_num = <span class="number">513</span></span><br><span class="line"></span><br><span class="line">x, y = <span class="built_in">zip</span>(*shares)</span><br><span class="line"></span><br><span class="line">delta = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, fx_num):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, i):</span><br><span class="line">        t = x[i] - x[j]</span><br><span class="line">        delta = (delta * t) % p</span><br><span class="line"></span><br><span class="line">delta_0 = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(fx_num):</span><br><span class="line">    tmp_x = [_ <span class="keyword">for</span> _ <span class="keyword">in</span> x]</span><br><span class="line">    tmp_x.pop(i)</span><br><span class="line">    yuzishi = -y[i] <span class="keyword">if</span> (i+<span class="number">1</span>+<span class="number">1</span>) % <span class="number">2</span> <span class="keyword">else</span> y[i]</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(fx_num-<span class="number">1</span>):</span><br><span class="line">        yuzishi = (yuzishi * tmp_x[j]) % p</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, fx_num-<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, j):</span><br><span class="line">            t = tmp_x[j] - tmp_x[k]</span><br><span class="line">            yuzishi = (yuzishi * t) % p</span><br><span class="line">    delta_0 = (delta_0 + yuzishi) % p</span><br><span class="line"></span><br><span class="line">delta_inverse = gmpy2.invert(delta, p)</span><br><span class="line">res = delta_inverse * delta_0 % p</span><br><span class="line"><span class="built_in">print</span> res</span><br><span class="line"><span class="comment"># 224s</span></span><br></pre></td></tr></table></figure></li><li><p><strong>攻击</strong></p><p>如果在加密 2 段明文 $s_1,s_2$ 过程中，使用相同的随机数 $a$ 以及大素数 $p$，还能得到同一个 $x$ 对应的两个 $f(x)$，如果知道一个明文 $s_1$ 的情况下，可以算出另一个明文。</p><p>在 $\text{GF}(p)$ 上：$s_1 + a_1x + a_2x^2 + a_3x^3 + … + a_{k-1}x^{k-1} = f(x)_1$</p><p>设：$A = a_1x + a_2x^2 + a_3x^3 + … + a_{k-1}x^{k-1}$</p><p>即：</p><p>$s_1 + A = f(x)_1 \\ s_2 + A = f(x)_2$</p><p>因此： $s_2 = f(x)_2 - f(x)_1 + s_1$</p><p>如果不知道两个明文的情况下，但两明文有一定的线性关系，也可以算出两明文。</p><p>若 $s_2 = as_1 + b$，则有同余方程组：</p><p>$\left\{ \begin{array}{c} s_1 + A - f(x)_1 \equiv 0 \pmod p \\ s_2 + A - f(x)_2 \equiv 0 \pmod p\\ as_1 + b - s_2 \equiv 0 \pmod p \end{array}\right.$</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Sage</span></span><br><span class="line">a = <span class="number">99999999</span></span><br><span class="line">b = <span class="number">123456</span></span><br><span class="line"></span><br><span class="line">PR.&lt;s1,s2,A&gt; = PolynomialRing(Zmod(p))</span><br><span class="line">f1 = s1 + A - y1</span><br><span class="line">f2 = s2 + A - y2</span><br><span class="line">f3 = a * s1 + b - s2</span><br><span class="line">Fs = [f1, f2, f3]</span><br><span class="line">I = Ideal(Fs)</span><br><span class="line">B = I.groebner_basis()</span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;s1 =&#x27;</span>, ZZ(-B[<span class="number">0</span>](<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;s2 =&#x27;</span>, ZZ(-B[<span class="number">1</span>](<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>))</span><br></pre></td></tr></table></figure></li></ul><p>​</p><h2 id="Okamoto-Uchiyama密码系统"><a href="#Okamoto-Uchiyama密码系统" class="headerlink" title="Okamoto-Uchiyama密码系统"></a>Okamoto-Uchiyama密码系统</h2><p>1998年由Tatsuaki Okamoto和Shigenori Uchiyama提出的公钥加密算法。</p><p><strong>条件</strong>：$n=p^2q$</p><ul><li><p>密钥生成</p><ol><li>生成两个大素数 $p$ 和 $q$；</li><li>计算 $n=p^2q$；</li><li>选择一个随机整数 $g \in \{2, \cdots ,n-1\}$ 满足 $g^{p-1} \not\equiv 1 \pmod {p^2}$；</li><li>计算 $h=g^n \bmod n$。</li></ol><p>公钥为 $(n,g,h)$，私钥为 $(p,q)$。</p></li><li><p>加密</p><p>明文 $m&lt;p$ 可以通过公钥 $(n,g,h)$ 加密：</p><ol><li>选择一个随机整数 $r \in \{1,\cdots,n-1\}$；</li><li>计算 $c=g^m h^r \bmod n$。</li></ol><p>$c$ 即为 $m$ 的密文。</p></li><li><p>解密</p><p>密文 $c$ 可以通过私钥 $(p,q)$ 解密：</p><ol><li>计算 $a=\cfrac{(c^{p-1} \bmod {p^2})-1}{p}$；</li><li>计算 $b=\cfrac{(g^{p-1} \bmod {p^2})-1}{p}$；</li><li>使用扩展欧几里得算法计算 $b$ 的模 $p$ 逆元 $b’=b^{-1} \bmod p$；</li><li>计算 $m=ab’ \bmod p$。</li></ol><p>$m$ 即为 $c$ 的明文。</p></li></ul><p>参考：<a target="_blank" rel="noopener" href="https://www.josephsurin.me/posts/2020-08-09-poseidonctf-2020-writeups#triplet-bits-encryption">PoseidonCTF 1st Edition 2020 - discrete log</a></p><p>​</p><h2 id="Schmidt-Samoa密码系统"><a href="#Schmidt-Samoa密码系统" class="headerlink" title="Schmidt-Samoa密码系统"></a>Schmidt-Samoa密码系统</h2><p>2005年，Katja Schmidt-Samoa 创建了 Schmidt-Samoa 公钥密码体系。</p><p>与 Rabin 类似，它的安全性基于大整数分解的困难性。但 Rabin 解密时会得到四个解，而 Schmidt-Samor 得到的是唯一解。</p><ul><li><p>密钥生成</p><p>选取大整数 $p,q$，计算 $N=p^2q$ 作为公钥。</p><p>计算 $d=\text{inv}(N,\varphi(pq))$ 作为私钥。</p></li><li><p>加密</p><p>对于小于 $pq$ 的明文 $m$，计算 $c=m^N \bmod N$ 作为密文。</p></li><li><p>解密</p><p>对于密文 $c$，计算 $c^d \bmod pq$，得到密文。</p><p>对于 $d$，当 $d=\text{inv}(N,\text{lcm}(p-1,q-1))$ 时，可以证明仍然有极大概率 $2^{N \cdot d} \equiv 2 \pmod {pq}$。</p><p>因为 $\text{lcm}(p-1,q-1)$ 已经是 $(p-1)(q-1)$ 非常大的因子，由拉格朗日定理，2生成的子群的阶应该是 $(p-1)(q-1)$ 的因数，所有概率还挺高的。</p><blockquote><p><strong>证明</strong></p><p>首先，计算 $\varphi(N)$，由欧拉函数的性质，显然有 $\varphi(N)=\varphi(p^2q)=p(p-1)(q-1)$</p><p>于是 $x^{p(p-1)(q-1)} \equiv 1 \pmod N$</p><p>尽管公钥、私钥都不包含 $pq$，但可以通过 $(N,d)$ 推出 $pq$，有 $N \cdot d \equiv 1 \pmod {\big((p-1)(q-1)\big)}$</p><p>随便选一个数2，来考察 $2^{N \cdot d}$ 在模 $pq$ 时的表现，有 $2^{N \cdot d} \equiv 2^{N \cdot d \bmod {\big((p-1)(q-1)\big)}} \equiv 2 \pmod {pq}$</p><p>从而 $pq \mid 2^{N \cdot d}-2$，于是计算 $\gcd(2^{N \cdot d}-2,N)$，即得到 $pq$。</p><p>容易发现，这些幂可以在模 $N$ 意义下计算，以节省复杂度。现在 $pq$ 到手，在模 $pq$ 意义下计算 $c^d$，即</p><p>$c^d \equiv m^{N \cdot d} \equiv m^{N \cdot d \bmod {\big((p-1)(q-1)\big)}} \equiv m \pmod {pq}$</p><p>至此完成解密。</p></blockquote></li></ul><p>参考：<a target="_blank" rel="noopener" href="https://eprint.iacr.org/2005/278.pdf">A New Rabin-type Trapdoor Permutation Equivalent to Factoring and Its Applications</a></p><p>​</p><h2 id="多项式"><a href="#多项式" class="headerlink" title="多项式"></a>多项式</h2><h3 id="极小多项式"><a href="#极小多项式" class="headerlink" title="极小多项式"></a>极小多项式</h3><p>一个域上的代数元 $\alpha$ 的极小多项式（或最小多项式）是满足 $P(\alpha)=0$ 的最低次首一多项式（多项式内最高次项之系数为1）$P$。</p><p>设 $k$ 为一个域，$A$ 为有限维 $k$-代数。对任一元素 $\alpha \in A$，集合 $\{1,\alpha,\alpha^2,\cdots\}$ 张出有限维向量空间，所以存在非平凡的线性关系 ：</p><p>$\sum\limits_{i=0}^n c_i\alpha^i=0 \quad (c_i \in k)$</p><p>可以假设 $c_n=1$，此时多项式 $f(X):= \sum\limits_{i=0}^n c_iX^i$ 满足 $f(\alpha)=0$。根据多项式环里的除法，可知这类多项式中只有一个次数最小者，称之为 $\alpha$ 的极小多项式。</p><p><strong>构造</strong></p><p>以3次为例，已知：</p><p>$\alpha^3 + a_2\alpha^2 + a_1\alpha + a_0 = 0$</p><p>这里 $a_i$ 都是整数，构造如下格：</p><p>$(1, a_2, a_1, a_0)<br>\begin{pmatrix}<br>\alpha^3C &amp; 1 &amp; 0 &amp; 0 \\<br>\alpha^2C &amp; 0 &amp; 1 &amp; 0 \\<br>\alpha C &amp; 0 &amp; 0 &amp; 1 \\<br>C &amp; 0 &amp; 0 &amp; 0 \\<br>\end{pmatrix}=(\epsilon C, 1,a_2, a_1)$</p><p>由于 $\alpha$ 精度有限，所以 $\epsilon$ 是一个非常接近0的数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">alpha = </span><br><span class="line">alpha = QQ(alpha)</span><br><span class="line">M = matrix(QQ, [</span><br><span class="line">    [alpha**<span class="number">3</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">    [alpha**<span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>],</span><br><span class="line">    [alpha**<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">    [alpha**<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">])</span><br><span class="line">M[:, <span class="number">0</span>] *= getrandbits(<span class="number">32</span>)</span><br><span class="line">L = M.LLL()</span><br><span class="line">v = L[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">if</span> v[<span class="number">1</span>] == -<span class="number">1</span>:</span><br><span class="line">    v *= -<span class="number">1</span></span><br><span class="line">a2, a1 = v[<span class="number">2</span>], v[<span class="number">3</span>]</span><br><span class="line">a0 = -(alpha**<span class="number">3</span> + a2 * alpha**<span class="number">2</span> + a1 * alpha)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alpha = </span><br><span class="line">f = algdep(alpha, <span class="number">3</span>)</span><br><span class="line">a0 = f(<span class="number">0</span>)</span><br></pre></td></tr></table></figure></div><div class="article-footer"></div></article><section id="comments"><div id="vcomments"></div></section></div><nav class="bar bar-footer clearfix" data-stick-bottom><div class="bar-inner"><ul class="pager pull-left"><li class="prev"><a href="/2020/05/15/web-SSTI/" title="SSTI"><i class="icon icon-angle-left" aria-hidden="true"></i><span>&nbsp;&nbsp;上一篇</span></a></li><li class="next"><a href="/2020/05/13/pwn-pwn%E5%B7%A5%E5%85%B7/" title="pwn工具"><span>下一篇&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a></li><li class="toggle-toc"><a class="toggle-btn collapsed" data-toggle="collapse" href="#collapseToc" aria-expanded="false" title="文章目录" role="button"><span>[&nbsp;</span><span>文章目录</span> <i class="text-collapsed icon icon-anchor"></i> <i class="text-in icon icon-close"></i> <span>]</span></a></li></ul><button type="button" class="btn btn-fancy btn-donate pop-onhover bg-gradient-warning" data-toggle="modal" data-target="#donateModal"><span>赏</span></button><div class="bar-right"><div class="share-component" data-sites="weibo,qq,wechat" data-mobile-sites="weibo,qq,wechat"></div></div></div></nav><div class="modal modal-center modal-small modal-xs-full fade" id="donateModal" tabindex="-1" role="dialog"><div class="modal-dialog" role="document"><div class="modal-content donate"><button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button><div class="modal-body"><div class="donate-box"><div class="donate-head"><p>这篇文章对你有用，赏一杯咖啡☕~~</p></div><div class="tab-content"><div role="tabpanel" class="tab-pane fade active in" id="wechatpay"><div class="donate-payimg"><img src="/images/donate/wechatpayimg.png" alt="扫码支持" title="扫一扫"></div><p class="text-muted mv">⎝Lazzaro⎠</p><p class="text-grey">打开微信扫一扫即可扫码打赏他一波哦~</p></div><div role="tabpanel" class="tab-pane fade" id="alipay"><div class="donate-payimg"><img src="/images/donate/alipayimg.png" alt="扫码支持" title="扫一扫"></div><p class="text-muted mv">⎝Lazzaro⎠</p><p class="text-grey">打开支付宝扫一扫即可扫码打赏他一波哦~</p></div></div><div class="donate-footer"><ul class="nav nav-tabs nav-justified" role="tablist"><li role="presentation" class="active"><a href="#wechatpay" role="tab" id="wechatpay-tab" data-toggle="tab" aria-controls="wechatpay" aria-expanded="true"><i class="icon icon-wepay"></i> 微信支付</a></li><li role="presentation"><a href="#alipay" id="alipay-tab" role="tab" data-toggle="tab" aria-controls="alipay" aria-expanded="false"><i class="icon icon-alipay"></i> 支付宝</a></li></ul></div></div></div></div></div></div></main><footer class="footer" itemscope itemtype="http://schema.org/WPFooter"><ul class="social-links"><li><a href="https://github.com/Lazzzaro" target="_blank" title="Github" data-toggle="tooltip" data-placement="top"><i class="icon icon-github"></i></a></li></ul><div class="copyright">&copy; 2025 Lazzaro<br><span>总访问 - <span id="busuanzi_value_site_pv"></span>次</span><br><span>访客数 - <span id="busuanzi_value_site_uv"></span>人</span><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></footer><script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script><script>window.jQuery||document.write('<script src="js/jquery.min.js"><\/script>')</script><script src="/js/plugin.min.js"></script><script src="/js/application.js"></script><script>window.INSIGHT_CONFIG={TRANSLATION:{POSTS:"文章",PAGES:"页面",CATEGORIES:"类别",TAGS:"关键词",UNTITLED:"(未命名)"},ROOT_URL:"/",CONTENT_URL:"/content.json"}</script><script src="/js/insight.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//cdn.jsdelivr.net/npm/valine"></script><script type="text/javascript">var GUEST=["nick","mail","link"],meta=(meta="nick,mail,link").split(",").filter(function(e){return-1<GUEST.indexOf(e)});new Valine({el:"#vcomments",verify:!1,notify:!1,appId:"sK4BUsDgfSB843HYgJyTcV7P-gzGzoHsz",appKey:"NKNx8m2CtFeDofr8LNLX7aNG",placeholder:"来来来说点啥~~\r\n对你有用？赏一波！↘↘",avatar:"mp",meta:meta,pageSize:"10",visitor:!0})</script><script defer type="text/javascript">!function(e,a,t,n,g,c){e.GoogleAnalyticsObject=n,e.ga=e.ga||function(){(e.ga.q=e.ga.q||[]).push(arguments)},e.ga.l=+new Date,g=a.createElement(t),c=a.getElementsByTagName(t)[0],g.async=1,g.src="//www.google-analytics.com/analytics.js",c.parentNode.insertBefore(g,c)}(window,document,"script","ga"),ga("create","UA-165804489-1","auto"),ga("send","pageview")</script><style>.copy-btn{display:inline-block;padding:6px 12px;font-size:13px;font-weight:700;line-height:20px;color:#333;white-space:nowrap;vertical-align:middle;cursor:pointer;background-color:#eee;background-image:linear-gradient(#fcfcfc,#eee);border:1px solid #d5d5d5;border-radius:3px;user-select:none;outline:0}.highlight-wrap .copy-btn{transition:opacity .3s ease-in-out;opacity:0;padding:2px 6px;position:absolute;right:4px;top:8px;z-index:2}.highlight-wrap .copy-btn:focus,.highlight-wrap:hover .copy-btn{opacity:1}.highlight-wrap{position:relative}</style><script>addLoadEvent(()=>{$(".highlight").each(function(t,e){var n=$("<div>").addClass("highlight-wrap");$(e).after(n),n.append($("<button>").addClass("copy-btn").append("复制").on("click",function(t){var e=$(this).parent().find(".code")[0].innerText;e+="\n/**\n* 复制并使用代码请注明引用出处哦~\n* Lazzaro @ https://lazzzaro.github.io\n*/";var n=document.createElement("textarea");document.body.appendChild(n),n.style.position="absolute",n.style.top="0px",n.style.left="0px",n.value=e,n.select(),n.focus();e=document.execCommand("copy");document.body.removeChild(n),e?$(this).text("复制成功"):$(this).text("复制失败"),$(this).blur()})).on("mouseleave",function(t){var e=$(this).find(".copy-btn");setTimeout(function(){e.text("复制")},300)}).append(e)})})</script></body></html>